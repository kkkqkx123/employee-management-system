This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
communication-implementation.md
database-design.md
department-implementation.md
design.md
employee-implementation.md
payroll-implementation.md
position-implementation.md
requirements.md
security-implementation.md
tasks.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="communication-implementation.md">
# Communication System Implementation

## Overview
This document provides detailed implementation specifications for the Communication System module, which includes Email Management and Chat/Notification functionality. This module handles template-based email sending, real-time chat, and system notifications.

## Package Structure
```
com.example.demo.communication/
├── email/
│   ├── entity/
│   │   ├── EmailTemplate.java
│   │   └── EmailLog.java
│   ├── service/
│   │   ├── EmailService.java
│   │   ├── EmailTemplateService.java
│   │   └── impl/
│   │       ├── EmailServiceImpl.java
│   │       └── EmailTemplateServiceImpl.java
│   ├── controller/
│   │   └── EmailController.java
│   ├── dto/
│   │   ├── EmailRequest.java
│   │   ├── BulkEmailRequest.java
│   │   ├── EmailTemplateDto.java
│   │   └── EmailLogDto.java
│   └── util/
│       └── EmailTemplateProcessor.java
├── chat/
│   ├── entity/
│   │   ├── ChatMessage.java
│   │   ├── ChatRoom.java
│   │   └── ChatParticipant.java
│   ├── service/
│   │   ├── ChatService.java
│   │   └── impl/
│   │       └── ChatServiceImpl.java
│   ├── controller/
│   │   └── ChatController.java
│   ├── dto/
│   │   ├── ChatMessageDto.java
│   │   ├── ChatRoomDto.java
│   │   └── ChatParticipantDto.java
│   └── websocket/
│       ├── ChatWebSocketHandler.java
│       └── WebSocketConfig.java
├── notification/
│   ├── entity/
│   │   └── Notification.java // Based on the single-table model in database-design.md
│   ├── service/
│   │   ├── NotificationService.java
│   │   └── impl/
│   │       └── NotificationServiceImpl.java
│   ├── controller/
│   │   └── NotificationController.java
│   ├── dto/
│   │   ├── NotificationDto.java
│   │   ├── NotificationCreateRequest.java
│   │   └── NotificationMarkReadRequest.java
│   └── websocket/
│       └── NotificationWebSocketHandler.java
└── exception/
    ├── EmailSendingException.java
    ├── TemplateNotFoundException.java
    ├── ChatRoomNotFoundException.java
    └── NotificationException.java
```

## Email Management

### Email Entity Classes

#### EmailTemplate Entity
```java
package com.example.demo.communication.email.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.Instant;
 
public enum TemplateType {
    HTML,
    TEXT,
    MIXED
}
 
public enum TemplateCategory {
    WELCOME,
    NOTIFICATION,
    REMINDER,
    MARKETING,
    PASSWORD_RESET
}

@Entity
@Table(name = "email_templates", indexes = {
    @Index(name = "idx_emailtemplate_code", columnList = "code", unique = true),
    @Index(name = "idx_emailtemplate_category", columnList = "category")
})
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@EntityListeners(AuditingEntityListener.class)
public class EmailTemplate {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "name", nullable = false, length = 100)
    private String name; // Template name for identification
    
    @Column(name = "code", nullable = false, unique = true, length = 50)
    private String code; // Unique template code
    
    @Column(name = "subject", nullable = false, length = 255)
    private String subject; // Email subject template
    
    @Lob
    @Column(name = "content", nullable = false, columnDefinition = "TEXT")
    private String content; // Email content template (HTML/Text)
    
    @Enumerated(EnumType.STRING)
    @Column(name = "template_type", nullable = false, length = 20)
    private TemplateType templateType; // HTML, TEXT, FREEMARKER
    
    @Enumerated(EnumType.STRING)
    @Column(name = "category", length = 50)
    private TemplateCategory category; // WELCOME, NOTIFICATION, REMINDER, etc.
    
    @Column(name = "description", length = 500)
    private String description;
    
    @Lob
    @Column(name = "variables", columnDefinition = "TEXT")
    private String variables; // JSON string of available template variables
    
    @Column(name = "is_default", nullable = false)
    private boolean isDefault = false;
    
    @Column(name = "enabled", nullable = false)
    private boolean enabled = true;
    
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;
    
    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;
    
    @Column(name = "created_by")
    private Long createdBy;
    
    @Column(name = "updated_by")
    private Long updatedBy;
}
```

#### EmailLog Entity
```java
package com.example.demo.communication.email.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.Instant;

public enum EmailStatus {
    PENDING,
    SENT,
    FAILED,
    BOUNCED,
    DELIVERED,
    OPENED,
    CLICKED
}
 
public enum EmailPriority {
    HIGH,
    NORMAL,
    LOW
}

@Entity
@Table(name = "email_logs", indexes = {
    @Index(name = "idx_emaillog_to_email", columnList = "to_email"),
    @Index(name = "idx_emaillog_status", columnList = "status"),
    @Index(name = "idx_emaillog_template_code", columnList = "template_code"),
    @Index(name = "idx_emaillog_sent_by", columnList = "sent_by")
})
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@EntityListeners(AuditingEntityListener.class)
public class EmailLog {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "to_email", nullable = false)
    private String toEmail;
    
    @Column(name = "cc_emails", length = 1000)
    private String ccEmails; // Comma-separated CC emails
    
    @Column(name = "bcc_emails", length = 1000)
    private String bccEmails; // Comma-separated BCC emails
    
    @Column(name = "subject", nullable = false)
    private String subject;
    
    @Lob
    @Column(name = "content", nullable = false, columnDefinition = "TEXT")
    private String content;
    
    @Column(name = "template_code", length = 50)
    private String templateCode; // Template used (if any)
    
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 20)
    private EmailStatus status; // PENDING, SENT, FAILED, BOUNCED
    
    @Column(name = "error_message", length = 2000)
    private String errorMessage; // Error details if failed
    
    @Column(name = "retry_count", nullable = false)
    private Integer retryCount = 0;
    
    @Column(name = "sent_at")
    private Instant sentAt;
    
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;
    
    @Column(name = "sent_by")
    private Long sentBy; // User who sent the email
    
    @Column(name = "message_id", length = 255)
    private String messageId; // Email provider message ID
    
    @Enumerated(EnumType.STRING)
    @Column(name = "priority", length = 20)
    private EmailPriority priority; // HIGH, NORMAL, LOW
}
```

### Email Service Interface
```java
package com.example.demo.communication.email.service;

import com.example.demo.communication.email.dto.EmailRequest;
import com.example.demo.communication.email.dto.BulkEmailRequest;
import com.example.demo.communication.email.dto.EmailLogDto;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;

public interface EmailService {
    
    /**
     * Send a single email
     * @param emailRequest Email request details
     * @return CompletableFuture for async processing
     * @throws EmailSendingException if email sending fails
     */
    CompletableFuture<Void> sendEmail(EmailRequest emailRequest);
    
    /**
     * Send templated email
     * @param toEmail Recipient email
     * @param templateCode Template code
     * @param variables Template variables
     * @return CompletableFuture for async processing
     * @throws TemplateNotFoundException if template not found
     * @throws EmailSendingException if email sending fails
     */
    CompletableFuture<Void> sendTemplatedEmail(String toEmail, String templateCode, Map<String, Object> variables);
    
    /**
     * Send bulk emails
     * @param bulkEmailRequest Bulk email request
     * @return CompletableFuture for async processing
     * @throws EmailSendingException if bulk email sending fails
     */
    CompletableFuture<Void> sendBulkEmails(BulkEmailRequest bulkEmailRequest);
    
    /**
     * Send bulk templated emails
     * @param recipients List of recipient emails
     * @param templateCode Template code
     * @param variables Template variables
     * @return CompletableFuture for async processing
     * @throws TemplateNotFoundException if template not found
     * @throws EmailSendingException if bulk email sending fails
     */
    CompletableFuture<Void> sendBulkTemplatedEmails(List<String> recipients, String templateCode, Map<String, Object> variables);
    
    /**
     * Get email logs with pagination
     * @param pageable Pagination parameters
     * @return Page of email log DTOs
     */
    Page<EmailLogDto> getEmailLogs(Pageable pageable);
    
    /**
     * Get email logs by recipient
     * @param toEmail Recipient email
     * @param pageable Pagination parameters
     * @return Page of email log DTOs
     */
    Page<EmailLogDto> getEmailLogsByRecipient(String toEmail, Pageable pageable);
    
    /**
     * Get email logs by status
     * @param status Email status
     * @param pageable Pagination parameters
     * @return Page of email log DTOs
     */
    Page<EmailLogDto> getEmailLogsByStatus(String status, Pageable pageable);
    
    /**
     * Get email logs by template
     * @param templateCode Template code
     * @param pageable Pagination parameters
     * @return Page of email log DTOs
     */
    Page<EmailLogDto> getEmailLogsByTemplate(String templateCode, Pageable pageable);
    
    /**
     * Retry failed email
     * @param emailLogId Email log ID
     * @return CompletableFuture for async processing
     * @throws EmailLogNotFoundException if email log not found
     * @throws EmailSendingException if retry fails
     */
    CompletableFuture<Void> retryFailedEmail(Long emailLogId);
    
    /**
     * Get email sending statistics
     * @return Email statistics
     */
    EmailStatisticsDto getEmailStatistics();
}
```

## Chat System

### Chat Entity Classes

### Enum Definitions

#### ChatRoomType Enum
```java
package com.example.demo.communication.chat.entity;

public enum ChatRoomType {
    DIRECT, // One-on-one chat
    GROUP,  // Multi-user group chat
    CHANNEL // Broadcast-style channel
}
```

#### ChatParticipantRole Enum
```java
package com.example.demo.communication.chat.entity;

public enum ChatParticipantRole {
    OWNER,
    ADMIN,
    MEMBER
}
```
#### ChatMessage Entity
```java
package com.example.demo.communication.chat.entity;
 
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;
 
import java.time.Instant;

public enum ChatMessageType {
    TEXT,
    IMAGE,
    FILE,
    SYSTEM // 系统消息, e.g., "User A has joined the room"
}
 
@Entity
@Table(name = "chat_messages", indexes = {
    @Index(name = "idx_chatmessage_room_id", columnList = "room_id"),
    @Index(name = "idx_chatmessage_sender_id", columnList = "sender_id"),
    @Index(name = "idx_chatmessage_created_at", columnList = "created_at")
})
@EntityListeners(AuditingEntityListener.class)
@Getter
@Setter
public class ChatMessage {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
  
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "room_id", nullable = false)
    private ChatRoom room;
  
    @Column(name = "sender_id", nullable = false)
    private Long senderId;         // Message sender
  
    @Column(name = "content", columnDefinition = "TEXT")
    private String content;        // Message content
  
    @Enumerated(EnumType.STRING)
    @Column(name = "message_type", length = 20)
    private ChatMessageType messageType;    // TEXT, IMAGE, FILE, SYSTEM
  
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;     // 时区无关的时间戳
  
    @Column(name = "is_edited", nullable = false)
    private Boolean isEdited = false;
  
    @Column(name = "edited_at")
    private Instant editedAt;      // 时区无关的时间戳
  
    @Column(name = "is_deleted", nullable = false)
    private Boolean isDeleted = false;
  
    @Column(name = "deleted_at")
    private Instant deletedAt;     // 时区无关的时间戳
    
    // Transient fields for display
    private transient String senderName;
    private transient String senderAvatar;
    private transient boolean isRead; // Whether current user has read this message
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "room_id", insertable = false, updatable = false)
    private ChatRoom chatRoom;
}
```

#### ChatRoom Entity
```java
package com.example.demo.communication.chat.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.Instant;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "chat_rooms", indexes = {
    @Index(name = "idx_chatroom_type", columnList = "type"),
    @Index(name = "idx_chatroom_created_by", columnList = "created_by")
})
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@EntityListeners(AuditingEntityListener.class)
public class ChatRoom {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "name", length = 100)
    private String name; // Room name (for group chats)
    
    @Enumerated(EnumType.STRING)
    @Column(name = "type", nullable = false, length = 20)
    private ChatRoomType type; // DIRECT, GROUP, CHANNEL
    
    @Column(name = "description", length = 500)
    private String description;
    
    @Column(name = "avatar_url", length = 255)
    private String avatarUrl;
    
    @Column(name = "created_by", nullable = false)
    private Long createdBy; // User who created the room
    
    @Column(name = "is_private", nullable = false)
    private boolean isPrivate = false;
    
    @Column(name = "is_active", nullable = false)
    private boolean isActive = true;
    
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;
    
    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;
    
    @Column(name = "last_message_at")
    private Instant lastMessageAt;
    
    @Column(name = "last_message_id")
    private Long lastMessageId; // Stored in Redis, synced periodically
    
    @OneToMany(mappedBy = "room", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<ChatParticipant> participants = new HashSet<>();

    // Transient fields for DTO mapping
    @Transient
    private Long unreadCount;
    @Transient
    private String lastMessageContent;
    @Transient
    private String lastMessageSender;
}
```

#### ChatParticipant Entity
```java
package com.example.demo.communication.chat.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import java.time.Instant;

@Entity
@Table(name = "chat_participants", uniqueConstraints = {
    @UniqueConstraint(columnNames = {"room_id", "user_id"}, name = "uk_participant_room_user")
})
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ChatParticipant {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "room_id", nullable = false)
    private ChatRoom room;
    
    @Column(name = "user_id", nullable = false)
    private Long userId;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "role", nullable = false, length = 20)
    private ChatParticipantRole role; // OWNER, ADMIN, MEMBER
    
    @Column(name = "joined_at", nullable = false)
    private Instant joinedAt;
    
    @Column(name = "last_read_at")
    private Instant lastReadAt;
    
    @Column(name = "last_read_message_id")
    private Long lastReadMessageId; // Stored in Redis, synced periodically
    
    @Column(name = "is_muted", nullable = false)
    private boolean isMuted = false;
    
    @Column(name = "is_active", nullable = false)
    private boolean isActive = true;
    
    @Column(name = "left_at")
    private Instant leftAt;
    
    // Transient fields for DTO mapping
    @Transient
    private String userName;
    @Transient
    private String userAvatar;
    @Transient
    private boolean isOnline;
}
```

### Chat Service Interface
```java
package com.example.demo.communication.chat.service;

import com.example.demo.communication.chat.dto.ChatMessageDto;
import com.example.demo.communication.chat.dto.ChatRoomDto;
import com.example.demo.communication.chat.dto.ChatParticipantDto;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import java.util.List;

public interface ChatService {
    
    /**
     * Create a new chat room
     * @param name Room name
     * @param type Room type (DIRECT, GROUP, CHANNEL)
     * @param description Room description
     * @param createdBy Creator user ID
     * @param participantIds Initial participant user IDs
     * @return Created chat room DTO
     * @throws ChatRoomCreationException if room creation fails
     */
    ChatRoomDto createChatRoom(String name, ChatRoomType type, String description, Long createdBy, List<Long> participantIds);
    
    /**
     * Get chat room by ID
     * @param roomId Room ID
     * @param userId Current user ID (for permission check)
     * @return Chat room DTO
     * @throws ChatRoomNotFoundException if room not found
     * @throws AccessDeniedException if user doesn't have access
     */
    ChatRoomDto getChatRoom(Long roomId, Long userId);
    
    /**
     * Get user's chat rooms
     * @param userId User ID
     * @return List of chat room DTOs
     */
    List<ChatRoomDto> getUserChatRooms(Long userId);
    
    /**
     * Send message to chat room
     * @param roomId Room ID
     * @param senderId Sender user ID
     * @param content Message content
     * @param messageType Message type
     * @return Created message DTO
     * @throws ChatRoomNotFoundException if room not found
     * @throws AccessDeniedException if user doesn't have access
     */
    ChatMessageDto sendMessage(Long roomId, Long senderId, String content, String messageType);
    
    /**
     * Get chat messages for room
     * @param roomId Room ID
     * @param userId Current user ID (for permission check)
     * @param pageable Pagination parameters
     * @return Page of message DTOs
     * @throws ChatRoomNotFoundException if room not found
     * @throws AccessDeniedException if user doesn't have access
     */
    Page<ChatMessageDto> getChatMessages(Long roomId, Long userId, Pageable pageable);
    
    /**
     * Edit message
     * @param messageId Message ID
     * @param userId User ID (must be message sender)
     * @param newContent New message content
     * @return Updated message DTO
     * @throws ChatMessageNotFoundException if message not found
     * @throws AccessDeniedException if user is not the sender
     */
    ChatMessageDto editMessage(Long messageId, Long userId, String newContent);
    
    /**
     * Delete message
     * @param messageId Message ID
     * @param userId User ID (must be message sender or room admin)
     * @throws ChatMessageNotFoundException if message not found
     * @throws AccessDeniedException if user doesn't have permission
     */
    void deleteMessage(Long messageId, Long userId);
    
    /**
     * Add participant to chat room
     * @param roomId Room ID
     * @param userId User ID to add
     * @param addedBy User ID who is adding (must have permission)
     * @return Chat participant DTO
     * @throws ChatRoomNotFoundException if room not found
     * @throws AccessDeniedException if addedBy user doesn't have permission
     */
    ChatParticipantDto addParticipant(Long roomId, Long userId, Long addedBy);
    
    /**
     * Remove participant from chat room
     * @param roomId Room ID
     * @param userId User ID to remove
     * @param removedBy User ID who is removing (must have permission)
     * @throws ChatRoomNotFoundException if room not found
     * @throws AccessDeniedException if removedBy user doesn't have permission
     */
    void removeParticipant(Long roomId, Long userId, Long removedBy);
    
    /**
     * Mark messages as read
     * @param roomId Room ID
     * @param userId User ID
     * @param lastReadMessageId Last message ID read
     */
    void markMessagesAsRead(Long roomId, Long userId, Long lastReadMessageId);
    
    /**
     * Get unread message count for user
     * @param userId User ID
     * @return Total unread message count across all rooms
     */
    Long getUnreadMessageCount(Long userId);
    
    /**
     * Get unread message count for specific room
     * @param roomId Room ID
     * @param userId User ID
     * @return Unread message count for the room
     */
    Long getUnreadMessageCount(Long roomId, Long userId);
    
    /**
     * Search messages in room
     * @param roomId Room ID
     * @param userId Current user ID (for permission check)
     * @param searchTerm Search term
     * @param pageable Pagination parameters
     * @return Page of matching message DTOs
     */
    Page<ChatMessageDto> searchMessages(Long roomId, Long userId, String searchTerm, Pageable pageable);
}
```

## Notification & Announcement System

**Note:** The implementation of the notification system must adhere to the `Notification` entity defined in `database-design.md`. The single-table model is the authoritative design standard, superseding any previous multi-table designs.

This section covers system-wide notifications and announcements.

### Announcement Entity
```java
package com.example.demo.communication.announcement.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.Instant;
import java.time.LocalDate;
 
public enum AnnouncementTarget {
    ALL,          // 全体员工
    DEPARTMENT,   // 特定部门
    ROLE          // 特定角色
}

@Entity
@Table(name = "announcements")
@EntityListeners(AuditingEntityListener.class)
@Getter
@Setter
public class Announcement {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 200)
    private String title;

    @Lob
    @Column(nullable = false, columnDefinition = "TEXT")
    private String content;

    @Column(name = "author_id", nullable = false)
    private Long authorId; // Added author ID

    @Enumerated(EnumType.STRING)
    @Column(name = "target_audience", length = 50) // e.g., ALL, DEPARTMENT, ROLE
    private AnnouncementTarget targetAudience;

    @Column(name = "department_id") // if target is a specific department
    private Long departmentId;

    @Column(name = "publish_date")
    private LocalDate publishDate;

    @Column(name = "expiry_date")
    private LocalDate expiryDate;

    @Column(nullable = false)
    private boolean published = false;

    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;

    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt; // Added updatedAt

    @Column(name = "created_by")
    private Long createdBy;

    @Column(name = "updated_by")
    private Long updatedBy; // Added updatedBy
}
```

### Notification Service Implementation
```java
package com.example.demo.communication.notification.service.impl;

import com.example.demo.communication.notification.service.NotificationService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;

@Service
@Slf4j
@RequiredArgsConstructor
public class NotificationServiceImpl implements NotificationService {

    // Assume WebSocket and Email services are injected
    // private final SimpMessagingTemplate messagingTemplate;
    // private final EmailService emailService;

    @Override
    @Async // Execute asynchronously to avoid blocking the caller thread
    public void sendNotification(Long userId, String message) {
        try {
            log.info("Sending notification to user {}: {}", userId, message);
            // 1. Send via WebSocket for real-time update
            // messagingTemplate.convertAndSendToUser(userId.toString(), "/queue/notifications", message);

            // 2. Optionally, send an email as well
            // Employee user = employeeRepository.findById(userId).orElse(null);
            // if (user != null && user.getEmail() != null) {
            //     emailService.sendSimpleMessage(user.getEmail(), "New Notification", message);
            // }
            log.info("Successfully sent notification to user {}", userId);
        } catch (Exception e) {
            // Robust error handling
            log.error("Failed to send notification to user {}: {}", userId, e.getMessage(), e);
            // Here you could add logic to retry, or flag the notification as failed
        }
    }
}
```

### Announcement Service Implementation
```java
package com.example.demo.communication.announcement.service.impl;

import com.example.demo.communication.announcement.dto.AnnouncementDto;
import com.example.demo.communication.announcement.entity.Announcement;
import com.example.demo.communication.announcement.repository.AnnouncementRepository;
import com.example.demo.communication.announcement.service.AnnouncementService;
import com.example.demo.communication.notification.service.NotificationService;
import com.example.demo.employee.repository.EmployeeRepository;
import lombok.RequiredArgsConstructor;
import org.modelmapper.ModelMapper;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class AnnouncementServiceImpl implements AnnouncementService {

    private final AnnouncementRepository announcementRepository;
    private final NotificationService notificationService;
    private final EmployeeRepository employeeRepository; // To get target employees
    private final ModelMapper modelMapper;

    @Override
    @Transactional
    public AnnouncementDto createAnnouncement(AnnouncementDto announcementDto) {
        Announcement announcement = modelMapper.map(announcementDto, Announcement.class);
        Announcement savedAnnouncement = announcementRepository.save(announcement);

        // If the announcement is published, send notifications
        if (savedAnnouncement.isPublished()) {
            notifyUsers(savedAnnouncement);
        }

        return modelMapper.map(savedAnnouncement, AnnouncementDto.class);
    }
  
    @Override
    @Transactional
    public AnnouncementDto updateAnnouncement(Long id, AnnouncementDto announcementDto) {
        Announcement existing = announcementRepository.findById(id)
            .orElseThrow(() -> new RuntimeException("Announcement not found"));
      
        modelMapper.map(announcementDto, existing);
        Announcement updatedAnnouncement = announcementRepository.save(existing);

        // If the announcement is published, send notifications
        if (updatedAnnouncement.isPublished()) {
            notifyUsers(updatedAnnouncement);
        }
      
        return modelMapper.map(updatedAnnouncement, AnnouncementDto.class);
    }

    private void notifyUsers(Announcement announcement) {
        String message = "New Announcement: " + announcement.getTitle();
        List<Long> targetUserIds = getTargetUserIds(announcement);
      
        targetUserIds.forEach(userId -> notificationService.sendNotification(userId, message));
    }

    private List<Long> getTargetUserIds(Announcement announcement) {
        // Logic to determine which users should be notified based on target_audience
        // For example:
        if ("ALL".equals(announcement.getTargetAudience())) {
            return employeeRepository.findAll().stream().map(e -> e.getId()).collect(Collectors.toList());
        } else if ("DEPARTMENT".equals(announcement.getTargetAudience()) && announcement.getDepartmentId() != null) {
            // Assuming EmployeeRepository has findByDepartmentId method
            // return employeeRepository.findByDepartmentId(announcement.getDepartmentId()).stream()...
        }
        return List.of(); // return empty list if no target
    }
    // Other methods (get, delete, etc.) would be implemented here.
}
```

### Announcement Controller
```java
package com.example.demo.communication.announcement.controller;

import com.example.demo.communication.announcement.dto.AnnouncementDto;
import com.example.demo.communication.announcement.service.AnnouncementService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/v1/announcements")
@RequiredArgsConstructor
public class AnnouncementController {

    private final AnnouncementService announcementService;

    @PostMapping
    @PreAuthorize("hasAuthority('ANNOUNCEMENT_MANAGE')")
    public ResponseEntity<AnnouncementDto> createAnnouncement(@Valid @RequestBody AnnouncementDto announcementDto) {
        AnnouncementDto created = announcementService.createAnnouncement(announcementDto);
        return new ResponseEntity<>(created, HttpStatus.CREATED);
    }

    @PutMapping("/{id}")
    @PreAuthorize("hasAuthority('ANNOUNCEMENT_MANAGE')")
    public ResponseEntity<AnnouncementDto> updateAnnouncement(@PathVariable Long id, @Valid @RequestBody AnnouncementDto announcementDto) {
        AnnouncementDto updated = announcementService.updateAnnouncement(id, announcementDto);
        return ResponseEntity.ok(updated);
    }

    // Endpoints for getting/deleting announcements would be here
}
```
</file>

<file path="database-design.md">
# Database Design Document - Employee Management System

## Overview

This document provides comprehensive database design specifications for the Spring Boot Employee Management System using a hybrid data storage approach with PostgreSQL as the primary database and Redis for caching and real-time features. The design supports all system modules including security, employee management, departments, positions, communication, and payroll with enhanced data integrity, security, and compliance features.

## Technology Stack

- **Primary Database**: PostgreSQL 15.x
- **Cache Layer**: Redis 7.x
- **ORM**: Spring Data JPA with Hibernate
- **Caching**: Redis with Spring Cache abstraction
- **Data Modeling**: JPA entities with proper relationships and constraints
- **Transactions**: JPA transactions with Spring @Transactional
- **Security**: Field-level encryption for sensitive data
- **Migration**: Flyway for database versioning

## Database Architecture

### Hybrid Data Storage Strategy

The system uses a hybrid approach with PostgreSQL as the primary database for all persistent data and Redis exclusively for caching and real-time features:

**PostgreSQL (Primary Database - All Persistent Data):**
- All core business entities (User, Role, Resource, Employee, Department, Position, PayrollLedger)
- All transactional data with ACID compliance and referential integrity
- Complex relational queries, joins, and reporting capabilities
- Foreign key constraints and check constraints for data integrity
- Comprehensive audit trails and historical data
- User authentication data and role-based permissions

**Redis (Cache & Real-time Features Only):**
- JWT token blacklisting for secure logout functionality
- Caching of frequently accessed data (department trees, user permissions)
- Real-time chat messages (temporary storage with TTL)
- WebSocket session management and connection tracking
- Search result caching for performance optimization
- Notification queues for real-time delivery

**Critical Design Principle:** 
Redis is used exclusively for caching and real-time features. All persistent, relational data is stored in PostgreSQL to ensure ACID compliance, referential integrity, and proper transaction support. This addresses the fundamental flaw of using Redis as a primary database for relational data.

### Connection Configuration

```properties
# PostgreSQL Configuration
spring.datasource.url=jdbc:postgresql://localhost:5432/employee_management
spring.datasource.username=${DB_USERNAME:employee_admin}
spring.datasource.password=${DB_PASSWORD:secure_password}
spring.datasource.driver-class-name=org.postgresql.Driver

# JPA Configuration
spring.jpa.hibernate.ddl-auto=validate
spring.jpa.show-sql=false
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.jdbc.batch_size=20
spring.jpa.properties.hibernate.order_inserts=true
spring.jpa.properties.hibernate.order_updates=true

# Flyway Configuration
spring.flyway.enabled=true
spring.flyway.locations=classpath:db/migration
spring.flyway.baseline-on-migrate=true

# Redis Configuration (for caching and real-time features)
spring.redis.host=localhost
spring.redis.port=6379
spring.redis.database=0
spring.redis.password=
spring.redis.timeout=2000ms
spring.redis.jedis.pool.max-active=8
spring.redis.jedis.pool.max-idle=8
spring.redis.jedis.pool.min-idle=0
spring.redis.jedis.pool.max-wait=-1ms

# Cache Configuration
spring.cache.type=redis
spring.cache.redis.time-to-live=600000
spring.cache.redis.cache-null-values=false
```

## Core Entity Schemas

### 1. Security Module Entities

#### User Entity
```java
@Entity
@Table(name = "users", 
    indexes = {
        @Index(name = "idx_user_username", columnList = "username"),
        @Index(name = "idx_user_email", columnList = "email"),
        @Index(name = "idx_user_enabled", columnList = "enabled"),
        @Index(name = "idx_user_account_locked", columnList = "account_locked")
    },
    uniqueConstraints = {
        @UniqueConstraint(name = "uk_user_username", columnNames = "username"),
        @UniqueConstraint(name = "uk_user_email", columnNames = "email")
    }
)
@EntityListeners(AuditingEntityListener.class)
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "username", nullable = false, length = 50)
    @NotBlank(message = "Username is required")
    @Size(min = 3, max = 50, message = "Username must be between 3 and 50 characters")
    private String username;        // Unique username for login
    
    @Column(name = "password", nullable = false)
    @NotBlank(message = "Password is required")
    private String password;        // BCrypt encoded password
    
    @Column(name = "email", nullable = false, length = 100)
    @NotBlank(message = "Email is required")
    @Email(message = "Email must be valid")
    private String email;          // User email address
    
    @Column(name = "first_name", length = 50)
    private String firstName;      // User first name
    
    @Column(name = "last_name", length = 50)
    private String lastName;       // User last name
    
    @Column(name = "enabled", nullable = false)
    private Boolean enabled = true; // Account status
    
    @Column(name = "last_login")
    private Instant lastLogin;     // Time-zone aware timestamp
    
    @Column(name = "login_attempts", nullable = false)
    private Integer loginAttempts = 0;
    
    @Column(name = "account_locked", nullable = false)
    private Boolean accountLocked = false;
    
    @Column(name = "account_locked_until")
    private Instant accountLockedUntil; // Automatic unlock time
    
    @Column(name = "password_expired", nullable = false)
    private Boolean passwordExpired = false;
    
    @Column(name = "password_change_required", nullable = false)
    private Boolean passwordChangeRequired = false;
    
    @Column(name = "password_changed_at")
    private Instant passwordChangedAt; // Track password changes
    
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;     // Time-zone aware timestamp
    
    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;     // Time-zone aware timestamp
    
    @Column(name = "created_by")
    private Long createdBy;
    
    @Column(name = "updated_by")
    private Long updatedBy;
    
    // Many-to-Many relationship with Role
    @ManyToMany(fetch = FetchType.LAZY)
    @JoinTable(
        name = "user_roles",
        joinColumns = @JoinColumn(name = "user_id"),
        inverseJoinColumns = @JoinColumn(name = "role_id"),
        foreignKey = @ForeignKey(name = "fk_user_roles_user"),
        inverseForeignKey = @ForeignKey(name = "fk_user_roles_role")
    )
    private Set<Role> roles = new HashSet<>();
    
    // Helper methods for business logic
    public boolean isAccountNonLocked() {
        if (!accountLocked) return true;
        if (accountLockedUntil != null && Instant.now().isAfter(accountLockedUntil)) {
            accountLocked = false;
            accountLockedUntil = null;
            return true;
        }
        return false;
    }
    
    public void incrementLoginAttempts() {
        this.loginAttempts++;
        if (this.loginAttempts >= 5) { // Configurable threshold
            this.accountLocked = true;
            this.accountLockedUntil = Instant.now().plus(Duration.ofMinutes(30));
        }
    }
    
    public void resetLoginAttempts() {
        this.loginAttempts = 0;
        this.accountLocked = false;
        this.accountLockedUntil = null;
        this.lastLogin = Instant.now();
    }
}
```

**Database Table:**
- Table: `users`
- Indexes: `idx_user_username`, `idx_user_email`, `idx_user_enabled`
- Constraints: Unique constraints on username and email

#### Role Entity
```java
@Entity
@Table(name = "roles", indexes = {
    @Index(name = "idx_role_name", columnList = "name"),
    @Index(name = "idx_role_active", columnList = "active")
})
@EntityListeners(AuditingEntityListener.class)
public class Role {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "name", unique = true, nullable = false, length = 50)
    private String name;           // Role name (ADMIN, HR_MANAGER, EMPLOYEE)
    
    @Column(name = "description", length = 255)
    private String description;    // Role description
    
    @Column(name = "active", nullable = false)
    private Boolean active = true; // Role status
    
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;
    
    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;
    
    @Column(name = "created_by")
    private Long createdBy;
    
    @Column(name = "updated_by")
    private Long updatedBy;
    
    // Many-to-Many relationship with User
    @ManyToMany(mappedBy = "roles", fetch = FetchType.LAZY)
    private Set<User> users = new HashSet<>();
    
    // Many-to-Many relationship with Resource
    @ManyToMany(fetch = FetchType.LAZY)
    @JoinTable(
        name = "role_resources",
        joinColumns = @JoinColumn(name = "role_id"),
        inverseJoinColumns = @JoinColumn(name = "resource_id")
    )
    private Set<Resource> resources = new HashSet<>();
}
```

**Database Table:**
- Table: `roles`
- Indexes: `idx_role_name`, `idx_role_active`
- Constraints: Unique constraint on name

#### Resource Entity
```java
public enum ResourceCategory {
    USER,
    EMPLOYEE,
    DEPARTMENT,
    POSITION,
    PAYROLL,
    COMMUNICATION,
    SECURITY,
    OTHER
}

@Entity
@Table(name = "resources", indexes = {
    @Index(name = "idx_resource_url", columnList = "url"),
    @Index(name = "idx_resource_method", columnList = "method"),
    @Index(name = "idx_resource_category", columnList = "category"),
    @Index(name = "idx_resource_active", columnList = "active")
})
@EntityListeners(AuditingEntityListener.class)
public class Resource {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "name", nullable = false, length = 100)
    private String name;           // Resource name
    
    @Column(name = "url", nullable = false, length = 255)
    private String url;            // URL pattern
    
    @Column(name = "method", nullable = false, length = 10)
    private String method;         // HTTP method (GET, POST, PUT, DELETE)
    
    @Column(name = "description", length = 255)
    private String description;    // Resource description
    
    @Enumerated(EnumType.STRING)
    @Column(name = "category", nullable = false, length = 50)
    private ResourceCategory category; // Resource category (USER, EMPLOYEE, DEPARTMENT, etc.)
    
    @Column(name = "active", nullable = false)
    private Boolean active = true; // Resource status
    
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;
    
    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;
    
    @Column(name = "created_by")
    private Long createdBy;
    
    @Column(name = "updated_by")
    private Long updatedBy;
    
    // Many-to-Many relationship with Role
    @ManyToMany(mappedBy = "resources", fetch = FetchType.LAZY)
    private Set<Role> roles = new HashSet<>();
}
```

**Database Table:**
- Table: `resources`
- Indexes: `idx_resource_url`, `idx_resource_method`, `idx_resource_category`, `idx_resource_active`
- Constraints: Composite unique constraint on (url, method)### 
2. Department Management Entities

#### Department Entity
```java
@Entity
@Table(name = "departments", indexes = {
    @Index(name = "idx_department_name", columnList = "name"),
    @Index(name = "idx_department_code", columnList = "code"),
    @Index(name = "idx_department_parent_id", columnList = "parent_id"),
    @Index(name = "idx_department_dep_path", columnList = "dep_path"),
    @Index(name = "idx_department_enabled", columnList = "enabled"),
    @Index(name = "idx_department_manager_id", columnList = "manager_id")
})
@EntityListeners(AuditingEntityListener.class)
public class Department {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "name", nullable = false, length = 100)
    private String name;           // Department name
    
    @Column(name = "code", unique = true, nullable = false, length = 20)
    private String code;           // Department code (unique)
    
    @Column(name = "description", length = 500)
    private String description;    // Department description
    
    @Column(name = "location", length = 255)
    private String location;       // Department physical location
    
    @Column(name = "parent_id")
    private Long parentId;         // Parent department ID (null for root)
    
    @Column(name = "dep_path", length = 500)
    private String depPath;        // Hierarchical path (e.g., "/1/2/3")
    
    @Column(name = "is_parent", nullable = false)
    private Boolean isParent = false; // Has child departments
    
    @Column(name = "enabled", nullable = false)
    private Boolean enabled = true; // Department status (renamed from active for consistency)
    
    @Column(name = "level")
    private Integer level = 0;     // Hierarchy level (0 for root)
    
    @Column(name = "sort_order")
    private Integer sortOrder = 0; // Display order
    
    @Column(name = "manager_id")
    private Long managerId;        // Department manager (Employee ID)
    
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;
    
    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;
    
    @Column(name = "created_by")
    private Long createdBy;
    
    @Column(name = "updated_by")
    private Long updatedBy;
    
    // Self-referencing relationship for parent department
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "parent_id", insertable = false, updatable = false)
    private Department parent;
    
    // One-to-Many relationship for child departments
    @OneToMany(mappedBy = "parent", fetch = FetchType.LAZY)
    private Set<Department> children = new HashSet<>();
    
    // One-to-Many relationship with employees
    @OneToMany(mappedBy = "department", fetch = FetchType.LAZY)
    private Set<Employee> employees = new HashSet<>();
    
    // Transient field for employee count (calculated dynamically)
    @Transient
    private Long employeeCount;
}
```

**Database Table:**
- Table: `departments`
- Indexes: Multiple indexes for efficient querying
- Constraints: Unique constraint on code, foreign key to self for parent_id

### 3. Position Management Entities

#### Position Entity
```java
@Entity
@Table(name = "positions", indexes = {
    @Index(name = "idx_position_job_title", columnList = "job_title"),
    @Index(name = "idx_position_code", columnList = "code"),
    @Index(name = "idx_position_department_id", columnList = "department_id"),
    @Index(name = "idx_position_level", columnList = "level"),
    @Index(name = "idx_position_enabled", columnList = "enabled"),
    @Index(name = "idx_position_category", columnList = "category")
})
@EntityListeners(AuditingEntityListener.class)
public class Position {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "job_title", nullable = false, length = 100)
    private String jobTitle;       // Job title
    
    @Column(name = "professional_title", length = 100)
    private String professionalTitle; // Professional title
    
    @Column(name = "code", unique = true, nullable = false, length = 20)
    private String code;           // Position code (unique)
    
    @Column(name = "description", length = 1000)
    private String description;    // Position description
    
    @Column(name = "requirements", length = 2000)
    private String requirements;   // Job requirements
    
    @Column(name = "responsibilities", length = 2000)
    private String responsibilities; // Job responsibilities
    
    @Enumerated(EnumType.STRING)
    @Column(name = "category", nullable = false, length = 20)
    private PositionCategory category = PositionCategory.TECHNICAL; // TECHNICAL, MANAGEMENT, ADMINISTRATIVE, etc.
    
    @Column(name = "salary_grade", length = 10)
    private String salaryGrade;    // Salary grade/band
    
    @Column(name = "department_id", nullable = false)
    @NotNull(message = "Department is required")
    private Long departmentId;     // Associated department
    
    @Enumerated(EnumType.STRING)
    @Column(name = "level", nullable = false, length = 20)
    private PositionLevel level = PositionLevel.JUNIOR; // JUNIOR, SENIOR, MANAGER, etc.
    
    @Column(name = "enabled", nullable = false)
    private Boolean enabled = true; // Position enabled status
    
    @Column(name = "min_salary", precision = 12, scale = 2)
    private BigDecimal minSalary;  // Minimum salary range
    
    @Column(name = "max_salary", precision = 12, scale = 2)
    private BigDecimal maxSalary;  // Maximum salary range
    
    @Column(name = "required_skills", length = 1000)
    private String requiredSkills; // Required skills (JSON or comma-separated)
    
    @Column(name = "required_education", length = 500)
    private String requiredEducation; // Required education level
    
    @Column(name = "required_experience")
    private Integer requiredExperience; // Required years of experience
    
    @Column(name = "benefits", length = 1000)
    private String benefits;       // Position benefits
    
    @Column(name = "work_location", length = 255)
    private String workLocation;   // Work location (OFFICE, REMOTE, HYBRID)
    
    @Enumerated(EnumType.STRING)
    @Column(name = "employment_type", nullable = false, length = 20)
    private EmploymentType employmentType = EmploymentType.FULL_TIME; // FULL_TIME, PART_TIME, CONTRACT
    
    @Column(name = "is_managerial", nullable = false)
    private Boolean isManagerial = false; // Is this a management position
    
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;     // Time-zone aware timestamp
    
    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;     // Time-zone aware timestamp
    
    @Column(name = "created_by")
    private Long createdBy;
    
    @Column(name = "updated_by")
    private Long updatedBy;
    
    // Many-to-One relationship with Department
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "department_id", insertable = false, updatable = false)
    private Department department;
    
    // One-to-Many relationship with employees
    @OneToMany(mappedBy = "position", fetch = FetchType.LAZY)
    private Set<Employee> employees = new HashSet<>();
    
    // Transient field for employee count (calculated dynamically)
    @Transient
    private Long employeeCount;
    
    // Business logic methods
    public boolean isWithinSalaryRange(BigDecimal salary) {
        if (salary == null) return true;
        boolean aboveMin = minSalary == null || salary.compareTo(minSalary) >= 0;
        boolean belowMax = maxSalary == null || salary.compareTo(maxSalary) <= 0;
        return aboveMin && belowMax;
    }
}

// Position Category Enum
public enum PositionCategory {
    TECHNICAL,
    MANAGEMENT,
    ADMINISTRATIVE,
    SALES,
    MARKETING,
    FINANCE,
    HR,
    OPERATIONS,
    LEGAL,
    OTHER
}

// Position Level Enum
public enum PositionLevel {
    INTERN,
    JUNIOR,
    SENIOR,
    LEAD,
    MANAGER,
    SENIOR_MANAGER,
    DIRECTOR,
    SENIOR_DIRECTOR,
    VP,
    SVP,
    EXECUTIVE
}
```

**Database Table:**
- Table: `positions`
- Indexes: Multiple indexes for efficient querying
- Constraints: Unique constraint on code, foreign key to departments

### 4. Employee Management Entities

#### Employee Entity
```java
@Entity
@Table(name = "employees", 
    indexes = {
        @Index(name = "idx_employee_number", columnList = "employee_number"),
        @Index(name = "idx_employee_email", columnList = "email"),
        @Index(name = "idx_employee_department_id", columnList = "department_id"),
        @Index(name = "idx_employee_position_id", columnList = "position_id"),
        @Index(name = "idx_employee_manager_id", columnList = "manager_id"),
        @Index(name = "idx_employee_status", columnList = "status"),
        @Index(name = "idx_employee_pay_type", columnList = "pay_type"),
        @Index(name = "idx_employee_hire_date", columnList = "hire_date"),
        @Index(name = "idx_employee_enabled", columnList = "enabled")
    },
    uniqueConstraints = {
        @UniqueConstraint(name = "uk_employee_number", columnNames = "employee_number"),
        @UniqueConstraint(name = "uk_employee_email", columnNames = "email")
    }
)
@EntityListeners(AuditingEntityListener.class)
public class Employee {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "employee_number", nullable = false, length = 20)
    @NotBlank(message = "Employee number is required")
    private String employeeNumber; // Unique employee number
    
    @Column(name = "first_name", nullable = false, length = 50)
    @NotBlank(message = "First name is required")
    private String firstName;      // First name
    
    @Column(name = "last_name", nullable = false, length = 50)
    @NotBlank(message = "Last name is required")
    private String lastName;       // Last name
    
    @Column(name = "email", nullable = false, length = 100)
    @NotBlank(message = "Email is required")
    @Email(message = "Email must be valid")
    private String email;          // Email address (unique)
    
    @Column(name = "phone", length = 20)
    private String phone;          // Phone number
    
    @Column(name = "mobile_phone", length = 20)
    private String mobilePhone;    // Mobile phone number
    
    // Address fields (detailed breakdown)
    @Column(name = "address", length = 255)
    private String address;        // Street address
    
    @Column(name = "city", length = 100)
    private String city;           // City
    
    @Column(name = "state", length = 100)
    private String state;          // State/Province
    
    @Column(name = "zip_code", length = 20)
    private String zipCode;        // ZIP/Postal code
    
    @Column(name = "country", length = 100)
    private String country;        // Country
    
    @Column(name = "date_of_birth_encrypted", length = 255)
    private String dateOfBirthEncrypted; // Encrypted date of birth (AES)
    
    @Enumerated(EnumType.STRING)
    @Column(name = "gender", length = 10)
    private Gender gender;         // MALE, FEMALE, OTHER, PREFER_NOT_TO_SAY
    
    @Column(name = "nationality", length = 50)
    private String nationality;    // Nationality
    
    @Enumerated(EnumType.STRING)
    @Column(name = "marital_status", length = 20)
    private MaritalStatus maritalStatus; // SINGLE, MARRIED, DIVORCED, WIDOWED
    
    @Column(name = "department_id", nullable = false)
    @NotNull(message = "Department is required")
    private Long departmentId;     // Department assignment
    
    @Column(name = "position_id", nullable = false)
    @NotNull(message = "Position is required")
    private Long positionId;       // Position assignment
    
    @Column(name = "manager_id")
    private Long managerId;        // Direct manager ID
    
    @Column(name = "hire_date", nullable = false)
    @NotNull(message = "Hire date is required")
    private LocalDate hireDate;    // Hire date
    
    @Column(name = "termination_date")
    private LocalDate terminationDate; // Termination date (if applicable)
    
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 20)
    private EmployeeStatus status = EmployeeStatus.ACTIVE;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "employment_type", nullable = false, length = 20)
    private EmploymentType employmentType = EmploymentType.FULL_TIME;
    
    // CRITICAL FIX: Support both salaried and hourly employees
    @Enumerated(EnumType.STRING)
    @Column(name = "pay_type", nullable = false, length = 10)
    private PayType payType = PayType.SALARY; // SALARY or HOURLY
    
    @Column(name = "salary", precision = 12, scale = 2)
    private BigDecimal salary;     // Annual salary for salaried employees
    
    @Column(name = "hourly_rate", precision = 8, scale = 2)
    private BigDecimal hourlyRate; // Hourly rate for hourly employees
    
    @Column(name = "salary_grade", length = 10)
    private String salaryGrade;    // Salary grade/band
    
    @Enumerated(EnumType.STRING)
    @Column(name = "work_location", length = 20)
    private WorkLocation workLocation = WorkLocation.OFFICE; // OFFICE, REMOTE, HYBRID
    
    // Encrypted sensitive fields (AES encryption)
    @Column(name = "bank_account_encrypted", length = 255)
    private String bankAccountEncrypted; // Bank account details (encrypted)
    
    @Column(name = "tax_id_encrypted", length = 255)
    private String taxIdEncrypted;       // Tax identification (encrypted)
    
    // Skills and qualifications
    @Column(name = "skills", columnDefinition = "TEXT")
    private String skills;         // Skills (JSON format)
    
    @Column(name = "education", length = 1000)
    private String education;      // Education background
    
    @Column(name = "certifications", length = 1000)
    private String certifications; // Professional certifications
    
    @Column(name = "notes", length = 2000)
    private String notes;          // Additional notes
    
    @Column(name = "enabled", nullable = false)
    private Boolean enabled = true; // Account enabled status
    
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;     // Time-zone aware timestamp
    
    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;     // Time-zone aware timestamp
    
    @Column(name = "created_by")
    private Long createdBy;
    
    @Column(name = "updated_by")
    private Long updatedBy;
    
    // Profile image URL
    @Column(name = "profile_image_url", length = 500)
    private String profileImageUrl;
    
    // Emergency contact information
    @Column(name = "emergency_contact_name", length = 100)
    private String emergencyContactName;
    
    @Column(name = "emergency_contact_phone", length = 20)
    private String emergencyContactPhone;
    
    @Column(name = "emergency_contact_relation", length = 50)
    private String emergencyContactRelation;
    
    // Relationships with proper foreign key constraints
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "department_id", insertable = false, updatable = false,
                foreignKey = @ForeignKey(name = "fk_employee_department"))
    private Department department;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "position_id", insertable = false, updatable = false,
                foreignKey = @ForeignKey(name = "fk_employee_position"))
    private Position position;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "manager_id", insertable = false, updatable = false,
                foreignKey = @ForeignKey(name = "fk_employee_manager"))
    private Employee manager;
    
    @OneToMany(mappedBy = "manager", fetch = FetchType.LAZY)
    private Set<Employee> directReports = new HashSet<>();
    
    @OneToMany(mappedBy = "employee", fetch = FetchType.LAZY, cascade = CascadeType.ALL)
    private Set<PayrollLedger> payrollLedgers = new HashSet<>();
    
    // Business logic methods
    public String getFullName() {
        return firstName + " " + lastName;
    }
    
    public boolean isActive() {
        return status == EmployeeStatus.ACTIVE && enabled;
    }
    
    public boolean isSalaried() {
        return payType == PayType.SALARY;
    }
    
    public boolean isHourly() {
        return payType == PayType.HOURLY;
    }
    
    // Validation method for salary range
    public void validateSalaryAgainstPosition(Position position) {
        if (isSalaried() && salary != null && position != null) {
            if (position.getMinSalary() != null && salary.compareTo(position.getMinSalary()) < 0) {
                throw new ValidationException("Salary below minimum range for position");
            }
            if (position.getMaxSalary() != null && salary.compareTo(position.getMaxSalary()) > 0) {
                throw new ValidationException("Salary above maximum range for position");
            }
        }
    }
}

// Employee Status Enum
public enum EmployeeStatus {
    ACTIVE,
    INACTIVE,
    TERMINATED,
    ON_LEAVE,
    SUSPENDED
}

// Employment Type Enum
public enum EmploymentType {
    FULL_TIME,
    PART_TIME,
    CONTRACT,
    INTERN,
    CONSULTANT
}

// Pay Type Enum (CRITICAL FIX for payroll support)
public enum PayType {
    SALARY,    // Annual salary
    HOURLY     // Hourly rate
}

// Gender Enum
public enum Gender {
    MALE,
    FEMALE,
    OTHER,
    PREFER_NOT_TO_SAY
}

// Marital Status Enum
public enum MaritalStatus {
    SINGLE,
    MARRIED,
    DIVORCED,
    WIDOWED,
    SEPARATED
}

// Work Location Enum
public enum WorkLocation {
    OFFICE,
    REMOTE,
    HYBRID
}
```

**Database Table:**
- Table: `employees`
- Indexes: Multiple indexes for efficient querying
- Constraints: Unique constraints on employee_number and email
- Security: Sensitive fields (dateOfBirth, bankAccount, taxId) should be encrypted##
# 5. Communication System Entities

#### Email Template Entity
```java
@Entity
@Table(name = "email_templates", indexes = {
    @Index(name = "idx_email_template_name", columnList = "name"),
    @Index(name = "idx_email_template_code", columnList = "code"),
    @Index(name = "idx_email_template_category", columnList = "category"),
    @Index(name = "idx_email_template_active", columnList = "active")
})
@EntityListeners(AuditingEntityListener.class)
public class EmailTemplate {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "name", nullable = false, length = 100)
    private String name;           // Template name
    
    @Column(name = "code", unique = true, nullable = false, length = 50)
    private String code;           // Template code (unique)
    
    @Column(name = "subject", nullable = false, length = 255)
    private String subject;        // Email subject template
    
    @Column(name = "content", columnDefinition = "TEXT")
    private String content;        // Email content (unified field)
    
    @Enumerated(EnumType.STRING)
    @Column(name = "template_type", nullable = false, length = 10)
    private TemplateType templateType = TemplateType.HTML; // HTML, TEXT, MIXED
    
    @Enumerated(EnumType.STRING)
    @Column(name = "category", length = 50)
    private TemplateCategory category; // Template category
    
    @Column(name = "enabled", nullable = false)
    private Boolean enabled = true;
    
    @Column(name = "is_default", nullable = false)
    private boolean isDefault = false;
    
    @Column(name = "variables", columnDefinition = "TEXT")
    private String variables;      // JSON array of template variables
    
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;
    
    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;
    
    @Column(name = "created_by")
    private Long createdBy;        // User who created template
    
    @Column(name = "updated_by")
    private Long updatedBy;
    
    @OneToMany(mappedBy = "template", fetch = FetchType.LAZY)
    private Set<EmailLog> emailLogs = new HashSet<>();
}

// Template Type Enum
public enum TemplateType {
    HTML,
    TEXT,
    MIXED
}
```

#### Email Log Entity
```java
@Entity
@Table(name = "email_logs", indexes = {
    @Index(name = "idx_email_log_template_code", columnList = "template_code"),
    @Index(name = "idx_email_log_to_email", columnList = "to_email"),
    @Index(name = "idx_email_log_status", columnList = "status"),
    @Index(name = "idx_email_log_sent_at", columnList = "sent_at"),
    @Index(name = "idx_email_log_sent_by", columnList = "sent_by")
})
@EntityListeners(AuditingEntityListener.class)
public class EmailLog {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "template_code", length = 50)
    private String templateCode;   // Template code used (instead of ID for flexibility)
    
    @Column(name = "to_email", nullable = false, length = 255)
    private String toEmail;        // Primary recipient email
    
    @Column(name = "cc_emails", length = 1000)
    private String ccEmails;       // CC recipients (comma-separated)
    
    @Column(name = "bcc_emails", length = 1000)
    private String bccEmails;      // BCC recipients (comma-separated)
    
    @Column(name = "subject", nullable = false, length = 255)
    private String subject;        // Actual subject sent
    
    @Column(name = "content", columnDefinition = "TEXT")
    private String content;        // Actual content sent
    
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 20)
    private EmailStatus status = EmailStatus.PENDING; // PENDING, SENT, FAILED, BOUNCED
    
    @Column(name = "sent_at")
    private Instant sentAt;  // When email was sent
    
    @Column(name = "error_message", length = 1000)
    private String errorMessage;   // Error details if failed
    
    @Column(name = "retry_count")
    private Integer retryCount = 0; // Number of retry attempts
    
    @Column(name = "sent_by")
    private Long sentBy;           // User who sent email
    
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;
    
    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;
    
    // Relationship with template (optional, as template might be deleted)
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "template_id")
    private EmailTemplate template;
}

// Email Status Enum
public enum EmailStatus {
    PENDING,
    SENT,
    FAILED,
    BOUNCED,
    DELIVERED,
    OPENED,
    CLICKED
}
```

#### Chat Message Entity
```java
@Entity
@Table(name = "chat_messages", indexes = {
    @Index(name = "idx_chatmessage_room_id", columnList = "room_id"),
    @Index(name = "idx_chatmessage_sender_id", columnList = "sender_id"),
    @Index(name = "idx_chatmessage_created_at", columnList = "created_at")
})
@EntityListeners(AuditingEntityListener.class)
public class ChatMessage {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
  
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "room_id", nullable = false)
    private ChatRoom room;
      
    @Column(name = "sender_id", nullable = false)
    private Long senderId;         // Message sender
      
    @Column(name = "content", columnDefinition = "TEXT")
    private String content;        // Message content
      
    @Enumerated(EnumType.STRING)
    @Column(name = "message_type", length = 20)
    private ChatMessageType messageType;    // TEXT, IMAGE, FILE, SYSTEM
      
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;     // Time-zone aware timestamp
      
    @Column(name = "is_edited", nullable = false)
    private Boolean isEdited = false;
      
    @Column(name = "edited_at")
    private Instant editedAt;      // Time-zone aware timestamp
      
    @Column(name = "reply_to_id")
    private Long replyToId;        // Reply to message ID
      
    @Column(name = "attachment_url", length = 500)
    private String attachmentUrl;
      
    @Column(name = "attachment_type", length = 100)
    private String attachmentType;
      
    @Column(name = "attachment_size")
    private Long attachmentSize;
      
    @Column(name = "is_deleted", nullable = false)
    private Boolean isDeleted = false;
      
    @Column(name = "deleted_at")
    private Instant deletedAt;     // Time-zone aware timestamp
      
    @Column(name = "metadata", columnDefinition = "TEXT")
    private String metadata;       // JSON
      
    @Column(name = "read_receipts", columnDefinition = "TEXT")
    private String readReceipts;   // JSON
    private ChatRoom chatRoom;
}
```

**Note:** Chat messages are stored in PostgreSQL to ensure data integrity and support complex queries.

#### Chat Room Entity
```java
@Entity
@Table(name = "chat_rooms", indexes = {
    @Index(name = "idx_chatroom_name", columnList = "name"),
    @Index(name = "idx_chatroom_type", columnList = "type"),
    @Index(name = "idx_chatroom_created_by", columnList = "created_by")
})
@EntityListeners(AuditingEntityListener.class)
public class ChatRoom {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
  
    @Column(name = "name", length = 100)
    private String name;           // Room name
  
    @Enumerated(EnumType.STRING)
    @Column(name = "type", nullable = false, length = 20)
    private ChatRoomType type;     // DIRECT, GROUP, CHANNEL
  
    @Column(name = "description", length = 500)
    private String description;
  
    @Column(name = "created_by")
    private Long createdBy;
  
    @Column(name = "is_active", nullable = false)
    private Boolean isActive = true;
  
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;     // Time-zone aware timestamp
  
    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;     // Time-zone aware timestamp
  
    @Column(name = "last_message_at")
    private Instant lastMessageAt; // Time-zone aware timestamp
  
    @Column(name = "is_private", nullable = false)
    private Boolean isPrivate = false;
  
    @Column(name = "max_participants")
    private Integer maxParticipants;
  
    @OneToMany(mappedBy = "chatRoom", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<ChatMessage> messages = new HashSet<>();
    
    @OneToMany(mappedBy = "room", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<ChatParticipant> participants = new HashSet<>();
}

public enum ChatRoomType {
    DIRECT,
    GROUP,
    CHANNEL
}

#### ChatParticipant Entity
```java
@Entity
@Table(name = "chat_participants", uniqueConstraints = {
    @UniqueConstraint(columnNames = {"room_id", "user_id"}, name = "uk_participant_room_user")
})
public class ChatParticipant {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "room_id", nullable = false)
    private ChatRoom room;
    
    @Column(name = "user_id", nullable = false)
    private Long userId;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "role", nullable = false, length = 20)
    private ChatParticipantRole role; // OWNER, ADMIN, MEMBER
    
    @Column(name = "joined_at", nullable = false)
    private Instant joinedAt;
    
    @Column(name = "last_read_at")
    private Instant lastReadAt;
    
    @Column(name = "last_read_message_id")
    private Long lastReadMessageId;
    
    @Column(name = "is_muted", nullable = false)
    private boolean isMuted = false;
    
    @Column(name = "is_active", nullable = false)
    private boolean isActive = true;
    
    @Column(name = "left_at")
    private Instant leftAt;
}
```

#### Notification Entity
```java
@Entity
@Table(name = "notifications", indexes = {
    @Index(name = "idx_notification_user_id", columnList = "user_id"),
    @Index(name = "idx_notification_type", columnList = "type"),
    @Index(name = "idx_notification_read_status", columnList = "read_status")
})
@EntityListeners(AuditingEntityListener.class)
public class Notification {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
  
    @Column(name = "user_id", nullable = false)
    private Long userId;           // Target user
  
    @Column(name = "type", length = 50)
    private String type;           // SYSTEM, EMAIL, CHAT, TASK, etc.
  
    @Column(name = "title", length = 255)
    private String title;
  
    @Column(name = "content", columnDefinition = "TEXT")
    private String content;
  
    @Column(name = "data", columnDefinition = "TEXT")
    private String data;           // Additional JSON data
  
    @Column(name = "read_status", nullable = false)
    private Boolean read = false;
  
    @Column(name = "priority", length = 20)
    private String priority;       // LOW, MEDIUM, HIGH, URGENT
  
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;     // Time-zone aware timestamp
  
    @Column(name = "read_at")
    private Instant readAt;        // Time-zone aware timestamp
  
    @Column(name = "expires_at")
    private Instant expiresAt;     // Time-zone aware timestamp
  
    @Column(name = "action_url", length = 500)
    private String actionUrl;
  
    @Column(name = "related_entity_id")
    private Long relatedEntityId;
  
    @Column(name = "related_entity_type", length = 50)
    private String relatedEntityType;
}
```
### 6. Payroll Management Entities

### PayrollLedger Entity
```java
package com.example.demo.payroll.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import lombok.Builder;
import com.example.demo.employee.entity.Employee;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.math.BigDecimal;
import java.math.BigDecimal;
import java.time.Instant;
import java.time.LocalDate;

@Entity
@Table(name = "payroll_ledgers", indexes = {
    @Index(name = "idx_payrollledger_employee_id", columnList = "employee_id"),
    @Index(name = "idx_payrollledger_period_id", columnList = "payroll_period_id"),
    @Index(name = "idx_payrollledger_status", columnList = "status")
})
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@EntityListeners(AuditingEntityListener.class)
public class PayrollLedger {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "employee_id", nullable = false)
    private Employee employee;

    @Column(name = "payroll_period_id", nullable = false)
    private Long payrollPeriodId;

    @Column(name = "employee_number", length = 20)
    private String employeeNumber;

    @Column(name = "employee_name", length = 100)
    private String employeeName;

    @Column(name = "department_id")
    private Long departmentId;

    @Column(name = "department_name", length = 100)
    private String departmentName;

    @Column(name = "position_id")
    private Long positionId;

    @Column(name = "position_name", length = 100)
    private String positionName;

    @Column(name = "base_salary", precision = 12, scale = 2)
    private BigDecimal baseSalary;

    @Column(name = "hourly_rate", precision = 12, scale = 2)
    private BigDecimal hourlyRate;

    @Column(name = "hours_worked", precision = 10, scale = 2)
    private BigDecimal hoursWorked;

    @Column(name = "overtime_hours", precision = 10, scale = 2)
    private BigDecimal overtimeHours;

    @Column(name = "overtime_rate", precision = 12, scale = 2)
    private BigDecimal overtimeRate;

    @Column(name = "total_allowances", precision = 12, scale = 2)
    private BigDecimal totalAllowances;

    @Column(name = "total_deductions", precision = 12, scale = 2)
    private BigDecimal totalDeductions;

    @Column(name = "gross_salary", precision = 12, scale = 2)
    private BigDecimal grossSalary;

    @Column(name = "net_salary", precision = 12, scale = 2)
    private BigDecimal netSalary;

    @Column(name = "employer_contributions", precision = 12, scale = 2)
    private BigDecimal employerContributions;

    @Column(name = "total_cost", precision = 12, scale = 2)
    private BigDecimal totalCost;

    @Column(name = "currency", length = 10)
    private String currency;

    @Enumerated(EnumType.STRING)
    @Column(name = "payment_method", length = 20)
    private PaymentMethod paymentMethod;

    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 20)
    private PayrollLedgerStatus status;

    @Column(name = "pay_date")
    private LocalDate payDate;

    @Lob
    @Column(name = "notes", columnDefinition = "TEXT")
    private String notes;

    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;

    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;

    @Column(name = "created_by")
    private Long createdBy;

    @Column(name = "updated_by")
    private Long updatedBy;

    @Lob
    @Column(name = "calculation_details", columnDefinition = "TEXT")
    private String calculationDetails; // JSON string for all components
}
```

> **关键业务规则：薪资记录快照**
>
> `PayrollLedger` 实体中的以下字段必须被视为 **一次性创建的快照（Snapshot）**，以确保历史薪资报告的永久准确性：
>
> *   `employeeName`
> *   `departmentName`
> *   `positionName`
> *   `baseSalary`, `hourlyRate`, 等所有与薪资计算相关的数值字段
>
> **实现要求**：
> 1.  在创建一条新的 `PayrollLedger` 记录的业务逻辑（例如在 `PayrollService` 中）时，必须在一个事务内，从关联的 `Employee`, `Department`, `Position` 等实体中获取当前的名称和值，并填充到这些快照字段中。
> 2.  一旦 `PayrollLedger` 记录被创建，这些快照字段 **绝对不能** 因为源实体信息（如员工改名、部门调动）的变更而被更新。它们必须永久保留创建时刻的状态。
> 3.  此规则是确保系统财务审计合规性的核心要求。

### PayrollPeriod Entity
```java
package com.example.demo.payroll.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.Instant;
import java.time.LocalDate;

@Entity
@Table(name = "payroll_periods", indexes = {
    @Index(name = "idx_payrollperiod_start_end", columnList = "start_date, end_date"),
    @Index(name = "idx_payrollperiod_status", columnList = "status")
})
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@EntityListeners(AuditingEntityListener.class)
public class PayrollPeriod {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "name", nullable = false, length = 100)
    private String name;

    @Enumerated(EnumType.STRING)
    @Column(name = "type", nullable = false, length = 20)
    private PayrollPeriodType type;

    @Column(name = "start_date", nullable = false)
    private LocalDate startDate;

    @Column(name = "end_date", nullable = false)
    private LocalDate endDate;

    @Column(name = "pay_date", nullable = false)
    private LocalDate payDate;

    @Column(name = "working_days")
    private Integer workingDays;

    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 20)
    private PayrollPeriodStatus status;

    @Column(name = "description", length = 500)
    private String description;

    @Column(name = "is_active", nullable = false)
    private boolean isActive = true;

    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;

    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;

    @Column(name = "created_by")
    private Long createdBy;

    @Column(name = "updated_by")
    private Long updatedBy;
}
```

### SalaryComponent Entity
```java
package com.example.demo.payroll.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.math.BigDecimal;
import java.time.Instant;

@Entity
@Table(name = "salary_components", indexes = {
    @Index(name = "idx_salarycomponent_code", columnList = "code", unique = true),
    @Index(name = "idx_salarycomponent_type", columnList = "type")
})
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@EntityListeners(AuditingEntityListener.class)
public class SalaryComponent {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "code", nullable = false, unique = true, length = 50)
    private String code;

    @Column(name = "name", nullable = false, length = 100)
    private String name;

    @Enumerated(EnumType.STRING)
    @Column(name = "type", nullable = false, length = 20)
    private SalaryComponentType type; // ALLOWANCE, DEDUCTION

    @Enumerated(EnumType.STRING)
    @Column(name = "calculation_type", nullable = false, length = 20)
    private CalculationType calculationType; // FIXED, PERCENTAGE

    @Column(name = "value", precision = 12, scale = 2)
    private BigDecimal value; // Amount for FIXED, percentage for PERCENTAGE

    @Column(name = "is_taxable", nullable = false)
    private boolean isTaxable = false;

    @Column(name = "is_active", nullable = false)
    private boolean isActive = true;

    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;

    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;
}
```

### PayrollAudit Entity
```java
package com.example.demo.payroll.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.Instant;

@Entity
@Table(name = "payroll_audits", indexes = {
    @Index(name = "idx_payrollaudit_ledger_id", columnList = "payroll_ledger_id"),
    @Index(name = "idx_payrollaudit_performed_by", columnList = "performed_by")
})
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@EntityListeners(AuditingEntityListener.class)
public class PayrollAudit {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "payroll_ledger_id", nullable = false)
    private Long payrollLedgerId;

    @Column(name = "action", nullable = false, length = 50)
    private String action;

    @Lob
    @Column(name = "details", columnDefinition = "TEXT")
    private String details; // JSON string of changes

    @Column(name = "reason", length = 500)
    private String reason;

    @Column(name = "performed_by", nullable = false)
    private Long performedBy;

    @CreatedDate
    @Column(name = "performed_at", nullable = false, updatable = false)
    private Instant performedAt;

    @Column(name = "ip_address", length = 45)
    private String ipAddress;
}
```

## Relationship Management

### Many-to-Many Relationships

Many-to-many relationships like `User-Role` and `Role-Resource` are managed directly via JPA's `@ManyToMany` and `@JoinTable` annotations within the `User` and `Role` entities. This ensures that the relationships are stored in PostgreSQL junction tables (`user_roles`, `role_resources`), maintaining full ACID compliance and referential integrity.

The previous design of storing these critical relationships in Redis (`@RedisHash`) was a severe design flaw and has been removed. The correct implementation is already defined in the `User` and `Role` entities.

## Caching Strategy

### Cache Configurations

```java
@Configuration
@EnableCaching
public class CacheConfig {
    
    // User permissions cache - 30 minutes TTL
    @Bean
    public RedisCacheConfiguration userPermissionsCache() {
        return RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofMinutes(30))
            .serializeKeysWith(RedisSerializationContext.SerializationPair
                .fromSerializer(new StringRedisSerializer()))
            .serializeValuesWith(RedisSerializationContext.SerializationPair
                .fromSerializer(new GenericJackson2JsonRedisSerializer()));
    }
    
    // Department tree cache - 1 hour TTL
    @Bean
    public RedisCacheConfiguration departmentTreeCache() {
        return RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofHours(1));
    }
    
    // Employee search cache - 15 minutes TTL
    @Bean
    public RedisCacheConfiguration employeeSearchCache() {
        return RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofMinutes(15));
    }
}
```

### Cache Keys Pattern

```
Cache Key Patterns:
- User permissions: cache:user_permissions:{userId}
- Department tree: cache:department_tree:all
- Employee search: cache:employee_search:{searchHash}
- Position list: cache:positions:department:{departmentId}
- Payroll summary: cache:payroll_summary:{employeeId}:{period}
```#
# Data Initialization and Seeding

### Initial Data Requirements

#### Default Roles
```java
// System default roles to be created on startup
public enum DefaultRoles {
    SUPER_ADMIN("Super Administrator", "Full system access"),
    ADMIN("Administrator", "System administration access"),
    HR_MANAGER("HR Manager", "Human resources management"),
    DEPARTMENT_MANAGER("Department Manager", "Department management"),
    EMPLOYEE("Employee", "Basic employee access");
}
```

#### Default Resources
```java
// System resources for permission management
public class DefaultResources {
    // User Management
    USER_CREATE("/api/users", "POST", "Create new user"),
    USER_READ("/api/users/**", "GET", "View user information"),
    USER_UPDATE("/api/users/**", "PUT", "Update user information"),
    USER_DELETE("/api/users/**", "DELETE", "Delete user"),
    
    // Employee Management
    EMPLOYEE_CREATE("/api/employees", "POST", "Create new employee"),
    EMPLOYEE_READ("/api/employees/**", "GET", "View employee information"),
    EMPLOYEE_UPDATE("/api/employees/**", "PUT", "Update employee information"),
    EMPLOYEE_DELETE("/api/employees/**", "DELETE", "Delete employee"),
    EMPLOYEE_IMPORT("/api/employees/import", "POST", "Import employees"),
    EMPLOYEE_EXPORT("/api/employees/export", "GET", "Export employees"),
    
    // Department Management
    DEPARTMENT_CREATE("/api/departments", "POST", "Create department"),
    DEPARTMENT_READ("/api/departments/**", "GET", "View departments"),
    DEPARTMENT_UPDATE("/api/departments/**", "PUT", "Update department"),
    DEPARTMENT_DELETE("/api/departments/**", "DELETE", "Delete department"),
    
    // Payroll Management
    PAYROLL_CREATE("/api/payroll/**", "POST", "Create payroll"),
    PAYROLL_READ("/api/payroll/**", "GET", "View payroll"),
    PAYROLL_UPDATE("/api/payroll/**", "PUT", "Update payroll"),
    PAYROLL_PROCESS("/api/payroll/process", "POST", "Process payroll");
}
```

### Data Migration Scripts

#### Version 1.0 - Initial Schema
```java
@Component
public class DatabaseInitializer implements ApplicationRunner {
    
    @Override
    public void run(ApplicationArguments args) throws Exception {
        // Create default roles
        createDefaultRoles();
        
        // Create default resources
        createDefaultResources();
        
        // Create default admin user
        createDefaultAdminUser();
        
        // Create default salary components
        createDefaultSalaryComponents();
        
        // Create default email templates
        createDefaultEmailTemplates();
    }
}
```

## Performance Optimization

### Indexing Strategy

```java
// Custom indexes for complex queries
@Configuration
public class RedisIndexConfig {
    
    @Bean
    public RedisTemplate<String, Object> redisTemplate() {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        
        // Configure serializers
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        template.setHashKeySerializer(new StringRedisSerializer());
        template.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());
        
        return template;
    }
    
    // Create composite indexes for complex queries
    @PostConstruct
    public void createIndexes() {
        // Employee search index
        createEmployeeSearchIndex();
        
        // Department hierarchy index
        createDepartmentHierarchyIndex();
        
        // Payroll period index
        createPayrollPeriodIndex();
    }
}
```

### Query Optimization Patterns

```java
// Efficient query patterns for Redis
public class QueryOptimizationPatterns {
    
    // Use pipeline for batch operations
    public List<Employee> findEmployeesByIds(Set<Long> ids) {
        return redisTemplate.executePipelined(connection -> {
            ids.forEach(id -> connection.get(("employees:" + id).getBytes()));
            return null;
        });
    }
    
    // **Architectural Mandate:** Caching layers are only to be updated or invalidated *after* a successful transaction in the primary PostgreSQL database.
    // The following Lua script example is removed as it violates this principle.
}
```

## Backup and Recovery

### Backup Strategy

```yaml
# Redis backup configuration
redis:
  backup:
    enabled: true
    schedule: "0 2 * * *"  # Daily at 2 AM
    retention: 30          # Keep 30 days of backups
    location: "/backup/redis"
    compression: true
```

### Data Recovery Procedures

```java
@Service
public class DataRecoveryService {
    
    public void createBackup(String backupName) {
        // Create Redis snapshot
        redisTemplate.execute(connection -> {
            connection.bgSave();
            return null;
        });
    }
    
    public void restoreFromBackup(String backupFile) {
        // Restore from Redis dump file
        // Implementation depends on deployment strategy
    }
    
    public void validateDataIntegrity() {
        // Validate referential integrity
        validateUserRoleReferences();
        validateEmployeeDepartmentReferences();
        validatePayrollEmployeeReferences();
    }
}
```

## Monitoring and Metrics

### Database Monitoring

```java
@Component
public class DatabaseMetrics {
    
    private final MeterRegistry meterRegistry;
    private final RedisTemplate redisTemplate;
    
    @EventListener
    public void handleDatabaseOperation(DatabaseOperationEvent event) {
        Timer.Sample sample = Timer.start(meterRegistry);
        sample.stop(Timer.builder("database.operation")
            .tag("operation", event.getOperation())
            .tag("entity", event.getEntityType())
            .register(meterRegistry));
    }
    
    @Scheduled(fixedRate = 60000) // Every minute
    public void collectRedisMetrics() {
        RedisInfo info = (RedisInfo) redisTemplate.execute(connection -> {
            return connection.info();
        });
        
        // Collect memory usage, connections, operations/sec
        meterRegistry.gauge("redis.memory.used", info.getUsedMemory());
        meterRegistry.gauge("redis.connections.connected", info.getConnectedClients());
    }
}
```

## Security and Compliance

### Field-Level Encryption

To address GDPR, CCPA, and other privacy regulations, sensitive PII fields must be encrypted at rest:

```java
@Configuration
public class EncryptionConfig {
    
    @Bean
    public AESUtil aesUtil() {
        return new AESUtil(encryptionKey());
    }
    
    private String encryptionKey() {
        // Load from secure key management system
        return System.getenv("DB_ENCRYPTION_KEY");
    }
}

// Custom JPA converter for encrypted fields
@Converter
public class EncryptedStringConverter implements AttributeConverter<String, String> {
    
    @Autowired
    private AESUtil aesUtil;
    
    @Override
    public String convertToDatabaseColumn(String attribute) {
        if (attribute == null) return null;
        return aesUtil.encrypt(attribute);
    }
    
    @Override
    public String convertToEntityAttribute(String dbData) {
        if (dbData == null) return null;
        return aesUtil.decrypt(dbData);
    }
}

// Usage in entities
@Entity
public class Employee {
    // ... other fields
    
    @Convert(converter = EncryptedStringConverter.class)
    @Column(name = "date_of_birth")
    private String dateOfBirth; // Encrypted
    
    @Convert(converter = EncryptedStringConverter.class)
    @Column(name = "bank_account")
    private String bankAccount; // Encrypted
    
    @Convert(converter = EncryptedStringConverter.class)
    @Column(name = "tax_id")
    private String taxId; // Encrypted
}
```

### Audit Trail Configuration

```java
@Configuration
@EnableJpaAuditing(auditorAwareRef = "auditorProvider")
public class AuditConfig {
    
    @Bean
    public AuditorAware<Long> auditorProvider() {
        return new SecurityAuditorAware();
    }
}

@Component
public class SecurityAuditorAware implements AuditorAware<Long> {
    
    @Override
    public Optional<Long> getCurrentAuditor() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication == null || !authentication.isAuthenticated()) {
            return Optional.empty();
        }
        
        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();
        return Optional.of(userPrincipal.getId());
    }
}
```

### Permission-Based Data Access

```java
// Repository with permission-based filtering
@Repository
public interface EmployeeRepository extends JpaRepository<Employee, Long> {
    
    // Department managers can only see employees in their department
    @Query("SELECT e FROM Employee e WHERE e.departmentId = :departmentId OR :hasGlobalAccess = true")
    Page<Employee> findByDepartmentWithPermission(
        @Param("departmentId") Long departmentId,
        @Param("hasGlobalAccess") boolean hasGlobalAccess,
        Pageable pageable
    );
    
    // HR can see all, managers can see their direct reports
    @Query("SELECT e FROM Employee e WHERE e.managerId = :managerId OR :hasHRAccess = true")
    List<Employee> findDirectReportsWithPermission(
        @Param("managerId") Long managerId,
        @Param("hasHRAccess") boolean hasHRAccess
    );
}
```

## Database Migration Scripts

### Flyway Migration Structure

```
src/main/resources/db/migration/
├── V1__Initial_schema.sql
├── V2__Add_encryption_support.sql
├── V3__Add_audit_fields.sql
├── V4__Create_indexes.sql
├── V5__Insert_default_data.sql
└── V6__Add_permission_constraints.sql
```

### Sample Migration Script (V1__Initial_schema.sql)

```sql
-- Users table
CREATE TABLE users (
    id BIGSERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    password VARCHAR(255) NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    enabled BOOLEAN NOT NULL DEFAULT true,
    last_login TIMESTAMP,
    login_attempts INTEGER DEFAULT 0,
    account_locked BOOLEAN DEFAULT false,
    password_expired BOOLEAN DEFAULT false,
    password_change_required BOOLEAN DEFAULT false,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_by BIGINT,
    updated_by BIGINT
);

-- Roles table
CREATE TABLE roles (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(50) UNIQUE NOT NULL,
    description VARCHAR(255),
    active BOOLEAN NOT NULL DEFAULT true,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_by BIGINT,
    updated_by BIGINT
);

-- Resources table
CREATE TABLE resources (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    url VARCHAR(255) NOT NULL,
    method VARCHAR(10) NOT NULL,
    description VARCHAR(255),
    category VARCHAR(50) NOT NULL,
    active BOOLEAN NOT NULL DEFAULT true,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_by BIGINT,
    updated_by BIGINT,
    UNIQUE(url, method)
);

-- User-Role junction table
CREATE TABLE user_roles (
    user_id BIGINT NOT NULL,
    role_id BIGINT NOT NULL,
    assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    assigned_by BIGINT,
    expires_at TIMESTAMP,
    active BOOLEAN DEFAULT true,
    PRIMARY KEY (user_id, role_id),
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (role_id) REFERENCES roles(id) ON DELETE CASCADE
);

-- Role-Resource junction table
CREATE TABLE role_resources (
    role_id BIGINT NOT NULL,
    resource_id BIGINT NOT NULL,
    assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    assigned_by BIGINT,
    active BOOLEAN DEFAULT true,
    PRIMARY KEY (role_id, resource_id),
    FOREIGN KEY (role_id) REFERENCES roles(id) ON DELETE CASCADE,
    FOREIGN KEY (resource_id) REFERENCES resources(id) ON DELETE CASCADE
);

-- Departments table
CREATE TABLE departments (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    code VARCHAR(20) UNIQUE NOT NULL,
    description VARCHAR(500),
    location VARCHAR(255),
    parent_id BIGINT,
    dep_path VARCHAR(500),
    is_parent BOOLEAN NOT NULL DEFAULT false,
    enabled BOOLEAN NOT NULL DEFAULT true,
    level INTEGER DEFAULT 0,
    sort_order INTEGER DEFAULT 0,
    manager_id BIGINT,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_by BIGINT,
    updated_by BIGINT,
    FOREIGN KEY (parent_id) REFERENCES departments(id)
);

-- Continue with other tables...
```

## Performance Optimization

### Database Indexes Strategy

```sql
-- Composite indexes for common query patterns
CREATE INDEX idx_employee_dept_status ON employees(department_id, status);
CREATE INDEX idx_employee_manager_active ON employees(manager_id, enabled);
CREATE INDEX idx_payroll_employee_period ON payroll_ledgers(employee_id, pay_period_id);
CREATE INDEX idx_email_log_status_date ON email_logs(status, sent_at);

-- Partial indexes for active records
CREATE INDEX idx_active_employees ON employees(department_id) WHERE enabled = true;
CREATE INDEX idx_active_departments ON departments(parent_id) WHERE enabled = true;

-- Full-text search indexes
CREATE INDEX idx_employee_search ON employees USING gin(to_tsvector('english', first_name || ' ' || last_name || ' ' || email));

-- Announcements Table
CREATE TABLE announcements (
    id BIGSERIAL PRIMARY KEY,
    title VARCHAR(200) NOT NULL,
    content TEXT NOT NULL,
    author_id BIGINT NOT NULL,
    target_audience VARCHAR(50),
    department_id BIGINT,
    publish_date DATE,
    expiry_date DATE,
    published BOOLEAN NOT NULL DEFAULT false,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP,
    created_by BIGINT,
    updated_by BIGINT
);

### Query Optimization Patterns

```java
// Use projections for list views to reduce data transfer
public interface EmployeeListProjection {
    Long getId();
    String getEmployeeNumber();
    String getFirstName();
    String getLastName();
    String getEmail();
    String getDepartmentName();
    String getPositionTitle();
    EmployeeStatus getStatus();
}

@Query("SELECT e.id as id, e.employeeNumber as employeeNumber, " +
       "e.firstName as firstName, e.lastName as lastName, e.email as email, " +
       "d.name as departmentName, p.jobTitle as positionTitle, e.status as status " +
       "FROM Employee e LEFT JOIN Department d ON e.departmentId = d.id " +
       "LEFT JOIN Position p ON e.positionId = p.id " +
       "WHERE (:departmentId IS NULL OR e.departmentId = :departmentId) " +
       "AND (:status IS NULL OR e.status = :status)")
Page<EmployeeListProjection> findEmployeeList(
    @Param("departmentId") Long departmentId,
    @Param("status") EmployeeStatus status,
    Pageable pageable
);
```

## Monitoring and Health Checks

### Database Health Monitoring

```java
@Component
public class DatabaseHealthIndicator implements HealthIndicator {
    
    @Autowired
    private DataSource dataSource;
    
    @Override
    public Health health() {
        try (Connection connection = dataSource.getConnection()) {
            if (connection.isValid(1)) {
                return Health.up()
                    .withDetail("database", "PostgreSQL")
                    .withDetail("status", "Connected")
                    .build();
            }
        } catch (SQLException e) {
            return Health.down()
                .withDetail("database", "PostgreSQL")
                .withDetail("error", e.getMessage())
                .build();
        }
        return Health.down().build();
    }
}
```

This comprehensive database design document provides:

1. **Hybrid Architecture** - PostgreSQL for persistent data, Redis for caching and real-time features
2. **Complete Entity Schemas** - All entities with proper JPA annotations and relationships
3. **Security & Compliance** - Field-level encryption, audit trails, and permission-based access
4. **Data Migration** - Flyway scripts for database versioning
5. **Performance Optimization** - Strategic indexing and query optimization
6. **Monitoring** - Database health checks and metrics
7. **Conflict Resolution** - Addresses all entity field mismatches identified in the conflict analysis

The design resolves all conflicts identified in the conflict analysis and provides a robust, secure, and scalable foundation for the Spring Boot implementation.
</file>

<file path="department-implementation.md">
# Department Management Implementation

## Overview
This document provides detailed implementation specifications for the Department Management module. This module handles hierarchical department structure, department CRUD operations, and department tree queries with recursive support.

## Package Structure
```
com.example.demo.department/
├── entity/
│   └── Department.java
├── repository/
│   └── DepartmentRepository.java
├── service/
│   ├── DepartmentService.java
│   └── impl/
│       └── DepartmentServiceImpl.java
├── controller/
│   └── DepartmentController.java
├── dto/
│   ├── DepartmentDto.java
│   ├── DepartmentTreeDto.java
│   └── DepartmentCreateRequest.java
|   └── DepartmentUpdateRequest.java
└── exception/
    ├── DepartmentNotFoundException.java
    ├── DepartmentHierarchyException.java
    └── DepartmentInUseException.java
```

## Entity Class

### Department Entity
```java
package com.example.demo.department.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.Instant;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "departments", indexes = {
    @Index(name = "idx_department_name", columnList = "name"),
    @Index(name = "idx_department_code", columnList = "code"),
    @Index(name = "idx_department_parent_id", columnList = "parent_id"),
    @Index(name = "idx_department_dep_path", columnList = "dep_path"),
    @Index(name = "idx_department_enabled", columnList = "enabled"),
    @Index(name = "idx_department_manager_id", columnList = "manager_id")
})
@EntityListeners(AuditingEntityListener.class)
@Getter
@Setter
public class Department {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "name", nullable = false, length = 100)
    private String name;
    
    @Column(name = "code", unique = true, nullable = false, length = 20)
    private String code;
    
    @Column(name = "description", length = 500)
    private String description;
    
    @Column(name = "location", length = 255)
    private String location;
    
    @Column(name = "parent_id")
    private Long parentId;
    
    @Column(name = "dep_path", length = 500)
    private String depPath;
    
    @Column(name = "is_parent", nullable = false)
    private Boolean isParent = false;
    
    @Column(name = "enabled", nullable = false)
    private Boolean enabled = true;
    
    @Column(name = "level")
    private Integer level = 0;
    
    @Column(name = "sort_order")
    private Integer sortOrder = 0;
    
    @Column(name = "manager_id")
    private Long managerId;
    
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;
    
    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;
    
    @Column(name = "created_by")
    private Long createdBy;
    
    @Column(name = "updated_by")
    private Long updatedBy;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "parent_id", insertable = false, updatable = false)
    private Department parent;
    
    @OneToMany(mappedBy = "parent", fetch = FetchType.LAZY)
    private Set<Department> children = new HashSet<>();
    
    // Employee relationship is defined in the Employee entity
    
    @Transient
    private Long employeeCount;
}
```

## Repository Interface

### DepartmentRepository
```java
package com.example.demo.department.repository;

import com.example.demo.department.entity.Department;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface DepartmentRepository extends JpaRepository<Department, Long> {
    
    /**
     * Find department by name
     * @param name Department name
     * @return Optional department
     */
    Optional<Department> findByName(String name);
    
    /**
     * Find departments by parent ID
     * @param parentId Parent department ID
     * @return List of child departments
     */
    List<Department> findByParentIdOrderBySortOrder(Long parentId);
    
    /**
     * Find root departments (parentId is null)
     * @return List of root departments
     */
    List<Department> findByParentIdIsNullOrderBySortOrder();
    
    /**
     * Find departments by level
     * @param level Hierarchy level
     * @return List of departments at specified level
     */
    List<Department> findByLevel(Integer level);
    
    /**
     * Find departments by path prefix (for subtree queries)
     * @param pathPrefix Path prefix to match
     * @return List of departments in subtree
     */
    List<Department> findByDepPathStartingWithOrderByDepPath(String pathPrefix);
    
    /**
     * Find enabled departments
     * @return List of enabled departments
     */
    List<Department> findByEnabledTrueOrderByDepPath();
    
    /**
     * Find departments by name containing (case insensitive)
     * @param name Name search term
     * @return List of matching departments
     */
    List<Department> findByNameContainingIgnoreCaseOrderByName(String name);
    
    /**
     * Find departments by code
     * @param code Department code
     * @return Optional department
     */
    Optional<Department> findByCode(String code);
    
    /**
     * Check if department name exists
     * @param name Department name
     * @return true if exists
     */
    boolean existsByName(String name);
    
    /**
     * Check if department code exists
     * @param code Department code
     * @return true if exists
     */
    boolean existsByCode(String code);
    
    /**
     * Check if department has children
     * @param parentId Parent department ID
     * @return true if has children
     */
    boolean existsByParentId(Long parentId);
    
    /**
     * Count departments by parent ID
     * @param parentId Parent department ID
     * @return Count of child departments
     */
    long countByParentId(Long parentId);
    
    /**
     * Find departments by manager ID
     * @param managerId Manager employee ID
     * @return List of departments managed by the employee
     */
    List<Department> findByManagerId(Long managerId);
}
```## DTO 
Classes

### DepartmentDto
```java
package com.example.demo.department.dto;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import jakarta.validation.constraints.Min;
import java.time.Instant;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class DepartmentDto {
    
    private Long id;
    
    @NotBlank(message = "Department name is required")
    @Size(min = 2, max = 100, message = "Department name must be between 2 and 100 characters")
    private String name;
    
    @Size(max = 255, message = "Description must not exceed 255 characters")
    private String description;
    
    private Long parentId;
    
    private String depPath;
    
    private Boolean isParent;
    
    @Min(value = 0, message = "Level must be non-negative")
    private Integer level;
    
    @Min(value = 0, message = "Sort order must be non-negative")
    private Integer sortOrder;
    
    @Size(max = 20, message = "Department code must not exceed 20 characters")
    private String code;
    
    @Size(max = 100, message = "Location must not exceed 100 characters")
    private String location;
    
    private Long managerId;
    
    private String managerName; // Transient field for display
    
    private boolean enabled;
    
    private Instant createdAt;
    private Instant updatedAt;
    
    private Long createdBy;
    
    private Long updatedBy;
    
    private String createdByName; // Transient field for display
    
    private String updatedByName; // Transient field for display
    
    private List<DepartmentDto> children;
    
    private DepartmentDto parent;
    
    private Long employeeCount; // Number of employees in this department
}
```

### DepartmentTreeDto
```java
package com.example.demo.department.dto;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;

import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class DepartmentTreeDto {
    
    private Long id;
    
    private String name;
    
    private String code;
    
    private Long parentId;
    
    private Integer level;
    
    private Integer sortOrder;
    
    private boolean enabled;
    
    private boolean hasChildren;
    
    private Long employeeCount;
    
    private String managerName;
    
    private List<DepartmentTreeDto> children;
    
    // Additional fields for tree display
    private boolean expanded; // For UI tree expansion state
    
    private boolean selectable; // Whether this node can be selected
    
    private String icon; // Icon for tree node display
}
```

### DepartmentCreateRequest
```java
package com.example.demo.department.dto;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import jakarta.validation.constraints.Min;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class DepartmentCreateRequest {
    
    @NotBlank(message = "Department name is required")
    @Size(min = 2, max = 100, message = "Department name must be between 2 and 100 characters")
    private String name;
    
    @Size(max = 255, message = "Description must not exceed 255 characters")
    private String description;
    
    private Long parentId;
    
    @Min(value = 0, message = "Sort order must be non-negative")
    private Integer sortOrder;
    
    @Size(max = 20, message = "Department code must not exceed 20 characters")
    private String code;
    
    @Size(max = 100, message = "Location must not exceed 100 characters")
    private String location;
    
    private Long managerId;
    
    private boolean enabled = true;
}
```

### DepartmentUpdateRequest
```java
package com.example.demo.department.dto;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import jakarta.validation.constraints.Min;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class DepartmentUpdateRequest {
    
    @NotBlank(message = "Department name is required")
    @Size(min = 2, max = 100, message = "Department name must be between 2 and 100 characters")
    private String name;
    
    @Size(max = 255, message = "Description must not exceed 255 characters")
    private String description;
    
    @Min(value = 0, message = "Sort order must be non-negative")
    private Integer sortOrder;
    
    @Size(max = 20, message = "Department code must not exceed 20 characters")
    private String code;
    
    @Size(max = 100, message = "Location must not exceed 100 characters")
    private String location;
    
    private Long managerId;
    
    private boolean enabled;
}
```#
# Service Interface and Implementation

### DepartmentService Interface
```java
package com.example.demo.department.service;

import com.example.demo.department.dto.DepartmentDto;
import com.example.demo.department.dto.DepartmentTreeDto;
import com.example.demo.department.dto.DepartmentCreateRequest;
import com.example.demo.department.dto.DepartmentUpdateRequest;

import java.util.List;

public interface DepartmentService {
    
    /**
     * Create a new department
     * @param request Department creation request
     * @return Created department DTO
     * @throws DepartmentAlreadyExistsException if name or code already exists
     * @throws DepartmentNotFoundException if parent department not found
     */
    DepartmentDto createDepartment(DepartmentCreateRequest request);
    
    /**
     * Update an existing department
     * @param id Department ID
     * @param request Department update request
     * @return Updated department DTO
     * @throws DepartmentNotFoundException if department not found
     * @throws DepartmentAlreadyExistsException if name or code conflicts
     */
    DepartmentDto updateDepartment(Long id, DepartmentUpdateRequest request);
    
    /**
     * Get department by ID
     * @param id Department ID
     * @return Department DTO
     * @throws DepartmentNotFoundException if department not found
     */
    DepartmentDto getDepartmentById(Long id);
    
    /**
     * Get department by code
     * @param code Department code
     * @return Department DTO
     * @throws DepartmentNotFoundException if department not found
     */
    DepartmentDto getDepartmentByCode(String code);
    
    /**
     * Get all departments as flat list
     * @return List of department DTOs
     */
    List<DepartmentDto> getAllDepartments();
    
    /**
     * Get department tree structure
     * @return List of root department tree DTOs with children
     */
    List<DepartmentTreeDto> getDepartmentTree();
    
    /**
     * Get department subtree starting from specified department
     * @param departmentId Root department ID for subtree
     * @return Department tree DTO with children
     * @throws DepartmentNotFoundException if department not found
     */
    DepartmentTreeDto getDepartmentSubtree(Long departmentId);
    
    /**
     * Get child departments of specified parent
     * @param parentId Parent department ID (null for root departments)
     * @return List of child department DTOs
     */
    List<DepartmentDto> getChildDepartments(Long parentId);
    
    /**
     * Get departments by level in hierarchy
     * @param level Hierarchy level (0 for root)
     * @return List of department DTOs at specified level
     */
    List<DepartmentDto> getDepartmentsByLevel(Integer level);
    
    /**
     * Search departments by name
     * @param searchTerm Search term for department name
     * @return List of matching department DTOs
     */
    List<DepartmentDto> searchDepartments(String searchTerm);
    
    /**
     * Delete department by ID
     * @param id Department ID
     * @throws DepartmentNotFoundException if department not found
     * @throws DepartmentHierarchyException if department has children
     * @throws DepartmentInUseException if department has employees
     */
    void deleteDepartment(Long id);
    
    /**
     * Move department to new parent
     * @param departmentId Department ID to move
     * @param newParentId New parent department ID (null for root)
     * @throws DepartmentNotFoundException if department or parent not found
     * @throws DepartmentHierarchyException if move would create circular reference
     */
    void moveDepartment(Long departmentId, Long newParentId);
    
    /**
     * Enable or disable department
     * @param id Department ID
     * @param enabled Enable/disable flag
     * @throws DepartmentNotFoundException if department not found
     */
    void setDepartmentEnabled(Long id, boolean enabled);
    
    /**
     * Update department sort order
     * @param id Department ID
     * @param sortOrder New sort order
     * @throws DepartmentNotFoundException if department not found
     */
    void updateSortOrder(Long id, Integer sortOrder);
    
    /**
     * Get department path from root to specified department
     * @param departmentId Department ID
     * @return List of department DTOs representing path from root
     * @throws DepartmentNotFoundException if department not found
     */
    List<DepartmentDto> getDepartmentPath(Long departmentId);
    
    /**
     * Get all ancestor departments of specified department
     * @param departmentId Department ID
     * @return List of ancestor department DTOs
     * @throws DepartmentNotFoundException if department not found
     */
    List<DepartmentDto> getAncestorDepartments(Long departmentId);
    
    /**
     * Get all descendant departments of specified department
     * @param departmentId Department ID
     * @return List of descendant department DTOs
     * @throws DepartmentNotFoundException if department not found
     */
    List<DepartmentDto> getDescendantDepartments(Long departmentId);
    
    /**
     * Check if department can be deleted
     * @param id Department ID
     * @return true if department can be safely deleted
     * @throws DepartmentNotFoundException if department not found
     */
    boolean canDeleteDepartment(Long id);
    
    /**
     * Get department statistics
     * @param departmentId Department ID
     * @return Department statistics including employee count, child count, etc.
     * @throws DepartmentNotFoundException if department not found
     */
    DepartmentStatisticsDto getDepartmentStatistics(Long departmentId);
    
    /**
     * Rebuild department paths (maintenance operation)
     * This method recalculates all department paths and levels
     */
    void rebuildDepartmentPaths();
}
```

### DepartmentStatisticsDto
```java
package com.example.demo.department.dto;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class DepartmentStatisticsDto {
    
    private Long departmentId;
    
    private String departmentName;
    
    private Long directEmployeeCount; // Employees directly in this department
    
    private Long totalEmployeeCount; // Employees in this department and all subdepartments
    
    private Long directChildCount; // Direct child departments
    
    private Long totalChildCount; // All descendant departments
    
    private Integer maxDepth; // Maximum depth of subdepartments
    
    private boolean hasManager;
    
    private String managerName;
}
```
</file>

<file path="design.md">
# Design Document - Employee Management System

## Overview

The Employee Management System is a comprehensive enterprise-grade HR management solution built with Spring Boot 3.5.3 and Java 24. The system provides role-based access control, employee information management, department processing, payroll management, and communication features. It follows a layered architecture pattern with clear separation of concerns and leverages Spring Boot's auto-configuration capabilities.

## Architecture

### System Architecture

```mermaid
graph TB
    subgraph "Frontend Layer"
        UI[React Frontend]
        AXIOS[Axios HTTP Client]
        WS[WebSocket Client]
    end
    
    subgraph "Spring Boot Application"
        CTRL[Controllers Layer]
        SVC[Services Layer]
        REPO[Repository Layer]
        SEC[Spring Security + JWT]
        MAIL[Email Service]
        CHAT[WebSocket Chat Service]
        ENCRYPT[Encryption Service]
        AUDIT[Audit Service]
    end
    
    subgraph "Data Layer"
        PG[(PostgreSQL Database)]
        REDIS[(Redis Cache & Real-time)]
        FLYWAY[Flyway Migration]
    end
    
    UI --> AXIOS
    UI --> WS
    AXIOS --> CTRL
    WS --> CHAT
    CTRL --> SEC
    CTRL --> SVC
    SVC --> REPO
    SVC --> MAIL
    SVC --> ENCRYPT
    SVC --> AUDIT
    REPO --> PG
    CHAT --> REDIS
    SVC --> REDIS
    FLYWAY --> PG
```

### Hybrid Data Storage Strategy

The system uses a hybrid approach with PostgreSQL as the primary database and Redis for caching and real-time features:

**PostgreSQL (Primary Database):**
- All core business entities (User, Role, Resource, Employee, Department, Position, PayrollLedger)
- All transactional data with ACID compliance
- Relational integrity enforcement with foreign key constraints
- Complex queries, joins, and reporting capabilities
- Audit trails and historical data
- User authentication data and role assignments

**Redis (Cache & Real-time Only):**
- JWT token blacklisting for logout functionality
- Session data caching (not authentication state)
- Real-time chat messages and notifications
- Search result caching and frequently accessed data
- WebSocket connection management
- Department tree caching for performance

**Critical Design Principle:** Redis is used exclusively for caching and real-time features. All persistent, relational data must be stored in PostgreSQL to ensure data integrity, consistency, and proper transaction support.

### Technology Stack Integration

- **Backend**: Spring Boot 3.5.4 with Java 24
- **Security**: Spring Security with JWT authentication and role-based authorization
- **Primary Database**: PostgreSQL 15.x with JPA/Hibernate
- **Cache & Real-time**: Redis 7.x for caching and WebSocket features
- **Migration**: Flyway for database versioning and schema management
- **Email**: Spring Boot Mail with Freemarker templates
- **Encryption**: AES encryption for sensitive PII data
- **Build**: Maven with standard Spring Boot structure
- **Deployment**: Executable JAR with embedded Tomcat (modern approach)

## Components and Interfaces

### 1. Security and Permission Management

#### Permission Management Components
```java
// Core permission entities (PostgreSQL-based)
@Entity
@Table(name = "resources")
public class Resource {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private String url;
    private String method;
    private String description;
    private String category; // Resource category for organization
    private Boolean active = true;
    
    @CreatedDate
    private Instant createdAt;
    @LastModifiedDate
    private Instant updatedAt;
    private Long createdBy;
    private Long updatedBy;
}

@Entity
@Table(name = "roles")
public class Role {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private String description;
    private Boolean active = true;
    
    @CreatedDate
    private Instant createdAt;
    @LastModifiedDate
    private Instant updatedAt;
    private Long createdBy;
    private Long updatedBy;
    
    @ManyToMany
    @JoinTable(name = "role_resources")
    private Set<Resource> resources;
}

@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String username;
    private String password; // BCrypt encoded
    private String email;
    private Boolean enabled = true;
    private Integer loginAttempts = 0;
    private Boolean accountLocked = false;
    
    @CreatedDate
    private Instant createdAt;
    @LastModifiedDate
    private Instant updatedAt;
    private Long createdBy;
    private Long updatedBy;
    
    @ManyToMany
    @JoinTable(name = "user_roles")
    private Set<Role> roles;
}
```

#### Permission String Format
The system uses a standardized permission string format: `RESOURCE:ACTION`
- Examples: `EMPLOYEE:READ`, `EMPLOYEE:WRITE`, `DEPARTMENT:DELETE`, `PAYROLL:ADMIN`
- This format is used consistently across all authorization checks

#### Security Configuration
```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http);
    
    @Bean
    public PasswordEncoder passwordEncoder();
    
    @Bean
    public AuthenticationManager authenticationManager();
}
```

### 2. Department Management

#### Department Entity and Service
```java
@Entity
@Table(name = "departments")
public class Department {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private String code; // Unique department code
    private String description;
    private String depPath; // Materialized path for hierarchy
    private Long parentId;
    private Boolean isParent = false;
    private Integer level = 0;
    private Boolean enabled = true;
    private Long managerId; // Employee ID of department manager
    
    @CreatedDate
    private Instant createdAt;
    @LastModifiedDate
    private Instant updatedAt;
    private Long createdBy;
    private Long updatedBy;
    
    @ManyToOne
    @JoinColumn(name = "parent_id", insertable = false, updatable = false)
    private Department parent;
    
    @OneToMany(mappedBy = "parent")
    private Set<Department> children;
}

@Service
public class DepartmentService {
    public List<Department> getDepartmentTree();
    public Department createDepartment(DepartmentCreateRequest request);
    public void updateDepartment(Long id, DepartmentUpdateRequest request);
    public void deleteDepartment(Long id); // With dependency validation
    public void moveDepartment(Long id, Long newParentId); // Atomic path updates
}
```

### 3. Employee Management

#### Employee Entity and Related Services
```java
@Entity
@Table(name = "employees")
public class Employee {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String employeeNumber; // Unique
    private String firstName;
    private String lastName;
    private String email; // Unique
    private String phone;
    private Long departmentId;
    private Long positionId;
    private Long managerId;
    private LocalDate hireDate;
    private LocalDate terminationDate;
    
    @Enumerated(EnumType.STRING)
    private EmployeeStatus status; // ACTIVE, INACTIVE, TERMINATED, ON_LEAVE
    
    @Enumerated(EnumType.STRING)
    private EmploymentType employmentType; // FULL_TIME, PART_TIME, CONTRACT
    
    @Enumerated(EnumType.STRING)
    private PayType payType; // SALARY, HOURLY
    
    private BigDecimal salary; // For salaried employees
    private BigDecimal hourlyRate; // For hourly employees
    
    // Encrypted sensitive fields
    private String dateOfBirth; // Encrypted
    private String bankAccount; // Encrypted
    private String taxId; // Encrypted
    
    @CreatedDate
    private Instant createdAt;
    @LastModifiedDate
    private Instant updatedAt;
    private Long createdBy;
    private Long updatedBy;
    
    @ManyToOne
    @JoinColumn(name = "department_id", insertable = false, updatable = false)
    private Department department;
    
    @ManyToOne
    @JoinColumn(name = "position_id", insertable = false, updatable = false)
    private Position position;
}

@Service
public class EmployeeService {
    public Page<Employee> getEmployees(Pageable pageable, EmployeeSearchCriteria criteria);
    public Employee createEmployee(EmployeeCreateRequest request);
    public void updateEmployee(Long id, EmployeeUpdateRequest request);
    public void deleteEmployees(List<Long> ids); // Batch operation with validation
    public EmployeeImportResult importFromExcel(MultipartFile file);
    public byte[] exportToExcel(EmployeeExportRequest request);
}
```

### 4. Position and Title Management

#### Position Management Components
```java
@Entity
@Table(name = "positions")
public class Position {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String jobTitle;
    private String professionalTitle;
    private String code; // Unique position code
    private String description;
    private Long departmentId;
    
    @Enumerated(EnumType.STRING)
    private PositionLevel level; // JUNIOR, SENIOR, MANAGER, DIRECTOR
    
    @Enumerated(EnumType.STRING)
    private PositionCategory category; // TECHNICAL, MANAGEMENT, ADMINISTRATIVE
    
    private BigDecimal minSalary; // Salary range validation
    private BigDecimal maxSalary;
    private Boolean enabled = true;
    
    @CreatedDate
    private Instant createdAt;
    @LastModifiedDate
    private Instant updatedAt;
    private Long createdBy;
    private Long updatedBy;
    
    @ManyToOne
    @JoinColumn(name = "department_id", insertable = false, updatable = false)
    private Department department;
}

@Service
public class PositionService {
    public Page<Position> getPositions(Pageable pageable, PositionSearchCriteria criteria);
    public Position createPosition(PositionCreateRequest request);
    public void updatePosition(Long id, PositionUpdateRequest request);
    public void deletePosition(Long id); // With dependency validation
    public void validateSalaryRange(BigDecimal salary, Long positionId); // Business rule validation
}
```

### 5. Communication System

#### Email Service
```java
@Service
public class EmailService {
    @Async
    public void sendTemplatedEmail(String to, String template, Map<String, Object> variables);
    
    @Async
    public void sendBulkEmails(List<String> recipients, String template, Map<String, Object> variables);
}
```

#### Chat and Notification System
```java
@Entity
@Table(name = "notifications", indexes = {
    @Index(name = "idx_notification_user_id", columnList = "user_id"),
    @Index(name = "idx_notification_type", columnList = "type"),
    @Index(name = "idx_notification_read_status", columnList = "read_status")
})
@EntityListeners(AuditingEntityListener.class)
public class Notification {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
  
    @Column(name = "user_id", nullable = false)
    private Long userId;           // 目标用户
  
    @Column(name = "type", length = 50)
    private String type;           // SYSTEM, EMAIL, CHAT, TASK, etc.
  
    @Column(name = "title", length = 255)
    private String title;
  
    @Column(name = "content", columnDefinition = "TEXT")
    private String content;
  
    @Column(name = "data", columnDefinition = "TEXT")
    private String data;           // 附加的 JSON 数据
  
    @Column(name = "read_status", nullable = false)
    private Boolean read = false;
  
    @Column(name = "priority", length = 20)
    private String priority;       // LOW, MEDIUM, HIGH, URGENT
  
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;     // 时区无关的时间戳
  
    @Column(name = "read_at")
    private Instant readAt;        // 时区无关的时间戳
  
    @Column(name = "expires_at")
    private Instant expiresAt;     // 时区无关的时间戳
  
    @Column(name = "action_url", length = 500)
    private String actionUrl;
  
    @Column(name = "related_entity_id")
    private Long relatedEntityId;
  
    @Column(name = "related_entity_type", length = 50)
    private String relatedEntityType;
}


@Service
public class NotificationService {
    public void createNotification(Long userId, String content);
    public List<SystemMessage> getUserNotifications(Long userId);
    public void markAsRead(Long messageId, Long userId);
}

#### Chat and Announcement Entities
```java
@Entity
@Table(name = "chat_rooms")
public class ChatRoom {
    @Id
    private Long id;
    private String name;
    @Enumerated(EnumType.STRING)
    private ChatRoomType type; // DIRECT, GROUP, CHANNEL
    private Long createdBy;
    
    @OneToMany(mappedBy = "room", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<ChatParticipant> participants;
}

@Entity
@Table(name = "chat_participants")
public class ChatParticipant {
    @Id
    private Long id;
    
    @ManyToOne
    @JoinColumn(name = "room_id")
    private ChatRoom room;
    
    private Long userId;
    
    @Enumerated(EnumType.STRING)
    private ChatParticipantRole role; // OWNER, ADMIN, MEMBER
}

@Entity
@Table(name = "chat_messages")
public class ChatMessage {
    @Id
    private Long id;
    
    @ManyToOne
    @JoinColumn(name = "room_id")
    private ChatRoom room;
    
    private Long senderId;
    private String content;
    
    @Enumerated(EnumType.STRING)
    private ChatMessageType messageType; // TEXT, IMAGE, FILE, SYSTEM
}

@Entity
@Table(name = "announcements")
public class Announcement {
    @Id
    private Long id;
    private String title;
    private String content;
    private Long authorId;
    @Enumerated(EnumType.STRING)
    private AnnouncementTarget targetAudience; // ALL, DEPARTMENT, ROLE
    private boolean published;
}
```
```

### 6. Payroll Management

#### Payroll Components
```java
@Entity
@Table(name = "payroll_ledgers")
public class PayrollLedger {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private Long employeeId;
    private String employeeNumber; // Snapshot for historical accuracy
    
    // Employee details at time of payroll (for historical accuracy)
    private String employeeFirstName;
    private String employeeLastName;
    private String departmentName;
    private String positionTitle;
    
    @Enumerated(EnumType.STRING)
    private PayType payType; // SALARY, HOURLY
    
    private BigDecimal baseSalary;
    private BigDecimal hourlyRate;
    private Integer hoursWorked; // For hourly employees
    private BigDecimal overtimeHours;
    private BigDecimal overtimeRate;
    private BigDecimal allowances;
    private BigDecimal deductions;
    private BigDecimal grossPay;
    private BigDecimal netSalary;
    
    private LocalDate payPeriodStart;
    private LocalDate payPeriodEnd;
    
    @Enumerated(EnumType.STRING)
    private PayrollStatus status; // DRAFT, APPROVED, PAID, CANCELLED
    
    @CreatedDate
    private Instant createdAt;
    @LastModifiedDate
    private Instant updatedAt;
    private Long createdBy;
    private Long updatedBy;
    private Long approvedBy;
    private Instant approvedAt;
    
    @ManyToOne
    @JoinColumn(name = "employee_id", insertable = false, updatable = false)
    private Employee employee;
}

@Service
public class PayrollService {
    public PayrollLedger createPayrollLedger(PayrollCreateRequest request);
    public PayrollLedger getPayrollLedger(Long id);
    public void updatePayrollLedger(Long id, PayrollUpdateRequest request);
    public Page<PayrollLedger> getEmployeePayrollHistory(Long employeeId, Pageable pageable);
    public void approvePayroll(Long id, Long approverId);
    public PayrollCalculationResult calculatePayroll(Long employeeId, LocalDate periodStart, LocalDate periodEnd);
}
```

## Data Models

### Database Schema Design

#### PostgreSQL Core Tables Structure
```sql
-- User Management (PostgreSQL)
users (id, username, password, email, enabled, login_attempts, account_locked, created_at, updated_at, created_by, updated_by)
roles (id, name, description, active, created_at, updated_at, created_by, updated_by)
resources (id, name, url, method, description, category, active, created_at, updated_at, created_by, updated_by)
user_roles (user_id, role_id)
role_resources (role_id, resource_id)

-- Organization Structure (PostgreSQL)
departments (id, name, code, description, dep_path, parent_id, is_parent, level, enabled, manager_id, created_at, updated_at, created_by, updated_by)
positions (id, job_title, professional_title, code, description, department_id, level, category, min_salary, max_salary, enabled, created_at, updated_at, created_by, updated_by)

-- Employee Management (PostgreSQL)
employees (id, employee_number, first_name, last_name, email, phone, department_id, position_id, manager_id, hire_date, termination_date, status, employment_type, pay_type, salary, hourly_rate, date_of_birth_encrypted, bank_account_encrypted, tax_id_encrypted, created_at, updated_at, created_by, updated_by)

-- Communication (PostgreSQL for persistence, Redis for real-time)
email_templates (id, name, code, subject, content, template_type, category, active, variables, created_at, updated_at, created_by, updated_by)
email_logs (id, template_code, to_email, cc_emails, bcc_emails, subject, content, status, sent_at, error_message, retry_count, sent_by, created_at, updated_at)
chat_rooms (id, name, type, description, created_by, is_active, created_at, updated_at, last_message_at)
chat_participants (id, room_id, user_id, role, joined_at, last_read_at, is_muted)
chat_messages (id, room_id, sender_id, content, message_type, created_at, is_edited, is_deleted)
announcements (id, title, content, author_id, target_audience, department_id, publish_date, expiry_date, published, created_at, updated_at)
notifications (id, user_id, title, content, type, priority, is_read, read_at, created_at, updated_at)

-- Payroll (PostgreSQL)
payroll_ledgers (id, employee_id, employee_number, employee_first_name, employee_last_name, department_name, position_title, pay_type, base_salary, hourly_rate, hours_worked, overtime_hours, overtime_rate, allowances, deductions, gross_pay, net_salary, pay_period_start, pay_period_end, status, created_at, updated_at, created_by, updated_by, approved_by, approved_at)

-- Audit Trail (PostgreSQL)
audit_logs (id, table_name, record_id, action, old_values, new_values, user_id, created_at)
```

### Redis Data Structure (Caching Only)

#### Caching Strategy
```java
// JWT token blacklisting (for logout)
"jwt:blacklist:{tokenId}" -> expiration timestamp

// Permission caching
"user:permissions:{userId}" -> Set<String> permissions (TTL: 30 minutes)

// Department tree caching
"department:tree" -> Department tree structure (TTL: 1 hour)

// Employee search cache
"employee:search:{hash}" -> Page<Employee> results (TTL: 15 minutes)

// Real-time chat messages (temporary storage)
"chat:room:{roomId}:messages" -> List<ChatMessage> (TTL: 24 hours)

// WebSocket session management
"websocket:sessions:{userId}" -> Set<String> sessionIds

// Notification queue
"notifications:user:{userId}" -> List<Notification> (TTL: 7 days)
```

**Important:** Redis is used exclusively for caching and real-time features. All persistent data is stored in PostgreSQL.

## Error Handling

### Unified Exception Handling

#### Global Exception Handler
```java
@ControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(ValidationException.class)
    public ResponseEntity<ErrorResponse> handleValidation(ValidationException ex);
    
    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity<ErrorResponse> handleAccessDenied(AccessDeniedException ex);
    
    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<ErrorResponse> handleDataIntegrity(DataIntegrityViolationException ex);
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGeneral(Exception ex);
}
```

#### Custom Exception Types
```java
public class EmployeeNotFoundException extends RuntimeException;
public class DepartmentHierarchyException extends RuntimeException;
public class PayrollCalculationException extends RuntimeException;
public class EmailSendingException extends RuntimeException;
public class ImportValidationException extends RuntimeException;
```

### Frontend Error Handling

#### Axios Interceptor Configuration
```javascript
// Request interceptor for authentication
axios.interceptors.request.use(config => {
    const token = localStorage.getItem('token');
    if (token) {
        config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
});

// Response interceptor for error handling
axios.interceptors.response.use(
    response => response,
    error => {
        if (error.response.status === 401) {
            // Handle authentication errors
        } else if (error.response.status === 403) {
            // Handle authorization errors
        }
        return Promise.reject(error);
    }
);
```

## Testing Strategy

### Unit Testing Approach

#### Service Layer Testing
```java
@ExtendWith(MockitoExtension.class)
class EmployeeServiceTest {
    @Mock
    private EmployeeRepository employeeRepository;
    
    @InjectMocks
    private EmployeeService employeeService;
    
    @Test
    void shouldCreateEmployeeSuccessfully();
    
    @Test
    void shouldThrowExceptionWhenEmployeeNumberExists();
}
```

#### Repository Testing
```java
@DataRedisTest
class EmployeeRepositoryTest {
    @Autowired
    private TestEntityManager entityManager;
    
    @Autowired
    private EmployeeRepository employeeRepository;
    
    @Test
    void shouldFindEmployeesByDepartment();
    
    @Test
    void shouldSupportPaginationAndSorting();
}
```

### Integration Testing

#### Web Layer Testing
```java
@SpringBootTest
@AutoConfigureTestDatabase
class EmployeeControllerIntegrationTest {
    @Autowired
    private MockMvc mockMvc;
    
    @Test
    @WithMockUser(roles = "HR_MANAGER")
    void shouldCreateEmployeeWithValidData();
    
    @Test
    @WithMockUser(roles = "EMPLOYEE")
    void shouldDenyAccessToRestrictedEndpoints();
}
```

### Security Testing

#### Authentication and Authorization Tests
```java
@SpringBootTest
@AutoConfigureTestDatabase
class SecurityIntegrationTest {
    @Test
    void shouldAuthenticateValidUser();
    
    @Test
    void shouldDenyAccessWithoutPermission();
    
    @Test
    void shouldLoadUserPermissionsDynamically();
}
```

### Performance Testing

#### Load Testing Strategy
- Use JMeter for API endpoint load testing
- Test concurrent user scenarios for chat functionality
- Validate database performance with large datasets
- Monitor Redis cache hit rates and performance

### Email and Notification Testing

#### Async Service Testing
```java
@SpringBootTest
class EmailServiceTest {
    @MockBean
    private JavaMailSender mailSender;
    
    @Test
    void shouldSendTemplatedEmailAsynchronously();
    
    @Test
    void shouldHandleEmailSendingFailures();
}
```

## API Design Patterns

### DTO Design Strategy

#### Request/Response DTO Separation
```java
// Separate DTOs for different operations
public class EmployeeDto {
    private Long id;
    private String employeeNumber;
    private String firstName;
    private String lastName;
    private String email;
    private DepartmentDto department;
    private PositionDto position;
    private Instant createdAt;
    private Instant updatedAt;
    // Read-only fields included
}

public class EmployeeCreateRequest {
    @NotBlank
    private String firstName;
    @NotBlank
    private String lastName;
    @Email
    private String email;
    private Long departmentId;
    private Long positionId;
    // No id, createdAt, updatedAt fields
}

public class EmployeeUpdateRequest {
    @NotBlank
    private String firstName;
    @NotBlank
    private String lastName;
    @Email
    private String email;
    private Long departmentId;
    private Long positionId;
    // No id, createdAt, updatedAt fields
}
```

#### Hierarchical Data DTOs
```java
// Safe hierarchical DTOs without circular references
public class DepartmentTreeDto {
    private Long id;
    private String name;
    private String code;
    private List<DepartmentTreeDto> children; // Only children, no parent reference
}

public class DepartmentDto {
    private Long id;
    private String name;
    private String code;
    private Long parentId; // Reference by ID only
    private String parentName; // Denormalized for display
}
```

#### Batch Operation DTOs
```java
public class BatchDeleteRequest {
    @NotEmpty
    private List<Long> ids;
    private String reason; // Audit trail
}

public class BatchOperationResult {
    private int totalRequested;
    private int successful;
    private int failed;
    private List<BatchError> errors;
}
```

## Implementation Considerations

### Security Implementation
- Use Spring Security's method-level security with @PreAuthorize("hasPermission(#id, 'EMPLOYEE', 'READ')")
- Implement stateless JWT authentication (no Redis sessions for auth state)
- Use JWT token blacklisting in Redis for logout functionality
- Use BCrypt for password hashing with proper salt rounds
- Implement field-level encryption for sensitive PII data

### Data Integrity and Validation
- Use PostgreSQL foreign key constraints for referential integrity
- Implement business rule validation in service layer
- Use Instant timestamps for all temporal data (time-zone aware)
- Implement comprehensive audit trails for all critical entities
- Use enum types instead of string fields for fixed value sets

### Performance Optimization
- Implement Redis caching for frequently accessed data (department trees, user permissions)
- Use PostgreSQL connection pooling with HikariCP
- Implement proper database indexing for query performance
- Use async processing for email sending and heavy operations
- Implement pagination for all list endpoints

### API Design Best Practices
- Use dedicated CreateRequest and UpdateRequest DTOs
- Implement proper batch operation endpoints
- Avoid circular references in hierarchical DTOs
- Use consistent error response formats
- Implement proper HTTP status codes and error messages

### Scalability Considerations
- Design stateless services for horizontal scaling
- Use Redis for distributed caching only (not primary data)
- Implement proper database indexing and query optimization
- Use connection pooling for database access
- Implement async processing for non-critical operations

### Monitoring and Logging
- Use Spring Boot Actuator for health checks and metrics
- Implement structured logging with correlation IDs
- Monitor PostgreSQL and Redis performance separately
- Track business metrics (login attempts, payroll processing, etc.)
- Implement comprehensive error tracking and alerting
</file>

<file path="employee-implementation.md">
# Employee Management Implementation

## Overview
This document provides detailed implementation specifications for the Employee Management module. This module handles comprehensive employee CRUD operations, search functionality, pagination, Excel import/export, and batch operations.

## Package Structure
```
com.example.demo.employee/
├── entity/
│   ├── Employee.java
│   └── EmployeeStatus.java
├── repository/
│   └── EmployeeRepository.java
├── service/
│   ├── EmployeeService.java
│   ├── EmployeeImportService.java
│   ├── EmployeeExportService.java
│   └── impl/
│       ├── EmployeeServiceImpl.java
│       ├── EmployeeImportServiceImpl.java
│       └── EmployeeExportServiceImpl.java
├── controller/
│   └── EmployeeController.java
├── dto/
│   ├── EmployeeDto.java
│   ├── EmployeeCreateRequest.java
│   ├── EmployeeUpdateRequest.java
│   ├── EmployeeSearchCriteria.java
│   ├── EmployeeImportResult.java
│   └── EmployeeExportRequest.java
├── util/
│   ├── EmployeeExcelUtil.java
│   └── EmployeeValidationUtil.java
└── exception/
    ├── EmployeeNotFoundException.java
    ├── EmployeeAlreadyExistsException.java
    ├── EmployeeImportException.java
    └── EmployeeExportException.java
```

## Entity Classes

### EmployeeStatus Enum
```java
package com.example.demo.employee.entity;

public enum EmployeeStatus {
    ACTIVE("Active"),
    INACTIVE("Inactive"),
    TERMINATED("Terminated"),
    ON_LEAVE("On Leave"),
    PROBATION("Probation"),
    SUSPENDED("Suspended");
    
    private final String displayName;
    
    EmployeeStatus(String displayName) {
        this.displayName = displayName;
    }
    
    public String getDisplayName() {
        return displayName;
    }
}
```

### PayType Enum
```java
package com.example.demo.employee.entity;

public enum PayType {
    SALARIED,
    HOURLY
}
```

### Employee Entity
```java
package com.example.demo.employee.entity;

import com.example.demo.config.security.EncryptedStringConverter;
import com.example.demo.department.entity.Department;
import com.example.demo.position.entity.Position;
import com.example.demo.payroll.entity.PayrollLedger;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.math.BigDecimal;
import java.time.Instant;
import java.time.LocalDate;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "employees",
    indexes = {
        @Index(name = "idx_employee_number", columnList = "employee_number", unique = true),
        @Index(name = "idx_employee_email", columnList = "email", unique = true),
        @Index(name = "idx_employee_department_id", columnList = "department_id"),
        @Index(name = "idx_employee_position_id", columnList = "position_id"),
        @Index(name = "idx_employee_status", columnList = "status")
    }
)
@EntityListeners(AuditingEntityListener.class)
@Getter
@Setter
public class Employee {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "employee_number", nullable = false, unique = true, length = 20)
    private String employeeNumber;

    @Column(name = "first_name", nullable = false, length = 50)
    private String firstName;

    @Column(name = "last_name", nullable = false, length = 50)
    private String lastName;

    @Column(name = "email", nullable = false, unique = true, length = 100)
    private String email;

    @Column(name = "phone", length = 20)
    private String phone;

    @Column(name = "mobile_phone", length = 20)
    private String mobilePhone;

    @Column(name = "address", length = 255)
    private String address;

    @Column(name = "city", length = 100)
    private String city;

    @Column(name = "state", length = 100)
    private String state;

    @Column(name = "zip_code", length = 20)
    private String zipCode;

    @Column(name = "country", length = 100)
    private String country;

    @Convert(converter = EncryptedStringConverter.class)
    @Column(name = "date_of_birth_encrypted")
    private String dateOfBirth; // Encrypted

    @Enumerated(EnumType.STRING)
    @Column(name = "gender", length = 20)
    private Gender gender;

    @Enumerated(EnumType.STRING)
    @Column(name = "marital_status", length = 20)
    private MaritalStatus maritalStatus;

    @Column(name = "nationality", length = 50)
    private String nationality;

    @Column(name = "department_id", nullable = false)
    private Long departmentId;

    @Column(name = "position_id", nullable = false)
    private Long positionId;

    @Column(name = "manager_id")
    private Long managerId;

    @Column(name = "hire_date", nullable = false)
    private LocalDate hireDate;

    @Column(name = "termination_date")
    private LocalDate terminationDate;

    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 20)
    private EmployeeStatus status = EmployeeStatus.ACTIVE;

    @Enumerated(EnumType.STRING)
    @Column(name = "employment_type", nullable = false, length = 20)
    private EmploymentType employmentType = EmploymentType.FULL_TIME;

    @Enumerated(EnumType.STRING)
    @Column(name = "pay_type", nullable = false, length = 10)
    private PayType payType = PayType.SALARY;

    @Column(name = "salary", precision = 12, scale = 2)
    private BigDecimal salary;

    @Column(name = "hourly_rate", precision = 8, scale = 2)
    private BigDecimal hourlyRate;

    @Convert(converter = EncryptedStringConverter.class)
    @Column(name = "bank_account_encrypted")
    private String bankAccount; // Encrypted

    @Convert(converter = EncryptedStringConverter.class)
    @Column(name = "tax_id_encrypted")
    private String taxId; // Encrypted

    @Column(name = "enabled", nullable = false)
    private boolean enabled = true;

    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;

    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;

    @Column(name = "created_by")
    private Long createdBy;

    @Column(name = "updated_by")
    private Long updatedBy;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "department_id", insertable = false, updatable = false)
    private Department department;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "position_id", insertable = false, updatable = false)
    private Position position;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "manager_id", insertable = false, updatable = false)
    private Employee manager;

    @OneToMany(mappedBy = "manager", fetch = FetchType.LAZY)
    private Set<Employee> directReports = new HashSet<>();

    @OneToMany(mappedBy = "employee", fetch = FetchType.LAZY, cascade = CascadeType.ALL)
    private Set<PayrollLedger> payrollLedgers = new HashSet<>();

    // Helper methods
    public String getFullName() {
        return firstName + " " + lastName;
    }
}
```
itory Interface
### EmployeeRepository
```java
package com.example.demo.employee.repository;

import com.example.demo.employee.entity.Employee;
import com.example.demo.employee.entity.EmployeeStatus;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

@Repository
public interface EmployeeRepository extends JpaRepository<Employee, Long> {
    
    /**
     * Find employee by employee number
     * @param employeeNumber Unique employee number
     * @return Optional employee
     */
    Optional<Employee> findByEmployeeNumber(String employeeNumber);
    
    /**
     * Find employee by email
     * @param email Employee email
     * @return Optional employee
     */
    Optional<Employee> findByEmail(String email);
    
    /**
     * Find employees by department ID
     * @param departmentId Department ID
     * @param pageable Pagination parameters
     * @return Page of employees
     */
    Page<Employee> findByDepartmentId(Long departmentId, Pageable pageable);
    
    /**
     * Find employees by position ID
     * @param positionId Position ID
     * @param pageable Pagination parameters
     * @return Page of employees
     */
    Page<Employee> findByPositionId(Long positionId, Pageable pageable);
    
    /**
     * Find employees by manager ID
     * @param managerId Manager employee ID
     * @param pageable Pagination parameters
     * @return Page of employees
     */
    Page<Employee> findByManagerId(Long managerId, Pageable pageable);
    
    /**
     * Find employees by status
     * @param status Employee status
     * @param pageable Pagination parameters
     * @return Page of employees
     */
    Page<Employee> findByStatus(EmployeeStatus status, Pageable pageable);
    
    /**
     * Find employees by hire date range
     * @param startDate Start date
     * @param endDate End date
     * @param pageable Pagination parameters
     * @return Page of employees
     */
    Page<Employee> findByHireDateBetween(LocalDate startDate, LocalDate endDate, Pageable pageable);
    
    /**
     * Find employees by first name containing (case insensitive)
     * @param firstName First name search term
     * @param pageable Pagination parameters
     * @return Page of employees
     */
    Page<Employee> findByFirstNameContainingIgnoreCase(String firstName, Pageable pageable);
    
    /**
     * Find employees by last name containing (case insensitive)
     * @param lastName Last name search term
     * @param pageable Pagination parameters
     * @return Page of employees
     */
    Page<Employee> findByLastNameContainingIgnoreCase(String lastName, Pageable pageable);
    
    /**
     * Find employees by first name or last name containing (case insensitive)
     * @param firstName First name search term
     * @param lastName Last name search term
     * @param pageable Pagination parameters
     * @return Page of employees
     */
    Page<Employee> findByFirstNameContainingIgnoreCaseOrLastNameContainingIgnoreCase(
        String firstName, String lastName, Pageable pageable);
    
    /**
     * Find employees by email containing (case insensitive)
     * @param email Email search term
     * @param pageable Pagination parameters
     * @return Page of employees
     */
    Page<Employee> findByEmailContainingIgnoreCase(String email, Pageable pageable);
    
    /**
     * Find enabled employees
     * @param pageable Pagination parameters
     * @return Page of enabled employees
     */
    Page<Employee> findByEnabledTrue(Pageable pageable);
    
    /**
     * Find employees by multiple criteria (for advanced search)
     * @param departmentId Department ID (optional)
     * @param positionId Position ID (optional)
     * @param status Employee status (optional)
     * @param pageable Pagination parameters
     * @return Page of employees matching criteria
     */
    Page<Employee> findByDepartmentIdAndPositionIdAndStatus(
        Long departmentId, Long positionId, EmployeeStatus status, Pageable pageable);
    
    /**
     * Check if employee number exists
     * @param employeeNumber Employee number
     * @return true if exists
     */
    boolean existsByEmployeeNumber(String employeeNumber);
    
    /**
     * Check if email exists
     * @param email Employee email
     * @return true if exists
     */
    boolean existsByEmail(String email);
    
    /**
     * Count employees by department ID
     * @param departmentId Department ID
     * @return Count of employees
     */
    long countByDepartmentId(Long departmentId);
    
    /**
     * Count employees by position ID
     * @param positionId Position ID
     * @return Count of employees
     */
    long countByPositionId(Long positionId);
    
    /**
     * Count employees by status
     * @param status Employee status
     * @return Count of employees
     */
    long countByStatus(EmployeeStatus status);
    
    /**
     * Find employees by IDs
     * @param ids List of employee IDs
     * @return List of employees
     */
    List<Employee> findByIdIn(List<Long> ids);
    
    /**
     * Find employees hired in date range
     * @param startDate Start date
     * @param endDate End date
     * @return List of employees
     */
    List<Employee> findByHireDateBetween(LocalDate startDate, LocalDate endDate);
    
    /**
     * Find employees with birthdays in date range
     * @param startDate Start date
     * @param endDate End date
     * @return List of employees
     */
    List<Employee> findByDateOfBirthBetween(LocalDate startDate, LocalDate endDate);
}
```
## DTO Classes

### EmployeeDto
```java
package com.example.demo.employee.dto;

import com.example.demo.employee.entity.EmployeeStatus;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;

import jakarta.validation.constraints.*;
import java.time.LocalDate;
import java.time.Instant;
import java.math.BigDecimal;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class EmployeeDto {
  
    private Long id;
  
    @NotBlank(message = "Employee number is required")
    @Size(max = 20, message = "Employee number must not exceed 20 characters")
    private String employeeNumber;
  
    @NotBlank(message = "First name is required")
    @Size(min = 2, max = 50, message = "First name must be between 2 and 50 characters")
    private String firstName;
  
    @NotBlank(message = "Last name is required")
    @Size(min = 2, max = 50, message = "Last name must be between 2 and 50 characters")
    private String lastName;
  
    @NotBlank(message = "Email is required")
    @Email(message = "Email should be valid")
    @Size(max = 100, message = "Email must not exceed 100 characters")
    private String email;
  
    @Pattern(regexp = "^[+]?[0-9\\s\\-\\(\\)]{10,20}$", message = "Phone number format is invalid")
    private String phone;
  
    @Pattern(regexp = "^[+]?[0-9\\s\\-\\(\\)]{10,20}$", message = "Mobile phone number format is invalid")
    private String mobilePhone;
  
    @Size(max = 255, message = "Address must not exceed 255 characters")
    private String address;
  
    @Size(max = 100, message = "City must not exceed 100 characters")
    private String city;
  
    @Size(max = 100, message = "State must not exceed 100 characters")
    private String state;
  
    @Size(max = 20, message = "Zip code must not exceed 20 characters")
    private String zipCode;
  
    @Size(max = 100, message = "Country must not exceed 100 characters")
    private String country;
  
    // Sensitive fields are strings in DTO, service layer handles encryption/decryption
    private String dateOfBirth;
  
    private String gender;
  
    private String maritalStatus;
  
    @Size(max = 50, message = "Nationality must not exceed 50 characters")
    private String nationality;
  
    @NotNull(message = "Department is required")
    private Long departmentId;
  
    private String departmentName; // Transient field for display
  
    @NotNull(message = "Position is required")
    private Long positionId;
  
    private String positionName; // Transient field for display
  
    private Long managerId;
  
    private String managerName; // Transient field for display
  
    @NotNull(message = "Hire date is required")
    @PastOrPresent(message = "Hire date cannot be in the future")
    private LocalDate hireDate;
  
    private LocalDate terminationDate;
  
    @NotNull(message = "Employee status is required")
    private EmployeeStatus status;
  
    private String employmentType;
  
    private String payType;
  
    @DecimalMin(value = "0.0", inclusive = true, message = "Salary must be non-negative")
    @Digits(integer = 10, fraction = 2, message = "Salary format is invalid")
    private BigDecimal salary;
  
    @DecimalMin(value = "0.0", inclusive = true, message = "Hourly rate must be non-negative")
    @Digits(integer = 6, fraction = 2, message = "Hourly rate format is invalid")
    private BigDecimal hourlyRate;
  
    // Sensitive fields are strings in DTO
    private String bankAccount;
    private String taxId;
  
    private boolean enabled;
  
    private Instant createdAt;
  
    private Instant updatedAt;
  
    private String fullName; // firstName + lastName
}
```

### EmployeeCreateRequest
```java
package com.example.demo.employee.dto;

import lombok.Data;

@Data
    @NotNull(message = "Department is required")
    private Long departmentId;
 
    @NotNull(message = "Position is required")
    private Long positionId;
 
    private Long managerId;
 
    @NotNull(message = "Hire date is required")
    @PastOrPresent
    private LocalDate hireDate;
 
    @NotNull(message = "Employee status is required")
    private EmployeeStatus status;
    
    @NotNull(message = "Pay type is required")
    private PayType payType;
    
    @DecimalMin(value = "0.0", inclusive = false)
    @Digits(integer = 10, fraction = 2)
    private BigDecimal salary; // For SALARY pay type
    
    @DecimalMin(value = "0.0", inclusive = false)
    @Digits(integer = 6, fraction = 2)
    private BigDecimal hourlyRate; // For HOURLY pay type
 
    // 其他允许在创建时由客户端提供的字段...
    private String phone;
    private String address;
    // 注意：不包含 id, employeeNumber, createdAt, updatedAt 等系统生成或只读的字段
}
```

### EmployeeUpdateRequest DTO
```java
package com.example.demo.employee.dto;

import com.example.demo.employee.entity.EmployeeStatus;
import com.example.demo.employee.entity.EmploymentType;
import com.example.demo.employee.entity.Gender;
import com.example.demo.employee.entity.MaritalStatus;
import jakarta.validation.constraints.*;
import lombok.Data;

import java.math.BigDecimal;
import java.time.LocalDate;

/**
 * 用于更新员工信息的数据传输对象。
 * 包含所有允许客户端修改的字段。
 */
@Data
public class EmployeeUpdateRequest {

    @NotBlank(message = "First name is required")
    @Size(max = 50, message = "First name must not exceed 50 characters")
    private String firstName;

    @NotBlank(message = "Last name is required")
    @Size(max = 50, message = "Last name must not exceed 50 characters")
    private String lastName;

    @NotBlank(message = "Email is required")
    @Email(message = "Email should be valid")
    @Size(max = 100, message = "Email must not exceed 100 characters")
    private String email;

    @Pattern(regexp = "^[+]?[0-9\\s\\-\\(\\)]{7,20}$", message = "Phone number format is invalid")
    private String phone;

    @Pattern(regexp = "^[+]?[0-9\\s\\-\\(\\)]{7,20}$", message = "Mobile phone number format is invalid")
    private String mobilePhone;

    @Size(max = 255)
    private String address;

    @Size(max = 100)
    private String city;

    @Size(max = 100)
    private String state;

    @Size(max = 20)
    private String zipCode;

    @Size(max = 100)
    private String country;

    // 敏感字段在传输时是字符串，由服务器处理加密
    private String dateOfBirth; 

    private Gender gender;
    
    private MaritalStatus maritalStatus;

    @Size(max = 50)
    private String nationality;

    @NotNull(message = "Department is required")
    private Long departmentId;

    @NotNull(message = "Position is required")
    private Long positionId;

    // 经理ID可以为null（例如，对于CEO）
    private Long managerId;

    @NotNull(message = "Hire date is required")
    @PastOrPresent(message = "Hire date cannot be in the future")
    private LocalDate hireDate;
    
    // 离职日期可以为null
    private LocalDate terminationDate;

    @NotNull(message = "Employee status is required")
    private EmployeeStatus status;
    
    @NotNull(message = "Employment type is required")
    private EmploymentType employmentType;

    // 薪资和时薪可以为null，取决于员工的薪资类型
    @DecimalMin(value = "0.0", inclusive = true, message = "Salary must be non-negative")
    @Digits(integer = 10, fraction = 2, message = "Salary format is invalid")
    private BigDecimal salary;

    @DecimalMin(value = "0.0", inclusive = true, message = "Hourly rate must be non-negative")
    @Digits(integer = 6, fraction = 2, message = "Hourly rate format is invalid")
    private BigDecimal hourlyRate;

    // 敏感字段
    private String bankAccount;
    private String taxId;

    @NotNull(message = "Enabled status is required")
    private Boolean enabled;
}
```

## Service Implementation

```java
package com.example.demo.employee.service.impl;

import com.example.demo.employee.dto.EmployeeCreateRequest;
import com.example.demo.employee.dto.EmployeeDto;
import com.example.demo.employee.dto.EmployeeUpdateRequest;
import com.example.demo.employee.entity.Employee;
import com.example.demo.employee.exception.EmployeeNotFoundException;
import com.example.demo.employee.exception.SalaryValidationException;
import com.example.demo.employee.repository.EmployeeRepository;
import com.example.demo.employee.service.EmployeeService;
import com.example.demo.position.entity.Position;
import com.example.demo.position.repository.PositionRepository;
import com.example.demo.util.EncryptionService; // 假设此服务存在
import lombok.RequiredArgsConstructor;
import org.modelmapper.ModelMapper;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.util.UUID; // <--- 新增：确保导入UUID

@Service
@RequiredArgsConstructor
public class EmployeeServiceImpl implements EmployeeService {

    private final EmployeeRepository employeeRepository;
    private final PositionRepository positionRepository;
    private final ModelMapper modelMapper;
    private final EncryptionService encryptionService;

    @Override
    @Transactional
    public EmployeeDto createEmployee(EmployeeCreateRequest createRequest) {
        // 校验薪资范围
        validateSalary(createRequest.getPositionId(), createRequest.getSalary());
 
        // 将 Request DTO 映射到新的 Employee 实体
        Employee employee = modelMapper.map(createRequest, Employee.class);
      
        // 生成系统控制的字段，如员工编号
        employee.setEmployeeNumber("EMP-" + UUID.randomUUID().toString().substring(0, 8).toUpperCase());
        employee.setEnabled(true); // 默认启用
    
        // 在保存前加密敏感数据
        if (createRequest.getDateOfBirth() != null) {
            employee.setDateOfBirth(encryptionService.encrypt(createRequest.getDateOfBirth()));
        }
        if (createRequest.getBankAccount() != null) {
            employee.setBankAccount(encryptionService.encrypt(createRequest.getBankAccount()));
        }
        if (createRequest.getTaxId() != null) {
            employee.setTaxId(encryptionService.encrypt(createRequest.getTaxId()));
        }
    
        // 保存实体并将其转换为用于响应的 DTO
        Employee savedEmployee = employeeRepository.save(employee);
        return convertToDto(savedEmployee);
    }

    /**
     * --- (2) 修改：重构 updateEmployee 方法以确保安全 ---
     *
     * 我们不再使用 modelMapper.map() 进行直接映射，以避免意外地将非空字段更新为 null。
     * 而是手动、有选择地更新每一个字段，只有当请求中的值不为 null 时才进行更新。
     * 这使得更新操作更加明确和安全。
     */
    @Override
    @Transactional
    public EmployeeDto updateEmployee(Long id, EmployeeUpdateRequest updateRequest) {
        Employee existingEmployee = employeeRepository.findById(id)
                .orElseThrow(() -> new EmployeeNotFoundException("Employee not found with id: " + id));
    
        // 校验薪资是否在职位范围内
        validateSalary(updateRequest.getPositionId(), updateRequest.getSalary());
    
        // **安全更新模式**
        // 有选择地更新非空字段
        if (updateRequest.getFirstName() != null) {
            existingEmployee.setFirstName(updateRequest.getFirstName());
        }
        if (updateRequest.getLastName() != null) {
            existingEmployee.setLastName(updateRequest.getLastName());
        }
        if (updateRequest.getEmail() != null) {
            existingEmployee.setEmail(updateRequest.getEmail());
        }
        if (updateRequest.getPhone() != null) {
            existingEmployee.setPhone(updateRequest.getPhone());
        }
        if (updateRequest.getMobilePhone() != null) {
            existingEmployee.setMobilePhone(updateRequest.getMobilePhone());
        }
        if (updateRequest.getAddress() != null) {
            existingEmployee.setAddress(updateRequest.getAddress());
        }
        if (updateRequest.getCity() != null) {
            existingEmployee.setCity(updateRequest.getCity());
        }
        if (updateRequest.getState() != null) {
            existingEmployee.setState(updateRequest.getState());
        }
        if (updateRequest.getZipCode() != null) {
            existingEmployee.setZipCode(updateRequest.getZipCode());
        }
        if (updateRequest.getCountry() != null) {
            existingEmployee.setCountry(updateRequest.getCountry());
        }
        if (updateRequest.getGender() != null) {
            existingEmployee.setGender(updateRequest.getGender());
        }
        if (updateRequest.getMaritalStatus() != null) {
            existingEmployee.setMaritalStatus(updateRequest.getMaritalStatus());
        }
        if (updateRequest.getNationality() != null) {
            existingEmployee.setNationality(updateRequest.getNationality());
        }
        if (updateRequest.getDepartmentId() != null) {
            existingEmployee.setDepartmentId(updateRequest.getDepartmentId());
        }
        if (updateRequest.getPositionId() != null) {
            existingEmployee.setPositionId(updateRequest.getPositionId());
        }
        if (updateRequest.getManagerId() != null) {
            existingEmployee.setManagerId(updateRequest.getManagerId());
        }
        if (updateRequest.getHireDate() != null) {
            existingEmployee.setHireDate(updateRequest.getHireDate());
        }
        if (updateRequest.getTerminationDate() != null) {
            existingEmployee.setTerminationDate(updateRequest.getTerminationDate());
        }
        if (updateRequest.getStatus() != null) {
            existingEmployee.setStatus(updateRequest.getStatus());
        }
        if (updateRequest.getEmploymentType() != null) {
            existingEmployee.setEmploymentType(updateRequest.getEmploymentType());
        }
        if (updateRequest.getSalary() != null) {
            existingEmployee.setSalary(updateRequest.getSalary());
        }
        if (updateRequest.getHourlyRate() != null) {
            existingEmployee.setHourlyRate(updateRequest.getHourlyRate());
        }
        if (updateRequest.getEnabled() != null) {
            existingEmployee.setEnabled(updateRequest.getEnabled());
        }
    
        // 加密敏感数据
        encryptSensitiveData(existingEmployee, updateRequest);
    
        Employee updatedEmployee = employeeRepository.save(existingEmployee);
        return convertToDto(updatedEmployee);
    }

    @Override
    @Transactional(readOnly = true)
    public EmployeeDto getEmployeeById(Long id) {
        Employee employee = employeeRepository.findById(id)
                .orElseThrow(() -> new EmployeeNotFoundException("Employee not found with id: " + id));
        return convertToDto(employee);
    }

    @Override
    @Transactional(readOnly = true)
    public Page<EmployeeDto> getAllEmployees(Pageable pageable) {
        return employeeRepository.findAll(pageable).map(this::convertToDto);
    }

    @Override
    @Transactional
    public void deleteEmployee(Long id) {
        if (!employeeRepository.existsById(id)) {
            throw new EmployeeNotFoundException("Employee not found with id: " + id);
        }
        employeeRepository.deleteById(id);
    }

    private void validateSalary(Long positionId, BigDecimal salary) {
        if (positionId == null || salary == null) {
            return;
        }
        Position position = positionRepository.findById(positionId)
                .orElseThrow(() -> new RuntimeException("Position not found with id: " + positionId));

        if (position.getMinSalary() != null && salary.compareTo(position.getMinSalary()) < 0) {
            throw new SalaryValidationException("Salary is below the minimum for this position.");
        }
        if (position.getMaxSalary() != null && salary.compareTo(position.getMaxSalary()) > 0) {
            throw new SalaryValidationException("Salary is above the maximum for this position.");
        }
    }

    private void encryptSensitiveData(Employee employee, EmployeeUpdateRequest dto) {
        if (dto.getDateOfBirth() != null) {
            employee.setDateOfBirth(encryptionService.encrypt(dto.getDateOfBirth()));
        }
        if (dto.getBankAccount() != null) {
            employee.setBankAccount(encryptionService.encrypt(dto.getBankAccount()));
        }
        if (dto.getTaxId() != null) {
            employee.setTaxId(encryptionService.encrypt(dto.getTaxId()));
        }
    }

    /**
     * --- (3) 修改：增强数据转换的健壮性 ---
     *
     * 在对银行账号进行脱敏处理时，增加了长度检查。
     * 这可以防止当银行账号长度不足时，substring 操作抛出异常。
     */
    private EmployeeDto convertToDto(Employee employee) {
        EmployeeDto dto = modelMapper.map(employee, EmployeeDto.class);
      
        // 解密敏感数据以供显示
        if (employee.getDateOfBirth() != null) {
            dto.setDateOfBirth(encryptionService.decrypt(employee.getDateOfBirth()));
        }
        if (employee.getBankAccount() != null) {
            String decryptedAccount = encryptionService.decrypt(employee.getBankAccount());
            // 增加健壮性检查
            if (decryptedAccount != null && decryptedAccount.length() > 4) {
                dto.setBankAccount("****" + decryptedAccount.substring(decryptedAccount.length() - 4));
            } else {
                dto.setBankAccount("****"); // 或者返回一个完全屏蔽的值
            }
        }
        if (employee.getTaxId() != null) {
            dto.setTaxId(encryptionService.decrypt(employee.getTaxId()));
        }
      
        // 填充用于显示的瞬态字段
        if (employee.getDepartment() != null) {
            dto.setDepartmentName(employee.getDepartment().getName());
        }
        if (employee.getPosition() != null) {
            dto.setPositionName(employee.getPosition().getJobTitle());
        }
        dto.setFullName(employee.getFullName());
      
        return dto;
    }
}

```

## Controller Implementation

### EmployeeController
```java
package com.example.demo.employee.controller;

import com.example.demo.employee.dto.EmployeeDto;
import com.example.demo.employee.service.EmployeeService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/v1/employees")
@RequiredArgsConstructor
public class EmployeeController {

    private final EmployeeService employeeService;

    @PostMapping
    @PreAuthorize("hasAuthority('EMPLOYEE_CREATE')")
    public ResponseEntity<EmployeeDto> createEmployee(@Valid @RequestBody EmployeeCreateRequest createRequest) {
        EmployeeDto createdEmployee = employeeService.createEmployee(createRequest);
        return new ResponseEntity<>(createdEmployee, HttpStatus.CREATED);
    }

    @GetMapping("/{id}")
    @PreAuthorize("hasAuthority('EMPLOYEE_READ')")
    public ResponseEntity<EmployeeDto> getEmployeeById(@PathVariable Long id) {
        EmployeeDto employeeDto = employeeService.getEmployeeById(id);
        return ResponseEntity.ok(employeeDto);
    }

    @GetMapping
    @PreAuthorize("hasAuthority('EMPLOYEE_READ')")
    public ResponseEntity<Page<EmployeeDto>> getAllEmployees(Pageable pageable) {
        Page<EmployeeDto> employees = employeeService.getAllEmployees(pageable);
        return ResponseEntity.ok(employees);
    }

    @PutMapping("/{id}")
    @PreAuthorize("hasAuthority('EMPLOYEE_UPDATE')")
    public ResponseEntity<EmployeeDto> updateEmployee(@PathVariable Long id, @Valid @RequestBody EmployeeUpdateRequest updateRequest) {
        EmployeeDto updatedEmployee = employeeService.updateEmployee(id, updateRequest);
        return ResponseEntity.ok(updatedEmployee);
    }

    @DeleteMapping("/{id}")
    @PreAuthorize("hasAuthority('EMPLOYEE_DELETE')")
    public ResponseEntity<Void> deleteEmployee(@PathVariable Long id) {
        employeeService.deleteEmployee(id);
        return ResponseEntity.noContent().build();
    }
}
```
</file>

<file path="payroll-implementation.md">
# Payroll Management Implementation

## Overview
This document provides detailed implementation specifications for the Payroll Management module. This module handles payroll ledgers, salary calculations, payroll processing, and payroll reporting with comprehensive audit trails.

## Package Structure
```
com.example.demo.payroll/
├── entity/
│   ├── PayrollLedger.java
│   ├── PayrollPeriod.java
│   ├── SalaryComponent.java
│   └── PayrollAudit.java
├── repository/
│   ├── PayrollLedgerRepository.java
│   ├── PayrollPeriodRepository.java
│   ├── SalaryComponentRepository.java
│   └── PayrollAuditRepository.java
├── service/
│   ├── PayrollService.java
│   ├── PayrollCalculationService.java
│   ├── PayrollReportService.java
│   └── impl/
│       ├── PayrollServiceImpl.java
│       ├── PayrollCalculationServiceImpl.java
│       └── PayrollReportServiceImpl.java
├── controller/
│   └── PayrollController.java
├── dto/
│   ├── PayrollLedgerDto.java
│   ├── PayrollPeriodDto.java
│   ├── SalaryComponentDto.java
│   ├── PayrollCalculationRequest.java
│   ├── PayrollReportRequest.java
│   └── PayrollSummaryDto.java
├── util/
│   ├── PayrollCalculationUtil.java
│   └── PayrollValidationUtil.java
└── exception/
    ├── PayrollNotFoundException.java
    ├── PayrollCalculationException.java
    ├── PayrollPeriodException.java
    └── PayrollValidationException.java
```

## Entity Classes

### Enum Definitions

#### PayrollLedgerStatus Enum
```java
package com.example.demo.payroll.entity;

public enum PayrollLedgerStatus {
    PENDING,
    CALCULATED,
    APPROVED,
    PAID,
    REJECTED,
    CANCELLED
}
```

#### PaymentMethod Enum
```java
package com.example.demo.payroll.entity;

public enum PaymentMethod {
    BANK_TRANSFER,
    CHECK,
    CASH,
    OTHER
}
```

#### PayrollPeriodType Enum
```java
package com.example.demo.payroll.entity;

public enum PayrollPeriodType {
    MONTHLY,
    BI_WEEKLY,
    WEEKLY,
    CUSTOM
}
```

#### PayrollPeriodStatus Enum
```java
package com.example.demo.payroll.entity;

public enum PayrollPeriodStatus {
    DRAFT,
    OPEN,
    CLOSED,
    ARCHIVED
}
```

#### SalaryComponentType Enum
```java
package com.example.demo.payroll.entity;

public enum SalaryComponentType {
    ALLOWANCE,
    DEDUCTION
}
```

#### CalculationType Enum
```java
package com.example.demo.payroll.entity;

public enum CalculationType {
    FIXED,
    PERCENTAGE
}
```
### PayrollLedger Entity
```java
package com.example.demo.payroll.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import lombok.Builder;
import com.example.demo.employee.entity.Employee;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.math.BigDecimal;
import java.time.Instant;
import java.time.LocalDate;

@Entity
@Table(name = "payroll_ledgers", indexes = {
    @Index(name = "idx_payrollledger_employee_id", columnList = "employee_id"),
    @Index(name = "idx_payrollledger_period_id", columnList = "payroll_period_id"),
    @Index(name = "idx_payrollledger_status", columnList = "status")
})
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@EntityListeners(AuditingEntityListener.class)
public class PayrollLedger {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "employee_id", nullable = false)
    private Employee employee;

    @Column(name = "payroll_period_id", nullable = false)
    private Long payrollPeriodId;

    @Column(name = "employee_number", length = 20)
    private String employeeNumber;

    @Column(name = "employee_name", length = 100)
    private String employeeName;

    @Column(name = "department_id")
    private Long departmentId;

    @Column(name = "department_name", length = 100)
    private String departmentName;

    @Column(name = "position_id")
    private Long positionId;

    @Column(name = "position_name", length = 100)
    private String positionName;

    @Column(name = "base_salary", precision = 12, scale = 2)
    private BigDecimal baseSalary;

    @Column(name = "hourly_rate", precision = 12, scale = 2)
    private BigDecimal hourlyRate;

    @Column(name = "hours_worked", precision = 10, scale = 2)
    private BigDecimal hoursWorked;

    @Column(name = "overtime_hours", precision = 10, scale = 2)
    private BigDecimal overtimeHours;

    @Column(name = "overtime_rate", precision = 12, scale = 2)
    private BigDecimal overtimeRate;

    @Column(name = "total_allowances", precision = 12, scale = 2)
    private BigDecimal totalAllowances;

    @Column(name = "total_deductions", precision = 12, scale = 2)
    private BigDecimal totalDeductions;

    @Column(name = "gross_salary", precision = 12, scale = 2)
    private BigDecimal grossSalary;

    @Column(name = "net_salary", precision = 12, scale = 2)
    private BigDecimal netSalary;

    @Column(name = "employer_contributions", precision = 12, scale = 2)
    private BigDecimal employerContributions;

    @Column(name = "total_cost", precision = 12, scale = 2)
    private BigDecimal totalCost;

    @Column(name = "currency", length = 10)
    private String currency;

    @Enumerated(EnumType.STRING)
    @Column(name = "payment_method", length = 20)
    private PaymentMethod paymentMethod;

    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 20)
    private PayrollLedgerStatus status;

    @Column(name = "pay_date")
    private LocalDate payDate;

    @Lob
    @Column(name = "notes", columnDefinition = "TEXT")
    private String notes;

    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;

    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;

    @Column(name = "created_by")
    private Long createdBy;

    @Column(name = "updated_by")
    private Long updatedBy;

    @Lob
    @Column(name = "calculation_details", columnDefinition = "TEXT")
    private String calculationDetails; // JSON string for all components
}
```
### PayrollPeriod Entity
```java
package com.example.demo.payroll.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.Instant;
import java.time.LocalDate;

@Entity
@Table(name = "payroll_periods", indexes = {
    @Index(name = "idx_payrollperiod_start_end", columnList = "start_date, end_date"),
    @Index(name = "idx_payrollperiod_status", columnList = "status")
})
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@EntityListeners(AuditingEntityListener.class)
public class PayrollPeriod {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "name", nullable = false, length = 100)
    private String name;

    @Enumerated(EnumType.STRING)
    @Column(name = "type", nullable = false, length = 20)
    private PayrollPeriodType type;

    @Column(name = "start_date", nullable = false)
    private LocalDate startDate;

    @Column(name = "end_date", nullable = false)
    private LocalDate endDate;

    @Column(name = "pay_date", nullable = false)
    private LocalDate payDate;

    @Column(name = "working_days")
    private Integer workingDays;

    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 20)
    private PayrollPeriodStatus status;

    @Column(name = "description", length = 500)
    private String description;

    @Column(name = "is_active", nullable = false)
    private boolean isActive = true;

    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;

    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;

    @Column(name = "created_by")
    private Long createdBy;

    @Column(name = "updated_by")
    private Long updatedBy;
}
```

### SalaryComponent Entity
```java
package com.example.demo.payroll.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.math.BigDecimal;
import java.time.Instant;

@Entity
@Table(name = "salary_components", indexes = {
    @Index(name = "idx_salarycomponent_code", columnList = "code", unique = true),
    @Index(name = "idx_salarycomponent_type", columnList = "type")
})
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@EntityListeners(AuditingEntityListener.class)
public class SalaryComponent {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "code", nullable = false, unique = true, length = 50)
    private String code;

    @Column(name = "name", nullable = false, length = 100)
    private String name;

    @Enumerated(EnumType.STRING)
    @Column(name = "type", nullable = false, length = 20)
    private SalaryComponentType type; // ALLOWANCE, DEDUCTION

    @Enumerated(EnumType.STRING)
    @Column(name = "calculation_type", nullable = false, length = 20)
    private CalculationType calculationType; // FIXED, PERCENTAGE

    @Column(name = "value", precision = 12, scale = 2)
    private BigDecimal value; // Amount for FIXED, percentage for PERCENTAGE

    @Column(name = "is_taxable", nullable = false)
    private boolean isTaxable = false;

    @Column(name = "is_active", nullable = false)
    private boolean isActive = true;

    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;

    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;
}
```

### PayrollAudit Entity
```java
package com.example.demo.payroll.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.Instant;

@Entity
@Table(name = "payroll_audits", indexes = {
    @Index(name = "idx_payrollaudit_ledger_id", columnList = "payroll_ledger_id"),
    @Index(name = "idx_payrollaudit_performed_by", columnList = "performed_by")
})
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@EntityListeners(AuditingEntityListener.class)
public class PayrollAudit {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "payroll_ledger_id", nullable = false)
    private Long payrollLedgerId;

    @Column(name = "action", nullable = false, length = 50)
    private String action;

    @Lob
    @Column(name = "details", columnDefinition = "TEXT")
    private String details; // JSON string of changes

    @Column(name = "reason", length = 500)
    private String reason;

    @Column(name = "performed_by", nullable = false)
    private Long performedBy;

    @CreatedDate
    @Column(name = "performed_at", nullable = false, updatable = false)
    private Instant performedAt;

    @Column(name = "ip_address", length = 45)
    private String ipAddress;
}
```
```## Repos
itory Interfaces

### PayrollLedgerRepository
```java
package com.example.demo.payroll.repository;

import com.example.demo.payroll.entity.PayrollLedger;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

@Repository
public interface PayrollLedgerRepository extends JpaRepository<PayrollLedger, Long> {
    
    /**
     * Find payroll ledger by employee and payroll period
     * @param employeeId Employee ID
     * @param payrollPeriodId Payroll period ID
     * @return Optional payroll ledger
     */
    Optional<PayrollLedger> findByEmployeeIdAndPayrollPeriodId(Long employeeId, Long payrollPeriodId);
    
    /**
     * Find payroll ledgers by employee ID
     * @param employeeId Employee ID
     * @param pageable Pagination parameters
     * @return Page of payroll ledgers
     */
    Page<PayrollLedger> findByEmployeeIdOrderByPayDateDesc(Long employeeId, Pageable pageable);
    
    /**
     * Find payroll ledgers by payroll period
     * @param payrollPeriodId Payroll period ID
     * @param pageable Pagination parameters
     * @return Page of payroll ledgers
     */
    Page<PayrollLedger> findByPayrollPeriodId(Long payrollPeriodId, Pageable pageable);
    
    /**
     * Find payroll ledgers by department
     * @param departmentId Department ID
     * @param pageable Pagination parameters
     * @return Page of payroll ledgers
     */
    Page<PayrollLedger> findByDepartmentId(Long departmentId, Pageable pageable);
    
    /**
     * Find payroll ledgers by status
     * @param status Payroll status
     * @param pageable Pagination parameters
     * @return Page of payroll ledgers
     */
    Page<PayrollLedger> findByStatus(String status, Pageable pageable);
    
    /**
     * Find payroll ledgers by pay date range
     * @param startDate Start date
     * @param endDate End date
     * @param pageable Pagination parameters
     * @return Page of payroll ledgers
     */
    Page<PayrollLedger> findByPayDateBetween(LocalDate startDate, LocalDate endDate, Pageable pageable);
    
    /**
     * Find payroll ledgers by employee and date range
     * @param employeeId Employee ID
     * @param startDate Start date
     * @param endDate End date
     * @return List of payroll ledgers
     */
    List<PayrollLedger> findByEmployeeIdAndPayDateBetweenOrderByPayDateDesc(
        Long employeeId, LocalDate startDate, LocalDate endDate);
    
    /**
     * Find payroll ledgers by department and payroll period
     * @param departmentId Department ID
     * @param payrollPeriodId Payroll period ID
     * @return List of payroll ledgers
     */
    List<PayrollLedger> findByDepartmentIdAndPayrollPeriodId(Long departmentId, Long payrollPeriodId);
    
    /**
     * Check if payroll exists for employee and period
     * @param employeeId Employee ID
     * @param payrollPeriodId Payroll period ID
     * @return true if exists
     */
    boolean existsByEmployeeIdAndPayrollPeriodId(Long employeeId, Long payrollPeriodId);
    
    /**
     * Count payroll ledgers by status
     * @param status Payroll status
     * @return Count of payroll ledgers
     */
    long countByStatus(String status);
    
    /**
     * Count payroll ledgers by payroll period
     * @param payrollPeriodId Payroll period ID
     * @return Count of payroll ledgers
     */
    long countByPayrollPeriodId(Long payrollPeriodId);
    
    /**
     * Find payroll ledgers by multiple criteria
     * @param departmentId Department ID (optional)
     * @param payrollPeriodId Payroll period ID (optional)
     * @param status Status (optional)
     * @param pageable Pagination parameters
     * @return Page of payroll ledgers
     */
    Page<PayrollLedger> findByDepartmentIdAndPayrollPeriodIdAndStatus(
        Long departmentId, Long payrollPeriodId, String status, Pageable pageable);
}
```

### PayrollPeriodRepository
```java
package com.example.demo.payroll.repository;

import com.example.demo.payroll.entity.PayrollPeriod;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

@Repository
public interface PayrollPeriodRepository extends JpaRepository<PayrollPeriod, Long> {
    
    /**
     * Find payroll period by name
     * @param name Period name
     * @return Optional payroll period
     */
    Optional<PayrollPeriod> findByName(String name);
    
    /**
     * Find active payroll periods
     * @return List of active payroll periods
     */
    List<PayrollPeriod> findByIsActiveTrueOrderByStartDateDesc();
    
    /**
     * Find payroll periods by type
     * @param type Period type
     * @param pageable Pagination parameters
     * @return Page of payroll periods
     */
    Page<PayrollPeriod> findByTypeOrderByStartDateDesc(String type, Pageable pageable);
    
    /**
     * Find payroll periods by status
     * @param status Period status
     * @param pageable Pagination parameters
     * @return Page of payroll periods
     */
    Page<PayrollPeriod> findByStatusOrderByStartDateDesc(String status, Pageable pageable);
    
    /**
     * Find payroll periods by date range
     * @param startDate Start date
     * @param endDate End date
     * @return List of payroll periods
     */
    List<PayrollPeriod> findByStartDateBetweenOrderByStartDateDesc(LocalDate startDate, LocalDate endDate);
    
    /**
     * Find current payroll period (contains given date)
     * @param date Date to check
     * @return Optional payroll period
     */
    Optional<PayrollPeriod> findByStartDateLessThanEqualAndEndDateGreaterThanEqualAndIsActiveTrue(
        LocalDate date, LocalDate date2);
    
    /**
     * Find overlapping payroll periods
     * @param startDate Start date
     * @param endDate End date
     * @return List of overlapping periods
     */
    List<PayrollPeriod> findByStartDateLessThanEqualAndEndDateGreaterThanEqual(
        LocalDate endDate, LocalDate startDate);
    
    /**
     * Check if period name exists
     * @param name Period name
     * @return true if exists
     */
    boolean existsByName(String name);
    
    /**
     * Find latest payroll period by type
     * @param type Period type
     * @return Optional payroll period
     */
    Optional<PayrollPeriod> findFirstByTypeOrderByStartDateDesc(String type);
}
```

## DTO Classes

### PayrollLedgerDto
```java
package com.example.demo.payroll.dto;

import lombok.Data;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;
import java.math.BigDecimal;
import java.time.Instant;
import java.time.LocalDate;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class PayrollLedgerDto {
    private Long id;

    @NotNull
    private Long employeeId;

    @NotNull
    private Long payrollPeriodId;

    private String employeeNumber;
    private String employeeName;
    private Long departmentId;
    private String departmentName;
    private Long positionId;
    private String positionName;

    @Positive
    private BigDecimal baseSalary;
    private BigDecimal hourlyRate;
    private BigDecimal hoursWorked;
    private BigDecimal overtimeHours;
    private BigDecimal overtimeRate;
    private BigDecimal totalAllowances;
    private BigDecimal totalDeductions;

    @NotNull
    private BigDecimal grossSalary;

    @NotNull
    private BigDecimal netSalary;

    private BigDecimal employerContributions;
    private BigDecimal totalCost;
    private String currency;
    private String paymentMethod;

    @NotNull
    private String status;

    private LocalDate payDate;
    private String notes;
    private String calculationDetails;

    private Instant createdAt;
    private Instant updatedAt;
}
```

### PayrollPeriodDto
```java
package com.example.demo.payroll.dto;

import lombok.Data;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import java.time.Instant;
import java.time.LocalDate;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class PayrollPeriodDto {
    private Long id;

    @NotBlank
    private String name;

    @NotBlank
    private String type;

    @NotNull
    private LocalDate startDate;

    @NotNull
    private LocalDate endDate;

    @NotNull
    private LocalDate payDate;

    private Integer workingDays;

    @NotBlank
    private String status;

    private String description;
    private boolean isActive;

    private Instant createdAt;
    private Instant updatedAt;
}
```

## Service Interfaces

### PayrollService
```java
package com.example.demo.payroll.service;

import com.example.demo.payroll.dto.PayrollLedgerDto;
import com.example.demo.payroll.dto.PayrollPeriodDto;
import com.example.demo.payroll.dto.PayrollCalculationRequest;
import com.example.demo.payroll.dto.PayrollSummaryDto;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import java.time.LocalDate;
import java.util.List;

public interface PayrollService {

    /**
     * ### Business Rule for Payroll Ledger Snapshot
     *
     * When creating a `PayrollLedger` record, the `PayrollService` must, within a transaction,
     * fetch the current names of associated entities like employee, department, and position.
     * These names must be stored as a **one-time snapshot** in the corresponding fields
     * (`employeeName`, `departmentName`, etc.). These snapshot fields **should not be automatically
     * updated** after the record is created to ensure the historical accuracy of payroll reports.
     */

    /**
     * Create a new payroll ledger
     * @param payrollLedgerDto Payroll ledger data
     * @return Created payroll ledger DTO
     * @throws PayrollValidationException if validation fails
     * @throws EmployeeNotFoundException if employee not found
     * @throws PayrollPeriodNotFoundException if payroll period not found
     */
    PayrollLedgerDto createPayrollLedger(PayrollLedgerDto payrollLedgerDto);
    
    /**
     * Update an existing payroll ledger
     * @param id Payroll ledger ID
     * @param payrollLedgerDto Updated payroll ledger data
     * @return Updated payroll ledger DTO
     * @throws PayrollNotFoundException if payroll ledger not found
     * @throws PayrollValidationException if validation fails
     */
    PayrollLedgerDto updatePayrollLedger(Long id, PayrollLedgerDto payrollLedgerDto);
    
    /**
     * Get payroll ledger by ID
     * @param id Payroll ledger ID
     * @return Payroll ledger DTO
     * @throws PayrollNotFoundException if payroll ledger not found
     */
    PayrollLedgerDto getPayrollLedger(Long id);
    
    /**
     * Get payroll ledgers with pagination
     * @param pageable Pagination parameters
     * @return Page of payroll ledger DTOs
     */
    Page<PayrollLedgerDto> getPayrollLedgers(Pageable pageable);
    
    /**
     * Get employee payroll history
     * @param employeeId Employee ID
     * @param pageable Pagination parameters
     * @return Page of payroll ledger DTOs
     * @throws EmployeeNotFoundException if employee not found
     */
    Page<PayrollLedgerDto> getEmployeePayrollHistory(Long employeeId, Pageable pageable);
    
    /**
     * Get payroll ledgers by period
     * @param payrollPeriodId Payroll period ID
     * @param pageable Pagination parameters
     * @return Page of payroll ledger DTOs
     * @throws PayrollPeriodNotFoundException if payroll period not found
     */
    Page<PayrollLedgerDto> getPayrollLedgersByPeriod(Long payrollPeriodId, Pageable pageable);
    
    /**
     * Get payroll ledgers by department
     * @param departmentId Department ID
     * @param pageable Pagination parameters
     * @return Page of payroll ledger DTOs
     * @throws DepartmentNotFoundException if department not found
     */
    Page<PayrollLedgerDto> getPayrollLedgersByDepartment(Long departmentId, Pageable pageable);
    
    /**
     * Calculate payroll for employee and period
     * @param request Payroll calculation request
     * @return Calculated payroll ledger DTO
     * @throws PayrollCalculationException if calculation fails
     * @throws EmployeeNotFoundException if employee not found
     * @throws PayrollPeriodNotFoundException if payroll period not found
     */
    PayrollLedgerDto calculatePayroll(PayrollCalculationRequest request);
    
    /**
     * Calculate payroll for all employees in a period
     * @param payrollPeriodId Payroll period ID
     * @return List of calculated payroll ledger DTOs
     * @throws PayrollPeriodNotFoundException if payroll period not found
     * @throws PayrollCalculationException if calculation fails
     */
    List<PayrollLedgerDto> calculatePayrollForPeriod(Long payrollPeriodId);
    
    /**
     * Calculate payroll for department in a period
     * @param departmentId Department ID
     * @param payrollPeriodId Payroll period ID
     * @return List of calculated payroll ledger DTOs
     * @throws DepartmentNotFoundException if department not found
     * @throws PayrollPeriodNotFoundException if payroll period not found
     * @throws PayrollCalculationException if calculation fails
     */
    List<PayrollLedgerDto> calculatePayrollForDepartment(Long departmentId, Long payrollPeriodId);
    
    /**
     * Approve payroll ledger
     * @param id Payroll ledger ID
     * @param approvedBy User ID who approved
     * @return Approved payroll ledger DTO
     * @throws PayrollNotFoundException if payroll ledger not found
     * @throws PayrollValidationException if payroll cannot be approved
     */
    PayrollLedgerDto approvePayroll(Long id, Long approvedBy);
    
    /**
     * Approve multiple payroll ledgers
     * @param ids List of payroll ledger IDs
     * @param approvedBy User ID who approved
     * @return List of approved payroll ledger DTOs
     * @throws PayrollNotFoundException if any payroll ledger not found
     * @throws PayrollValidationException if any payroll cannot be approved
     */
    List<PayrollLedgerDto> approvePayrolls(List<Long> ids, Long approvedBy);
    
    /**
     * Mark payroll as paid
     * @param id Payroll ledger ID
     * @param paidBy User ID who marked as paid
     * @param paymentReference Payment reference
     * @return Updated payroll ledger DTO
     * @throws PayrollNotFoundException if payroll ledger not found
     * @throws PayrollValidationException if payroll cannot be marked as paid
     */
    PayrollLedgerDto markPayrollAsPaid(Long id, Long paidBy, String paymentReference);
    
    /**
     * Cancel payroll ledger
     * @param id Payroll ledger ID
     * @param cancelledBy User ID who cancelled
     * @param reason Cancellation reason
     * @throws PayrollNotFoundException if payroll ledger not found
     * @throws PayrollValidationException if payroll cannot be cancelled
     */
    void cancelPayroll(Long id, Long cancelledBy, String reason);
    
    /**
     * Delete payroll ledger
     * @param id Payroll ledger ID
     * @throws PayrollNotFoundException if payroll ledger not found
     * @throws PayrollValidationException if payroll cannot be deleted
     */
    void deletePayrollLedger(Long id);
    
    /**
     * Get payroll summary for period
     * @param payrollPeriodId Payroll period ID
     * @return Payroll summary DTO
     * @throws PayrollPeriodNotFoundException if payroll period not found
     */
    PayrollSummaryDto getPayrollSummary(Long payrollPeriodId);
    
    /**
     * Get payroll summary for department and period
     * @param departmentId Department ID
     * @param payrollPeriodId Payroll period ID
     * @return Payroll summary DTO
     * @throws DepartmentNotFoundException if department not found
     * @throws PayrollPeriodNotFoundException if payroll period not found
     */
    PayrollSummaryDto getPayrollSummary(Long departmentId, Long payrollPeriodId);
}
```

This completes the comprehensive implementation documentation for all major modules of the Spring Boot backend. Each document provides:

1. **Complete package structure** with all necessary classes
2. **Detailed entity definitions** with all fields, annotations, and relationships
3. **Repository interfaces** with all required query methods
4. **Service interfaces** with complete method signatures, parameters, return types, and exceptions
5. **DTO classes** with validation annotations and constraints
6. **Exception handling** specifications
7. **Database schema** considerations for Redis

The implementation documents are structured to provide developers with everything they need to implement each module without having to make design decisions. Each method signature includes:
- Clear parameter definitions
- Return type specifications
- Exception declarations
- JavaDoc documentation explaining the purpose and behavior
</file>

<file path="position-implementation.md">
# Position and Title Management Implementation

## Overview
This document provides detailed implementation specifications for the Position and Title Management module. This module handles job positions, professional titles, position hierarchies, and position-related CRUD operations.

## Package Structure
```
com.example.demo.position/
├── entity/
│   └── Position.java
├── repository/
│   └── PositionRepository.java
├── service/
│   ├── PositionService.java
│   └── impl/
│       └── PositionServiceImpl.java
├── controller/
│   └── PositionController.java
├── dto/
│   ├── PositionDto.java
│   ├── PositionCreateRequest.java
│   ├── PositionUpdateRequest.java
│   └── PositionSearchCriteria.java
└── exception/
    ├── PositionNotFoundException.java
    ├── PositionAlreadyExistsException.java
    └── PositionInUseException.java
```

## Entity Class

### Enums

#### PositionCategory Enum
```java
package com.example.demo.position.enums;

public enum PositionCategory {
    TECHNICAL,
    MANAGEMENT,
    ADMINISTRATIVE,
    SALES,
    HR,
    FINANCE,
    MARKETING,
    OPERATIONS,
    SUPPORT,
    OTHER
}
```

#### PositionLevel Enum
```java
package com.example.demo.position.enums;

public enum PositionLevel {
    JUNIOR,
    MID,
    SENIOR,
    LEAD,
    MANAGER,
    DIRECTOR,
    VP,
    EXECUTIVE
}
```

#### EmploymentType Enum
```java
package com.example.demo.position.enums;

public enum EmploymentType {
    FULL_TIME,
    PART_TIME,
    CONTRACT,
    INTERNSHIP,
    TEMPORARY
}
```
### Position Entity
```java
package com.example.demo.position.entity;

import com.example.demo.department.entity.Department;
import com.example.demo.employee.entity.Employee;
import com.example.demo.position.enums.EmploymentType;
import com.example.demo.position.enums.PositionCategory;
import com.example.demo.position.enums.PositionLevel;
import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.Data;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "positions", indexes = {
    @Index(name = "idx_position_job_title", columnList = "job_title"),
    @Index(name = "idx_position_code", columnList = "code"),
    @Index(name = "idx_position_department_id", columnList = "department_id"),
    @Index(name = "idx_position_level", columnList = "level"),
    @Index(name = "idx_position_enabled", columnList = "enabled"),
    @Index(name = "idx_position_category", columnList = "category")
})
@EntityListeners(AuditingEntityListener.class)
@Data
public class Position {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotBlank(message = "Job title is required")
    @Column(name = "job_title", nullable = false, length = 100)
    private String jobTitle;

    @Column(name = "professional_title", length = 100)
    private String professionalTitle;

    @NotBlank(message = "Position code is required")
    @Column(name = "code", unique = true, nullable = false, length = 20)
    private String code;

    @Column(name = "description", length = 1000)
    private String description;

    @Column(name = "requirements", length = 2000)
    private String requirements;

    @Column(name = "responsibilities", length = 2000)
    private String responsibilities;

    @NotNull(message = "Position category is required")
    @Enumerated(EnumType.STRING)
    @Column(name = "category", nullable = false, length = 20)
    private PositionCategory category = PositionCategory.TECHNICAL;

    @Column(name = "salary_grade", length = 10)
    private String salaryGrade;

    @NotNull(message = "Department is required")
    @Column(name = "department_id", nullable = false)
    private Long departmentId;

    @NotNull(message = "Position level is required")
    @Enumerated(EnumType.STRING)
    @Column(name = "level", nullable = false, length = 20)
    private PositionLevel level = PositionLevel.JUNIOR;

    @Column(name = "enabled", nullable = false)
    private Boolean enabled = true;

    @Column(name = "min_salary", precision = 12, scale = 2)
    private BigDecimal minSalary;

    @Column(name = "max_salary", precision = 12, scale = 2)
    private BigDecimal maxSalary;

    @Column(name = "required_skills", length = 1000)
    private String requiredSkills;

    @Column(name = "required_education", length = 500)
    private String requiredEducation;

    @Column(name = "required_experience")
    private Integer requiredExperience;

    @Column(name = "benefits", length = 1000)
    private String benefits;

    @Column(name = "work_location", length = 255)
    private String workLocation;

    @NotNull(message = "Employment type is required")
    @Enumerated(EnumType.STRING)
    @Column(name = "employment_type", nullable = false, length = 20)
    private EmploymentType employmentType = EmploymentType.FULL_TIME;

    @Column(name = "is_managerial", nullable = false)
    private Boolean isManagerial = false;

    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;

    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;

    @Column(name = "created_by")
    private Long createdBy;

    @Column(name = "updated_by")
    private Long updatedBy;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "department_id", insertable = false, updatable = false,
            foreignKey = @ForeignKey(name = "fk_position_department"))
    private Department department;

    @OneToMany(mappedBy = "position", fetch = FetchType.LAZY)
    private Set<Employee> employees = new HashSet<>();
}
```

## Repository Interface

### PositionRepository
```java
package com.example.demo.position.repository;

import com.example.demo.position.entity.Position;
import com.example.demo.position.enums.PositionCategory;
import com.example.demo.position.enums.PositionLevel;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface PositionRepository extends JpaRepository<Position, Long>, JpaSpecificationExecutor<Position> {

    /**
     * Find a position by its unique code.
     *
     * @param code The position code.
     * @return An Optional containing the found position or empty if not found.
     */
    Optional<Position> findByCode(String code);

    /**
     * Check if a position with the given code exists.
     *
     * @param code The position code.
     * @return true if a position with the code exists, false otherwise.
     */
    boolean existsByCode(String code);

    /**
     * Find all positions within a specific department.
     *
     * @param departmentId The ID of the department.
     * @return A list of positions in the specified department.
     */
    List<Position> findByDepartmentId(Long departmentId);

    /**
     * Find all positions matching a specific level.
     *
     * @param level The position level.
     * @return A list of positions with the specified level.
     */
    List<Position> findByLevel(PositionLevel level);

    /**
     * Find all positions belonging to a specific category.
     *
     * @param category The position category.
     * @return A list of positions in the specified category.
     */
    List<Position> findByCategory(PositionCategory category);

    /**
     * Find all enabled positions with pagination.
     *
     * @param pageable Pagination information.
     * @return A Page of enabled positions.
     */
    Page<Position> findByEnabledTrue(Pageable pageable);

    /**
     * Search for positions by job title.
     *
     * @param jobTitle The job title to search for (case-insensitive).
     * @param pageable Pagination information.
     * @return A Page of positions matching the job title.
     */
    Page<Position> findByJobTitleContainingIgnoreCase(String jobTitle, Pageable pageable);

    /**
     * Custom query to find positions by department and filter by job title.
     *
     * @param departmentId The ID of the department.
     * @param jobTitle     A part of the job title to search for.
     * @return A list of matching positions.
     */
    @Query("SELECT p FROM Position p WHERE p.departmentId = :departmentId AND lower(p.jobTitle) LIKE lower(concat('%', :jobTitle, '%'))")
    List<Position> findByDepartmentAndJobTitle(@Param("departmentId") Long departmentId, @Param("jobTitle") String jobTitle);
}
```
</file>

<file path="requirements.md">
# Requirements Document

## Introduction

This document outlines the requirements for a comprehensive Employee Management System built with Spring Boot and React. The system provides role-based access control, employee information management, department processing, payroll management, and communication features. It serves as an enterprise-grade HR management solution with robust security and user experience features.

## Requirements

### Requirement 1: Permission Management System

**User Story:** As a system administrator, I want to manage user permissions through roles and resources, so that I can control access to different parts of the system based on user responsibilities.

#### Acceptance Criteria

1. WHEN the system starts THEN it SHALL load a permission database containing resource tables, role tables, user tables, resource-role tables, and user-role tables
2. WHEN a user logs in THEN the system SHALL dynamically load modules based on the user's assigned roles
3. WHEN an administrator assigns roles to users THEN the system SHALL update user-role relationships in real-time
4. WHEN a user attempts to access a resource THEN the system SHALL verify permissions through the role-resource mapping
5. IF a user lacks permission for a resource THEN the system SHALL deny access and display an appropriate message

### Requirement 2: Authentication and Security

**User Story:** As a system user, I want secure login functionality with stateless JWT-based authentication and comprehensive security measures, so that my data and actions are protected according to industry standards.

#### Acceptance Criteria

1. WHEN the system is deployed THEN it SHALL use Spring Boot with Spring Security and stateless JWT authentication (no Redis sessions for authentication state)
2. WHEN a user logs in successfully THEN the system SHALL issue a JWT token with appropriate expiration, refresh capabilities, and secure signing using strong secret keys
3. WHEN JWT tokens are used THEN the system SHALL implement token blacklisting in Redis for logout functionality while maintaining stateless authentication
4. WHEN sensitive PII data is stored THEN the system SHALL encrypt dateOfBirth, bankAccount, and taxId fields using AES encryption with proper key management
5. WHEN server-side exceptions occur THEN the system SHALL handle them through a unified exception handling mechanism without exposing sensitive information
6. WHEN frontend requests are made THEN the system SHALL validate JWT tokens, enforce role-based access control, and implement method-level security with @PreAuthorize
7. WHEN user actions are performed THEN the system SHALL maintain comprehensive audit trails with user identification and Instant timestamps
8. WHEN password authentication fails multiple times THEN the system SHALL implement account lockout mechanisms with configurable thresholds
9. WHEN permission checks are performed THEN the system SHALL use a clearly defined permission string format (e.g., "RESOURCE:ACTION" like "EMPLOYEE:READ")
10. IF authentication fails THEN the system SHALL return appropriate error messages without exposing sensitive system information

### Requirement 3: Department Management

**User Story:** As an HR manager, I want to manage organizational departments in a hierarchical structure with proper data integrity, so that I can organize employees effectively.

#### Acceptance Criteria

1. WHEN the system initializes THEN it SHALL create department database tables in PostgreSQL with proper foreign key constraints and hierarchical query support
2. WHEN displaying departments THEN the system SHALL use a Tree component to show hierarchical relationships with proper parent-child references
3. WHEN querying department data THEN the system SHALL implement efficient hierarchical queries using depPath and PostgreSQL recursive CTEs
4. WHEN loading department information THEN the system SHALL use depPath for efficient querying and cache results in Redis for performance
5. WHEN identifying parent departments THEN the system SHALL use isParent field and maintain referential integrity through database constraints
6. WHEN department managers are assigned THEN the system SHALL validate that the manager is an employee and enforce proper authorization
7. WHEN departments are deleted THEN the system SHALL check for dependent employees and prevent deletion if dependencies exist

### Requirement 4: Position and Title Management

**User Story:** As an HR administrator, I want to manage job titles and professional titles, so that I can maintain accurate organizational structure.

#### Acceptance Criteria

1. WHEN managing positions THEN the system SHALL display job title and professional title information in tables
2. WHEN performing position operations THEN the system SHALL support Create, Read, Update, and Delete (CRUD) operations
3. WHEN viewing position data THEN the system SHALL provide clear tabular display with sorting capabilities
4. WHEN modifying position information THEN the system SHALL validate data integrity before saving
5. IF position deletion is attempted THEN the system SHALL check for dependencies before allowing removal

### Requirement 5: Employee Information Management

**User Story:** As an HR staff member, I want comprehensive employee management capabilities, so that I can efficiently handle all employee-related data operations with proper data integrity and validation.

#### Acceptance Criteria

1. WHEN managing employees THEN the system SHALL support full CRUD operations for employee basic information with proper validation and business rule enforcement
2. WHEN displaying employee lists THEN the system SHALL implement pagination for large datasets with configurable page sizes
3. WHEN selecting multiple employees THEN the system SHALL support batch deletion operations with dependency validation
4. WHEN searching for employees THEN the system SHALL provide both basic search and advanced search functionality with proper indexing
5. WHEN storing employee data THEN the system SHALL support both salaried and hourly employees with separate fields for salary and hourly rate
6. WHEN validating employee data THEN the system SHALL ensure salary falls within position's defined salary range and enforce all business rules
7. WHEN importing employee data THEN the system SHALL support Excel file import with comprehensive validation and error reporting
8. WHEN exporting employee data THEN the system SHALL generate Excel files with current employee information and proper formatting
9. WHEN handling employee payroll data THEN the system SHALL maintain referential integrity between employees and payroll records
10. IF invalid data is imported THEN the system SHALL provide detailed error messages, reject the import, and maintain data consistency

### Requirement 6: Email Communication System

**User Story:** As a system user, I want to send formatted emails to employees, so that I can communicate important information effectively.

#### Acceptance Criteria

1. WHEN sending emails THEN the system SHALL use Freemarker templates for email generation
2. WHEN processing email requests THEN the system SHALL implement Java email sending functionality
3. WHEN sending multiple emails THEN the system SHALL use new threads to prevent blocking
4. WHEN creating email templates THEN the system SHALL store template files in the ftl directory under resources
5. IF email sending fails THEN the system SHALL log errors and provide user feedback

### Requirement 7: Payroll Management

**User Story:** As a payroll administrator, I want to manage payroll ledgers and employee salary information with proper data integrity and historical accuracy, so that I can process payroll accurately and maintain compliance.

#### Acceptance Criteria

1. WHEN managing payroll THEN the system SHALL support adding new payroll ledgers with proper validation and business rule enforcement
2. WHEN setting up employee ledgers THEN the system SHALL allow viewing of ledger details with proper access control and audit trails
3. WHEN modifying ledgers THEN the system SHALL support ledger modifications with comprehensive audit trail and approval workflows
4. WHEN processing payroll THEN the system SHALL maintain data integrity, accuracy, and referential consistency with employee records
5. WHEN storing historical payroll data THEN the system SHALL maintain accurate employee and department names at the time of payroll processing without denormalization issues
6. WHEN payroll data changes THEN the system SHALL implement proper mechanisms to handle updates to historical records while preserving audit trails
7. WHEN calculating payroll THEN the system SHALL support both salaried and hourly employees with appropriate calculation methods
8. IF payroll calculations are performed THEN the system SHALL validate all financial data, enforce business rules, and maintain transaction integrity

### Requirement 8: Communication and Notification System

**User Story:** As a system user, I want online chat and notification capabilities, so that I can communicate with colleagues and receive important system updates.

#### Acceptance Criteria

1. WHEN using chat functionality THEN the system SHALL provide real-time online chat capabilities
WHEN system notifications are generated THEN the system SHALL save them to a single `notifications` table. This table is the source of truth for real-time, user-specific notifications. This is distinct from the `announcements` feature, which handles broader, system-wide communications.
3. WHEN managing user notifications THEN the system SHALL handle all aspects including content, recipients, status, and type within the `notifications` entity.
4. WHEN notifications are created THEN the system SHALL push notifications to relevant users based on the data in the `notifications` table.
5. WHEN users access notifications THEN the system SHALL provide viewing and management capabilities based on the unified `notifications` model.
6. IF chat messages are sent THEN the system SHALL ensure real-time delivery and display

### Requirement 9: User Interface and Experience

**User Story:** As a system user, I want an intuitive and responsive interface, so that I can efficiently perform my tasks.

#### Acceptance Criteria

1. WHEN displaying roles THEN the system SHALL use ElementUI Collapse panels for role information
2. WHEN showing role resources THEN the system SHALL use tree controls for hierarchical display
3. WHEN managing positions and titles THEN the system SHALL use tables for clear data presentation
4. WHEN accessing employee management THEN the system SHALL provide comprehensive CRUD interface with search capabilities
5. WHEN using chat and notifications THEN the system SHALL provide user-friendly interface for message sending and viewing

### Requirement 10: Hybrid Data Storage and Compliance

**User Story:** As a system administrator, I want a robust hybrid data storage strategy with compliance features, so that the system meets enterprise requirements and regulatory standards while maintaining optimal performance.

#### Acceptance Criteria

1. WHEN storing core business data THEN the system SHALL use PostgreSQL as the primary database with ACID compliance, referential integrity, and proper foreign key constraints for all relational entities (Users, Roles, Employees, Departments, Positions, Payroll)
2. WHEN handling caching and real-time features THEN the system SHALL use Redis exclusively for session management, frequently accessed data caching, real-time chat messages, and WebSocket connection management
3. WHEN storing sensitive PII data THEN the system SHALL implement field-level AES encryption for dateOfBirth, bankAccount, and taxId fields in compliance with GDPR and CCPA
4. WHEN handling timestamps THEN the system SHALL use Instant (UTC) or ZonedDateTime for all timestamp fields to ensure time-zone awareness and eliminate ambiguity
5. WHEN database schema changes are needed THEN the system SHALL use Flyway for versioned database migrations with proper rollback capabilities
6. WHEN data integrity is required THEN the system SHALL enforce foreign key constraints, check constraints, and proper transaction boundaries in PostgreSQL
7. WHEN audit trails are needed THEN the system SHALL automatically track created_by, updated_by, created_at, and updated_at fields using Instant timestamps for all critical entities
8. WHEN backup and recovery is required THEN the system SHALL support standard PostgreSQL backup procedures and Redis persistence configuration
9. IF data access is requested THEN the system SHALL implement permission-based filtering to ensure users only see authorized data through repository-level security

### Requirement 11: API Design and Data Consistency

**User Story:** As a frontend developer and system integrator, I want well-designed APIs with proper DTOs and consistent data handling, so that I can build reliable integrations and maintain system integrity.

#### Acceptance Criteria

1. WHEN designing API endpoints THEN the system SHALL use dedicated CreateRequest and UpdateRequest DTOs instead of reusing read DTOs for write operations
2. WHEN handling API requests THEN the system SHALL prevent clients from sending immutable fields (id, createdAt, updatedAt) in update operations
3. WHEN implementing batch operations THEN the system SHALL provide true batch endpoints (e.g., DELETE /api/employees/batch) as specified in requirements
4. WHEN returning hierarchical data THEN the system SHALL avoid infinite recursion risks by using appropriate DTO structures without circular references
5. WHEN defining entity fields THEN the system SHALL use enum types instead of string fields for fixed value sets (status, level, type fields)
6. WHEN implementing audit trails THEN the system SHALL provide comprehensive auditing for all critical entities (users, roles, employees, departments) not just payroll
7. WHEN maintaining data consistency THEN the system SHALL ensure all entity definitions are consistent across all documentation and implementation files
8. IF API responses include sensitive data THEN the system SHALL implement proper field filtering and access control at the DTO level

### Requirement 12: System Documentation and Maintainability

**User Story:** As a new developer or user, I want comprehensive documentation with a single source of truth, so that I can quickly understand and work with the system without conflicts.

#### Acceptance Criteria

1. WHEN onboarding new team members THEN the system SHALL provide detailed documentation for quick understanding with consistent entity definitions
2. WHEN maintaining the system THEN the documentation SHALL include architectural decisions and implementation details from a single source of truth
3. WHEN troubleshooting issues THEN the documentation SHALL provide clear guidance for common problems with up-to-date information
4. WHEN extending functionality THEN the documentation SHALL explain the system's extensibility patterns with consistent examples
5. WHEN defining entities and DTOs THEN the system SHALL maintain a single source of truth to prevent conflicting definitions across documents
6. IF system updates are made THEN the documentation SHALL be updated accordingly with version control and change tracking
</file>

<file path="security-implementation.md">
# Security and Permission Management Implementation

## Overview
This document provides detailed implementation specifications for the Security and Permission Management module of the Employee Management System. This module handles authentication, authorization, role-based access control, and permission management.

## Package Structure
```
com.example.demo.security/
├── config/
│   ├── SecurityConfig.java
│   ├── JwtConfig.java
│   └── RedisConfig.java
├── entity/
│   ├── User.java
│   ├── Role.java
│   └── Resource.java
├── repository/
│   ├── UserRepository.java
│   ├── RoleRepository.java
│   └── ResourceRepository.java
├── service/
│   ├── UserService.java
│   ├── RoleService.java
│   ├── ResourceService.java
│   ├── AuthenticationService.java
│   └── PermissionService.java
├── controller/
│   ├── AuthController.java
│   ├── UserController.java
│   ├── RoleController.java
│   └── ResourceController.java
├── dto/
│   ├── LoginRequest.java
│   ├── LoginResponse.java
│   ├── UserDto.java
│   ├── RoleDto.java
│   └── ResourceDto.java
├── security/
│   ├── JwtAuthenticationFilter.java
│   ├── JwtTokenProvider.java
│   ├── CustomUserDetailsService.java
│   └── SecurityUtils.java
└── exception/
    ├── AuthenticationException.java
    ├── AuthorizationException.java
    └── UserNotFoundException.java
```

## Entity Classes

### User Entity
```java
package com.example.demo.security.entity;

### User Entity
```java
package com.example.demo.security.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.Duration;
import java.time.Instant;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "users",
    indexes = {
        @Index(name = "idx_user_username", columnList = "username"),
        @Index(name = "idx_user_email", columnList = "email"),
        @Index(name = "idx_user_enabled", columnList = "enabled"),
        @Index(name = "idx_user_account_locked", columnList = "account_locked")
    },
    uniqueConstraints = {
        @UniqueConstraint(name = "uk_user_username", columnNames = "username"),
        @UniqueConstraint(name = "uk_user_email", columnNames = "email")
    }
)
@EntityListeners(AuditingEntityListener.class)
@Getter
@Setter
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "username", nullable = false, length = 50)
    @NotBlank(message = "Username is required")
    @Size(min = 3, max = 50, message = "Username must be between 3 and 50 characters")
    private String username;

    @Column(name = "password", nullable = false)
    @NotBlank(message = "Password is required")
    private String password;
    
    @Column(name = "email", nullable = false, length = 100)
    @NotBlank(message = "Email is required")
    @Email(message = "Email must be valid")
    private String email;
    
    @Column(name = "first_name", length = 50)
    private String firstName;
    
    @Column(name = "last_name", length = 50)
    private String lastName;
    
    @Column(name = "enabled", nullable = false)
    private Boolean enabled = true;
    
    @Column(name = "last_login")
    private Instant lastLogin;
    
    @Column(name = "login_attempts", nullable = false)
    private Integer loginAttempts = 0;
    
    @Column(name = "account_locked", nullable = false)
    private Boolean accountLocked = false;
    
    @Column(name = "account_locked_until")
    private Instant accountLockedUntil;
    
    @Column(name = "password_expired", nullable = false)
    private Boolean passwordExpired = false;
    
    @Column(name = "password_change_required", nullable = false)
    private Boolean passwordChangeRequired = false;
    
    @Column(name = "password_changed_at")
    private Instant passwordChangedAt;
    
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;
    
    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;
    
    @Column(name = "created_by")
    private Long createdBy;
    
    @Column(name = "updated_by")
    private Long updatedBy;
    
    @ManyToMany(fetch = FetchType.LAZY)
    @JoinTable(
        name = "user_roles",
        joinColumns = @JoinColumn(name = "user_id"),
        inverseJoinColumns = @JoinColumn(name = "role_id"),
        foreignKey = @ForeignKey(name = "fk_user_roles_user"),
        inverseForeignKey = @ForeignKey(name = "fk_user_roles_role")
    )
    private Set<Role> roles = new HashSet<>();
    
    public boolean isAccountNonLocked() {
        if (!accountLocked) return true;
        if (accountLockedUntil != null && Instant.now().isAfter(accountLockedUntil)) {
            accountLocked = false;
            accountLockedUntil = null;
            return true;
        }
        return false;
    }
    
    public void incrementLoginAttempts() {
        this.loginAttempts++;
        if (this.loginAttempts >= 5) {
            this.accountLocked = true;
            this.accountLockedUntil = Instant.now().plus(Duration.ofMinutes(30));
        }
    }
    
    public void resetLoginAttempts() {
        this.loginAttempts = 0;
        this.accountLocked = false;
        this.accountLockedUntil = null;
        this.lastLogin = Instant.now();
    }
}
```

### Role Entity
```java
package com.example.demo.security.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.Instant;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "roles", indexes = {
    @Index(name = "idx_role_name", columnList = "name"),
    @Index(name = "idx_role_active", columnList = "active")
})
@EntityListeners(AuditingEntityListener.class)
@Getter
@Setter
public class Role {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "name", unique = true, nullable = false, length = 50)
    private String name;
    
    @Column(name = "description", length = 255)
    private String description;
    
    @Column(name = "active", nullable = false)
    private Boolean active = true;
    
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;
    
    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;
    
    @Column(name = "created_by")
    private Long createdBy;
    
    @Column(name = "updated_by")
    private Long updatedBy;
    
    @ManyToMany(mappedBy = "roles", fetch = FetchType.LAZY)
    private Set<User> users = new HashSet<>();
    
    @ManyToMany(fetch = FetchType.LAZY)
    @JoinTable(
        name = "role_resources",
        joinColumns = @JoinColumn(name = "role_id"),
        inverseJoinColumns = @JoinColumn(name = "resource_id")
    )
    private Set<Resource> resources = new HashSet<>();
}
```


### UserCreateRequest DTO
```java
package com.example.demo.security.dto;

import lombok.Data;
import jakarta.validation.constraints.*;
import java.util.Set;

@Data
public class UserCreateRequest {
    @NotBlank @Size(min = 3, max = 50)
    private String username;
    @NotBlank @Email
    private String email;
    @NotBlank @Size(min = 8, max = 100)
    private String password;
    @NotBlank @Size(max = 50)
    private String firstName;
    @NotBlank @Size(max = 50)
    private String lastName;
    private Set<Long> roleIds;
}
```

### UserUpdateRequest DTO
```java
package com.example.demo.security.dto;

import lombok.Data;
import jakarta.validation.constraints.*;
import java.util.Set;

@Data
public class UserUpdateRequest {
    @NotBlank @Email
    private String email;
    @NotBlank @Size(max = 50)
    private String firstName;
    @NotBlank @Size(max = 50)
    private String lastName;
    private Boolean enabled;
    private Set<Long> roleIds;
}

```

### Resource Entity
```java
package com.example.demo.security.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.Instant;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "resources", indexes = {
    @Index(name = "idx_resource_url", columnList = "url"),
    @Index(name = "idx_resource_method", columnList = "method"),
    @Index(name = "idx_resource_category", columnList = "category"),
    @Index(name = "idx_resource_active", columnList = "active")
})
@EntityListeners(AuditingEntityListener.class)
@Getter
@Setter
public class Resource {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "name", nullable = false, length = 100)
    private String name;
    
    @Column(name = "url", nullable = false, length = 255)
    private String url;
    
    @Column(name = "method", nullable = false, length = 10)
    private String method;
    
    @Column(name = "description", length = 255)
    private String description;
    
    @Column(name = "category", nullable = false, length = 50)
    private String category;
    
    @Column(name = "active", nullable = false)
    private Boolean active = true;
    
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;
    
    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;
    
    @Column(name = "created_by")
    private Long createdBy;
    
    @Column(name = "updated_by")
    private Long updatedBy;
    
    @ManyToMany(mappedBy = "resources", fetch = FetchType.LAZY)
    private Set<Role> roles = new HashSet<>();
tory Interfaces

### UserRepository
```java
package com.example.demo.security.repository;

import com.example.demo.security.entity.User;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;
import java.util.List;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    
    Optional<User> findByUsername(String username);
    
    Optional<User> findByEmail(String email);
    
    boolean existsByUsername(String username);
    
    boolean existsByEmail(String email);
    
    List<User> findByEnabledTrue();
    
    Page<User> findByEnabledTrue(Pageable pageable);
    
    List<User> findByUsernameContainingIgnoreCase(String username);
    
    List<User> findByFirstNameContainingIgnoreCaseOrLastNameContainingIgnoreCase(
        String firstName, String lastName);
}
```

### RoleRepository
```java
package com.example.demo.security.repository;

import com.example.demo.security.entity.Role;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;
import java.util.List;

@Repository
public interface RoleRepository extends JpaRepository<Role, Long> {
    
    Optional<Role> findByName(String name);
    
    boolean existsByName(String name);
    
    List<Role> findByEnabledTrue();
    
    List<Role> findByNameContainingIgnoreCase(String name);
}
```

### ResourceRepository
```java
package com.example.demo.security.repository;

import com.example.demo.security.entity.Resource;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface ResourceRepository extends JpaRepository<Resource, Long> {
    
    Optional<Resource> findByNameAndMethod(String name, String method);
    
    List<Resource> findByEnabledTrue();
    
    List<Resource> findByCategory(String category);
    
    List<Resource> findByUrlContainingIgnoreCase(String url);
    
    boolean existsByNameAndMethod(String name, String method);
}
```
### LoginRequest
```java
package com.example.demo.security.dto;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class LoginRequest {
    
    @NotBlank(message = "Username is required")
    @Size(min = 3, max = 50, message = "Username must be between 3 and 50 characters")
    private String username;
    
    @NotBlank(message = "Password is required")
    @Size(min = 6, max = 100, message = "Password must be between 6 and 100 characters")
    private String password;
    
    private boolean rememberMe = false;
}
```

### LoginResponse
```java
package com.example.demo.security.dto;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;

import java.time.Instant;
import java.util.Set;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class LoginResponse {
    
    private String token;
    
    private String tokenType = "Bearer";
    
    private Long expiresIn; // seconds
    
    private UserDto user;
    
    private Set<String> permissions;
    
    private Instant loginTime;
}
```

### UserDto
```java
package com.example.demo.security.dto;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import java.time.Instant;
import java.util.Set;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserDto {
    
    private Long id;
    
    @NotBlank(message = "Username is required")
    @Size(min = 3, max = 50, message = "Username must be between 3 and 50 characters")
    private String username;
    
    @NotBlank(message = "Email is required")
    @Email(message = "Email should be valid")
    private String email;
    
    @NotBlank(message = "First name is required")
    @Size(max = 50, message = "First name must not exceed 50 characters")
    private String firstName;
    
    @NotBlank(message = "Last name is required")
    @Size(max = 50, message = "Last name must not exceed 50 characters")
    private String lastName;
    
    private boolean enabled;
    
    private Instant createdAt;
    
    private Instant updatedAt;
    
    private Instant lastLoginAt;
    
    private Set<RoleDto> roles;
}
```

### RoleDto
```java
package com.example.demo.security.dto;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;

import javax.validation.constraints.NotBlank;
import javax.validation.constraints.Size;
import java.time.Instant;
import java.util.Set;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class RoleDto {
    
    private Long id;
    
    @NotBlank(message = "Role name is required")
    @Size(min = 2, max = 50, message = "Role name must be between 2 and 50 characters")
    private String name;
    
    @Size(max = 255, message = "Description must not exceed 255 characters")
    private String description;
    
    private boolean enabled;
    
    private Instant createdAt;
    
    private Instant updatedAt;
    
    private Set<ResourceDto> resources;
}
```

### ResourceDto
```java
package com.example.demo.security.dto;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;

import javax.validation.constraints.NotBlank;
import javax.validation.constraints.Pattern;
import javax.validation.constraints.Size;
import java.time.Instant;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ResourceDto {
    
    private Long id;
    
    @NotBlank(message = "Resource name is required")
    @Size(min = 2, max = 100, message = "Resource name must be between 2 and 100 characters")
    private String name;
    
    @NotBlank(message = "URL is required")
    @Size(max = 255, message = "URL must not exceed 255 characters")
    private String url;
    
    @NotBlank(message = "HTTP method is required")
    @Pattern(regexp = "GET|POST|PUT|DELETE|PATCH", message = "Method must be GET, POST, PUT, DELETE, or PATCH")
    private String method;
    
    @Size(max = 255, message = "Description must not exceed 255 characters")
    private String description;
    
    @Size(max = 50, message = "Category must not exceed 50 characters")
    private String category;
    
    private boolean enabled;
    
    private Instant createdAt;
    
    private Instant updatedAt;
}
```#
# Service Layer Implementation

### UserService
```java
package com.example.demo.security.service;

import com.example.demo.security.dto.UserDto;
import com.example.demo.security.entity.User;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import java.util.List;
import java.util.Optional;
import java.util.Set;

public interface UserService {
    
    /**
     * Create a new user
     * @param userDto User data transfer object
     * @return Created user DTO
     * @throws UserAlreadyExistsException if username or email already exists
     */
    UserDto createUser(UserCreateRequest createRequest);
    
    /**
     * Update an existing user
     * @param id User ID
     * @param userDto Updated user data
     * @return Updated user DTO
     * @throws UserNotFoundException if user not found
     */
    UserDto updateUser(Long id, UserUpdateRequest updateRequest);
    
    /**
     * Get user by ID
     * @param id User ID
     * @return User DTO
     * @throws UserNotFoundException if user not found
     */
    UserDto getUserById(Long id);
    
    /**
     * Get user by username
     * @param username Username
     * @return User DTO
     * @throws UserNotFoundException if user not found
     */
    UserDto getUserByUsername(String username);
    
    /**
     * Get all users with pagination
     * @param pageable Pagination parameters
     * @return Page of user DTOs
     */
    Page<UserDto> getAllUsers(Pageable pageable);
    
    /**
     * Search users by criteria
     * @param searchTerm Search term for username, first name, or last name
     * @param pageable Pagination parameters
     * @return Page of matching user DTOs
     */
    Page<UserDto> searchUsers(String searchTerm, Pageable pageable);
    
    /**
     * Delete user by ID
     * @param id User ID
     * @throws UserNotFoundException if user not found
     */
    void deleteUser(Long id);
    
    /**
     * Enable or disable user
     * @param id User ID
     * @param enabled Enable/disable flag
     * @throws UserNotFoundException if user not found
     */
    void setUserEnabled(Long id, boolean enabled);
    
    /**
     * Assign roles to user
     * @param userId User ID
     * @param roleIds Set of role IDs to assign
     * @throws UserNotFoundException if user not found
     * @throws RoleNotFoundException if any role not found
     */
    void assignRolesToUser(Long userId, Set<Long> roleIds);
    
    /**
     * Remove roles from user
     * @param userId User ID
     * @param roleIds Set of role IDs to remove
     * @throws UserNotFoundException if user not found
     */
    void removeRolesFromUser(Long userId, Set<Long> roleIds);
    
    /**
     * Get user permissions
     * @param userId User ID
     * @return Set of permission strings
     * @throws UserNotFoundException if user not found
     */
    Set<String> getUserPermissions(Long userId);
    
    /**
     * Check if user has specific permission
     * @param userId User ID
     * @param permission Permission string
     * @return true if user has permission
     */
    boolean hasPermission(Long userId, String permission);
    
    /**
     * Update user last login time
     * @param userId User ID
     */
    void updateLastLoginTime(Long userId);
    
    /**
     * Change user password
     * @param userId User ID
     * @param oldPassword Current password
     * @param newPassword New password
     * @throws InvalidPasswordException if old password is incorrect
     * @throws UserNotFoundException if user not found
     */
    void changePassword(Long userId, String oldPassword, String newPassword);
    
    /**
     * Reset user password (admin function)
     * @param userId User ID
     * @param newPassword New password
     * @throws UserNotFoundException if user not found
     */
    void resetPassword(Long userId, String newPassword);
}
```

### RoleService
```java
package com.example.demo.security.service;

import com.example.demo.security.dto.RoleDto;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import java.util.List;
import java.util.Set;

public interface RoleService {
    
    /**
     * Create a new role
     * @param roleDto Role data transfer object
     * @return Created role DTO
     * @throws RoleAlreadyExistsException if role name already exists
     */
    RoleDto createRole(RoleDto roleDto);
    
    /**
     * Update an existing role
     * @param id Role ID
     * @param roleDto Updated role data
     * @return Updated role DTO
     * @throws RoleNotFoundException if role not found
     */
    RoleDto updateRole(Long id, RoleDto roleDto);
    
    /**
     * Get role by ID
     * @param id Role ID
     * @return Role DTO
     * @throws RoleNotFoundException if role not found
     */
    RoleDto getRoleById(Long id);
    
    /**
     * Get role by name
     * @param name Role name
     * @return Role DTO
     * @throws RoleNotFoundException if role not found
     */
    RoleDto getRoleByName(String name);
    
    /**
     * Get all roles
     * @return List of role DTOs
     */
    List<RoleDto> getAllRoles();
    
    /**
     * Get all roles with pagination
     * @param pageable Pagination parameters
     * @return Page of role DTOs
     */
    Page<RoleDto> getAllRoles(Pageable pageable);
    
    /**
     * Search roles by name
     * @param searchTerm Search term for role name
     * @return List of matching role DTOs
     */
    List<RoleDto> searchRoles(String searchTerm);
    
    /**
     * Delete role by ID
     * @param id Role ID
     * @throws RoleNotFoundException if role not found
     * @throws RoleInUseException if role is assigned to users
     */
    void deleteRole(Long id);
    
    /**
     * Enable or disable role
     * @param id Role ID
     * @param enabled Enable/disable flag
     * @throws RoleNotFoundException if role not found
     */
    void setRoleEnabled(Long id, boolean enabled);
    
    /**
     * Assign resources to role
     * @param roleId Role ID
     * @param resourceIds Set of resource IDs to assign
     * @throws RoleNotFoundException if role not found
     * @throws ResourceNotFoundException if any resource not found
     */
    void assignResourcesToRole(Long roleId, Set<Long> resourceIds);
    
    /**
     * Remove resources from role
     * @param roleId Role ID
     * @param resourceIds Set of resource IDs to remove
     * @throws RoleNotFoundException if role not found
     */
    void removeResourcesFromRole(Long roleId, Set<Long> resourceIds);
    
    /**
     * Get role permissions
     * @param roleId Role ID
     * @return Set of permission strings
     * @throws RoleNotFoundException if role not found
     */
    Set<String> getRolePermissions(Long roleId);
}
```
</file>

<file path="tasks.md">
# Implementation Plan - Spring Boot Employee Management System

## Overview

This implementation plan provides detailed, actionable tasks for building the Spring Boot Employee Management System backend using a hybrid PostgreSQL + Redis architecture. Each task is designed to be executed incrementally, building upon previous implementations while maintaining system integrity and following best practices. The plan addresses all conflicts identified in the conflict analysis and implements comprehensive security and compliance features.

## Phase 1: Project Foundation and Hybrid Database Setup

### Task 1: Project Initialization and Basic Structure

- [ ] 1.1 Create Spring Boot project structure with hybrid database support
  - Initialize Maven project with Spring Boot 3.5.4 and Java 24
  - Set up basic directory structure following package conventions
  - Create main application class DemoApplication.java
  - Configure Maven pom.xml with PostgreSQL, Redis, and security dependencies
  - Set up executable JAR packaging for modern deployment
  - _Requirements: 2.1, 10.1_

- [ ] 1.2 Configure hybrid database dependencies
  - Add Spring Boot Starter Web for REST API support
  - Add Spring Boot Starter Security for authentication
  - Add Spring Boot Starter Data JPA for PostgreSQL operations
  - Add Spring Boot Starter Data Redis for caching and real-time features
  - Add PostgreSQL JDBC driver
  - Add Flyway for database migrations
  - Add Spring Boot Starter WebSocket for real-time communication
  - Add Spring Boot Starter Mail for email functionality
  - Add Spring Boot Starter Actuator for monitoring
  - Add Lombok for code generation
  - Add Spring Boot Starter Test for testing
  - _Requirements: 2.1, 6.2, 8.1, 10.1_

- [ ] 1.3 Set up hybrid database configuration
  - Create application.properties with PostgreSQL and Redis configuration
  - Create application-dev.properties for development environment
  - Configure PostgreSQL connection properties with connection pooling
  - Configure Redis connection properties for caching and sessions
  - Set up Flyway migration configuration
  - Configure JPA/Hibernate properties for PostgreSQL
  - Set up basic logging configuration
  - Configure server port and context path
  - _Requirements: 2.1, 10.1, 10.2_

### Task 2: Database Infrastructure Setup

- [ ] 2.1 Implement PostgreSQL configuration
  - Create JpaConfig class with EntityManagerFactory configuration
  - Configure PostgreSQL dialect and connection pooling
  - Set up transaction management with @Transactional support
  - Add PostgreSQL health check configuration
  - Create database connection validation
  - _Requirements: 10.1, 10.5_

- [ ] 2.2 Implement Redis configuration for caching and real-time features
  - Create RedisConfig class with RedisTemplate configuration
  - Configure Redis serializers for keys and values
  - Set up Redis connection factory with connection pooling
  - Configure Redis cache manager for Spring Cache abstraction
  - Add Redis health check configuration
  - Test Redis connectivity with basic operations
  - _Requirements: 8.1, 8.2, 10.1_

- [ ] 2.3 Create database migration infrastructure
  - Set up Flyway configuration for versioned migrations
  - Create initial migration scripts directory structure
  - Implement database initialization scripts
  - Create rollback and recovery procedures
  - Add migration validation and testing
  - _Requirements: 10.4, 10.5_

- [ ] 2.4 Create common infrastructure classes
  - Implement ApiResponse<T> for standardized API responses
  - Create ErrorResponse for error information
  - Add PageResponse<T> for paginated data
  - Create basic utility classes (DateUtil, StringUtil)
  - Set up global exception handling structure
  - _Requirements: 2.4, 5.2_
  - Add PageResponse<T> for paginated data
  - Create basic utility classes (DateUtil, StringUtil)
  - Set up global exception handling structure
  - _Requirements: 2.4, 5.2_
## Security and Authentication Module

### Task 3: Core Security Entities and Database Schema

- [ ] 3.1 Implement User entity with JPA annotations for PostgreSQL
  - Create User.java with @Entity annotation for PostgreSQL.
  - Define fields: id, username, password, enabled, roles
  - Add validation annotations (@NotNull, @Size, @Email)
  - Implement audit fields with @CreatedDate, @LastModifiedDate
  - Add password encoding support with BCrypt
  - Create proper JPA relationships with Role entities.
  - _Requirements: 1.1, 2.1, 2.2_

- [ ] 3.2 Implement Role entity with resource relationships
  - Create Role.java with @Entity annotation for PostgreSQL.
  - Define fields: id, name, description, resources
  - Implement many-to-many relationship with Resource entities
  - Add validation for role name uniqueness
  - Create proper database constraints and indexes.
  - _Requirements: 1.1, 1.2_

- [ ] 3.3 Implement Resource entity for permission management
  - Create Resource.java with @Entity annotation for PostgreSQL.
  - Define fields: id, name, url, method, description
  - Add validation for URL patterns and HTTP methods
  - Implement resource hierarchy support
  - _Requirements: 1.1, 1.4_
  - Create composite unique constraints on (url, method).

- [ ] 3.4 Create junction entities for many-to-many relationships
  - Create V1__Create_security_tables.sql migration script.
  - Define users, roles, resources tables with proper constraints.
  - Create user_roles and role_resources junction tables.
  - Add indexes for performance optimization.
  - Implement UserRole.java for user-role associations
  - Implement RoleResource.java for role-resource associations
  - Add composite keys and validation
  - _Requirements: 1.1, 1.3_

### Task 4: Security Repository Layer

- [ ] 4.1 Create UserRepository with custom query methods
  - Extend JpaRepository<User, Long>
  - Add findByUsername method using JPQL.
  - Add findByUsername method with @Query annotation
  - Implement findByEnabledTrue for active users
  - Add existsByUsername for validation
  - Create findUsersWithRoles method using JOIN FETCH for performance.
  - _Requirements: 1.2, 2.2_

- [ ] 4.2 Create RoleRepository with permission queries
  - Extend JpaRepository<Role, Long>
  - Add findByName method for role lookup
  - Implement findRolesWithResources method using JOIN FETCH.
  - Add caching annotations for frequently accessed roles.
  - Create custom query for role hierarchy
  - _Requirements: 1.2, 1.3_

- [ ] 4.3 Create ResourceRepository with URL pattern matching
  - Extend JpaRepository<Resource, Long>
  - Add findByUrlAndMethod for permission checking
  - Implement findResourcesByRoleId method
  - Create pattern matching queries for URL authorization
  - _Requirements: 1.4, 1.5_

- [ ] 4.4 Implement junction table repositories
  - Create UserRoleRepository for user-role management
  - Create RoleResourceRepository for role-resource management
  - Add bulk operations with @Modifying annotations
  - Implement transaction support with @Transactional
  - _Requirements: 1.3_

### Task 5: Security Service Layer Implementation

- [ ] 5.1 Implement UserDetailsService for Spring Security
  - Create CustomUserDetailsService implementing UserDetailsService
  - Override loadUserByUsername method with database queries from UserRepository.
  - Map User entity to UserDetails with authorities
  - Handle user not found and disabled user scenarios
  - Cache user details in Redis for performance
  - _Requirements: 2.1, 2.2_

- [ ] 5.2 Create AuthenticationService for login/logout
  - Implement authenticate method with password validation
  - Generate JWT tokens upon successful authentication
  - Handle authentication failures with custom exceptions
  - Implement logout functionality with token invalidation
  - Implement secure logout functionality by adding the JWT token to a blacklist in Redis until it expires.
  - _Requirements: 2.1, 2.2, 2.5_

- [ ] 5.3 Implement UserService for user management
  - Create CRUD operations for user entities
  - Add password encoding and validation
  - Implement user role assignment methods
  - Create user search and pagination functionality
  - Add bulk user operations with transaction support
  - _Requirements: 1.2, 1.3_

- [ ] 5.4 Create PermissionService for authorization
  - Implement hasPermission method for resource access
  - Create role-based permission checking
  - Add dynamic permission loading based on user roles
  - Implement permission caching with Redis
  - Create permission validation utilities
  - _Requirements: 1.4, 1.5_

### Task 6: JWT Token Management

- [ ] 6.1 Implement JwtTokenProvider utility class
  - Create JWT token generation with user claims
  - Implement token validation and parsing
  - Add token expiration and refresh logic
  - Create token blacklist functionality with Redis
  - Handle token security with proper signing keys
  - _Requirements: 2.1, 2.2_

- [ ] 6.2 Create JwtAuthenticationFilter for request processing
  - Extend OncePerRequestFilter for JWT processing
  - Extract and validate JWT tokens from requests
  - Set SecurityContext with authenticated user
  - Handle token expiration and invalid token scenarios
  - Implement proper error responses for authentication failures
  - _Requirements: 2.1, 2.5_

### Task 7: Security Configuration

- [ ] 7.1 Implement SecurityConfig with filter chain
  - Create SecurityFilterChain bean with HTTP security
  - Configure JWT authentication filter in security chain
  - Set up CORS configuration for frontend integration
  - Disable CSRF for stateless JWT authentication
  - Configure session management as stateless
  - _Requirements: 2.1, 2.3_

- [ ] 7.2 Configure method-level security
  - Enable @PreAuthorize and @PostAuthorize annotations
  - Create custom security expressions for permission checking
  - Implement role-based method security
  - Add audit logging for security events
  - _Requirements: 1.4, 1.5_

### Task 8: Security Controllers and DTOs

- [ ] 8.1 Create AuthController for authentication endpoints
  - Implement POST /api/auth/login endpoint
  - Add POST /api/auth/logout endpoint
  - Create POST /api/auth/refresh-token endpoint
  - Implement proper request/response DTOs
  - Add comprehensive error handling and validation
  - Include OpenAPI/Swagger documentation
  - _Requirements: 2.1, 2.2_

- [ ] 8.2 Implement UserController for user management
  - Create GET /api/users endpoint with pagination
  - Add POST /api/users for user creation
  - Implement PUT /api/users/{id} for user updates
  - Create DELETE /api/users/{id} with validation
  - Add GET /api/users/{id}/roles for role management
  - Include @PreAuthorize annotations for security
  - _Requirements: 1.2, 1.3_

- [ ] 8.3 Create security-related DTOs
  - Implement LoginRequest with validation annotations
  - Create LoginResponse with token and user info
  - Add UserDto for user data transfer
  - Create RoleDto and ResourceDto classes
  - Implement proper validation and error messages
  - _Requirements: 2.1, 1.2_

## Department Management Module

### Task 9: Department Entity and Repository

- [ ] 9.1 Implement Department entity with hierarchical structure
  - Create Department.java with @Entity annotation for PostgreSQL.
  - Define fields: id, name, depPath, parentId, isParent
  - Implement self-referencing relationship for hierarchy
  - Add validation for department name and path
  - Create audit fields for tracking changes
  - _Requirements: 3.1, 3.4, 3.5_

- [ ] 9.2 Create DepartmentRepository with tree queries
  - Extend JpaRepository<Department, Long>
  - Add findByParentId method for child departments
  - Implement findRootDepartments for top-level departments
  - Create recursive query methods for department tree
  - Add findByDepPathStartingWith for path-based queries
  - _Requirements: 3.1, 3.3_

- [ ] 9.3 Create Flyway migration for departments table
  - Create a new migration script, e.g., V2__Create_departments_table.sql.
  - Define the departments table schema including hierarchical fields (parent_id, dep_path, is_parent, level) and manager_id.
  - Add a self-referencing foreign key on parent_id to the departments(id) to enforce the hierarchy.
  - Create a unique constraint on the department code column to prevent duplicate codes.
  - Add indexes on parent_id and dep_path to optimize hierarchical queries, and on manager_id for quick lookups.
  - _Requirements: 3.1, 10.4_


### Task 10: Department Service Implementation

- [ ] 10.1 Implement DepartmentService with tree operations
  - Create getDepartmentTree method with recursive loading
  - Implement createDepartment with path generation
  - Add updateDepartment with hierarchy validation
  - Create deleteDepartment with dependency checking
  - Implement department move operations
  - _Requirements: 3.1, 3.2, 3.4, 3.5_

- [ ] 10.2 Add department validation and business logic
  - Validate department hierarchy constraints
  - Prevent circular references in department tree
  - Check for existing employees before deletion
  - Implement department path recalculation
  - Add department statistics and reporting
  - _Requirements: 3.4, 3.5_

### Task 11: Department Controller and DTOs

- [ ] 11.1 Create DepartmentController with REST endpoints
  - Implement GET /api/departments/tree for hierarchy
  - Add POST /api/departments for creation
  - Create PUT /api/departments/{id} for updates
  - Implement DELETE /api/departments/{id} with validation
  - Add GET /api/departments/{id}/employees endpoint
  - Include proper security annotations
  - _Requirements: 3.1, 3.2_

- [ ] 11.2 Implement department DTOs and validation
  - Create DepartmentDto for data transfer
  - Add DepartmentTreeDto for hierarchical display
  - Implement DepartmentCreateRequest with validation
  - Create DepartmentUpdateRequest class
  - Add custom validation for department hierarchy
  - _Requirements: 3.1, 3.2_## Employee Management Module

### Task 12: Employee Entity and Status Management

- [ ] 12.1 Implement Employee entity with comprehensive fields
  - Create Employee.java with @Entity annotation for PostgreSQL.
  - Define fields: id, employeeNumber, name, email, phone
  - Add department and position relationships
  - Include hireDate, status, and audit fields
  - Implement validation annotations for all fields
  - _Requirements: 5.1, 5.7_

- [ ] 12.2 Create EmployeeStatus enum and validation
  - Define status values: ACTIVE, INACTIVE, TERMINATED
  - Add status transition validation logic
  - Implement status-based business rules
  - Create status history tracking
  - _Requirements: 5.1_

- [ ] 12.3 Create Flyway migration for employees table
  - Create a new migration script, e.g., V4__Create_employees_table.sql.
  - Define the employees table schema with all comprehensive fields, including encrypted columns for sensitive data (e.g., bank_account_encrypted).
  - Add foreign key constraints for department_id, position_id, and a self-referencing key for manager_id.
  - Create unique constraints on employee_number and email to ensure data integrity.
  - Add indexes on frequently queried fields like last_name, status, department_id, and position_id to boost search performance.
  - _Requirements: 5.1, 10.4_

### Task 13: Employee Repository with Search Capabilities

- [ ] 13.1 Create EmployeeRepository with advanced queries
  - Extend JpaRepository<Employee, Long>
  - Add findByDepartmentId for department filtering
  - Implement findByStatus for status-based queries
  - Create findByEmployeeNumberContaining for search
  - Add pagination support with Pageable parameters
  - _Requirements: 5.1, 5.2, 5.4_

- [ ] 13.2 Implement dynamic search with Specification API
  - Create EmployeeSearchCriteria class
  - Implement dynamic query building
  - Add support for multiple search criteria
  - Create sorting and filtering capabilities
  - Implement full-text search functionality
  - _Requirements: 5.4_

### Task 14: Employee Service Layer

- [ ] 14.1 Implement core EmployeeService operations
  - Create CRUD operations for employee management
  - Add employee number generation and validation
  - Implement employee search with pagination
  - Create batch operations for multiple employees
  - Add employee status management methods
  - _Requirements: 5.1, 5.2, 5.3_

- [ ] 14.2 Create EmployeeImportService for Excel processing
  - Implement Excel file parsing with Apache POI
  - Add data validation for imported employees
  - Create error reporting for invalid data
  - Implement batch import with transaction support
  - Add duplicate detection and handling
  - _Requirements: 5.5, 5.7_

- [ ] 14.3 Implement EmployeeExportService for data export
  - Create Excel export functionality
  - Add customizable export templates
  - Implement filtered export based on criteria
  - Create export scheduling and background processing
  - Add export history and tracking
  - _Requirements: 5.6_

### Task 15: Employee Controller and API Endpoints

- [ ] 15.1 Create EmployeeController with comprehensive REST API
  - Implement GET /api/employees with pagination and search
  - Add POST /api/employees for employee creation
  - Create PUT /api/employees/{id} for updates
  - Implement DELETE /api/employees/{id} with validation
  - Add batch operations endpoints
  - Include proper security and validation
  - _Requirements: 5.1, 5.2, 5.3_

- [ ] 15.2 Add import/export endpoints
  - Create POST /api/employees/import for Excel upload
  - Implement GET /api/employees/export for data export
  - Add GET /api/employees/import/template for template download
  - Create import status tracking endpoints
  - Add export job management
  - _Requirements: 5.5, 5.6, 5.7_## Position Management Module

### Task 16: Position Entity and Repository

- [ ] 16.1 Implement Position entity with job classifications
  - Create Position.java with @Entity annotation for PostgreSQL.
  - Define fields: id, jobTitle, professionalTitle, description
  - Add department relationship and validation
  - Implement position hierarchy if needed
  - Create audit fields and validation rules
  - _Requirements: 4.1, 4.4_

- [ ] 16.2 Create PositionRepository with search capabilities
  - Extend JpaRepository<Position, Long> to leverage JPA-specific features.
  - Add findByDepartmentId for department filtering
  - Implement findByJobTitleContaining for search
  - Create position availability queries
  - Add sorting and pagination support
  - _Requirements: 4.1, 4.2, 4.3_

- [ ] 16.3 Create Flyway migration for positions table
  - Create a new migration script, e.g., V3__Create_positions_table.sql.
  - Define the positions table schema with all required columns (job_title, code, department_id, min_salary, max_salary, etc.).
  - Add a foreign key constraint linking department_id to the departments table.
  - Create indexes on frequently queried columns like department_id, job_title, and category for performance.
  - Add a unique constraint on the position code column to ensure data integrity.
  - _Requirements: 4.1, 10.4_

### Task 17: Position Service and Controller

- [ ] 17.1 Implement PositionService with business logic
  - Create CRUD operations for position management
  - Add position validation and dependency checking
  - Implement position search and filtering
  - Create position assignment tracking
  - Add position statistics and reporting
  - _Requirements: 4.1, 4.2, 4.4, 4.5_

- [ ] 17.2 Create PositionController with REST endpoints
  - Implement GET /api/positions with filtering
  - Add POST /api/positions for creation
  - Create PUT /api/positions/{id} for updates
  - Implement DELETE /api/positions/{id} with validation
  - Add position assignment endpoints
  - Include proper security annotations
  - _Requirements: 4.1, 4.2, 4.3_

## Communication System Module

### Task 18: Email Management Implementation

- [ ] 18.1 Create email entities and templates
  - Implement EmailTemplate.java with template management
  - Create EmailLog.java for tracking sent emails
  - Add template variable support with Freemarker
  - Implement template versioning and validation
  - Create email template repository
  - _Requirements: 6.1, 6.4_

- [ ] 18.2 Implement EmailService with async processing
  - Create sendTemplatedEmail method with @Async
  - Add sendBulkEmails for mass communication
  - Implement email queue management
  - Create email retry logic for failures
  - Add email tracking and status updates
  - _Requirements: 6.1, 6.2, 6.3, 6.5_

- [ ] 18.3 Create EmailController and template management
  - Implement POST /api/emails/send for single emails
  - Add POST /api/emails/bulk for mass emails
  - Create GET /api/email-templates for template management
  - Implement email preview functionality
  - Add email history and tracking endpoints
  - _Requirements: 6.1, 6.4_

### Task 19: Chat System Implementation

- [ ] 19.1 Implement chat entities **for Redis storage**
  - Create `ChatMessage.java` with the **@RedisHash** annotation for real-time message storage.
  - Implement ChatRoom.java for conversation management
  - Add ChatParticipant.java for user participation
  - Create message threading and reply support
  - Implement message status tracking
  - _Requirements: 8.1, 8.6_

- [ ] 19.2 Create ChatService with real-time features
  - Implement message sending and receiving
  - Add chat room management functionality
  - Create message history with pagination
  - Implement message search and filtering
  - Add typing indicators and presence
  - _Requirements: 8.1, 8.6_

- [ ] 19.3 Implement WebSocket configuration for real-time chat
  - Create WebSocketConfig with message broker
  - Add ChatWebSocketHandler for connection management
  - Implement message routing and broadcasting
  - Create user session management
  - Add connection authentication and authorization
  - _Requirements: 8.1, 8.6_
  
### Task 20: Notification System Implementation

- [ ] 20.1 Create notification entities **for persistent storage in PostgreSQL**
  - Implement MessageContent.java for notification content
  - Create SystemMessage.java for user-notification relationships
  - Add notification types and priority levels
  - Implement notification templates and formatting
  - Create notification history and archiving
  - _Requirements: 8.2, 8.3, 8.5_

- [ ] 20.2 Implement NotificationService with **hybrid delivery mechanism**
  - Create createNotification method for system notifications
  - Add getUserNotifications with pagination
  - Implement markAsRead functionality
  - Create notification broadcasting with WebSocket
  - Add notification preferences and filtering
  - _Requirements: 8.2, 8.4, 8.5_

  **note**
  - When a notification is created, the service **must first save it to the PostgreSQL `notifications` table**.
  - **After successful persistence**, the service will then **publish the notification message to a Redis Pub/Sub channel** (e.g., `notifications:{userId}`).
  - WebSocket handlers will subscribe to these Redis channels to push real-time updates to connected clients.
  - Implement `getUserNotifications` to fetch the history from PostgreSQL with pagination.

- [ ] 20.3 Create NotificationController and WebSocket handlers
  - Implement GET /api/notifications for user notifications
  - Add PUT /api/notifications/{id}/read for marking read
  - Create NotificationWebSocketHandler for real-time updates
  - Implement notification subscription management
  - Add notification statistics and reporting
  - _Requirements: 8.4, 8.5_

## Payroll Management Module

### Task 21: Payroll Entities and Calculations

- [ ] 21.1 Implement payroll entities with financial data
  - Create PayrollLedger.java with salary components
  - Implement PayrollPeriod.java for pay period management
  - Add SalaryComponent.java for detailed breakdowns
  - Create PayrollAudit.java for change tracking
  - Implement financial validation and constraints
  - _Requirements: 7.1, 7.4, 7.5_

- [ ] 21.2 Create PayrollCalculationService for salary processing
  - Implement salary calculation algorithms
  - Add tax and deduction calculations
  - Create overtime and bonus processing
  - Implement payroll validation rules
  - Add calculation audit trails
  - _Requirements: 7.4, 7.5_

### Task 22: Payroll Service and Management

- [ ] 22.1 Implement PayrollService with ledger management
  - Create payroll ledger CRUD operations
  - Add payroll period management
  - Implement employee payroll history
  - Create payroll approval workflows
  - Add payroll reporting and analytics
  - _Requirements: 7.1, 7.2, 7.3_

- [ ] 22.2 Create PayrollController with financial endpoints
  - Implement GET /api/payroll/ledgers with filtering
  - Add POST /api/payroll/calculate for salary calculations
  - Create payroll report generation endpoints
  - Implement payroll approval and processing
  - Add payroll audit and history endpoints
  - Include proper financial security measures
  - _Requirements: 7.1, 7.2, 7.3_

## Common Infrastructure and Utilities

### Task 22: Global Exception Handling

- [ ] 22.1 Create custom exception classes
  - Implement BusinessException for business logic errors
  - Create ValidationException for data validation
  - Add feature-specific exceptions (EmployeeNotFoundException, etc.)
  - Implement exception hierarchy and error codes
  - Create exception message internationalization
  - _Requirements: 2.3, 2.5_

- [ ] 22.2 Implement GlobalExceptionHandler
  - Create @ControllerAdvice for centralized exception handling
  - Add @ExceptionHandler methods for different exception types
  - Implement proper HTTP status code mapping
  - Create standardized error response format
  - Add exception logging and monitoring
  - _Requirements: 2.3, 2.4_### Ta
sk 23: Common DTOs and Utilities

- [ ] 23.1 Create common response DTOs
  - Implement ApiResponse<T> for standardized responses
  - Create ErrorResponse for error information
  - Add PageResponse<T> for paginated data
  - Implement validation error response formatting
  - Create success response templates
  - _Requirements: 2.4, 5.2_

- [ ] 23.2 Implement utility classes
  - Create DateUtil for date operations
  - Add StringUtil for string processing
  - Implement ValidationUtil for custom validations
  - Create FileUtil for file operations
  - Add CacheUtil for Redis operations
  - _Requirements: 5.5, 5.6, 6.4_

### Task 24: Configuration and Infrastructure

- [ ] 24.1 Implement Redis configuration
  - Create RedisConfig with connection settings
  - Add Redis template configuration
  - Implement caching configuration with @Cacheable
  - Create Redis key naming strategies
  - Add Redis health checks and monitoring
  - _Requirements: 1.1, 2.2_

- [ ] 24.2 Configure async processing
  - Create AsyncConfig with thread pool settings
  - Implement @EnableAsync configuration
  - Add AsyncUncaughtExceptionHandler
  - Create async method monitoring
  - Configure async security context propagation
  - _Requirements: 6.3, 8.1_

- [ ] 24.3 Set up WebSocket configuration
  - Create WebSocketConfig with STOMP support
  - Configure message broker settings
  - Add WebSocket security configuration
  - Implement connection interceptors
  - Create WebSocket monitoring and logging
  - _Requirements: 8.1, 8.6_

- [ ] 24.4 Configure CORS and security headers
  - Create CorsConfig for frontend integration
  - Add security headers configuration
  - Implement CSRF protection where needed
  - Configure content security policy
  - Add request/response logging
  - _Requirements: 2.1, 2.3_

## Testing Implementation

### Task 25: Unit Testing Setup

- [ ] 25.1 Create test configuration and utilities
  - Set up test application properties
  - Create test data builders and factories
  - Implement test utilities for Redis operations
  - Add mock configuration for external services
  - Create test security configuration
  - _Requirements: 10.1, 10.2_

- [ ] 25.2 Implement repository layer tests
  - Create @DataRedisTest classes for repositories
  - Add test cases for custom query methods
  - Implement pagination and sorting tests
  - Create transaction rollback tests
  - Add performance tests for complex queries
  - _Requirements: 10.1_

### Task 26: Service Layer Testing

- [ ] 26.1 Create service unit tests with Mockito
  - Implement @ExtendWith(MockitoExtension.class) setup
  - Add @Mock and @InjectMocks configurations
  - Create test cases for business logic validation
  - Implement exception handling tests
  - Add async method testing
  - _Requirements: 10.1_

- [ ] 26.2 Create integration tests for services
  - Implement @SpringBootTest configurations
  - Add database integration tests
  - Create email service integration tests
  - Implement WebSocket integration tests
  - Add security integration tests
  - _Requirements: 10.1_#
## Task 27: Controller and API Testing

- [ ] 27.1 Implement controller unit tests
  - Create @WebMvcTest configurations for controllers
  - Add MockMvc setup for HTTP testing
  - Implement request/response validation tests
  - Create security annotation tests with @WithMockUser
  - Add JSON serialization/deserialization tests
  - _Requirements: 10.1_

- [ ] 27.2 Create API integration tests
  - Implement full @SpringBootTest with web environment
  - Add TestRestTemplate for API testing
  - Create end-to-end workflow tests
  - Implement authentication flow tests
  - Add file upload/download tests
  - _Requirements: 10.1_

### Task 28: Performance and Load Testing

- [ ] 28.1 Create performance test suite
  - Implement JMeter test plans for API endpoints
  - Add database performance tests
  - Create concurrent user simulation tests
  - Implement memory usage and leak tests
  - Add Redis cache performance tests
  - _Requirements: 10.1_

- [ ] 28.2 Set up monitoring and metrics
  - Configure Spring Boot Actuator endpoints
  - Add custom metrics for business operations
  - Implement health checks for dependencies
  - Create performance monitoring dashboards
  - Add alerting for performance degradation
  - _Requirements: 10.2_

## Documentation and Deployment

### Task 29: API Documentation

- [ ] 29.1 Implement OpenAPI/Swagger documentation
  - Add Springdoc OpenAPI dependency
  - Create API documentation annotations
  - Implement request/response schema documentation
  - Add authentication documentation
  - Create API usage examples
  - _Requirements: 10.1, 10.2_

- [ ] 29.2 Create developer documentation
  - Write setup and installation guides
  - Create API integration examples
  - Document configuration options
  - Add troubleshooting guides
  - Create architecture documentation
  - _Requirements: 10.1, 10.2, 10.3, 10.4_

### Task 30: Production Deployment Preparation

- [ ] 30.1 Configure production settings
  - Create production application properties
  - Add environment-specific configurations
  - Implement security hardening measures
  - Configure logging for production
  - Add monitoring and alerting setup
  - _Requirements: 2.1, 10.2_

- [ ] 30.2 Create deployment artifacts
  - Build WAR file for deployment
  - Create Docker containerization (optional)
  - Add database migration scripts
  - Create deployment documentation
  - Implement rollback procedures
  - _Requirements: 10.2, 10.5_

## Final Integration and Testing

### Task 31: System Integration Testing

- [ ] 31.1 End-to-end system testing
  - Test complete user workflows
  - Validate security across all modules
  - Test real-time features (chat, notifications)
  - Verify email functionality
  - Test file import/export operations
  - _Requirements: All requirements_

- [ ] 31.2 Performance optimization and tuning
  - Optimize database queries and indexing
  - Tune Redis cache configurations
  - Optimize async processing performance
  - Implement connection pooling tuning
  - Add performance monitoring and alerting
  - _Requirements: 10.2_

### Task 32: Final Documentation and Handover

- [ ] 32.1 Complete system documentation
  - Finalize API documentation
  - Create user guides and tutorials
  - Document deployment procedures
  - Add maintenance and troubleshooting guides
  - Create system architecture documentation
  - _Requirements: 10.1, 10.2, 10.3, 10.4, 10.5_

- [ ] 32.2 Prepare for production deployment
  - Conduct final security review
  - Perform load testing validation
  - Create monitoring and alerting setup
  - Prepare rollback and recovery procedures
  - Document post-deployment verification steps
  - _Requirements: 10.2, 10.5_

## Implementation Notes

### Development Best Practices
- Follow test-driven development (TDD) approach where applicable
- Implement proper logging at all levels (DEBUG, INFO, WARN, ERROR)
- Use transactions appropriately for data consistency
- Implement proper validation at all input points
- Follow Spring Boot conventions and best practices
- Maintain clean code principles and documentation

### Security Considerations
- Validate all inputs and sanitize outputs
- Implement proper authentication and authorization
- Use HTTPS for all communications
- Implement rate limiting for API endpoints
- Log security events for audit purposes
- Regular security testing and vulnerability assessment

### Performance Guidelines
- Implement caching strategies for frequently accessed data
- Use pagination for large datasets
- Optimize database queries and use appropriate indexes
- Implement async processing for long-running operations
- Monitor and optimize memory usage
- Use connection pooling for database connections

This implementation plan provides a comprehensive roadmap for building the Spring Boot Employee Management System backend. Each task builds upon previous implementations and includes specific requirements references to ensure all functionality is properly implemented.
## Phase 
2: Security and Authentication Module

### Task 3: Core Security Entities and Database Schema

- [ ] 3.1 Implement User entity with JPA annotations
  - Create User.java with @Entity annotation
  - Define fields: id, username, password, enabled, roles
  - Add validation annotations (@NotNull, @Size, @Email)
  - Implement audit fields with @CreatedDate, @LastModifiedDate
  - Add password encoding support with BCrypt
  - Create proper JPA relationships with Role entities
  - _Requirements: 1.1, 2.1, 2.2_

- [ ] 3.2 Implement Role entity with resource relationships
  - Create Role.java with @Entity annotation
  - Define fields: id, name, description, resources
  - Implement many-to-many relationship with Resource entities
  - Add validation for role name uniqueness
  - Create proper database constraints and indexes
  - _Requirements: 1.1, 1.2_

- [ ] 3.3 Implement Resource entity for permission management
  - Create Resource.java with @Entity annotation
  - Define fields: id, name, url, method, description
  - Add validation for URL patterns and HTTP methods
  - Implement resource hierarchy support
  - Create composite unique constraints on (url, method)
  - _Requirements: 1.1, 1.4_

- [ ] 3.4 Create Flyway migration scripts for security tables
  - Create V1__Create_security_tables.sql migration script
  - Define users, roles, resources tables with proper constraints
  - Create user_roles and role_resources junction tables
  - Add indexes for performance optimization
  - Include default data insertion for system roles and resources
  - _Requirements: 1.1, 1.3, 10.4_

### Task 4: Security Repository Layer

- [ ] 4.1 Create UserRepository with custom query methods
  - Extend JpaRepository<User, Long>
  - Add findByUsername method with @Query annotation
  - Implement findByEnabledTrue for active users
  - Add existsByUsername for validation
  - Create findUsersWithRoles method using JOIN FETCH
  - _Requirements: 1.2, 2.2_

- [ ] 4.2 Create RoleRepository with permission queries
  - Extend JpaRepository<Role, Long>
  - Add findByName method for role lookup
  - Implement findRolesWithResources method
  - Create custom query for role hierarchy
  - Add caching annotations for frequently accessed roles
  - _Requirements: 1.2, 1.3_

- [ ] 4.3 Create ResourceRepository with URL pattern matching
  - Extend JpaRepository<Resource, Long>
  - Add findByUrlAndMethod for permission checking
  - Implement findResourcesByRoleId method
  - Create pattern matching queries for URL authorization
  - Add caching for resource permissions
  - _Requirements: 1.4, 1.5_

### Task 5: Security Service Layer Implementation

- [ ] 5.1 Implement UserDetailsService for Spring Security
  - Create CustomUserDetailsService implementing UserDetailsService
  - Override loadUserByUsername method with database queries
  - Map User entity to UserDetails with authorities
  - Handle user not found and disabled user scenarios
  - Cache user details in Redis for performance
  - _Requirements: 2.1, 2.2_

- [ ] 5.2 Create AuthenticationService for login/logout
  - Implement authenticate method with password validation
  - Generate JWT tokens upon successful authentication
  - Handle authentication failures with custom exceptions
  - Implement logout functionality with token invalidation
  - Add session management with Redis storage
  - _Requirements: 2.1, 2.2, 2.5_

- [ ] 5.3 Implement UserService for user management
  - Create CRUD operations for user entities
  - Add password encoding and validation
  - Implement user role assignment methods
  - Create user search and pagination functionality
  - Add bulk user operations with transaction support
  - _Requirements: 1.2, 1.3_

- [ ] 5.4 Create PermissionService for authorization
  - Implement hasPermission method for resource access
  - Create role-based permission checking
  - Add dynamic permission loading based on user roles
  - Implement permission caching with Redis
  - Create permission validation utilities
  - _Requirements: 1.4, 1.5_

### Task 6: JWT Token Management and Encryption

- [ ] 6.1 Implement JwtTokenProvider utility class
  - Create JWT token generation with user claims
  - Implement token validation and parsing
  - Add token expiration and refresh logic
  - Create token blacklist functionality with Redis
  - Handle token security with proper signing keys
  - _Requirements: 2.1, 2.2_

- [ ] 6.2 Create JwtAuthenticationFilter for request processing
  - Extend OncePerRequestFilter for JWT processing
  - Extract and validate JWT tokens from requests
  - Set SecurityContext with authenticated user
  - Handle token expiration and invalid token scenarios
  - Implement proper error responses for authentication failures
  - _Requirements: 2.1, 2.5_

- [ ] 6.3 Implement field-level encryption for sensitive data
  - Create AESUtil class for encryption/decryption operations
  - Implement EncryptedStringConverter for JPA attribute conversion
  - Add encryption configuration with secure key management
  - Apply encryption to sensitive fields (dateOfBirth, bankAccount, taxId)
  - Create encryption service for manual encrypt/decrypt operations
  - _Requirements: 2.3, 10.3_

### Task 7: Security Configuration and Audit

- [ ] 7.1 Implement SecurityConfig with filter chain
  - Create SecurityFilterChain bean with HTTP security
  - Configure JWT authentication filter in security chain
  - Set up CORS configuration for frontend integration
  - Disable CSRF for stateless JWT authentication
  - Configure session management as stateless
  - _Requirements: 2.1, 2.3_

- [ ] 7.2 Configure method-level security and audit
  - Enable @PreAuthorize and @PostAuthorize annotations
  - Create custom security expressions for permission checking
  - Implement role-based method security
  - Add audit logging for security events
  - Create AuditorAware implementation for automatic audit field population
  - _Requirements: 1.4, 1.5, 2.6_

### Task 8: Security Controllers and DTOs

- [ ] 8.1 Create AuthController for authentication endpoints
  - Implement POST /api/auth/login endpoint
  - Add POST /api/auth/logout endpoint
  - Create POST /api/auth/refresh-token endpoint
  - Implement proper request/response DTOs
  - Add comprehensive error handling and validation
  - Include OpenAPI/Swagger documentation
  - _Requirements: 2.1, 2.2_

- [ ] 8.2 Implement UserController for user management
  - Create GET /api/users endpoint with pagination
  - Add POST /api/users for user creation
  - Implement PUT /api/users/{id} for user updates
  - Create DELETE /api/users/{id} with validation
  - Add GET /api/users/{id}/roles for role management
  - Include @PreAuthorize annotations for security
  - _Requirements: 1.2, 1.3_

- [ ] 8.3 Create security-related DTOs
  - Implement LoginRequest with validation annotations
  - Create LoginResponse with token and user info
  - Add UserDto for user data transfer
  - Create RoleDto and ResourceDto classes
  - Implement proper validation and error messages
  - _Requirements: 2.1, 1.2_## Phase 3:
 Department Management Module

### Task 9: Department Entity and Repository

- [ ] 9.1 Implement Department entity with hierarchical structure
  - Create Department.java with @Entity annotation
  - Define fields: id, name, code, depPath, parentId, isParent, location, managerId
  - Implement self-referencing relationship for hierarchy
  - Add validation for department name and path
  - Create audit fields for tracking changes
  - Add proper indexes for hierarchical queries
  - _Requirements: 3.1, 3.4, 3.5, 3.6_

- [ ] 9.2 Create DepartmentRepository with tree queries
  - Extend JpaRepository<Department, Long>
  - Add findByParentId method for child departments
  - Implement findRootDepartments for top-level departments
  - Create recursive query methods for department tree using PostgreSQL CTEs
  - Add findByDepPathStartingWith for path-based queries
  - Implement caching for department tree structure
  - _Requirements: 3.1, 3.3, 3.4_

- [ ] 9.3 Create Flyway migration for departments table
  - Create V2__Create_departments_table.sql migration script
  - Define departments table with hierarchical constraints
  - Add foreign key constraints for parent-child relationships
  - Create indexes for efficient tree queries
  - Add check constraints for data integrity
  - _Requirements: 3.1, 10.4_

### Task 10: Department Service Implementation

- [ ] 10.1 Implement DepartmentService with tree operations
  - Create getDepartmentTree method with recursive loading
  - Implement createDepartment with path generation
  - Add updateDepartment with hierarchy validation
  - Create deleteDepartment with dependency checking
  - Implement department move operations with path recalculation
  - Add caching for frequently accessed department data
  - _Requirements: 3.1, 3.2, 3.4, 3.5, 3.6, 3.7_

- [ ] 10.2 Add department validation and business logic
  - Validate department hierarchy constraints
  - Prevent circular references in department tree
  - Check for existing employees before deletion
  - Implement department path recalculation
  - Add department statistics and reporting
  - Validate manager assignment (must be an employee)
  - _Requirements: 3.4, 3.5, 3.6, 3.7_

### Task 11: Department Controller and DTOs

- [ ] 11.1 Create DepartmentController with REST endpoints
  - Implement GET /api/departments/tree for hierarchy
  - Add POST /api/departments for creation
  - Create PUT /api/departments/{id} for updates
  - Implement DELETE /api/departments/{id} with validation
  - Add GET /api/departments/{id}/employees endpoint
  - Include proper security annotations and permission checks
  - _Requirements: 3.1, 3.2, 3.6_

- [ ] 11.2 Implement department DTOs and validation
  - Create DepartmentDto for data transfer
  - Add DepartmentTreeDto for hierarchical display
  - Implement DepartmentCreateRequest with validation
  - Create DepartmentUpdateRequest class
  - Add custom validation for department hierarchy
  - Include manager assignment validation
  - _Requirements: 3.1, 3.2, 3.6_## Phase 4
: Position Management Module

### Task 12: Position Entity and Repository

- [ ] 12.1 Implement Position entity with comprehensive fields
  - Create Position.java with @Entity annotation
  - Define fields: id, jobTitle, professionalTitle, code, category, salaryGrade
  - Add detailed fields: requirements, responsibilities, benefits, workLocation
  - Include salary range fields (minSalary, maxSalary)
  - Add employment type and managerial status fields
  - Create proper relationships with Department entity
  - _Requirements: 4.1, 4.4_

- [ ] 12.2 Create PositionRepository with search capabilities
  - Extend JpaRepository<Position, Long>
  - Add findByDepartmentId for department filtering
  - Implement findByJobTitleContaining for search
  - Create position availability queries
  - Add sorting and pagination support
  - Implement caching for frequently accessed positions
  - _Requirements: 4.1, 4.2, 4.3_

- [ ] 12.3 Create Flyway migration for positions table
  - Create V3__Create_positions_table.sql migration script
  - Define positions table with all required fields
  - Add foreign key constraints to departments
  - Create indexes for search and filtering
  - Add unique constraints on position codes
  - _Requirements: 4.1, 10.4_

### Task 13: Position Service and Controller

- [ ] 13.1 Implement PositionService with business logic
  - Create CRUD operations for position management
  - Add position validation and dependency checking
  - Implement position search and filtering
  - Create position assignment tracking
  - Add position statistics and reporting
  - Validate salary ranges and employment types
  - _Requirements: 4.1, 4.2, 4.4, 4.5_

- [ ] 13.2 Create PositionController with REST endpoints
  - Implement GET /api/positions with filtering
  - Add POST /api/positions for creation
  - Create PUT /api/positions/{id} for updates
  - Implement DELETE /api/positions/{id} with validation
  - Add position assignment endpoints
  - Include proper security annotations
  - _Requirements: 4.1, 4.2, 4.3_

## Phase 5: Employee Management Module

### Task 14: Employee Entity and Status Management

- [ ] 14.1 Implement Employee entity with comprehensive fields
  - Create Employee.java with @Entity annotation
  - Define core fields: id, employeeNumber, firstName, lastName, email
  - Add contact fields: phone, mobilePhone, address details (city, state, zipCode)
  - Include personal fields: dateOfBirth, gender, nationality, maritalStatus
  - Add employment fields: departmentId, positionId, managerId, hireDate, status
  - Include payroll fields: salary, salaryGrade, bankAccount, taxId (encrypted)
  - Add skills, education, certifications, and notes fields
  - Create emergency contact fields
  - _Requirements: 5.1, 5.7, 10.3_

- [ ] 14.2 Create EmployeeStatus enum and validation
  - Define status values: ACTIVE, INACTIVE, TERMINATED, ON_LEAVE, SUSPENDED
  - Add status transition validation logic
  - Implement status-based business rules
  - Create status history tracking
  - Add proper enum mapping for database storage
  - _Requirements: 5.1_

- [ ] 14.3 Create Flyway migration for employees table
  - Create V4__Create_employees_table.sql migration script
  - Define employees table with all comprehensive fields
  - Add foreign key constraints to departments, positions, and self-reference for manager
  - Create indexes for search, filtering, and relationships
  - Add unique constraints on employee number and email
  - _Requirements: 5.1, 10.4_

### Task 15: Employee Repository with Advanced Search

- [ ] 15.1 Create EmployeeRepository with advanced queries
  - Extend JpaRepository<Employee, Long>
  - Add findByDepartmentId for department filtering
  - Implement findByStatus for status-based queries
  - Create findByEmployeeNumberContaining for search
  - Add pagination support with Pageable parameters
  - Implement permission-based filtering queries
  - _Requirements: 5.1, 5.2, 5.4, 10.8_

- [ ] 15.2 Implement dynamic search with Specification API
  - Create EmployeeSearchCriteria class with all search fields
  - Implement EmployeeSpecification for dynamic query building
  - Add support for multiple search criteria combination
  - Create sorting and filtering capabilities
  - Implement full-text search functionality
  - Add date range searches for hire dates
  - _Requirements: 5.4_

### Task 16: Employee Service Layer

- [ ] 16.1 Implement core EmployeeService operations
  - Create CRUD operations for employee management
  - Add employee number generation and validation
  - Implement employee search with pagination and criteria
  - Create batch operations for multiple employees
  - Add employee status management methods
  - Implement permission-based data filtering
  - _Requirements: 5.1, 5.2, 5.3, 10.8_

- [ ] 16.2 Create EmployeeImportService for Excel processing
  - Implement Excel file parsing with Apache POI
  - Add data validation for imported employees
  - Create error reporting for invalid data
  - Implement batch import with transaction support
  - Add duplicate detection and handling
  - Create import progress tracking
  - _Requirements: 5.5, 5.7_

- [ ] 16.3 Implement EmployeeExportService for data export
  - Create Excel export functionality
  - Add customizable export templates
  - Implement filtered export based on criteria
  - Create export scheduling and background processing
  - Add export history and tracking
  - Implement permission-based export filtering
  - _Requirements: 5.6, 10.8_

### Task 17: Employee Controller and API Endpoints

- [ ] 17.1 Create EmployeeController with comprehensive REST API
  - Implement GET /api/employees with pagination and search
  - Add POST /api/employees for employee creation
  - Create PUT /api/employees/{id} for updates
  - Implement DELETE /api/employees/{id} with validation
  - Add batch operations endpoints
  - Include proper security and validation
  - _Requirements: 5.1, 5.2, 5.3_

- [ ] 17.2 Add import/export endpoints
  - Create POST /api/employees/import for Excel upload
  - Implement GET /api/employees/export for data export
  - Add GET /api/employees/import/template for template download
  - Create import status tracking endpoints
  - Add export job management
  - Include permission-based access control
  - _Requirements: 5.5, 5.6, 5.7, 10.8_## Phase 6:
 Communication System Module

### Task 18: Email Management Implementation

- [ ] 18.1 Create email entities and templates
  - Implement EmailTemplate.java with unified content field and templateType enum
  - Create EmailLog.java with templateCode reference and multiple recipient fields
  - Add template variable support with Freemarker
  - Implement template versioning and validation
  - Create proper JPA relationships and constraints
  - _Requirements: 6.1, 6.4_

- [ ] 18.2 Create Flyway migration for email tables
  - Create V5__Create_email_tables.sql migration script
  - Define email_templates and email_logs tables
  - Add indexes for efficient querying
  - Create constraints for data integrity
  - Add default email templates
  - _Requirements: 6.1, 10.4_

- [ ] 18.3 Implement EmailService with async processing
  - Create sendTemplatedEmail method with @Async
  - Add sendBulkEmails for mass communication
  - Implement email queue management
  - Create email retry logic for failures
  - Add email tracking and status updates
  - Implement template processing with Freemarker
  - _Requirements: 6.1, 6.2, 6.3, 6.5_

- [ ] 18.4 Create EmailController and template management
  - Implement POST /api/emails/send for single emails
  - Add POST /api/emails/bulk for mass emails
  - Create GET /api/email-templates for template management
  - Implement email preview functionality
  - Add email history and tracking endpoints
  - Include proper security and permission checks
  - _Requirements: 6.1, 6.4_

### Task 19: Chat System Implementation

- [ ] 19.1 Implement chat entities for Redis storage
  - Create ChatMessage.java with consistent field naming (createdAt, isDeleted)
  - Implement ChatRoom.java for conversation management
  - Add ChatParticipant.java for user participation
  - Create message threading and reply support
  - Implement message status tracking and read receipts
  - Add attachment support with metadata
  - _Requirements: 8.1, 8.6_

- [ ] 19.2 Create ChatService with real-time features
  - Implement message sending and receiving
  - Add chat room management functionality
  - Create message history with pagination
  - Implement message search and filtering
  - Add typing indicators and presence
  - Create message archiving for historical data
  - _Requirements: 8.1, 8.6_

- [ ] 19.3 Implement WebSocket configuration for real-time chat
  - Create WebSocketConfig with message broker
  - Add ChatWebSocketHandler for connection management
  - Implement message routing and broadcasting
  - Create user session management
  - Add connection authentication and authorization
  - Implement connection recovery and reconnection
  - _Requirements: 8.1, 8.6_

### Task 20: Notification System Implementation

- [ ] 20.1 Create notification entities and management
  - Implement `Notification.java` entity for the `notifications` table (as defined in `design.md`), to be stored persistently in PostgreSQL. This entity should include fields like `user_id`, `title`, `content`, `type`, `is_read`, `read_at`, etc.
  - Create SystemMessage.java for user-notification relationships (PostgreSQL)
  - Add notification types and priority levels
  - Implement notification templates and formatting
  - Create notification history and archiving
  - Add notification preferences and filtering
  - _Requirements: 8.2, 8.3, 8.5_

- [ ] 20.2 Create Flyway migration for notification tables
  - Create V6__Create_notification_tables.sql migration script
  - Define msgcontent and sysmsg tables
  - Add indexes for efficient querying
  - Create constraints for data integrity
  - Add notification type and priority enums
  - _Requirements: 8.2, 10.4_

- [ ] 20.3 Implement NotificationService with real-time delivery
  - Create createNotification method for system notifications
  - Add getUserNotifications with pagination
  - Implement markAsRead functionality
  - Create notification broadcasting with WebSocket
  - Add notification preferences and filtering
  - Implement notification cleanup and archiving
  - _Requirements: 8.2, 8.4, 8.5_

- [ ] 20.4 Create NotificationController and WebSocket handlers
  - Implement GET /api/notifications for user notifications
  - Add PUT /api/notifications/{id}/read for marking read
  - Create NotificationWebSocketHandler for real-time updates
  - Implement notification subscription management
  - Add notification statistics and reporting
  - Include proper security and permission checks
  - _Requirements: 8.4, 8.5_

## Phase 7: Payroll Management Module

### Task 21: Payroll Entities and Calculations

- [ ] 21.1 Implement payroll entities with financial data
  - Create PayrollLedger.java with comprehensive salary components
  - Implement PayrollPeriod.java for pay period management
  - Add SalaryComponent.java for detailed breakdowns
  - Create PayrollAudit.java for change tracking
  - Implement financial validation and constraints
  - Add proper decimal precision for monetary fields
  - _Requirements: 7.1, 7.4, 7.5_

- [ ] 21.2 Create Flyway migration for payroll tables
  - Create V7__Create_payroll_tables.sql migration script
  - Define payroll_ledgers, pay_periods, salary_components tables
  - Add foreign key constraints to employees
  - Create indexes for efficient querying
  - Add check constraints for financial data integrity
  - _Requirements: 7.1, 10.4_

- [ ] 21.3 Create PayrollCalculationService for salary processing
  - Implement salary calculation algorithms
  - Add tax and deduction calculations
  - Create overtime and bonus processing
  - Implement payroll validation rules
  - Add calculation audit trails
  - Create snapshot functionality for historical accuracy
  - _Requirements: 7.4, 7.5_

### Task 22: Payroll Service and Management

- [ ] 22.1 Implement PayrollService with ledger management
  - Create payroll ledger CRUD operations
  - Add payroll period management
  - Implement employee payroll history
  - Create payroll approval workflows
  - Add payroll reporting and analytics
  - Implement data snapshot preservation for historical records
  - _Requirements: 7.1, 7.2, 7.3_

- [ ] 22.2 Create PayrollController with financial endpoints
  - Implement GET /api/payroll/ledgers with filtering
  - Add POST /api/payroll/calculate for salary calculations
  - Create payroll report generation endpoints
  - Implement payroll approval and processing
  - Add payroll audit and history endpoints
  - Include proper financial security measures and permissions
  - _Requirements: 7.1, 7.2, 7.3_#
# Phase 8: Common Infrastructure and Utilities

### Task 23: Global Exception Handling

- [ ] 23.1 Create custom exception classes
  - Implement BusinessException for business logic errors
  - Create ValidationException for data validation
  - Add feature-specific exceptions (EmployeeNotFoundException, etc.)
  - Implement exception hierarchy and error codes
  - Create exception message internationalization
  - _Requirements: 2.3, 2.5_

- [ ] 23.2 Implement GlobalExceptionHandler
  - Create @ControllerAdvice for centralized exception handling
  - Add @ExceptionHandler methods for different exception types
  - Implement proper HTTP status code mapping
  - Create standardized error response format
  - Add exception logging and monitoring
  - Handle security exceptions without exposing sensitive information
  - _Requirements: 2.3, 2.4, 2.8_

### Task 24: Common DTOs and Utilities

- [ ] 24.1 Create common response DTOs
  - Implement ApiResponse<T> for standardized responses
  - Create ErrorResponse for error information
  - Add PageResponse<T> for paginated data
  - Implement validation error response formatting
  - Create success response templates
  - _Requirements: 2.4, 5.2_

- [ ] 24.2 Implement utility classes
  - Create DateUtil for date operations
  - Add StringUtil for string processing
  - Implement ValidationUtil for custom validations
  - Create FileUtil for file operations
  - Add CacheUtil for Redis operations
  - Create EncryptionUtil for field-level encryption
  - _Requirements: 5.5, 5.6, 6.4, 10.3_

### Task 25: Configuration and Infrastructure

- [ ] 25.1 Implement caching configuration
  - Create CacheConfig with Redis cache manager
  - Add cache configurations for different data types
  - Implement cache key naming strategies
  - Create cache eviction policies
  - Add cache monitoring and metrics
  - _Requirements: 1.1, 2.2, 10.2_

- [ ] 25.2 Configure async processing
  - Create AsyncConfig with thread pool settings
  - Implement @EnableAsync configuration
  - Add AsyncUncaughtExceptionHandler
  - Create async method monitoring
  - Configure async security context propagation
  - _Requirements: 6.3, 8.1_

- [ ] 25.3 Set up WebSocket configuration
  - Create WebSocketConfig with STOMP support
  - Configure message broker settings
  - Add WebSocket security configuration
  - Implement connection interceptors
  - Create WebSocket monitoring and logging
  - _Requirements: 8.1, 8.6_

- [ ] 25.4 Configure CORS and security headers
  - Create CorsConfig for frontend integration
  - Add security headers configuration
  - Implement CSRF protection where needed
  - Configure content security policy
  - Add request/response logging
  - _Requirements: 2.1, 2.3_

## Phase 9: Testing Implementation

### Task 26: Unit Testing Setup

- [ ] 26.1 Create test configuration and utilities
  - Set up test application properties
  - Create test data builders and factories
  - Implement test utilities for database operations
  - Add mock configuration for external services
  - Create test security configuration
  - _Requirements: 10.1, 10.2_

- [ ] 26.2 Implement repository layer tests
  - Create @DataJpaTest classes for repositories
  - Create separate @DataRedisTest classes for Redis-specific repositories
  - Add test cases for custom query methods
  - Implement pagination and sorting tests
  - Create transaction rollback tests
  - Add performance tests for complex queries
  - Test encryption/decryption functionality
  - _Requirements: 10.1, 10.3_

### Task 27: Service Layer Testing

- [ ] 27.1 Create service unit tests with Mockito
  - Implement @ExtendWith(MockitoExtension.class) setup
  - Add @Mock and @InjectMocks configurations
  - Create test cases for business logic validation
  - Implement exception handling tests
  - Add async method testing
  - Test security and permission enforcement
  - _Requirements: 10.1_

- [ ] 27.2 Create integration tests for services
  - Implement @SpringBootTest configurations
  - Add database integration tests
  - Create email service integration tests
  - Implement WebSocket integration tests
  - Add security integration tests
  - Test cross-module interactions
  - _Requirements: 10.1_

### Task 28: Controller and API Testing

- [ ] 28.1 Implement controller unit tests
  - Create @WebMvcTest configurations for controllers
  - Add MockMvc setup for HTTP testing
  - Implement request/response validation tests
  - Create security annotation tests with @WithMockUser
  - Add JSON serialization/deserialization tests
  - Test permission-based access control
  - _Requirements: 10.1_

- [ ] 28.2 Create API integration tests
  - Implement full @SpringBootTest with web environment
  - Add TestRestTemplate for API testing
  - Create end-to-end workflow tests
  - Implement authentication flow tests
  - Add file upload/download tests
  - Test real-time features (WebSocket)
  - _Requirements: 10.1_

### Task 29: Performance and Load Testing

- [ ] 29.1 Create performance test suite
  - Implement JMeter test plans for API endpoints
  - Add database performance tests
  - Create concurrent user simulation tests
  - Implement memory usage and leak tests
  - Add Redis cache performance tests
  - Test encryption/decryption performance
  - _Requirements: 10.1, 10.2_

- [ ] 29.2 Set up monitoring and metrics
  - Configure Spring Boot Actuator endpoints
  - Add custom metrics for business operations
  - Implement health checks for dependencies
  - Create performance monitoring dashboards
  - Add alerting for performance degradation
  - Monitor security events and audit trails
  - _Requirements: 10.2_

## Phase 10: Documentation and Deployment

### Task 30: API Documentation

- [ ] 30.1 Implement OpenAPI/Swagger documentation
  - Add Springdoc OpenAPI dependency
  - Create API documentation annotations
  - Implement request/response schema documentation
  - Add authentication documentation
  - Create API usage examples
  - Document security requirements and permissions
  - _Requirements: 11.1, 11.2_

- [ ] 30.2 Create developer documentation
  - Write setup and installation guides
  - Create API integration examples
  - Document configuration options
  - Add troubleshooting guides
  - Create architecture documentation
  - Document security and encryption procedures
  - _Requirements: 11.1, 11.2, 11.3, 11.4_

### Task 31: Production Deployment Preparation

- [ ] 31.1 Configure production settings
  - Create production application properties
  - Add environment-specific configurations
  - Implement security hardening measures
  - Configure logging for production
  - Add monitoring and alerting setup
  - Configure database connection pooling
  - _Requirements: 2.1, 10.2, 10.7_

- [ ] 31.2 Create deployment artifacts
  - Build executable JAR file for deployment
  - Create Docker containerization (optional)
  - Add database migration scripts
  - Create deployment documentation
  - Implement rollback procedures
  - Set up backup and recovery procedures
  - _Requirements: 10.2, 10.5, 10.7_

## Phase 11: Final Integration and Testing

### Task 32: System Integration Testing

- [ ] 32.1 End-to-end system testing
  - Test complete user workflows
  - Validate security across all modules
  - Test real-time features (chat, notifications)
  - Verify email functionality
  - Test file import/export operations
  - Validate encryption and audit trails
  - _Requirements: All requirements_

- [ ] 32.2 Performance optimization and tuning
  - Optimize database queries and indexing
  - Tune Redis cache configurations
  - Optimize async processing performance
  - Implement connection pooling tuning
  - Add performance monitoring and alerting
  - Optimize encryption operations
  - _Requirements: 10.2_

### Task 33: Final Documentation and Handover

- [ ] 33.1 Complete system documentation
  - Finalize API documentation
  - Create user guides and tutorials
  - Document deployment procedures
  - Add maintenance and troubleshooting guides
  - Create system architecture documentation
  - Document security procedures and compliance measures
  - _Requirements: 11.1, 11.2, 11.3, 11.4, 11.5_

- [ ] 33.2 Prepare for production deployment
  - Conduct final security review
  - Perform load testing validation
  - Create monitoring and alerting setup
  - Prepare rollback and disaster recovery procedures
  - Conduct compliance audit for data protection
  - Create operational runbooks
  - _Requirements: 10.2, 10.3, 10.7_

## Summary

This comprehensive implementation plan addresses all conflicts identified in the conflict analysis:

1. **Hybrid Architecture**: Uses PostgreSQL for persistent data and Redis for caching/real-time features
2. **Entity Field Reconciliation**: Includes all missing fields identified in the conflict analysis
3. **Security & Compliance**: Implements field-level encryption and comprehensive audit trails
4. **Consistent Naming**: Standardizes field names across all entities
5. **Modern Deployment**: Uses executable JAR instead of WAR packaging
6. **Permission-Based Access**: Implements fine-grained, ownership-based permissions
7. **Data Integrity**: Ensures proper referential integrity and transaction boundaries

The plan provides 33 major tasks with 66 sub-tasks, each referencing specific requirements and focusing exclusively on coding activities that can be executed by a development team.
</file>

</files>
