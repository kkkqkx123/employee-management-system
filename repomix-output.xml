This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
.kiro/specs/react-frontend/design.md
.kiro/specs/react-frontend/requirements.md
.kiro/specs/spring-backend/communication-implementation.md
.kiro/specs/spring-backend/database-design.md
.kiro/specs/spring-backend/department-implementation.md
.kiro/specs/spring-backend/design.md
.kiro/specs/spring-backend/employee-implementation.md
.kiro/specs/spring-backend/payroll-implementation.md
.kiro/specs/spring-backend/position-implementation.md
.kiro/specs/spring-backend/requirements.md
.kiro/specs/spring-backend/security-implementation.md
.kiro/specs/spring-backend/tasks.md
.kiro/steering/frontend-guidelines.md
.kiro/steering/product.md
.kiro/steering/structure.md
.kiro/steering/tech.md
design.md
LOMBOK_COMPATIBILITY_SOLUTION.md
pom.xml
README.md
src/main/java/com/example/demo/common/dto/ApiResponse.java
src/main/java/com/example/demo/common/dto/ErrorResponse.java
src/main/java/com/example/demo/common/dto/PageResponse.java
src/main/java/com/example/demo/common/exception/BusinessException.java
src/main/java/com/example/demo/common/exception/GlobalExceptionHandler.java
src/main/java/com/example/demo/common/exception/ValidationException.java
src/main/java/com/example/demo/common/README.md
src/main/java/com/example/demo/common/util/CacheUtil.java
src/main/java/com/example/demo/common/util/DateUtil.java
src/main/java/com/example/demo/common/util/FileUtil.java
src/main/java/com/example/demo/common/util/StringUtil.java
src/main/java/com/example/demo/common/util/ValidationUtil.java
src/main/java/com/example/demo/communication/announcement/controller/AnnouncementController.java
src/main/java/com/example/demo/communication/announcement/dto/AnnouncementCreateRequest.java
src/main/java/com/example/demo/communication/announcement/dto/AnnouncementDto.java
src/main/java/com/example/demo/communication/announcement/dto/AnnouncementStatisticsDto.java
src/main/java/com/example/demo/communication/announcement/dto/AnnouncementUpdateRequest.java
src/main/java/com/example/demo/communication/announcement/entity/Announcement.java
src/main/java/com/example/demo/communication/announcement/entity/AnnouncementTarget.java
src/main/java/com/example/demo/communication/announcement/repository/AnnouncementRepository.java
src/main/java/com/example/demo/communication/announcement/service/AnnouncementScheduledService.java
src/main/java/com/example/demo/communication/announcement/service/AnnouncementService.java
src/main/java/com/example/demo/communication/announcement/service/AnnouncementValidationService.java
src/main/java/com/example/demo/communication/announcement/service/impl/AnnouncementServiceImpl.java
src/main/java/com/example/demo/communication/chat/controller/ChatController.java
src/main/java/com/example/demo/communication/chat/dto/ChatMessageDto.java
src/main/java/com/example/demo/communication/chat/dto/ChatParticipantDto.java
src/main/java/com/example/demo/communication/chat/dto/ChatRoomDto.java
src/main/java/com/example/demo/communication/chat/dto/CreateChatRoomRequest.java
src/main/java/com/example/demo/communication/chat/dto/SendMessageRequest.java
src/main/java/com/example/demo/communication/chat/entity/ChatMessage.java
src/main/java/com/example/demo/communication/chat/entity/ChatMessageType.java
src/main/java/com/example/demo/communication/chat/entity/ChatParticipant.java
src/main/java/com/example/demo/communication/chat/entity/ChatParticipantRole.java
src/main/java/com/example/demo/communication/chat/entity/ChatRoom.java
src/main/java/com/example/demo/communication/chat/entity/ChatRoomType.java
src/main/java/com/example/demo/communication/chat/repository/ChatMessageRepository.java
src/main/java/com/example/demo/communication/chat/repository/ChatParticipantRepository.java
src/main/java/com/example/demo/communication/chat/repository/ChatRoomRepository.java
src/main/java/com/example/demo/communication/chat/service/ChatService.java
src/main/java/com/example/demo/communication/chat/service/impl/ChatServiceImpl.java
src/main/java/com/example/demo/communication/chat/websocket/ChatWebSocketHandler.java
src/main/java/com/example/demo/communication/chat/websocket/WebSocketConfig.java
src/main/java/com/example/demo/communication/email/dto/BulkEmailRequest.java
src/main/java/com/example/demo/communication/email/dto/EmailLogDto.java
src/main/java/com/example/demo/communication/email/dto/EmailRequest.java
src/main/java/com/example/demo/communication/email/dto/EmailStatisticsDto.java
src/main/java/com/example/demo/communication/email/dto/EmailTemplateDto.java
src/main/java/com/example/demo/communication/email/entity/EmailLog.java
src/main/java/com/example/demo/communication/email/entity/EmailPriority.java
src/main/java/com/example/demo/communication/email/entity/EmailStatus.java
src/main/java/com/example/demo/communication/email/entity/EmailTemplate.java
src/main/java/com/example/demo/communication/email/entity/TemplateCategory.java
src/main/java/com/example/demo/communication/email/entity/TemplateType.java
src/main/java/com/example/demo/communication/email/exception/EmailLogNotFoundException.java
src/main/java/com/example/demo/communication/email/exception/EmailSendingException.java
src/main/java/com/example/demo/communication/email/exception/TemplateNotFoundException.java
src/main/java/com/example/demo/communication/email/repository/EmailLogRepository.java
src/main/java/com/example/demo/communication/email/repository/EmailTemplateRepository.java
src/main/java/com/example/demo/communication/email/service/EmailService.java
src/main/java/com/example/demo/communication/email/service/EmailTemplateService.java
src/main/java/com/example/demo/communication/email/service/impl/EmailServiceImpl.java
src/main/java/com/example/demo/communication/email/service/impl/EmailTemplateServiceImpl.java
src/main/java/com/example/demo/communication/email/util/EmailTemplateProcessor.java
src/main/java/com/example/demo/communication/exception/AnnouncementNotFoundException.java
src/main/java/com/example/demo/communication/exception/ChatMessageNotFoundException.java
src/main/java/com/example/demo/communication/exception/ChatRoomNotFoundException.java
src/main/java/com/example/demo/communication/exception/NotificationException.java
src/main/java/com/example/demo/communication/notification/controller/NotificationController.java
src/main/java/com/example/demo/communication/notification/dto/NotificationCreateRequest.java
src/main/java/com/example/demo/communication/notification/dto/NotificationDto.java
src/main/java/com/example/demo/communication/notification/dto/NotificationMarkReadRequest.java
src/main/java/com/example/demo/communication/notification/entity/Notification.java
src/main/java/com/example/demo/communication/notification/entity/NotificationPriority.java
src/main/java/com/example/demo/communication/notification/entity/NotificationType.java
src/main/java/com/example/demo/communication/notification/repository/NotificationRepository.java
src/main/java/com/example/demo/communication/notification/service/impl/NotificationServiceImpl.java
src/main/java/com/example/demo/communication/notification/service/NotificationService.java
src/main/java/com/example/demo/communication/notification/websocket/NotificationWebSocketHandler.java
src/main/java/com/example/demo/config/AsyncConfig.java
src/main/java/com/example/demo/config/CorsConfig.java
src/main/java/com/example/demo/config/CsrfConfig.java
src/main/java/com/example/demo/config/FlywayConfig.java
src/main/java/com/example/demo/config/JpaConfig.java
src/main/java/com/example/demo/config/RedisConfig.java
src/main/java/com/example/demo/config/RequestResponseLoggingConfig.java
src/main/java/com/example/demo/config/SecurityHeadersConfig.java
src/main/java/com/example/demo/DemoApplication.java
src/main/java/com/example/demo/department/controller/DepartmentController.java
src/main/java/com/example/demo/department/dto/DepartmentCreateRequest.java
src/main/java/com/example/demo/department/dto/DepartmentDto.java
src/main/java/com/example/demo/department/dto/DepartmentStatisticsDto.java
src/main/java/com/example/demo/department/dto/DepartmentTreeDto.java
src/main/java/com/example/demo/department/dto/DepartmentUpdateRequest.java
src/main/java/com/example/demo/department/entity/Department.java
src/main/java/com/example/demo/department/exception/DepartmentAlreadyExistsException.java
src/main/java/com/example/demo/department/exception/DepartmentHierarchyException.java
src/main/java/com/example/demo/department/exception/DepartmentInUseException.java
src/main/java/com/example/demo/department/exception/DepartmentNotFoundException.java
src/main/java/com/example/demo/department/README.md
src/main/java/com/example/demo/department/repository/DepartmentRepository.java
src/main/java/com/example/demo/department/service/DepartmentService.java
src/main/java/com/example/demo/department/service/impl/DepartmentServiceImpl.java
src/main/java/com/example/demo/employee/controller/EmployeeController.java
src/main/java/com/example/demo/employee/dto/EmployeeCreateRequest.java
src/main/java/com/example/demo/employee/dto/EmployeeDto.java
src/main/java/com/example/demo/employee/dto/EmployeeExportRequest.java
src/main/java/com/example/demo/employee/dto/EmployeeImportResult.java
src/main/java/com/example/demo/employee/dto/EmployeeSearchCriteria.java
src/main/java/com/example/demo/employee/dto/EmployeeUpdateRequest.java
src/main/java/com/example/demo/employee/entity/Employee.java
src/main/java/com/example/demo/employee/entity/EmployeeStatus.java
src/main/java/com/example/demo/employee/entity/EmploymentType.java
src/main/java/com/example/demo/employee/entity/Gender.java
src/main/java/com/example/demo/employee/entity/MaritalStatus.java
src/main/java/com/example/demo/employee/entity/PayType.java
src/main/java/com/example/demo/employee/exception/EmployeeAlreadyExistsException.java
src/main/java/com/example/demo/employee/exception/EmployeeExportException.java
src/main/java/com/example/demo/employee/exception/EmployeeImportException.java
src/main/java/com/example/demo/employee/exception/EmployeeNotFoundException.java
src/main/java/com/example/demo/employee/repository/EmployeeRepository.java
src/main/java/com/example/demo/employee/service/EmployeeExportService.java
src/main/java/com/example/demo/employee/service/EmployeeImportService.java
src/main/java/com/example/demo/employee/service/EmployeeService.java
src/main/java/com/example/demo/employee/service/impl/EmployeeServiceImpl.java
src/main/java/com/example/demo/employee/util/EmployeeExcelUtil.java
src/main/java/com/example/demo/employee/util/EmployeeValidationUtil.java
src/main/java/com/example/demo/payroll/controller/PayrollController.java
src/main/java/com/example/demo/payroll/dto/PayrollCalculationRequest.java
src/main/java/com/example/demo/payroll/dto/PayrollLedgerComponentDto.java
src/main/java/com/example/demo/payroll/dto/PayrollLedgerDto.java
src/main/java/com/example/demo/payroll/dto/PayrollPeriodDto.java
src/main/java/com/example/demo/payroll/dto/PayrollReportRequest.java
src/main/java/com/example/demo/payroll/dto/PayrollSummaryDto.java
src/main/java/com/example/demo/payroll/dto/SalaryComponentDto.java
src/main/java/com/example/demo/payroll/entity/PaymentMethod.java
src/main/java/com/example/demo/payroll/entity/PayrollAudit.java
src/main/java/com/example/demo/payroll/entity/PayrollLedger.java
src/main/java/com/example/demo/payroll/entity/PayrollLedgerComponent.java
src/main/java/com/example/demo/payroll/entity/PayrollLedgerStatus.java
src/main/java/com/example/demo/payroll/entity/PayrollPeriod.java
src/main/java/com/example/demo/payroll/entity/PayrollPeriodStatus.java
src/main/java/com/example/demo/payroll/entity/PayrollPeriodType.java
src/main/java/com/example/demo/payroll/entity/SalaryComponent.java
src/main/java/com/example/demo/payroll/exception/PayrollCalculationException.java
src/main/java/com/example/demo/payroll/exception/PayrollNotFoundException.java
src/main/java/com/example/demo/payroll/exception/PayrollPeriodException.java
src/main/java/com/example/demo/payroll/exception/PayrollValidationException.java
src/main/java/com/example/demo/payroll/repository/PayrollAuditRepository.java
src/main/java/com/example/demo/payroll/repository/PayrollLedgerRepository.java
src/main/java/com/example/demo/payroll/repository/PayrollPeriodRepository.java
src/main/java/com/example/demo/payroll/repository/SalaryComponentRepository.java
src/main/java/com/example/demo/payroll/service/impl/PayrollCalculationServiceImpl.java
src/main/java/com/example/demo/payroll/service/impl/PayrollServiceImpl.java
src/main/java/com/example/demo/payroll/service/PayrollCalculationService.java
src/main/java/com/example/demo/payroll/service/PayrollService.java
src/main/java/com/example/demo/position/controller/PositionController.java
src/main/java/com/example/demo/position/dto/PositionCreateRequest.java
src/main/java/com/example/demo/position/dto/PositionDto.java
src/main/java/com/example/demo/position/dto/PositionSearchCriteria.java
src/main/java/com/example/demo/position/dto/PositionStatisticsDto.java
src/main/java/com/example/demo/position/dto/PositionUpdateRequest.java
src/main/java/com/example/demo/position/entity/Position.java
src/main/java/com/example/demo/position/enums/EmploymentType.java
src/main/java/com/example/demo/position/enums/PositionCategory.java
src/main/java/com/example/demo/position/enums/PositionLevel.java
src/main/java/com/example/demo/position/exception/PositionAlreadyExistsException.java
src/main/java/com/example/demo/position/exception/PositionInUseException.java
src/main/java/com/example/demo/position/exception/PositionNotFoundException.java
src/main/java/com/example/demo/position/repository/PositionRepository.java
src/main/java/com/example/demo/position/service/impl/PositionServiceImpl.java
src/main/java/com/example/demo/position/service/PositionService.java
src/main/java/com/example/demo/security/config/SecurityConfig.java
src/main/java/com/example/demo/security/controller/AuthController.java
src/main/java/com/example/demo/security/controller/RoleController.java
src/main/java/com/example/demo/security/controller/UserController.java
src/main/java/com/example/demo/security/dto/LoginRequest.java
src/main/java/com/example/demo/security/dto/LoginResponse.java
src/main/java/com/example/demo/security/dto/ResourceDto.java
src/main/java/com/example/demo/security/dto/RoleDto.java
src/main/java/com/example/demo/security/dto/UserCreateRequest.java
src/main/java/com/example/demo/security/dto/UserDto.java
src/main/java/com/example/demo/security/dto/UserUpdateRequest.java
src/main/java/com/example/demo/security/entity/Resource.java
src/main/java/com/example/demo/security/entity/Role.java
src/main/java/com/example/demo/security/entity/User.java
src/main/java/com/example/demo/security/exception/AuthenticationException.java
src/main/java/com/example/demo/security/exception/AuthorizationException.java
src/main/java/com/example/demo/security/exception/InvalidPasswordException.java
src/main/java/com/example/demo/security/exception/ResourceNotFoundException.java
src/main/java/com/example/demo/security/exception/RoleAlreadyExistsException.java
src/main/java/com/example/demo/security/exception/RoleInUseException.java
src/main/java/com/example/demo/security/exception/RoleNotFoundException.java
src/main/java/com/example/demo/security/exception/UserAlreadyExistsException.java
src/main/java/com/example/demo/security/exception/UserNotFoundException.java
src/main/java/com/example/demo/security/repository/ResourceRepository.java
src/main/java/com/example/demo/security/repository/RoleRepository.java
src/main/java/com/example/demo/security/repository/UserRepository.java
src/main/java/com/example/demo/security/security/AESUtil.java
src/main/java/com/example/demo/security/security/CustomUserDetailsService.java
src/main/java/com/example/demo/security/security/CustomUserPrincipal.java
src/main/java/com/example/demo/security/security/EncryptedStringConverter.java
src/main/java/com/example/demo/security/security/JwtAuthenticationFilter.java
src/main/java/com/example/demo/security/security/JwtTokenProvider.java
src/main/java/com/example/demo/security/security/SecurityUtils.java
src/main/java/com/example/demo/security/service/AuthenticationService.java
src/main/java/com/example/demo/security/service/impl/AuthenticationServiceImpl.java
src/main/java/com/example/demo/security/service/impl/PermissionServiceImpl.java
src/main/java/com/example/demo/security/service/impl/RoleServiceImpl.java
src/main/java/com/example/demo/security/service/impl/UserServiceImpl.java
src/main/java/com/example/demo/security/service/PermissionService.java
src/main/java/com/example/demo/security/service/RoleService.java
src/main/java/com/example/demo/security/service/UserService.java
src/main/java/com/example/demo/ServletInitializer.java
src/main/resources/application-dev.properties
src/main/resources/application-prod.properties
src/main/resources/application.properties
src/main/resources/db/migration/.gitkeep
src/main/resources/db/migration/V0__Initial_baseline.sql
src/main/resources/db/migration/V1__Create_security_tables.sql
src/main/resources/db/migration/V2__Create_departments_table.sql
src/main/resources/db/migration/V3__Create_positions_table.sql
src/main/resources/db/migration/V4__Create_employees_table.sql
src/main/resources/db/migration/V5__Create_email_tables.sql
src/main/resources/db/migration/V6__Create_chat_tables.sql
src/main/resources/db/migration/V7__Create_notification_tables.sql
src/main/resources/db/migration/V8__Create_payroll_tables.sql
src/main/resources/static/.gitkeep
src/main/resources/templates/.gitkeep
src/test/java/com/example/demo/common/dto/ApiResponseTest.java
src/test/java/com/example/demo/common/dto/ErrorResponseTest.java
src/test/java/com/example/demo/common/dto/PageResponseTest.java
src/test/java/com/example/demo/common/exception/GlobalExceptionHandlerTest.java
src/test/java/com/example/demo/common/util/ValidationUtilTest.java
src/test/java/com/example/demo/communication/announcement/controller/AnnouncementControllerTest.java
src/test/java/com/example/demo/communication/announcement/service/AnnouncementScheduledServiceTest.java
src/test/java/com/example/demo/communication/announcement/service/AnnouncementServiceTest.java
src/test/java/com/example/demo/communication/announcement/service/AnnouncementValidationServiceTest.java
src/test/java/com/example/demo/communication/announcement/service/impl/AnnouncementServiceImplTest.java
src/test/java/com/example/demo/communication/chat/controller/ChatControllerTest.java
src/test/java/com/example/demo/communication/chat/service/impl/ChatServiceImplTest.java
src/test/java/com/example/demo/communication/email/service/impl/EmailServiceImplTest.java
src/test/java/com/example/demo/communication/email/service/impl/EmailTemplateServiceImplTest.java
src/test/java/com/example/demo/communication/email/util/EmailTemplateProcessorTest.java
src/test/java/com/example/demo/communication/notification/controller/NotificationControllerTest.java
src/test/java/com/example/demo/communication/notification/service/impl/NotificationServiceImplTest.java
src/test/java/com/example/demo/DemoApplicationTests.java
src/test/java/com/example/demo/department/controller/DepartmentControllerTest.java
src/test/java/com/example/demo/department/service/DepartmentServiceTest.java
src/test/resources/application-test.properties
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/main/java/com/example/demo/common/README.md">
# Common Infrastructure and Utilities

This package contains the foundational infrastructure components and utility classes that are used throughout the Employee Management System. These components provide standardized responses, error handling, validation, and common operations.

## Package Structure

```
common/
├── dto/                    # Data Transfer Objects for standardized responses
│   ├── ApiResponse.java    # Generic API response wrapper
│   ├── ErrorResponse.java  # Standardized error response structure
│   └── PageResponse.java   # Paginated response wrapper
├── exception/              # Exception handling infrastructure
│   ├── BusinessException.java        # Business logic exceptions
│   ├── GlobalExceptionHandler.java   # Centralized exception handling
│   └── ValidationException.java      # Validation error exceptions
└── util/                   # Utility classes for common operations
    ├── CacheUtil.java      # Redis cache operations
    ├── DateUtil.java       # Date/time utilities
    ├── FileUtil.java       # File operations
    ├── StringUtil.java     # String manipulation utilities
    └── ValidationUtil.java # Business validation utilities
```

## Core Components

### 1. Response DTOs

#### ApiResponse<T>
A generic wrapper for all API responses that provides:
- Consistent response structure across all endpoints
- Success/failure indication
- Error details when applicable
- Timestamp and path information for debugging

**Usage:**
```java
// Success response
return ResponseEntity.ok(ApiResponse.success(data));

// Success with custom message
return ResponseEntity.ok(ApiResponse.success(data, "Operation completed"));

// Error response
return ResponseEntity.badRequest().body(ApiResponse.error("Invalid input"));
```

#### ErrorResponse
Detailed error information structure that includes:
- Application-specific error codes
- HTTP status codes
- User-friendly messages
- Developer details
- Validation errors
- Context information

#### PageResponse<T>
Standardized pagination wrapper that provides:
- Page content
- Pagination metadata (page, size, total elements, etc.)
- Navigation flags (first, last, hasNext, hasPrevious)
- Easy conversion from Spring Data Page objects

### 2. Exception Handling

#### GlobalExceptionHandler
Centralized exception handling using `@ControllerAdvice` that:
- Handles all application exceptions consistently
- Maps exceptions to appropriate HTTP status codes
- Provides standardized error responses
- Logs exceptions for monitoring
- Handles validation errors with field-specific messages

#### Custom Exceptions
- **BusinessException**: For business logic violations
- **ValidationException**: For data validation errors
- Feature-specific exceptions for each module

### 3. Utility Classes

#### CacheUtil
Redis cache operations utility providing:
- Generic cache operations (get, set, delete)
- Cache key management with prefixes
- TTL (Time To Live) management
- Bulk operations
- Cache statistics and monitoring
- Pattern-based key operations

#### DateUtil
Date and time operations utility providing:
- Date formatting and parsing
- Business day calculations
- Age calculations
- Date range validations
- Timezone conversions
- Period calculations

#### StringUtil
String manipulation utility providing:
- Null-safe string operations
- Validation helpers
- Text formatting
- Case conversions
- Sanitization methods
- Pattern matching utilities

#### ValidationUtil
Business-specific validation utility providing:
- Employee number format validation
- Department and position code validation
- Date of birth and hire date validation
- Salary range validation
- Password strength validation
- Name and address validation

#### FileUtil
File operations utility providing:
- File upload/download operations
- File type validation
- Size validation
- Path sanitization
- Temporary file management
- File content operations

## Configuration Integration

The common infrastructure integrates with the application configuration:

### WebSocket Configuration
- Secure WebSocket connections with authentication
- Message-level security validation
- Connection monitoring and logging
- Heartbeat configuration

### CSRF Protection
- Cookie-based CSRF token management
- Configurable exclusion patterns
- Environment-specific configurations
- XOR encoding for security

### Caching Configuration
- Redis-based caching with TTL management
- Cache key naming strategies
- Performance monitoring

## Best Practices

### 1. Error Handling
```java
// Always use standardized responses
@ExceptionHandler(BusinessException.class)
public ResponseEntity<ApiResponse<Void>> handleBusinessException(BusinessException ex) {
    ErrorResponse error = ErrorResponse.of("BUSINESS_ERROR", 400, ex.getMessage());
    return ResponseEntity.badRequest().body(ApiResponse.error(ex.getMessage(), error));
}
```

### 2. Validation
```java
// Use ValidationUtil for business validations
if (!ValidationUtil.isValidEmployeeNumber(employeeNumber)) {
    throw new ValidationException("Invalid employee number format");
}
```

### 3. Caching
```java
// Use CacheUtil for cache operations
@Service
public class EmployeeService {
    
    public Employee getEmployee(Long id) {
        return CacheUtil.get("employee:" + id, Employee.class)
            .orElseGet(() -> {
                Employee emp = repository.findById(id);
                CacheUtil.set("employee:" + id, emp, Duration.ofMinutes(30));
                return emp;
            });
    }
}
```

### 4. Date Operations
```java
// Use DateUtil for date operations
LocalDate hireDate = DateUtil.parseDate(hireDateString);
if (!ValidationUtil.isValidHireDate(hireDate)) {
    throw new ValidationException("Invalid hire date");
}
```

## Testing

Comprehensive test coverage is provided for all utility classes and exception handling:

- Unit tests for all utility methods
- Integration tests for exception handling
- Cache operation tests with TestContainers
- WebSocket security tests
- CSRF protection tests

## Security Considerations

1. **Input Validation**: All utilities include input validation and sanitization
2. **XSS Prevention**: String utilities include XSS protection methods
3. **Path Traversal**: File utilities prevent path traversal attacks
4. **Cache Security**: Cache keys are properly namespaced and validated
5. **Error Information**: Error responses don't expose sensitive information

## Performance Considerations

1. **Caching**: Efficient Redis operations with connection pooling
2. **Lazy Loading**: Utilities use lazy initialization where appropriate
3. **Memory Management**: Proper resource cleanup in file operations
4. **Batch Operations**: Support for bulk cache operations
5. **Connection Management**: Proper WebSocket connection handling

## Monitoring and Logging

All components include comprehensive logging:
- Operation logs for debugging
- Performance metrics for monitoring
- Error logs with context information
- Cache hit/miss statistics
- WebSocket connection monitoring

## Dependencies

The common infrastructure relies on:
- Spring Boot 3.5.4
- Spring Security
- Spring Data Redis
- Jackson for JSON processing
- Lombok for code generation
- SLF4J for logging

## Future Enhancements

Planned improvements include:
- Distributed caching with Redis Cluster
- Advanced validation with custom annotations
- Metrics collection with Micrometer
- Enhanced WebSocket security with JWT validation
- Audit logging for all operations
</file>

<file path="src/main/java/com/example/demo/config/AsyncConfig.java">
package com.example.demo.config;

import lombok.extern.slf4j.Slf4j;
import org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.AsyncConfigurer;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.task.DelegatingSecurityContextAsyncTaskExecutor;

import java.lang.reflect.Method;
import java.util.concurrent.Executor;

/**
 * Async Configuration for asynchronous processing.
 * 
 * Configures thread pools, exception handling, and security context
 * propagation for async method execution.
 */
@Slf4j
@Configuration
@EnableAsync
public class AsyncConfig implements AsyncConfigurer {

    @Value("${app.async.core-pool-size:5}")
    private int corePoolSize;

    @Value("${app.async.max-pool-size:20}")
    private int maxPoolSize;

    @Value("${app.async.queue-capacity:100}")
    private int queueCapacity;

    @Value("${app.async.thread-name-prefix:async-}")
    private String threadNamePrefix;

    @Value("${app.async.keep-alive-seconds:60}")
    private int keepAliveSeconds;

    /**
     * Primary async executor with security context propagation
     */
    @Override
    @Bean(name = "taskExecutor")
    public Executor getAsyncExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(corePoolSize);
        executor.setMaxPoolSize(maxPoolSize);
        executor.setQueueCapacity(queueCapacity);
        executor.setThreadNamePrefix(threadNamePrefix);
        executor.setKeepAliveSeconds(keepAliveSeconds);
        executor.setWaitForTasksToCompleteOnShutdown(true);
        executor.setAwaitTerminationSeconds(30);
        executor.setRejectedExecutionHandler((r, executor1) -> {
            log.warn("Task rejected from async executor: {}", r.toString());
            throw new RuntimeException("Task rejected from async executor");
        });
        executor.initialize();

        // Wrap with security context propagation
        return new DelegatingSecurityContextAsyncTaskExecutor(executor);
    }

    /**
     * Email processing executor
     */
    @Bean(name = "emailTaskExecutor")
    public Executor emailTaskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(2);
        executor.setMaxPoolSize(10);
        executor.setQueueCapacity(50);
        executor.setThreadNamePrefix("email-async-");
        executor.setKeepAliveSeconds(60);
        executor.setWaitForTasksToCompleteOnShutdown(true);
        executor.setAwaitTerminationSeconds(30);
        executor.initialize();

        return new DelegatingSecurityContextAsyncTaskExecutor(executor);
    }

    /**
     * File processing executor
     */
    @Bean(name = "fileTaskExecutor")
    public Executor fileTaskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(1);
        executor.setMaxPoolSize(5);
        executor.setQueueCapacity(20);
        executor.setThreadNamePrefix("file-async-");
        executor.setKeepAliveSeconds(60);
        executor.setWaitForTasksToCompleteOnShutdown(true);
        executor.setAwaitTerminationSeconds(30);
        executor.initialize();

        return new DelegatingSecurityContextAsyncTaskExecutor(executor);
    }

    /**
     * Notification processing executor
     */
    @Bean(name = "notificationTaskExecutor")
    public Executor notificationTaskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(3);
        executor.setMaxPoolSize(15);
        executor.setQueueCapacity(100);
        executor.setThreadNamePrefix("notification-async-");
        executor.setKeepAliveSeconds(60);
        executor.setWaitForTasksToCompleteOnShutdown(true);
        executor.setAwaitTerminationSeconds(30);
        executor.initialize();

        return new DelegatingSecurityContextAsyncTaskExecutor(executor);
    }

    /**
     * Async exception handler
     */
    @Override
    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
        return new CustomAsyncExceptionHandler();
    }

    /**
     * Custom async exception handler with detailed logging
     */
    public static class CustomAsyncExceptionHandler implements AsyncUncaughtExceptionHandler {

        @Override
        public void handleUncaughtException(Throwable throwable, Method method, Object... params) {
            log.error("Async method execution failed - Method: {}.{}, Parameters: {}", 
                    method.getDeclaringClass().getSimpleName(), 
                    method.getName(), 
                    params, 
                    throwable);

            // Additional error handling logic can be added here
            // For example: sending notifications, updating metrics, etc.
            
            // Log security context if available
            SecurityContext securityContext = SecurityContextHolder.getContext();
            if (securityContext != null && securityContext.getAuthentication() != null) {
                log.error("Async error occurred for user: {}", 
                        securityContext.getAuthentication().getName());
            }
        }
    }

    /**
     * Async method monitoring bean
     */
    @Bean
    public AsyncMethodMonitor asyncMethodMonitor() {
        return new AsyncMethodMonitor();
    }

    /**
     * Monitor for async method execution
     */
    public static class AsyncMethodMonitor {
        
        public void logAsyncMethodStart(String methodName, String threadName) {
            log.debug("Async method started - Method: {}, Thread: {}", methodName, threadName);
        }
        
        public void logAsyncMethodEnd(String methodName, String threadName, long executionTime) {
            log.debug("Async method completed - Method: {}, Thread: {}, Duration: {}ms", 
                    methodName, threadName, executionTime);
        }
        
        public void logAsyncMethodError(String methodName, String threadName, Throwable error) {
            log.error("Async method failed - Method: {}, Thread: {}", methodName, threadName, error);
        }
    }
}
</file>

<file path="src/main/java/com/example/demo/config/CorsConfig.java">
package com.example.demo.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

import java.util.Arrays;
import java.util.List;

/**
 * CORS Configuration for frontend integration.
 * 
 * Configures Cross-Origin Resource Sharing settings to allow
 * frontend applications to communicate with the backend API.
 */
@Configuration
public class CorsConfig implements WebMvcConfigurer {

    @Value("${app.cors.allowed-origins:http://localhost:3000,http://localhost:5173}")
    private List<String> allowedOrigins;

    @Value("${app.cors.allowed-methods:GET,POST,PUT,DELETE,PATCH,OPTIONS}")
    private List<String> allowedMethods;

    @Value("${app.cors.allowed-headers:*}")
    private List<String> allowedHeaders;

    @Value("${app.cors.exposed-headers:Authorization,Content-Disposition}")
    private List<String> exposedHeaders;

    @Value("${app.cors.allow-credentials:true}")
    private boolean allowCredentials;

    @Value("${app.cors.max-age:3600}")
    private long maxAge;

    /**
     * Global CORS configuration
     */
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api/**")
                .allowedOriginPatterns(allowedOrigins.toArray(new String[0]))
                .allowedMethods(allowedMethods.toArray(new String[0]))
                .allowedHeaders(allowedHeaders.toArray(new String[0]))
                .exposedHeaders(exposedHeaders.toArray(new String[0]))
                .allowCredentials(allowCredentials)
                .maxAge(maxAge);

        // WebSocket endpoints
        registry.addMapping("/ws/**")
                .allowedOriginPatterns(allowedOrigins.toArray(new String[0]))
                .allowedMethods("GET", "POST", "OPTIONS")
                .allowedHeaders("*")
                .allowCredentials(allowCredentials)
                .maxAge(maxAge);

        // Actuator endpoints
        registry.addMapping("/actuator/**")
                .allowedOriginPatterns(allowedOrigins.toArray(new String[0]))
                .allowedMethods("GET", "POST", "OPTIONS")
                .allowedHeaders("*")
                .allowCredentials(false)
                .maxAge(maxAge);
    }

    /**
     * CORS configuration source for Spring Security
     */
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        
        // Allow specific origins in production, all in development
        configuration.setAllowedOriginPatterns(allowedOrigins);
        
        // Allow common HTTP methods
        configuration.setAllowedMethods(allowedMethods);
        
        // Allow all headers by default
        configuration.setAllowedHeaders(allowedHeaders);
        
        // Expose specific headers to frontend
        configuration.setExposedHeaders(exposedHeaders);
        
        // Allow credentials for authentication
        configuration.setAllowCredentials(allowCredentials);
        
        // Cache preflight requests
        configuration.setMaxAge(maxAge);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        
        return source;
    }

    /**
     * Development CORS configuration (more permissive)
     */
    @Bean
    public CorsConfigurationSource developmentCorsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOriginPatterns(List.of("*"));
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS", "HEAD"));
        configuration.setAllowedHeaders(List.of("*"));
        configuration.setExposedHeaders(Arrays.asList(
            "Authorization", 
            "Content-Disposition", 
            "X-Total-Count",
            "X-Page-Number",
            "X-Page-Size"
        ));
        configuration.setAllowCredentials(true);
        configuration.setMaxAge(3600L);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        
        return source;
    }

    /**
     * Production CORS configuration (more restrictive)
     */
    @Bean
    public CorsConfigurationSource productionCorsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        
        // Only allow specific production origins
        configuration.setAllowedOrigins(Arrays.asList(
            "https://yourdomain.com",
            "https://www.yourdomain.com",
            "https://app.yourdomain.com"
        ));
        
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "PATCH"));
        configuration.setAllowedHeaders(Arrays.asList(
            "Authorization",
            "Content-Type",
            "X-Requested-With",
            "Accept",
            "Origin",
            "Access-Control-Request-Method",
            "Access-Control-Request-Headers"
        ));
        configuration.setExposedHeaders(Arrays.asList(
            "Authorization",
            "Content-Disposition"
        ));
        configuration.setAllowCredentials(true);
        configuration.setMaxAge(1800L); // 30 minutes

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        
        return source;
    }
}
</file>

<file path="src/main/java/com/example/demo/config/CsrfConfig.java">
package com.example.demo.config;

import jakarta.servlet.http.HttpServletRequest;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.web.csrf.CookieCsrfTokenRepository;
import org.springframework.security.web.csrf.CsrfTokenRepository;
import org.springframework.security.web.csrf.CsrfTokenRequestAttributeHandler;
import org.springframework.security.web.csrf.CsrfTokenRequestHandler;
import org.springframework.security.web.csrf.XorCsrfTokenRequestAttributeHandler;
import org.springframework.security.web.util.matcher.AntPathRequestMatcher;
import org.springframework.security.web.util.matcher.RequestMatcher;

import java.util.Arrays;
import java.util.List;

/**
 * CSRF Protection Configuration.
 * 
 * Configures Cross-Site Request Forgery protection for state-changing operations
 * while allowing stateless API endpoints to bypass CSRF protection.
 */
@Configuration
public class CsrfConfig {

    @Value("${app.csrf.enabled:true}")
    private boolean csrfEnabled;

    @Value("${app.csrf.cookie.name:XSRF-TOKEN}")
    private String csrfCookieName;

    @Value("${app.csrf.header.name:X-XSRF-TOKEN}")
    private String csrfHeaderName;

    @Value("${app.csrf.parameter.name:_csrf}")
    private String csrfParameterName;

    @Value("${app.csrf.cookie.http-only:false}")
    private boolean csrfCookieHttpOnly;

    @Value("${app.csrf.cookie.secure:false}")
    private boolean csrfCookieSecure;

    @Value("${app.csrf.cookie.same-site:Lax}")
    private String csrfCookieSameSite;

    /**
     * CSRF token repository configuration
     */
    @Bean
    public CsrfTokenRepository csrfTokenRepository() {
        CookieCsrfTokenRepository repository = CookieCsrfTokenRepository.withHttpOnlyFalse();
        repository.setCookieName(csrfCookieName);
        repository.setHeaderName(csrfHeaderName);
        repository.setParameterName(csrfParameterName);
        repository.setCookieHttpOnly(csrfCookieHttpOnly);
        repository.setSecure(csrfCookieSecure);
        repository.setCookiePath("/");
        repository.setCookieMaxAge(-1); // Session cookie
        
        return repository;
    }

    /**
     * CSRF token request handler with XOR encoding for additional security
     */
    @Bean
    public CsrfTokenRequestHandler csrfTokenRequestHandler() {
        XorCsrfTokenRequestAttributeHandler requestHandler = new XorCsrfTokenRequestAttributeHandler();
        requestHandler.setCsrfRequestAttributeName("_csrf");
        return requestHandler;
    }

    /**
     * Request matcher for endpoints that should be excluded from CSRF protection
     */
    @Bean
    public RequestMatcher csrfExclusionMatcher() {
        return new CsrfExclusionRequestMatcher();
    }

    /**
     * Custom request matcher that excludes specific endpoints from CSRF protection
     */
    private static class CsrfExclusionRequestMatcher implements RequestMatcher {
        
        private final List<RequestMatcher> excludedMatchers = Arrays.asList(
            // API endpoints (stateless, JWT-based)
            new AntPathRequestMatcher("/api/**"),
            
            // WebSocket endpoints
            new AntPathRequestMatcher("/ws/**"),
            
            // Actuator endpoints
            new AntPathRequestMatcher("/actuator/**"),
            
            // Authentication endpoints
            new AntPathRequestMatcher("/auth/**"),
            
            // Public endpoints
            new AntPathRequestMatcher("/public/**"),
            
            // Health check endpoints
            new AntPathRequestMatcher("/health/**"),
            
            // Static resources
            new AntPathRequestMatcher("/static/**"),
            new AntPathRequestMatcher("/css/**"),
            new AntPathRequestMatcher("/js/**"),
            new AntPathRequestMatcher("/images/**"),
            new AntPathRequestMatcher("/favicon.ico"),
            
            // H2 Console (development only)
            new AntPathRequestMatcher("/h2-console/**")
        );

        @Override
        public boolean matches(HttpServletRequest request) {
            // Return true if the request should be excluded from CSRF protection
            return excludedMatchers.stream().anyMatch(matcher -> matcher.matches(request));
        }
    }

    /**
     * CSRF configuration for different environments
     */
    @Bean
    public CsrfEnvironmentConfig csrfEnvironmentConfig() {
        return new CsrfEnvironmentConfig();
    }

    /**
     * Environment-specific CSRF configuration
     */
    public static class CsrfEnvironmentConfig {
        
        /**
         * Development CSRF configuration (more lenient)
         */
        public CsrfTokenRepository developmentCsrfTokenRepository() {
            CookieCsrfTokenRepository repository = CookieCsrfTokenRepository.withHttpOnlyFalse();
            repository.setCookieName("DEV-XSRF-TOKEN");
            repository.setHeaderName("X-XSRF-TOKEN");
            repository.setCookieHttpOnly(false);
            repository.setSecure(false);
            repository.setCookiePath("/");
            repository.setCookieMaxAge(3600); // 1 hour for development
            
            return repository;
        }

        /**
         * Production CSRF configuration (more secure)
         */
        public CsrfTokenRepository productionCsrfTokenRepository() {
            CookieCsrfTokenRepository repository = CookieCsrfTokenRepository.withHttpOnlyFalse();
            repository.setCookieName("XSRF-TOKEN");
            repository.setHeaderName("X-XSRF-TOKEN");
            repository.setCookieHttpOnly(false); // Must be false for JavaScript access
            repository.setSecure(true); // HTTPS only in production
            repository.setCookiePath("/");
            repository.setCookieMaxAge(-1); // Session cookie
            
            return repository;
        }

        /**
         * Request matcher for production (more restrictive)
         */
        public RequestMatcher productionCsrfExclusionMatcher() {
            return new RequestMatcher() {
                private final List<RequestMatcher> excludedMatchers = Arrays.asList(
                    // Only API endpoints in production
                    new AntPathRequestMatcher("/api/**"),
                    new AntPathRequestMatcher("/actuator/health"),
                    new AntPathRequestMatcher("/actuator/info")
                );

                @Override
                public boolean matches(HttpServletRequest request) {
                    return excludedMatchers.stream().anyMatch(matcher -> matcher.matches(request));
                }
            };
        }
    }

    /**
     * CSRF token utility methods
     */
    @Bean
    public CsrfTokenUtil csrfTokenUtil() {
        return new CsrfTokenUtil();
    }

    /**
     * Utility class for CSRF token operations
     */
    public static class CsrfTokenUtil {
        
        /**
         * Check if CSRF protection should be applied to the request
         */
        public boolean shouldApplyCsrfProtection(HttpServletRequest request) {
            // Skip CSRF for safe HTTP methods
            String method = request.getMethod();
            if ("GET".equals(method) || "HEAD".equals(method) || 
                "TRACE".equals(method) || "OPTIONS".equals(method)) {
                return false;
            }
            
            // Skip CSRF for API endpoints (assuming JWT-based authentication)
            String requestURI = request.getRequestURI();
            if (requestURI.startsWith("/api/")) {
                return false;
            }
            
            // Apply CSRF for state-changing operations on web endpoints
            return true;
        }

        /**
         * Get CSRF token from request
         */
        public String getCsrfTokenFromRequest(HttpServletRequest request) {
            // Try header first
            String token = request.getHeader("X-XSRF-TOKEN");
            if (token != null) {
                return token;
            }
            
            // Try parameter
            token = request.getParameter("_csrf");
            if (token != null) {
                return token;
            }
            
            // Try custom header
            return request.getHeader("X-CSRF-TOKEN");
        }

        /**
         * Validate CSRF token format
         */
        public boolean isValidCsrfTokenFormat(String token) {
            return token != null && 
                   token.length() >= 32 && 
                   token.matches("^[a-zA-Z0-9+/=\\-_]+$");
        }
    }
}
</file>

<file path="src/main/java/com/example/demo/config/RequestResponseLoggingConfig.java">
package com.example.demo.config;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.filter.OncePerRequestFilter;
import org.springframework.web.util.ContentCachingRequestWrapper;
import org.springframework.web.util.ContentCachingResponseWrapper;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Arrays;
import java.util.List;
import java.util.UUID;

/**
 * Request and Response Logging Configuration.
 * 
 * Provides comprehensive logging of HTTP requests and responses
 * for monitoring, debugging, and audit purposes.
 */
@Slf4j
@Configuration
public class RequestResponseLoggingConfig {

    @Value("${app.logging.request-response.enabled:true}")
    private boolean loggingEnabled;

    @Value("${app.logging.request-response.include-payload:false}")
    private boolean includePayload;

    @Value("${app.logging.request-response.max-payload-length:1000}")
    private int maxPayloadLength;

    @Value("${app.logging.request-response.excluded-paths:/actuator,/swagger-ui,/v3/api-docs}")
    private List<String> excludedPaths;

    /**
     * Request/Response logging filter
     */
    @Bean
    public RequestResponseLoggingFilter requestResponseLoggingFilter() {
        return new RequestResponseLoggingFilter();
    }

    /**
     * Custom logging filter implementation
     */
    public class RequestResponseLoggingFilter extends OncePerRequestFilter {

        @Override
        protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response,
                                      FilterChain filterChain) throws ServletException, IOException {
            
            if (!loggingEnabled || shouldSkipLogging(request)) {
                filterChain.doFilter(request, response);
                return;
            }

            // Generate unique request ID
            String requestId = UUID.randomUUID().toString().substring(0, 8);
            
            // Wrap request and response for content caching
            ContentCachingRequestWrapper wrappedRequest = new ContentCachingRequestWrapper(request);
            ContentCachingResponseWrapper wrappedResponse = new ContentCachingResponseWrapper(response);
            
            long startTime = System.currentTimeMillis();
            
            try {
                // Log request
                logRequest(wrappedRequest, requestId);
                
                // Process request
                filterChain.doFilter(wrappedRequest, wrappedResponse);
                
            } finally {
                long duration = System.currentTimeMillis() - startTime;
                
                // Log response
                logResponse(wrappedResponse, requestId, duration);
                
                // Copy response content back to original response
                wrappedResponse.copyBodyToResponse();
            }
        }

        private boolean shouldSkipLogging(HttpServletRequest request) {
            String requestURI = request.getRequestURI();
            return excludedPaths.stream().anyMatch(requestURI::startsWith);
        }

        private void logRequest(ContentCachingRequestWrapper request, String requestId) {
            StringBuilder logMessage = new StringBuilder();
            logMessage.append("\n=== INCOMING REQUEST [").append(requestId).append("] ===\n");
            logMessage.append("Timestamp: ").append(LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME)).append("\n");
            logMessage.append("Method: ").append(request.getMethod()).append("\n");
            logMessage.append("URI: ").append(request.getRequestURI()).append("\n");
            
            if (request.getQueryString() != null) {
                logMessage.append("Query: ").append(request.getQueryString()).append("\n");
            }
            
            logMessage.append("Remote Address: ").append(getClientIpAddress(request)).append("\n");
            logMessage.append("User Agent: ").append(request.getHeader("User-Agent")).append("\n");
            
            // Log headers (excluding sensitive ones)
            logMessage.append("Headers:\n");
            request.getHeaderNames().asIterator().forEachRemaining(headerName -> {
                if (!isSensitiveHeader(headerName)) {
                    logMessage.append("  ").append(headerName).append(": ").append(request.getHeader(headerName)).append("\n");
                } else {
                    logMessage.append("  ").append(headerName).append(": [REDACTED]\n");
                }
            });
            
            // Log request body if enabled and not sensitive
            if (includePayload && !isSensitiveEndpoint(request.getRequestURI())) {
                String payload = getRequestPayload(request);
                if (payload != null && !payload.isEmpty()) {
                    logMessage.append("Payload: ").append(truncatePayload(payload)).append("\n");
                }
            }
            
            logMessage.append("=== END REQUEST [").append(requestId).append("] ===");
            
            log.info(logMessage.toString());
        }

        private void logResponse(ContentCachingResponseWrapper response, String requestId, long duration) {
            StringBuilder logMessage = new StringBuilder();
            logMessage.append("\n=== OUTGOING RESPONSE [").append(requestId).append("] ===\n");
            logMessage.append("Status: ").append(response.getStatus()).append("\n");
            logMessage.append("Duration: ").append(duration).append("ms\n");
            
            // Log response headers
            logMessage.append("Headers:\n");
            response.getHeaderNames().forEach(headerName -> {
                logMessage.append("  ").append(headerName).append(": ").append(response.getHeader(headerName)).append("\n");
            });
            
            // Log response body if enabled
            if (includePayload) {
                String payload = getResponsePayload(response);
                if (payload != null && !payload.isEmpty()) {
                    logMessage.append("Payload: ").append(truncatePayload(payload)).append("\n");
                }
            }
            
            logMessage.append("=== END RESPONSE [").append(requestId).append("] ===");
            
            if (response.getStatus() >= 400) {
                log.error(logMessage.toString());
            } else {
                log.info(logMessage.toString());
            }
        }

        private String getClientIpAddress(HttpServletRequest request) {
            String[] headerNames = {
                "X-Forwarded-For",
                "X-Real-IP",
                "Proxy-Client-IP",
                "WL-Proxy-Client-IP",
                "HTTP_X_FORWARDED_FOR",
                "HTTP_X_FORWARDED",
                "HTTP_X_CLUSTER_CLIENT_IP",
                "HTTP_CLIENT_IP",
                "HTTP_FORWARDED_FOR",
                "HTTP_FORWARDED",
                "HTTP_VIA",
                "REMOTE_ADDR"
            };

            for (String headerName : headerNames) {
                String ip = request.getHeader(headerName);
                if (ip != null && !ip.isEmpty() && !"unknown".equalsIgnoreCase(ip)) {
                    return ip.split(",")[0].trim();
                }
            }

            return request.getRemoteAddr();
        }

        private boolean isSensitiveHeader(String headerName) {
            List<String> sensitiveHeaders = Arrays.asList(
                "authorization", "cookie", "set-cookie", "x-auth-token", "x-api-key"
            );
            return sensitiveHeaders.contains(headerName.toLowerCase());
        }

        private boolean isSensitiveEndpoint(String uri) {
            List<String> sensitiveEndpoints = Arrays.asList(
                "/api/auth/login", "/api/auth/register", "/api/users/password"
            );
            return sensitiveEndpoints.stream().anyMatch(uri::contains);
        }

        private String getRequestPayload(ContentCachingRequestWrapper request) {
            byte[] content = request.getContentAsByteArray();
            if (content.length > 0) {
                return new String(content, StandardCharsets.UTF_8);
            }
            return null;
        }

        private String getResponsePayload(ContentCachingResponseWrapper response) {
            byte[] content = response.getContentAsByteArray();
            if (content.length > 0) {
                return new String(content, StandardCharsets.UTF_8);
            }
            return null;
        }

        private String truncatePayload(String payload) {
            if (payload.length() > maxPayloadLength) {
                return payload.substring(0, maxPayloadLength) + "... [TRUNCATED]";
            }
            return payload;
        }
    }
}
</file>

<file path="src/main/java/com/example/demo/config/SecurityHeadersConfig.java">
package com.example.demo.config;

import jakarta.servlet.http.HttpServletResponse;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.web.header.HeaderWriter;
import org.springframework.security.web.header.writers.ReferrerPolicyHeaderWriter;
import org.springframework.security.web.header.writers.XXssProtectionHeaderWriter;
import org.springframework.web.filter.OncePerRequestFilter;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import java.io.IOException;

/**
 * Security Headers Configuration.
 * 
 * Configures comprehensive security headers to protect against
 * common web vulnerabilities and attacks.
 */
@Configuration
public class SecurityHeadersConfig {

    @Value("${app.security.content-security-policy:default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self' data:}")
    private String contentSecurityPolicy;

    @Value("${app.security.frame-options:DENY}")
    private String frameOptions;

    @Value("${app.security.content-type-options:nosniff}")
    private String contentTypeOptions;

    @Value("${app.security.referrer-policy:strict-origin-when-cross-origin}")
    private String referrerPolicy;

    @Value("${app.security.permissions-policy:geolocation=(), microphone=(), camera=()}")
    private String permissionsPolicy;

    /**
     * Security headers filter
     */
    @Bean
    public SecurityHeadersFilter securityHeadersFilter() {
        return new SecurityHeadersFilter();
    }

    /**
     * Content Security Policy header writer
     */
    @Bean
    public HeaderWriter contentSecurityPolicyHeaderWriter() {
        return (request, response) -> {
            if (!response.containsHeader("Content-Security-Policy")) {
                response.setHeader("Content-Security-Policy", contentSecurityPolicy);
            }
        };
    }

    /**
     * X-Frame-Options header writer
     */
    @Bean
    public HeaderWriter frameOptionsHeaderWriter() {
        return (request, response) -> {
            if (!response.containsHeader("X-Frame-Options")) {
                response.setHeader("X-Frame-Options", frameOptions);
            }
        };
    }

    /**
     * X-Content-Type-Options header writer
     */
    @Bean
    public HeaderWriter contentTypeOptionsHeaderWriter() {
        return (request, response) -> {
            if (!response.containsHeader("X-Content-Type-Options")) {
                response.setHeader("X-Content-Type-Options", contentTypeOptions);
            }
        };
    }

    /**
     * Referrer Policy header writer
     */
    @Bean
    public HeaderWriter referrerPolicyHeaderWriter() {
        return new ReferrerPolicyHeaderWriter(ReferrerPolicyHeaderWriter.ReferrerPolicy.STRICT_ORIGIN_WHEN_CROSS_ORIGIN);
    }

    /**
     * X-XSS-Protection header writer
     */
    @Bean
    public HeaderWriter xssProtectionHeaderWriter() {
        return new XXssProtectionHeaderWriter();
    }

    /**
     * Permissions Policy header writer
     */
    @Bean
    public HeaderWriter permissionsPolicyHeaderWriter() {
        return (request, response) -> {
            if (!response.containsHeader("Permissions-Policy")) {
                response.setHeader("Permissions-Policy", permissionsPolicy);
            }
        };
    }

    /**
     * Strict Transport Security header writer
     */
    @Bean
    public HeaderWriter strictTransportSecurityHeaderWriter() {
        return (request, response) -> {
            if (request.isSecure() && !response.containsHeader("Strict-Transport-Security")) {
                response.setHeader("Strict-Transport-Security", "max-age=31536000; includeSubDomains; preload");
            }
        };
    }

    /**
     * Custom security headers filter
     */
    public class SecurityHeadersFilter extends OncePerRequestFilter {

        @Override
        protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, 
                                      FilterChain filterChain) throws ServletException, IOException {
            
            // Add security headers
            addSecurityHeaders(request, response);
            
            // Continue with the filter chain
            filterChain.doFilter(request, response);
        }

        private void addSecurityHeaders(HttpServletRequest request, HttpServletResponse response) {
            // Content Security Policy
            if (!response.containsHeader("Content-Security-Policy")) {
                response.setHeader("Content-Security-Policy", contentSecurityPolicy);
            }

            // X-Frame-Options
            if (!response.containsHeader("X-Frame-Options")) {
                response.setHeader("X-Frame-Options", frameOptions);
            }

            // X-Content-Type-Options
            if (!response.containsHeader("X-Content-Type-Options")) {
                response.setHeader("X-Content-Type-Options", contentTypeOptions);
            }

            // Referrer Policy
            if (!response.containsHeader("Referrer-Policy")) {
                response.setHeader("Referrer-Policy", referrerPolicy);
            }

            // Permissions Policy
            if (!response.containsHeader("Permissions-Policy")) {
                response.setHeader("Permissions-Policy", permissionsPolicy);
            }

            // X-XSS-Protection
            if (!response.containsHeader("X-XSS-Protection")) {
                response.setHeader("X-XSS-Protection", "1; mode=block");
            }

            // Strict Transport Security (only for HTTPS)
            if (request.isSecure() && !response.containsHeader("Strict-Transport-Security")) {
                response.setHeader("Strict-Transport-Security", "max-age=31536000; includeSubDomains; preload");
            }

            // Cache Control for sensitive endpoints
            String requestURI = request.getRequestURI();
            if (requestURI.contains("/api/auth/") || requestURI.contains("/api/users/") || 
                requestURI.contains("/api/admin/")) {
                response.setHeader("Cache-Control", "no-cache, no-store, must-revalidate");
                response.setHeader("Pragma", "no-cache");
                response.setHeader("Expires", "0");
            }

            // Remove server information
            response.setHeader("Server", "");
            
            // Add custom application headers
            response.setHeader("X-Application-Name", "Employee Management System");
            response.setHeader("X-Application-Version", "1.0.0");
        }
    }
}
</file>

<file path="src/test/java/com/example/demo/common/dto/ApiResponseTest.java">
package com.example.demo.common.dto;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

import java.time.LocalDateTime;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * Unit tests for ApiResponse class.
 */
@SpringBootTest
class ApiResponseTest {

    private final ObjectMapper objectMapper = new ObjectMapper();

    @Test
    void testSuccessResponse() {
        // Given
        String data = "test data";
        
        // When
        ApiResponse<String> response = ApiResponse.success(data);
        
        // Then
        assertThat(response.isSuccess()).isTrue();
        assertThat(response.getData()).isEqualTo(data);
        assertThat(response.getMessage()).isEqualTo("Operation completed successfully");
        assertThat(response.getError()).isNull();
        assertThat(response.getTimestamp()).isNotNull();
        assertThat(response.getTimestamp()).isBefore(LocalDateTime.now().plusSeconds(1));
    }

    @Test
    void testSuccessResponseWithCustomMessage() {
        // Given
        String data = "test data";
        String message = "Custom success message";
        
        // When
        ApiResponse<String> response = ApiResponse.success(data, message);
        
        // Then
        assertThat(response.isSuccess()).isTrue();
        assertThat(response.getData()).isEqualTo(data);
        assertThat(response.getMessage()).isEqualTo(message);
        assertThat(response.getError()).isNull();
        assertThat(response.getTimestamp()).isNotNull();
    }

    @Test
    void testErrorResponse() {
        // Given
        String errorMessage = "Something went wrong";
        
        // When
        ApiResponse<Void> response = ApiResponse.error(errorMessage);
        
        // Then
        assertThat(response.isSuccess()).isFalse();
        assertThat(response.getData()).isNull();
        assertThat(response.getMessage()).isEqualTo(errorMessage);
        assertThat(response.getError()).isNull();
        assertThat(response.getTimestamp()).isNotNull();
    }

    @Test
    void testErrorResponseWithErrorDetails() {
        // Given
        String errorMessage = "Validation failed";
        ErrorResponse errorDetails = ErrorResponse.of("VALIDATION_ERROR", 400, "Field validation failed");
        
        // When
        ApiResponse<Void> response = ApiResponse.error(errorMessage, errorDetails);
        
        // Then
        assertThat(response.isSuccess()).isFalse();
        assertThat(response.getData()).isNull();
        assertThat(response.getMessage()).isEqualTo(errorMessage);
        assertThat(response.getError()).isEqualTo(errorDetails);
        assertThat(response.getTimestamp()).isNotNull();
    }

    @Test
    void testJsonSerialization() throws Exception {
        // Given
        ApiResponse<String> response = ApiResponse.success("test data", "Success");
        response.setPath("/api/test");
        
        // When
        String json = objectMapper.writeValueAsString(response);
        
        // Then
        assertThat(json).contains("\"success\":true");
        assertThat(json).contains("\"data\":\"test data\"");
        assertThat(json).contains("\"message\":\"Success\"");
        assertThat(json).contains("\"path\":\"/api/test\"");
        assertThat(json).contains("\"timestamp\":");
    }

    @Test
    void testJsonDeserialization() throws Exception {
        // Given
        String json = "{\"success\":true,\"message\":\"Test\",\"data\":\"test data\",\"timestamp\":\"2023-01-01T12:00:00\"}";
        
        // When
        ApiResponse<?> response = objectMapper.readValue(json, ApiResponse.class);
        
        // Then
        assertThat(response.isSuccess()).isTrue();
        assertThat(response.getMessage()).isEqualTo("Test");
        assertThat(response.getData()).isEqualTo("test data");
    }

    @Test
    void testBuilderPattern() {
        // Given & When
        ApiResponse<String> response = ApiResponse.<String>builder()
                .success(true)
                .message("Builder test")
                .data("builder data")
                .path("/api/builder")
                .build();
        
        // Then
        assertThat(response.isSuccess()).isTrue();
        assertThat(response.getMessage()).isEqualTo("Builder test");
        assertThat(response.getData()).isEqualTo("builder data");
        assertThat(response.getPath()).isEqualTo("/api/builder");
        assertThat(response.getTimestamp()).isNotNull();
    }

    @Test
    void testNullDataHandling() {
        // When
        ApiResponse<String> response = ApiResponse.success(null);
        
        // Then
        assertThat(response.isSuccess()).isTrue();
        assertThat(response.getData()).isNull();
        assertThat(response.getMessage()).isEqualTo("Operation completed successfully");
    }

    @Test
    void testEqualsAndHashCode() {
        // Given
        ApiResponse<String> response1 = ApiResponse.success("data");
        ApiResponse<String> response2 = ApiResponse.success("data");
        
        // Set same timestamp to make them equal
        LocalDateTime timestamp = LocalDateTime.now();
        response1.setTimestamp(timestamp);
        response2.setTimestamp(timestamp);
        
        // Then
        assertThat(response1).isEqualTo(response2);
        assertThat(response1.hashCode()).isEqualTo(response2.hashCode());
    }

    @Test
    void testToString() {
        // Given
        ApiResponse<String> response = ApiResponse.success("test");
        
        // When
        String toString = response.toString();
        
        // Then
        assertThat(toString).contains("ApiResponse");
        assertThat(toString).contains("success=true");
        assertThat(toString).contains("data=test");
    }
}
</file>

<file path="src/test/java/com/example/demo/common/dto/ErrorResponseTest.java">
package com.example.demo.common.dto;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * Unit tests for ErrorResponse class.
 */
@SpringBootTest
class ErrorResponseTest {

    private final ObjectMapper objectMapper = new ObjectMapper();

    @Test
    void testSimpleErrorResponse() {
        // Given
        String errorCode = "VALIDATION_ERROR";
        int status = 400;
        String message = "Validation failed";
        
        // When
        ErrorResponse response = ErrorResponse.of(errorCode, status, message);
        
        // Then
        assertThat(response.getErrorCode()).isEqualTo(errorCode);
        assertThat(response.getStatus()).isEqualTo(status);
        assertThat(response.getMessage()).isEqualTo(message);
        assertThat(response.getTimestamp()).isNotNull();
        assertThat(response.getTimestamp()).isBefore(LocalDateTime.now().plusSeconds(1));
    }

    @Test
    void testErrorResponseWithValidationErrors() {
        // Given
        String errorCode = "VALIDATION_ERROR";
        int status = 400;
        String message = "Field validation failed";
        Map<String, String> validationErrors = Map.of(
            "name", "Name is required",
            "email", "Invalid email format"
        );
        
        // When
        ErrorResponse response = ErrorResponse.withValidationErrors(errorCode, status, message, validationErrors);
        
        // Then
        assertThat(response.getErrorCode()).isEqualTo(errorCode);
        assertThat(response.getStatus()).isEqualTo(status);
        assertThat(response.getMessage()).isEqualTo(message);
        assertThat(response.getValidationErrors()).isEqualTo(validationErrors);
        assertThat(response.getTimestamp()).isNotNull();
    }

    @Test
    void testBuilderPattern() {
        // Given & When
        ErrorResponse response = ErrorResponse.builder()
                .errorCode("BUSINESS_ERROR")
                .status(422)
                .message("Business rule violation")
                .details("Detailed error description")
                .path("/api/employees")
                .errors(List.of("Error 1", "Error 2"))
                .context(Map.of("userId", "123", "action", "create"))
                .build();
        
        // Then
        assertThat(response.getErrorCode()).isEqualTo("BUSINESS_ERROR");
        assertThat(response.getStatus()).isEqualTo(422);
        assertThat(response.getMessage()).isEqualTo("Business rule violation");
        assertThat(response.getDetails()).isEqualTo("Detailed error description");
        assertThat(response.getPath()).isEqualTo("/api/employees");
        assertThat(response.getErrors()).containsExactly("Error 1", "Error 2");
        assertThat(response.getContext()).containsEntry("userId", "123");
        assertThat(response.getTimestamp()).isNotNull();
    }

    @Test
    void testJsonSerialization() throws Exception {
        // Given
        ErrorResponse response = ErrorResponse.builder()
                .errorCode("TEST_ERROR")
                .status(500)
                .message("Test error")
                .details("Test details")
                .path("/api/test")
                .validationErrors(Map.of("field1", "error1"))
                .errors(List.of("General error"))
                .context(Map.of("key", "value"))
                .build();
        
        // When
        String json = objectMapper.writeValueAsString(response);
        
        // Then
        assertThat(json).contains("\"errorCode\":\"TEST_ERROR\"");
        assertThat(json).contains("\"status\":500");
        assertThat(json).contains("\"message\":\"Test error\"");
        assertThat(json).contains("\"details\":\"Test details\"");
        assertThat(json).contains("\"path\":\"/api/test\"");
        assertThat(json).contains("\"validationErrors\":{\"field1\":\"error1\"}");
        assertThat(json).contains("\"errors\":[\"General error\"]");
        assertThat(json).contains("\"context\":{\"key\":\"value\"}");
    }

    @Test
    void testJsonDeserialization() throws Exception {
        // Given
        String json = """
            {
                "errorCode": "DESERIALIZATION_TEST",
                "status": 400,
                "message": "Test message",
                "details": "Test details",
                "path": "/api/test",
                "timestamp": "2023-01-01T12:00:00",
                "validationErrors": {"field": "error"},
                "errors": ["error1", "error2"],
                "context": {"key": "value"}
            }
            """;
        
        // When
        ErrorResponse response = objectMapper.readValue(json, ErrorResponse.class);
        
        // Then
        assertThat(response.getErrorCode()).isEqualTo("DESERIALIZATION_TEST");
        assertThat(response.getStatus()).isEqualTo(400);
        assertThat(response.getMessage()).isEqualTo("Test message");
        assertThat(response.getDetails()).isEqualTo("Test details");
        assertThat(response.getPath()).isEqualTo("/api/test");
        assertThat(response.getValidationErrors()).containsEntry("field", "error");
        assertThat(response.getErrors()).containsExactly("error1", "error2");
        assertThat(response.getContext()).containsEntry("key", "value");
    }

    @Test
    void testNullFieldsHandling() {
        // Given & When
        ErrorResponse response = ErrorResponse.of("ERROR", 400, "Message");
        
        // Then
        assertThat(response.getDetails()).isNull();
        assertThat(response.getPath()).isNull();
        assertThat(response.getValidationErrors()).isNull();
        assertThat(response.getErrors()).isNull();
        assertThat(response.getContext()).isNull();
    }

    @Test
    void testEqualsAndHashCode() {
        // Given
        LocalDateTime timestamp = LocalDateTime.now();
        
        ErrorResponse response1 = ErrorResponse.builder()
                .errorCode("TEST")
                .status(400)
                .message("Test")
                .timestamp(timestamp)
                .build();
                
        ErrorResponse response2 = ErrorResponse.builder()
                .errorCode("TEST")
                .status(400)
                .message("Test")
                .timestamp(timestamp)
                .build();
        
        // Then
        assertThat(response1).isEqualTo(response2);
        assertThat(response1.hashCode()).isEqualTo(response2.hashCode());
    }

    @Test
    void testToString() {
        // Given
        ErrorResponse response = ErrorResponse.of("TEST_ERROR", 400, "Test message");
        
        // When
        String toString = response.toString();
        
        // Then
        assertThat(toString).contains("ErrorResponse");
        assertThat(toString).contains("errorCode=TEST_ERROR");
        assertThat(toString).contains("status=400");
        assertThat(toString).contains("message=Test message");
    }

    @Test
    void testJsonIncludeNonNull() throws Exception {
        // Given
        ErrorResponse response = ErrorResponse.of("SIMPLE_ERROR", 400, "Simple message");
        
        // When
        String json = objectMapper.writeValueAsString(response);
        
        // Then - null fields should not be included in JSON
        assertThat(json).doesNotContain("\"details\":");
        assertThat(json).doesNotContain("\"path\":");
        assertThat(json).doesNotContain("\"validationErrors\":");
        assertThat(json).doesNotContain("\"errors\":");
        assertThat(json).doesNotContain("\"context\":");
    }
}
</file>

<file path="src/test/java/com/example/demo/common/dto/PageResponseTest.java">
package com.example.demo.common.dto;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;

import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * Unit tests for PageResponse class.
 */
@SpringBootTest
class PageResponseTest {

    private final ObjectMapper objectMapper = new ObjectMapper();

    @Test
    void testCreateFromSpringDataPage() {
        // Given
        List<String> content = List.of("item1", "item2", "item3");
        Pageable pageable = PageRequest.of(0, 10);
        Page<String> page = new PageImpl<>(content, pageable, 25);
        
        // When
        PageResponse<String> response = PageResponse.of(page);
        
        // Then
        assertThat(response.getContent()).isEqualTo(content);
        assertThat(response.getPage()).isEqualTo(0);
        assertThat(response.getSize()).isEqualTo(10);
        assertThat(response.getTotalElements()).isEqualTo(25);
        assertThat(response.getTotalPages()).isEqualTo(3);
        assertThat(response.isFirst()).isTrue();
        assertThat(response.isLast()).isFalse();
        assertThat(response.isHasNext()).isTrue();
        assertThat(response.isHasPrevious()).isFalse();
        assertThat(response.getNumberOfElements()).isEqualTo(3);
        assertThat(response.isEmpty()).isFalse();
    }

    @Test
    void testCreateFromCustomParameters() {
        // Given
        List<String> content = List.of("item1", "item2");
        
        // When
        PageResponse<String> response = PageResponse.of(content, 1, 5, 12, 3);
        
        // Then
        assertThat(response.getContent()).isEqualTo(content);
        assertThat(response.getPage()).isEqualTo(1);
        assertThat(response.getSize()).isEqualTo(5);
        assertThat(response.getTotalElements()).isEqualTo(12);
        assertThat(response.getTotalPages()).isEqualTo(3);
        assertThat(response.isFirst()).isFalse();
        assertThat(response.isLast()).isFalse();
        assertThat(response.isHasNext()).isTrue();
        assertThat(response.isHasPrevious()).isTrue();
        assertThat(response.getNumberOfElements()).isEqualTo(2);
        assertThat(response.isEmpty()).isFalse();
    }

    @Test
    void testFirstPage() {
        // Given
        List<String> content = List.of("item1", "item2");
        
        // When
        PageResponse<String> response = PageResponse.of(content, 0, 5, 10, 2);
        
        // Then
        assertThat(response.isFirst()).isTrue();
        assertThat(response.isLast()).isFalse();
        assertThat(response.isHasNext()).isTrue();
        assertThat(response.isHasPrevious()).isFalse();
    }

    @Test
    void testLastPage() {
        // Given
        List<String> content = List.of("item1", "item2");
        
        // When
        PageResponse<String> response = PageResponse.of(content, 1, 5, 7, 2);
        
        // Then
        assertThat(response.isFirst()).isFalse();
        assertThat(response.isLast()).isTrue();
        assertThat(response.isHasNext()).isFalse();
        assertThat(response.isHasPrevious()).isTrue();
    }

    @Test
    void testSinglePage() {
        // Given
        List<String> content = List.of("item1", "item2");
        
        // When
        PageResponse<String> response = PageResponse.of(content, 0, 5, 2, 1);
        
        // Then
        assertThat(response.isFirst()).isTrue();
        assertThat(response.isLast()).isTrue();
        assertThat(response.isHasNext()).isFalse();
        assertThat(response.isHasPrevious()).isFalse();
    }

    @Test
    void testEmptyPage() {
        // Given
        List<String> content = List.of();
        
        // When
        PageResponse<String> response = PageResponse.of(content, 0, 5, 0, 0);
        
        // Then
        assertThat(response.getContent()).isEmpty();
        assertThat(response.isEmpty()).isTrue();
        assertThat(response.getNumberOfElements()).isEqualTo(0);
        assertThat(response.getTotalElements()).isEqualTo(0);
        assertThat(response.getTotalPages()).isEqualTo(0);
    }

    @Test
    void testJsonSerialization() throws Exception {
        // Given
        List<String> content = List.of("item1", "item2");
        PageResponse<String> response = PageResponse.of(content, 0, 5, 10, 2);
        
        // When
        String json = objectMapper.writeValueAsString(response);
        
        // Then
        assertThat(json).contains("\"content\":[\"item1\",\"item2\"]");
        assertThat(json).contains("\"page\":0");
        assertThat(json).contains("\"size\":5");
        assertThat(json).contains("\"totalElements\":10");
        assertThat(json).contains("\"totalPages\":2");
        assertThat(json).contains("\"first\":true");
        assertThat(json).contains("\"last\":false");
        assertThat(json).contains("\"hasNext\":true");
        assertThat(json).contains("\"hasPrevious\":false");
        assertThat(json).contains("\"numberOfElements\":2");
        assertThat(json).contains("\"empty\":false");
    }

    @Test
    void testJsonDeserialization() throws Exception {
        // Given
        String json = """
            {
                "content": ["item1", "item2"],
                "page": 1,
                "size": 5,
                "totalElements": 15,
                "totalPages": 3,
                "first": false,
                "last": false,
                "hasNext": true,
                "hasPrevious": true,
                "numberOfElements": 2,
                "empty": false
            }
            """;
        
        // When
        PageResponse<?> response = objectMapper.readValue(json, PageResponse.class);
        
        // Then
        assertThat(response.getContent()).hasSize(2);
        assertThat(response.getPage()).isEqualTo(1);
        assertThat(response.getSize()).isEqualTo(5);
        assertThat(response.getTotalElements()).isEqualTo(15);
        assertThat(response.getTotalPages()).isEqualTo(3);
        assertThat(response.isFirst()).isFalse();
        assertThat(response.isLast()).isFalse();
        assertThat(response.isHasNext()).isTrue();
        assertThat(response.isHasPrevious()).isTrue();
        assertThat(response.getNumberOfElements()).isEqualTo(2);
        assertThat(response.isEmpty()).isFalse();
    }

    @Test
    void testBuilderPattern() {
        // Given & When
        PageResponse<String> response = PageResponse.<String>builder()
                .content(List.of("test"))
                .page(0)
                .size(10)
                .totalElements(1)
                .totalPages(1)
                .first(true)
                .last(true)
                .hasNext(false)
                .hasPrevious(false)
                .numberOfElements(1)
                .empty(false)
                .build();
        
        // Then
        assertThat(response.getContent()).containsExactly("test");
        assertThat(response.getPage()).isEqualTo(0);
        assertThat(response.getSize()).isEqualTo(10);
        assertThat(response.getTotalElements()).isEqualTo(1);
        assertThat(response.getTotalPages()).isEqualTo(1);
        assertThat(response.isFirst()).isTrue();
        assertThat(response.isLast()).isTrue();
        assertThat(response.isHasNext()).isFalse();
        assertThat(response.isHasPrevious()).isFalse();
        assertThat(response.getNumberOfElements()).isEqualTo(1);
        assertThat(response.isEmpty()).isFalse();
    }

    @Test
    void testEqualsAndHashCode() {
        // Given
        List<String> content = List.of("item1", "item2");
        PageResponse<String> response1 = PageResponse.of(content, 0, 5, 10, 2);
        PageResponse<String> response2 = PageResponse.of(content, 0, 5, 10, 2);
        
        // Then
        assertThat(response1).isEqualTo(response2);
        assertThat(response1.hashCode()).isEqualTo(response2.hashCode());
    }

    @Test
    void testToString() {
        // Given
        List<String> content = List.of("item1");
        PageResponse<String> response = PageResponse.of(content, 0, 5, 1, 1);
        
        // When
        String toString = response.toString();
        
        // Then
        assertThat(toString).contains("PageResponse");
        assertThat(toString).contains("content=[item1]");
        assertThat(toString).contains("page=0");
        assertThat(toString).contains("totalElements=1");
    }

    @Test
    void testJsonIncludeNonNull() throws Exception {
        // Given
        PageResponse<String> response = PageResponse.<String>builder()
                .content(List.of("test"))
                .page(0)
                .size(10)
                .totalElements(1)
                .totalPages(1)
                .build();
        
        // When
        String json = objectMapper.writeValueAsString(response);
        
        // Then - null fields should not be included in JSON
        assertThat(json).contains("\"content\":");
        assertThat(json).contains("\"page\":");
        assertThat(json).contains("\"size\":");
        assertThat(json).contains("\"totalElements\":");
        assertThat(json).contains("\"totalPages\":");
    }
}
</file>

<file path="src/test/java/com/example/demo/common/exception/GlobalExceptionHandlerTest.java">
package com.example.demo.common.exception;

import com.example.demo.common.dto.ApiResponse;
import com.example.demo.common.dto.ErrorResponse;
import com.example.demo.department.exception.DepartmentNotFoundException;
import com.example.demo.employee.exception.EmployeeNotFoundException;
import com.example.demo.security.exception.UserNotFoundException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.boot.test.context.TestConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Import;
import org.springframework.http.MediaType;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.test.context.support.WithMockUser;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.MvcResult;
import org.springframework.validation.BindException;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import jakarta.validation.ConstraintViolation;
import jakarta.validation.ConstraintViolationException;
import jakarta.validation.Path;
import java.util.Set;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

/**
 * Integration tests for GlobalExceptionHandler.
 */
@WebMvcTest(GlobalExceptionHandlerTest.TestController.class)
@Import(GlobalExceptionHandlerTest.TestConfig.class)
class GlobalExceptionHandlerTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private ObjectMapper objectMapper;

    @TestConfiguration
    static class TestConfig {
        @Bean
        public GlobalExceptionHandler globalExceptionHandler() {
            return new GlobalExceptionHandler();
        }
    }

    @RestController
    @RequestMapping("/test")
    static class TestController {

        @GetMapping("/business-exception")
        public void throwBusinessException() {
            throw new BusinessException("Business rule violated");
        }

        @GetMapping("/validation-exception")
        public void throwValidationException() {
            throw new ValidationException("Validation failed");
        }

        @GetMapping("/employee-not-found")
        public void throwEmployeeNotFoundException() {
            throw new EmployeeNotFoundException("Employee not found");
        }

        @GetMapping("/department-not-found")
        public void throwDepartmentNotFoundException() {
            throw new DepartmentNotFoundException("Department not found");
        }

        @GetMapping("/user-not-found")
        public void throwUserNotFoundException() {
            throw new UserNotFoundException("User not found");
        }

        @GetMapping("/access-denied")
        public void throwAccessDeniedException() {
            throw new AccessDeniedException("Access denied");
        }

        @GetMapping("/constraint-violation")
        public void throwConstraintViolationException() {
            ConstraintViolation<?> violation = mock(ConstraintViolation.class);
            Path propertyPath = mock(Path.class);
            when(violation.getPropertyPath()).thenReturn(propertyPath);
            when(propertyPath.toString()).thenReturn("email");
            when(violation.getMessage()).thenReturn("Invalid email format");
            
            throw new ConstraintViolationException("Validation failed", Set.of(violation));
        }

        @GetMapping("/bind-exception")
        public void throwBindException() {
            BindException bindException = new BindException("target", "objectName");
            bindException.addError(new FieldError("objectName", "name", "Name is required"));
            bindException.addError(new FieldError("objectName", "email", "Email is invalid"));
            throw bindException;
        }

        @GetMapping("/runtime-exception")
        public void throwRuntimeException() {
            throw new RuntimeException("Unexpected error occurred");
        }

        @GetMapping("/illegal-argument")
        public void throwIllegalArgumentException() {
            throw new IllegalArgumentException("Invalid argument provided");
        }
    }

    @Test
    @WithMockUser
    void testBusinessExceptionHandling() throws Exception {
        // When & Then
        MvcResult result = mockMvc.perform(get("/test/business-exception"))
                .andExpect(status().isBadRequest())
                .andReturn();

        String responseBody = result.getResponse().getContentAsString();
        ApiResponse<?> response = objectMapper.readValue(responseBody, ApiResponse.class);

        assertThat(response.isSuccess()).isFalse();
        assertThat(response.getMessage()).isEqualTo("Business rule violated");
        assertThat(response.getError()).isNotNull();
    }

    @Test
    @WithMockUser
    void testValidationExceptionHandling() throws Exception {
        // When & Then
        MvcResult result = mockMvc.perform(get("/test/validation-exception"))
                .andExpect(status().isBadRequest())
                .andReturn();

        String responseBody = result.getResponse().getContentAsString();
        ApiResponse<?> response = objectMapper.readValue(responseBody, ApiResponse.class);

        assertThat(response.isSuccess()).isFalse();
        assertThat(response.getMessage()).isEqualTo("Validation failed");
    }

    @Test
    @WithMockUser
    void testEmployeeNotFoundExceptionHandling() throws Exception {
        // When & Then
        MvcResult result = mockMvc.perform(get("/test/employee-not-found"))
                .andExpect(status().isNotFound())
                .andReturn();

        String responseBody = result.getResponse().getContentAsString();
        ApiResponse<?> response = objectMapper.readValue(responseBody, ApiResponse.class);

        assertThat(response.isSuccess()).isFalse();
        assertThat(response.getMessage()).isEqualTo("Employee not found");
    }

    @Test
    @WithMockUser
    void testDepartmentNotFoundExceptionHandling() throws Exception {
        // When & Then
        MvcResult result = mockMvc.perform(get("/test/department-not-found"))
                .andExpect(status().isNotFound())
                .andReturn();

        String responseBody = result.getResponse().getContentAsString();
        ApiResponse<?> response = objectMapper.readValue(responseBody, ApiResponse.class);

        assertThat(response.isSuccess()).isFalse();
        assertThat(response.getMessage()).isEqualTo("Department not found");
    }

    @Test
    @WithMockUser
    void testUserNotFoundExceptionHandling() throws Exception {
        // When & Then
        MvcResult result = mockMvc.perform(get("/test/user-not-found"))
                .andExpect(status().isNotFound())
                .andReturn();

        String responseBody = result.getResponse().getContentAsString();
        ApiResponse<?> response = objectMapper.readValue(responseBody, ApiResponse.class);

        assertThat(response.isSuccess()).isFalse();
        assertThat(response.getMessage()).isEqualTo("User not found");
    }

    @Test
    @WithMockUser
    void testAccessDeniedExceptionHandling() throws Exception {
        // When & Then
        MvcResult result = mockMvc.perform(get("/test/access-denied"))
                .andExpect(status().isForbidden())
                .andReturn();

        String responseBody = result.getResponse().getContentAsString();
        ApiResponse<?> response = objectMapper.readValue(responseBody, ApiResponse.class);

        assertThat(response.isSuccess()).isFalse();
        assertThat(response.getMessage()).isEqualTo("Access denied");
    }

    @Test
    @WithMockUser
    void testConstraintViolationExceptionHandling() throws Exception {
        // When & Then
        MvcResult result = mockMvc.perform(get("/test/constraint-violation"))
                .andExpect(status().isBadRequest())
                .andReturn();

        String responseBody = result.getResponse().getContentAsString();
        ApiResponse<?> response = objectMapper.readValue(responseBody, ApiResponse.class);

        assertThat(response.isSuccess()).isFalse();
        assertThat(response.getMessage()).contains("Validation failed");
        assertThat(response.getError()).isNotNull();
    }

    @Test
    @WithMockUser
    void testBindExceptionHandling() throws Exception {
        // When & Then
        MvcResult result = mockMvc.perform(get("/test/bind-exception"))
                .andExpect(status().isBadRequest())
                .andReturn();

        String responseBody = result.getResponse().getContentAsString();
        ApiResponse<?> response = objectMapper.readValue(responseBody, ApiResponse.class);

        assertThat(response.isSuccess()).isFalse();
        assertThat(response.getMessage()).contains("Validation failed");
        assertThat(response.getError()).isNotNull();
    }

    @Test
    @WithMockUser
    void testRuntimeExceptionHandling() throws Exception {
        // When & Then
        MvcResult result = mockMvc.perform(get("/test/runtime-exception"))
                .andExpect(status().isInternalServerError())
                .andReturn();

        String responseBody = result.getResponse().getContentAsString();
        ApiResponse<?> response = objectMapper.readValue(responseBody, ApiResponse.class);

        assertThat(response.isSuccess()).isFalse();
        assertThat(response.getMessage()).isEqualTo("An unexpected error occurred");
    }

    @Test
    @WithMockUser
    void testIllegalArgumentExceptionHandling() throws Exception {
        // When & Then
        MvcResult result = mockMvc.perform(get("/test/illegal-argument"))
                .andExpect(status().isBadRequest())
                .andReturn();

        String responseBody = result.getResponse().getContentAsString();
        ApiResponse<?> response = objectMapper.readValue(responseBody, ApiResponse.class);

        assertThat(response.isSuccess()).isFalse();
        assertThat(response.getMessage()).isEqualTo("Invalid argument provided");
    }

    @Test
    @WithMockUser
    void testResponseStructure() throws Exception {
        // When & Then
        MvcResult result = mockMvc.perform(get("/test/business-exception"))
                .andExpect(status().isBadRequest())
                .andReturn();

        String responseBody = result.getResponse().getContentAsString();
        ApiResponse<?> response = objectMapper.readValue(responseBody, ApiResponse.class);

        // Verify response structure
        assertThat(response.isSuccess()).isFalse();
        assertThat(response.getMessage()).isNotNull();
        assertThat(response.getTimestamp()).isNotNull();
        assertThat(response.getPath()).isNotNull();
        assertThat(response.getError()).isNotNull();
        
        ErrorResponse error = response.getError();
        assertThat(error.getErrorCode()).isNotNull();
        assertThat(error.getStatus()).isEqualTo(400);
        assertThat(error.getMessage()).isNotNull();
        assertThat(error.getTimestamp()).isNotNull();
    }

    @Test
    @WithMockUser
    void testContentTypeIsJson() throws Exception {
        // When & Then
        mockMvc.perform(get("/test/business-exception"))
                .andExpect(status().isBadRequest())
                .andExpect(result -> {
                    String contentType = result.getResponse().getContentType();
                    assertThat(contentType).contains(MediaType.APPLICATION_JSON_VALUE);
                });
    }
}
</file>

<file path="src/test/java/com/example/demo/common/util/ValidationUtilTest.java">
package com.example.demo.common.util;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

import java.time.LocalDate;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * Unit tests for ValidationUtil class.
 */
@SpringBootTest
class ValidationUtilTest {

    @Test
    void testValidEmployeeNumber() {
        // Valid employee numbers
        assertThat(ValidationUtil.isValidEmployeeNumber("EMP123456")).isTrue();
        assertThat(ValidationUtil.isValidEmployeeNumber("EMP000001")).isTrue();
        assertThat(ValidationUtil.isValidEmployeeNumber("EMP999999")).isTrue();
    }

    @Test
    void testInvalidEmployeeNumber() {
        // Invalid employee numbers
        assertThat(ValidationUtil.isValidEmployeeNumber(null)).isFalse();
        assertThat(ValidationUtil.isValidEmployeeNumber("")).isFalse();
        assertThat(ValidationUtil.isValidEmployeeNumber("EMP12345")).isFalse(); // Too short
        assertThat(ValidationUtil.isValidEmployeeNumber("EMP1234567")).isFalse(); // Too long
        assertThat(ValidationUtil.isValidEmployeeNumber("emp123456")).isFalse(); // Lowercase
        assertThat(ValidationUtil.isValidEmployeeNumber("EMPLOYEE123456")).isFalse(); // Wrong prefix
        assertThat(ValidationUtil.isValidEmployeeNumber("EMP12345A")).isFalse(); // Contains letter
        assertThat(ValidationUtil.isValidEmployeeNumber("123456")).isFalse(); // No prefix
    }

    @Test
    void testValidDepartmentCode() {
        // Valid department codes
        assertThat(ValidationUtil.isValidDepartmentCode("DEPT1234")).isTrue();
        assertThat(ValidationUtil.isValidDepartmentCode("DEPT0001")).isTrue();
        assertThat(ValidationUtil.isValidDepartmentCode("DEPT9999")).isTrue();
    }

    @Test
    void testInvalidDepartmentCode() {
        // Invalid department codes
        assertThat(ValidationUtil.isValidDepartmentCode(null)).isFalse();
        assertThat(ValidationUtil.isValidDepartmentCode("")).isFalse();
        assertThat(ValidationUtil.isValidDepartmentCode("DEPT123")).isFalse(); // Too short
        assertThat(ValidationUtil.isValidDepartmentCode("DEPT12345")).isFalse(); // Too long
        assertThat(ValidationUtil.isValidDepartmentCode("dept1234")).isFalse(); // Lowercase
        assertThat(ValidationUtil.isValidDepartmentCode("DEPARTMENT1234")).isFalse(); // Wrong prefix
        assertThat(ValidationUtil.isValidDepartmentCode("DEPT123A")).isFalse(); // Contains letter
    }

    @Test
    void testValidPositionCode() {
        // Valid position codes
        assertThat(ValidationUtil.isValidPositionCode("POS1234")).isTrue();
        assertThat(ValidationUtil.isValidPositionCode("POS0001")).isTrue();
        assertThat(ValidationUtil.isValidPositionCode("POS9999")).isTrue();
    }

    @Test
    void testInvalidPositionCode() {
        // Invalid position codes
        assertThat(ValidationUtil.isValidPositionCode(null)).isFalse();
        assertThat(ValidationUtil.isValidPositionCode("")).isFalse();
        assertThat(ValidationUtil.isValidPositionCode("POS123")).isFalse(); // Too short
        assertThat(ValidationUtil.isValidPositionCode("POS12345")).isFalse(); // Too long
        assertThat(ValidationUtil.isValidPositionCode("pos1234")).isFalse(); // Lowercase
        assertThat(ValidationUtil.isValidPositionCode("POSITION1234")).isFalse(); // Wrong prefix
        assertThat(ValidationUtil.isValidPositionCode("POS123A")).isFalse(); // Contains letter
    }

    @Test
    void testValidDateOfBirth() {
        LocalDate now = LocalDate.now();
        
        // Valid dates of birth
        assertThat(ValidationUtil.isValidDateOfBirth(now.minusYears(25))).isTrue(); // 25 years old
        assertThat(ValidationUtil.isValidDateOfBirth(now.minusYears(16))).isTrue(); // Minimum age
        assertThat(ValidationUtil.isValidDateOfBirth(now.minusYears(65))).isTrue(); // Retirement age
        assertThat(ValidationUtil.isValidDateOfBirth(now.minusYears(99))).isTrue(); // Very old but valid
    }

    @Test
    void testInvalidDateOfBirth() {
        LocalDate now = LocalDate.now();
        
        // Invalid dates of birth
        assertThat(ValidationUtil.isValidDateOfBirth(null)).isFalse();
        assertThat(ValidationUtil.isValidDateOfBirth(now.minusYears(15))).isFalse(); // Too young
        assertThat(ValidationUtil.isValidDateOfBirth(now.minusYears(101))).isFalse(); // Too old
        assertThat(ValidationUtil.isValidDateOfBirth(now.plusDays(1))).isFalse(); // Future date
        assertThat(ValidationUtil.isValidDateOfBirth(now)).isFalse(); // Today
    }

    @Test
    void testValidHireDate() {
        LocalDate now = LocalDate.now();
        
        // Valid hire dates
        assertThat(ValidationUtil.isValidHireDate(now.minusYears(1))).isTrue(); // 1 year ago
        assertThat(ValidationUtil.isValidHireDate(now.minusDays(1))).isTrue(); // Yesterday
        assertThat(ValidationUtil.isValidHireDate(now.plusDays(15))).isTrue(); // Future hire date
        assertThat(ValidationUtil.isValidHireDate(now.minusYears(10))).isTrue(); // 10 years ago
    }

    @Test
    void testInvalidHireDate() {
        LocalDate now = LocalDate.now();
        
        // Invalid hire dates
        assertThat(ValidationUtil.isValidHireDate(null)).isFalse();
        assertThat(ValidationUtil.isValidHireDate(now.minusYears(51))).isFalse(); // Too far in past
        assertThat(ValidationUtil.isValidHireDate(now.plusDays(31))).isFalse(); // Too far in future
    }

    @Test
    void testValidSalary() {
        // Valid salaries
        assertThat(ValidationUtil.isValidSalary(30000.0)).isTrue();
        assertThat(ValidationUtil.isValidSalary(50000.50)).isTrue();
        assertThat(ValidationUtil.isValidSalary(999999.99)).isTrue();
        assertThat(ValidationUtil.isValidSalary(1.0)).isTrue(); // Minimum positive
    }

    @Test
    void testInvalidSalary() {
        // Invalid salaries
        assertThat(ValidationUtil.isValidSalary(null)).isFalse();
        assertThat(ValidationUtil.isValidSalary(0.0)).isFalse(); // Zero
        assertThat(ValidationUtil.isValidSalary(-1000.0)).isFalse(); // Negative
        assertThat(ValidationUtil.isValidSalary(1000001.0)).isFalse(); // Too high
    }

    @Test
    void testValidSalaryRange() {
        // Valid salary ranges
        assertThat(ValidationUtil.isValidSalaryRange(30000.0, 50000.0)).isTrue();
        assertThat(ValidationUtil.isValidSalaryRange(40000.0, 40000.0)).isTrue(); // Equal min/max
        assertThat(ValidationUtil.isValidSalaryRange(1.0, 999999.0)).isTrue();
    }

    @Test
    void testInvalidSalaryRange() {
        // Invalid salary ranges
        assertThat(ValidationUtil.isValidSalaryRange(null, 50000.0)).isFalse();
        assertThat(ValidationUtil.isValidSalaryRange(30000.0, null)).isFalse();
        assertThat(ValidationUtil.isValidSalaryRange(50000.0, 30000.0)).isFalse(); // Min > Max
        assertThat(ValidationUtil.isValidSalaryRange(0.0, 50000.0)).isFalse(); // Zero min
        assertThat(ValidationUtil.isValidSalaryRange(30000.0, 0.0)).isFalse(); // Zero max
        assertThat(ValidationUtil.isValidSalaryRange(-1000.0, 50000.0)).isFalse(); // Negative min
    }

    @Test
    void testValidPassword() {
        // Valid passwords
        assertThat(ValidationUtil.isValidPassword("Password123!")).isTrue();
        assertThat(ValidationUtil.isValidPassword("MySecure@Pass1")).isTrue();
        assertThat(ValidationUtil.isValidPassword("Complex#Pass123")).isTrue();
        assertThat(ValidationUtil.isValidPassword("Aa1!Bb2@")).isTrue(); // Minimum length with all requirements
    }

    @Test
    void testInvalidPassword() {
        // Invalid passwords
        assertThat(ValidationUtil.isValidPassword(null)).isFalse();
        assertThat(ValidationUtil.isValidPassword("")).isFalse();
        assertThat(ValidationUtil.isValidPassword("short")).isFalse(); // Too short
        assertThat(ValidationUtil.isValidPassword("password123!")).isFalse(); // No uppercase
        assertThat(ValidationUtil.isValidPassword("PASSWORD123!")).isFalse(); // No lowercase
        assertThat(ValidationUtil.isValidPassword("Password!")).isFalse(); // No digit
        assertThat(ValidationUtil.isValidPassword("Password123")).isFalse(); // No special character
        assertThat(ValidationUtil.isValidPassword("Password")).isFalse(); // Missing digit and special char
    }

    @Test
    void testValidUsername() {
        // Valid usernames
        assertThat(ValidationUtil.isValidUsername("john_doe")).isTrue();
        assertThat(ValidationUtil.isValidUsername("user123")).isTrue();
        assertThat(ValidationUtil.isValidUsername("admin")).isTrue();
        assertThat(ValidationUtil.isValidUsername("test_user_123")).isTrue();
        assertThat(ValidationUtil.isValidUsername("a1b")).isTrue(); // Minimum length
        assertThat(ValidationUtil.isValidUsername("a123456789012345678")).isTrue(); // Maximum length
    }

    @Test
    void testInvalidUsername() {
        // Invalid usernames
        assertThat(ValidationUtil.isValidUsername(null)).isFalse();
        assertThat(ValidationUtil.isValidUsername("")).isFalse();
        assertThat(ValidationUtil.isValidUsername("ab")).isFalse(); // Too short
        assertThat(ValidationUtil.isValidUsername("a12345678901234567890")).isFalse(); // Too long
        assertThat(ValidationUtil.isValidUsername("user-name")).isFalse(); // Contains hyphen
        assertThat(ValidationUtil.isValidUsername("user.name")).isFalse(); // Contains dot
        assertThat(ValidationUtil.isValidUsername("user name")).isFalse(); // Contains space
        assertThat(ValidationUtil.isValidUsername("user@name")).isFalse(); // Contains special char
    }

    @Test
    void testValidName() {
        // Valid names
        assertThat(ValidationUtil.isValidName("John")).isTrue();
        assertThat(ValidationUtil.isValidName("John Doe")).isTrue();
        assertThat(ValidationUtil.isValidName("Mary Jane Smith")).isTrue();
        assertThat(ValidationUtil.isValidName("Jean-Pierre")).isFalse(); // Contains hyphen - this should be false based on current regex
        assertThat(ValidationUtil.isValidName("Anne Marie")).isTrue();
    }

    @Test
    void testInvalidName() {
        // Invalid names
        assertThat(ValidationUtil.isValidName(null)).isFalse();
        assertThat(ValidationUtil.isValidName("")).isFalse();
        assertThat(ValidationUtil.isValidName("A")).isFalse(); // Too short
        assertThat(ValidationUtil.isValidName("J")).isFalse(); // Too short
        assertThat(ValidationUtil.isValidName("John123")).isFalse(); // Contains numbers
        assertThat(ValidationUtil.isValidName("John@Doe")).isFalse(); // Contains special chars
        assertThat(ValidationUtil.isValidName("   ")).isFalse(); // Only spaces
        assertThat(ValidationUtil.isValidName("A".repeat(51))).isFalse(); // Too long
    }

    @Test
    void testValidPostalCode() {
        // Valid postal codes (various formats)
        assertThat(ValidationUtil.isValidPostalCode("12345")).isTrue(); // US ZIP
        assertThat(ValidationUtil.isValidPostalCode("K1A 0A6")).isTrue(); // Canadian
        assertThat(ValidationUtil.isValidPostalCode("SW1A 1AA")).isTrue(); // UK
        assertThat(ValidationUtil.isValidPostalCode("12345-6789")).isTrue(); // US ZIP+4
        assertThat(ValidationUtil.isValidPostalCode("ABC123")).isTrue(); // Mixed
        assertThat(ValidationUtil.isValidPostalCode("123")).isTrue(); // Minimum length
        assertThat(ValidationUtil.isValidPostalCode("1234567890")).isTrue(); // Maximum length
    }

    @Test
    void testInvalidPostalCode() {
        // Invalid postal codes
        assertThat(ValidationUtil.isValidPostalCode(null)).isFalse();
        assertThat(ValidationUtil.isValidPostalCode("")).isFalse();
        assertThat(ValidationUtil.isValidPostalCode("12")).isFalse(); // Too short
        assertThat(ValidationUtil.isValidPostalCode("12345678901")).isFalse(); // Too long
        assertThat(ValidationUtil.isValidPostalCode("12345@6789")).isFalse(); // Invalid character
        assertThat(ValidationUtil.isValidPostalCode("   ")).isFalse(); // Only spaces
    }
}
</file>

<file path=".gitignore">
.vscode
target
</file>

<file path=".kiro/specs/react-frontend/design.md">
# React Frontend Design Document

## Overview

This document outlines the design for a modern React frontend application that interfaces with the existing Spring Boot employee management system. The frontend will be built using React 18+ with TypeScript, providing a responsive, accessible, and feature-rich user interface for managing employees, departments, authentication, real-time chat, email communications, notifications, payroll, and permissions.

The application will follow modern React patterns including functional components, hooks, and a component-driven architecture. It will implement real-time features using WebSocket connections and provide an intuitive user experience across desktop and mobile devices.

## Architecture

### High-Level Architecture

```mermaid
graph TB
    subgraph "Frontend (React)"
        A[React App] --> B[Router]
        B --> C[Layout Components]
        C --> D[Feature Components]
        D --> E[UI Components]
        
        F[State Management] --> G[Zustand Stores]
        F --> H[TanStack Query]
        
        I[Services] --> J[API Client]
        I --> K[WebSocket Client]
        I --> L[Auth Service]
    end
    
    subgraph "Backend (Spring Boot)"
        M[REST APIs]
        N[WebSocket Endpoints]
        O[Authentication]
    end
    
    J --> M
    K --> N
    L --> O
```

### Technology Stack

- **Core Framework**: React 18+ with TypeScript
- **Build Tool**: Vite for fast development and optimized builds
- **State Management**: 
  - Zustand for global state management
  - TanStack Query (React Query) for server state management
- **UI Library**: Mantine for comprehensive component library
- **Routing**: React Router v6 for client-side routing
- **Real-time Communication**: Socket.IO client for WebSocket connections
- **Form Management**: React Hook Form with Zod validation
- **Styling**: CSS Modules with Mantine's theming system
- **Testing**: Vitest + React Testing Library
- **Code Quality**: ESLint + Prettier + TypeScript strict mode

### Project Structure

```
src/
├── components/           # Reusable UI components
│   ├── ui/              # Basic UI components
│   ├── forms/           # Form components
│   └── layout/          # Layout components
├── features/            # Feature-based modules
│   ├── auth/            # Authentication feature
│   ├── employees/       # Employee management
│   ├── departments/     # Department management
│   ├── chat/            # Chat functionality
│   ├── email/           # Email management
│   ├── notifications/   # Notification system
│   └── permissions/     # Permission management
├── hooks/               # Custom React hooks
├── services/            # API and external services
├── stores/              # Zustand stores
├── types/               # TypeScript type definitions
├── utils/               # Utility functions
├── constants/           # Application constants
└── assets/              # Static assets
```

## Components and Interfaces

### Core Layout Components

#### AppShell
- **Purpose**: Main application wrapper with navigation and header
- **Props**: `user: User`, `children: ReactNode`
- **Features**: Responsive sidebar, header with notifications, user menu
- **State**: Navigation collapse state, theme preferences

#### Navigation
- **Purpose**: Role-based navigation menu
- **Props**: `userRoles: string[]`, `collapsed: boolean`
- **Features**: Hierarchical menu structure, active route highlighting
- **Permissions**: Dynamic menu items based on user permissions

#### Header
- **Purpose**: Top navigation bar with user actions
- **Props**: `user: User`, `notificationCount: number`
- **Features**: Search bar, notification dropdown, user profile menu
- **Actions**: Logout, profile settings, theme toggle

### Feature Components

#### Authentication Module

**LoginForm**
- **Props**: `onSubmit: (credentials: LoginRequest) => void`
- **Validation**: Email format, password requirements
- **Features**: Remember me, forgot password link, loading states

**RegisterForm**
- **Props**: `onSubmit: (data: RegisterRequest) => void`
- **Validation**: Email uniqueness, password confirmation, required fields
- **Features**: Real-time validation, terms acceptance

#### Employee Management Module

**EmployeeList**
- **Props**: `employees: Employee[]`, `loading: boolean`, `onEdit: (id: number) => void`
- **Features**: Pagination, sorting, filtering, bulk actions
- **Search**: Multi-criteria search with debounced input

**EmployeeForm**
- **Props**: `employee?: Employee`, `onSubmit: (data: Employee) => void`
- **Validation**: Required fields, email format, phone format
- **Features**: File upload for profile picture, department selection

**EmployeeImport**
- **Props**: `onImport: (file: File) => void`
- **Features**: Drag-and-drop file upload, template download, validation preview

#### Department Management Module

**DepartmentTree**
- **Props**: `departments: Department[]`, `onSelect: (dept: Department) => void`
- **Features**: Expandable tree view, drag-and-drop reordering
- **Actions**: Add, edit, delete, move departments

**DepartmentForm**
- **Props**: `department?: Department`, `parentOptions: Department[]`
- **Validation**: Name uniqueness, parent relationship validation
- **Features**: Parent department selection, description editor

#### Chat Module

**ChatInterface**
- **Props**: `currentUser: User`
- **Features**: Real-time messaging, conversation list, message history
- **WebSocket**: Live message updates, typing indicators, online status

**ConversationList**
- **Props**: `conversations: Conversation[]`, `unreadCounts: Record<string, number>`
- **Features**: Search conversations, unread badges, last message preview

**MessageInput**
- **Props**: `onSend: (message: string) => void`, `disabled: boolean`
- **Features**: Emoji picker, file attachments, message formatting

#### Email Module

**EmailComposer**
- **Props**: `templates: EmailTemplate[]`, `recipients: User[]`
- **Features**: Template selection, recipient picker, variable substitution
- **Validation**: Recipient validation, content requirements

**EmailTemplateSelector**
- **Props**: `templates: EmailTemplate[]`, `onSelect: (template: EmailTemplate) => void`
- **Features**: Template preview, variable documentation

#### Notification Module

**NotificationDropdown**
- **Props**: `notifications: Notification[]`, `onMarkRead: (id: number) => void`
- **Features**: Real-time updates, mark as read, notification grouping

**NotificationItem**
- **Props**: `notification: Notification`, `onClick: () => void`
- **Features**: Icon based on type, timestamp formatting, read status

### UI Components

#### DataTable
- **Props**: `data: T[]`, `columns: Column<T>[]`, `pagination: PaginationConfig`
- **Features**: Sorting, filtering, row selection, export functionality
- **Accessibility**: Keyboard navigation, screen reader support

#### FormField
- **Props**: `label: string`, `error?: string`, `required?: boolean`, `children: ReactNode`
- **Features**: Error display, required indicator, help text
- **Validation**: Integration with React Hook Form

#### LoadingSpinner
- **Props**: `size?: 'sm' | 'md' | 'lg'`, `overlay?: boolean`
- **Features**: Multiple sizes, overlay mode for full-page loading
- **Accessibility**: Proper ARIA labels

## Data Models

### Core Types

```typescript
interface User {
  id: number;
  username: string;
  email: string;
  firstName?: string;
  lastName?: string;
  roles: Role[];
  enabled: boolean;
  createdAt: string;
  updatedAt: string;
}

interface Employee {
  id: number;
  employeeNumber: string;
  firstName: string;
  lastName: string;
  email: string;
  phone?: string;
  department: Department;
  position: Position;
  hireDate: string;
  salary?: number;
  status: EmployeeStatus;
  profilePicture?: string;
}

interface Department {
  id: number;
  name: string;
  description?: string;
  parentId?: number;
  children?: Department[];
  employeeCount: number;
  createdAt: string;
}

interface ChatMessage {
  id: number;
  content: string;
  senderId: number;
  senderName: string;
  recipientId: number;
  recipientName: string;
  createdAt: string;
  read: boolean;
}

interface Notification {
  id: number;
  title: string;
  message: string;
  type: NotificationType;
  userId: number;
  read: boolean;
  createdAt: string;
  actionUrl?: string;
}
```

### API Response Types

```typescript
interface ApiResponse<T> {
  data: T;
  message?: string;
  success: boolean;
}

interface PaginatedResponse<T> {
  content: T[];
  totalElements: number;
  totalPages: number;
  size: number;
  number: number;
  first: boolean;
  last: boolean;
}

interface AuthResponse {
  token: string;
  id: number;
  username: string;
  email: string;
  roles: string[];
}
```

## Error Handling

### Error Boundary Strategy

```typescript
interface ErrorBoundaryState {
  hasError: boolean;
  error?: Error;
  errorInfo?: ErrorInfo;
}

class AppErrorBoundary extends Component<PropsWithChildren, ErrorBoundaryState> {
  // Catch JavaScript errors anywhere in the child component tree
  // Log error details and display fallback UI
  // Provide error reporting functionality
}
```

### API Error Handling

- **Network Errors**: Display retry mechanism with exponential backoff
- **Authentication Errors**: Automatic token refresh or redirect to login
- **Validation Errors**: Field-level error display with clear messaging
- **Server Errors**: User-friendly error messages with error codes
- **Rate Limiting**: Queue requests and display appropriate feedback

### Form Validation

```typescript
const employeeSchema = z.object({
  firstName: z.string().min(1, "First name is required"),
  lastName: z.string().min(1, "Last name is required"),
  email: z.string().email("Invalid email format"),
  phone: z.string().optional(),
  departmentId: z.number().min(1, "Department is required"),
  hireDate: z.string().min(1, "Hire date is required")
});
```

## Testing Strategy

### Unit Testing
- **Components**: Test rendering, props handling, user interactions
- **Hooks**: Test custom hook logic and state management
- **Services**: Test API calls, data transformation, error handling
- **Utilities**: Test helper functions and data manipulation

### Integration Testing
- **Feature Flows**: Test complete user workflows
- **API Integration**: Test service layer integration with mock APIs
- **State Management**: Test store interactions and data flow

### E2E Testing
- **Critical Paths**: Authentication, employee CRUD, chat functionality
- **Cross-browser**: Ensure compatibility across major browsers
- **Responsive**: Test mobile and desktop layouts

### Testing Tools
- **Vitest**: Fast unit test runner with TypeScript support
- **React Testing Library**: Component testing with user-centric approach
- **MSW**: Mock Service Worker for API mocking
- **Playwright**: End-to-end testing framework

## Performance Optimization

### Code Splitting
- **Route-based**: Lazy load feature modules
- **Component-based**: Dynamic imports for heavy components
- **Library-based**: Separate vendor bundles for better caching

### State Management Optimization
- **Selective Subscriptions**: Use Zustand selectors to prevent unnecessary re-renders
- **Query Optimization**: Implement proper caching strategies with TanStack Query
- **Memoization**: Use React.memo and useMemo for expensive computations

### Bundle Optimization
- **Tree Shaking**: Remove unused code from final bundle
- **Asset Optimization**: Compress images and optimize static assets
- **CDN Integration**: Serve static assets from CDN for better performance

### Real-time Performance
- **WebSocket Management**: Implement connection pooling and automatic reconnection
- **Message Batching**: Batch multiple updates to reduce re-renders
- **Virtual Scrolling**: Implement for large lists (chat history, employee lists)

## Security Considerations

### Authentication & Authorization
- **JWT Storage**: Secure token storage using httpOnly cookies or secure localStorage
- **Token Refresh**: Automatic token refresh with proper error handling
- **Role-based Access**: Component-level permission checks
- **Route Protection**: Protected routes based on user roles

### Data Security
- **Input Sanitization**: Sanitize all user inputs to prevent XSS
- **CSRF Protection**: Implement CSRF tokens for state-changing operations
- **Content Security Policy**: Implement CSP headers to prevent code injection
- **Sensitive Data**: Mask sensitive information in forms and displays

### API Security
- **Request Validation**: Validate all API requests on the client side
- **Error Information**: Avoid exposing sensitive error information
- **Rate Limiting**: Implement client-side rate limiting for API calls
- **HTTPS Only**: Ensure all communications use HTTPS

## Accessibility Features

### WCAG 2.1 Compliance
- **Keyboard Navigation**: Full keyboard accessibility for all interactive elements
- **Screen Reader Support**: Proper ARIA labels and descriptions
- **Color Contrast**: Ensure sufficient color contrast ratios
- **Focus Management**: Proper focus indicators and management

### Responsive Design
- **Mobile First**: Design for mobile devices first, then enhance for desktop
- **Touch Targets**: Ensure touch targets are at least 44px in size
- **Viewport Meta**: Proper viewport configuration for mobile devices
- **Flexible Layouts**: Use CSS Grid and Flexbox for responsive layouts

### Internationalization
- **Text Externalization**: All user-facing text in translation files
- **RTL Support**: Support for right-to-left languages
- **Date/Time Formatting**: Locale-aware date and time formatting
- **Number Formatting**: Locale-aware number and currency formatting
</file>

<file path=".kiro/specs/react-frontend/requirements.md">
# Requirements Document

## Introduction

This document outlines the requirements for developing a modern React frontend application for the existing Spring Boot employee management system. The frontend will provide a comprehensive user interface for managing employees, departments, authentication, real-time chat, email communications, notifications, payroll, and permissions. The application will be responsive, accessible, and provide an intuitive user experience for HR managers, administrators, and regular users.

## Requirements

### Requirement 1

**User Story:** As a user, I want to authenticate securely with the system, so that I can access features based on my role and permissions.

#### Acceptance Criteria

1. WHEN a user visits the application THEN the system SHALL display a login form
2. WHEN a user enters valid credentials THEN the system SHALL authenticate them and redirect to the dashboard
3. WHEN a user enters invalid credentials THEN the system SHALL display an error message
4. WHEN a user is authenticated THEN the system SHALL store the JWT token securely
5. WHEN a user's token expires THEN the system SHALL automatically refresh the token or redirect to login
6. WHEN a user logs out THEN the system SHALL clear all authentication data and redirect to login
7. WHEN a new user registers THEN the system SHALL validate the form data and create the account

### Requirement 2

**User Story:** As an authenticated user, I want to navigate through different sections of the application, so that I can access the features I need efficiently.

#### Acceptance Criteria

1. WHEN a user is authenticated THEN the system SHALL display a navigation menu with role-based options
2. WHEN a user clicks on a navigation item THEN the system SHALL route to the corresponding page
3. WHEN a user is on a specific page THEN the system SHALL highlight the active navigation item
4. WHEN a user has insufficient permissions THEN the system SHALL hide or disable restricted navigation items
5. WHEN the application loads THEN the system SHALL display a responsive sidebar navigation on desktop
6. WHEN viewed on mobile devices THEN the system SHALL provide a collapsible hamburger menu

### Requirement 3

**User Story:** As an HR manager or admin, I want to manage employee records, so that I can maintain accurate employee information.

#### Acceptance Criteria

1. WHEN viewing the employees page THEN the system SHALL display a paginated list of employees
2. WHEN searching for employees THEN the system SHALL filter results based on multiple criteria
3. WHEN creating a new employee THEN the system SHALL validate all required fields
4. WHEN editing an employee THEN the system SHALL pre-populate the form with existing data
5. WHEN deleting an employee THEN the system SHALL request confirmation before deletion
6. WHEN importing employees THEN the system SHALL support Excel file upload with validation
7. WHEN exporting employees THEN the system SHALL generate an Excel file with selected data
8. WHEN viewing employee details THEN the system SHALL display comprehensive information in a readable format

### Requirement 4

**User Story:** As an HR manager or admin, I want to manage department structure, so that I can organize employees effectively.

#### Acceptance Criteria

1. WHEN viewing departments THEN the system SHALL display a hierarchical tree structure
2. WHEN creating a department THEN the system SHALL validate the department name and parent relationship
3. WHEN editing a department THEN the system SHALL allow updating name, description, and parent
4. WHEN deleting a department THEN the system SHALL check for dependencies and request confirmation
5. WHEN moving a department THEN the system SHALL update the hierarchy and validate the new structure
6. WHEN viewing department details THEN the system SHALL show associated employees and subdepartments

### Requirement 5

**User Story:** As a user, I want to communicate with other users through real-time chat, so that I can collaborate effectively.

#### Acceptance Criteria

1. WHEN accessing the chat feature THEN the system SHALL display a list of recent conversations
2. WHEN selecting a conversation THEN the system SHALL load the message history with pagination
3. WHEN sending a message THEN the system SHALL deliver it in real-time via WebSocket
4. WHEN receiving a message THEN the system SHALL display it immediately and show notifications
5. WHEN viewing conversations THEN the system SHALL indicate unread message counts
6. WHEN searching messages THEN the system SHALL filter results across all conversations
7. WHEN marking messages as read THEN the system SHALL update the read status immediately

### Requirement 6

**User Story:** As an HR manager or admin, I want to send emails to employees, so that I can communicate important information efficiently.

#### Acceptance Criteria

1. WHEN composing an email THEN the system SHALL provide template selection and recipient options
2. WHEN selecting recipients THEN the system SHALL support individual employees, departments, or bulk selection
3. WHEN previewing an email THEN the system SHALL show how the template will render with variables
4. WHEN sending an email THEN the system SHALL validate recipients and content before sending
5. WHEN viewing email templates THEN the system SHALL display available templates with descriptions
6. WHEN sending bulk emails THEN the system SHALL show progress and handle errors gracefully

### Requirement 7

**User Story:** As a user, I want to receive and manage notifications, so that I can stay informed about important updates.

#### Acceptance Criteria

1. WHEN notifications are available THEN the system SHALL display a notification badge in the header
2. WHEN clicking the notification icon THEN the system SHALL show a dropdown with recent notifications
3. WHEN receiving a new notification THEN the system SHALL update the UI in real-time
4. WHEN marking notifications as read THEN the system SHALL update the read status immediately
5. WHEN viewing notification details THEN the system SHALL display full content and timestamp
6. WHEN notifications are old THEN the system SHALL automatically archive them after a specified period

### Requirement 8

**User Story:** As an admin, I want to manage user permissions and roles, so that I can control access to system features.

#### Acceptance Criteria

1. WHEN viewing permissions THEN the system SHALL display a matrix of roles and permissions
2. WHEN assigning permissions THEN the system SHALL validate role-permission combinations
3. WHEN updating user roles THEN the system SHALL immediately reflect changes in the UI
4. WHEN viewing role details THEN the system SHALL show associated permissions and users
5. WHEN creating custom roles THEN the system SHALL allow selecting specific permissions
6. WHEN removing permissions THEN the system SHALL warn about potential access impacts

### Requirement 9

**User Story:** As a user, I want the application to be responsive and accessible, so that I can use it effectively on any device and regardless of my abilities.

#### Acceptance Criteria

1. WHEN viewing on mobile devices THEN the system SHALL adapt the layout for smaller screens
2. WHEN using keyboard navigation THEN the system SHALL provide proper focus management
3. WHEN using screen readers THEN the system SHALL provide appropriate ARIA labels and descriptions
4. WHEN viewing in different browsers THEN the system SHALL maintain consistent functionality
5. WHEN the network is slow THEN the system SHALL show loading states and handle errors gracefully
6. WHEN offline THEN the system SHALL display appropriate messages and cache essential data

### Requirement 10

**User Story:** As a user, I want the application to provide real-time updates and feedback, so that I can work efficiently with current information.

#### Acceptance Criteria

1. WHEN data changes THEN the system SHALL update the UI without requiring page refresh
2. WHEN performing actions THEN the system SHALL provide immediate visual feedback
3. WHEN operations are in progress THEN the system SHALL show loading indicators
4. WHEN errors occur THEN the system SHALL display clear error messages with suggested actions
5. WHEN forms are submitted THEN the system SHALL validate data and show success/error states
6. WHEN WebSocket connections are lost THEN the system SHALL attempt reconnection and notify users
</file>

<file path=".kiro/steering/frontend-guidelines.md">
# Frontend Development Guidelines

## Development Approach

### Vertical Slice Development
- Implement complete features end-to-end (frontend + corresponding backend API) in each iteration
- Prioritize working software over comprehensive documentation
- Focus on user-facing functionality that delivers immediate value

### Component-Driven Development
- Use Storybook for component library documentation and development
- Build reusable UI components before feature-specific components
- Maintain a design system with consistent styling and behavior

## Architecture Patterns

### Feature-Based Organization
```
src/features/[feature-name]/
├── components/          # Feature-specific components
├── hooks/              # Feature-specific custom hooks
├── services/           # Feature-specific API services
├── types/              # Feature-specific type definitions
├── utils/              # Feature-specific utilities
└── index.ts            # Feature public API
```

### State Management Strategy
- **Global State (Zustand)**: Authentication, UI preferences, notifications
- **Server State (TanStack Query)**: API data with caching and synchronization
- **Local State (useState/useReducer)**: Component-specific state
- **Form State (React Hook Form)**: Form data and validation

### Real-time System Architecture
Use an **Event Bus Pattern** for managing real-time events:
```typescript
// Central event bus for WebSocket events
class EventBus {
  private listeners: Map<string, Function[]> = new Map();
  
  subscribe(event: string, callback: Function) { /* ... */ }
  emit(event: string, data: any) { /* ... */ }
  unsubscribe(event: string, callback: Function) { /* ... */ }
}

// Usage in components
const { subscribe, unsubscribe } = useEventBus();
useEffect(() => {
  const handleNewMessage = (message) => { /* ... */ };
  subscribe('chat:new-message', handleNewMessage);
  return () => unsubscribe('chat:new-message', handleNewMessage);
}, []);
```

## Performance Optimization

### Code Splitting Strategy
1. **Route-based splitting**: Lazy load feature modules
2. **Component-based splitting**: Dynamic imports for heavy components
3. **Library splitting**: Separate vendor bundles for better caching

### Rendering Optimization
- Use `React.memo` for expensive components
- Implement `useMemo` and `useCallback` for expensive computations
- Use Zustand selectors to prevent unnecessary re-renders
- Implement virtual scrolling for large lists (employee lists, chat history)

### Bundle Optimization
```typescript
// vite.config.ts
export default defineConfig({
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['react', 'react-dom'],
          ui: ['@mantine/core', '@mantine/hooks'],
          utils: ['axios', 'socket.io-client']
        }
      }
    }
  }
});
```

## Testing Strategy

### Testing Pyramid
1. **Unit Tests (70%)**: Components, hooks, utilities
2. **Integration Tests (20%)**: Feature workflows, API integration
3. **E2E Tests (10%)**: Critical user paths

### Testing Tools and Patterns
```typescript
// Component testing with React Testing Library
import { render, screen, fireEvent } from '@testing-library/react';
import { EmployeeForm } from './EmployeeForm';

test('should validate required fields', async () => {
  render(<EmployeeForm onSubmit={jest.fn()} />);
  
  fireEvent.click(screen.getByRole('button', { name: /submit/i }));
  
  expect(await screen.findByText(/first name is required/i)).toBeInTheDocument();
});

// Hook testing
import { renderHook, act } from '@testing-library/react';
import { useEmployeeForm } from './useEmployeeForm';

test('should handle form submission', async () => {
  const { result } = renderHook(() => useEmployeeForm());
  
  act(() => {
    result.current.handleSubmit({ firstName: 'John', lastName: 'Doe' });
  });
  
  expect(result.current.isSubmitting).toBe(true);
});
```

### Visual Regression Testing
- Use Storybook + Chromatic for visual regression testing
- Maintain component stories for all UI components
- Automate visual testing in CI/CD pipeline

## Security Implementation

### Authentication & Authorization
```typescript
// Permission-based component rendering
const ProtectedComponent = ({ requiredPermission, children }) => {
  const { hasPermission } = useAuth();
  
  if (!hasPermission(requiredPermission)) {
    return <AccessDenied />;
  }
  
  return children;
};

// Route protection
const ProtectedRoute = ({ children, requiredRole }) => {
  const { user, isAuthenticated } = useAuth();
  
  if (!isAuthenticated) {
    return <Navigate to="/login" />;
  }
  
  if (requiredRole && !user.roles.includes(requiredRole)) {
    return <AccessDenied />;
  }
  
  return children;
};
```

### Input Sanitization
```typescript
import DOMPurify from 'dompurify';

// Sanitize user inputs
const sanitizeInput = (input: string): string => {
  return DOMPurify.sanitize(input);
};

// Use in forms
const handleSubmit = (data) => {
  const sanitizedData = {
    ...data,
    content: sanitizeInput(data.content)
  };
  // Submit sanitized data
};
```

## Accessibility Implementation

### WCAG 2.1 Compliance
```typescript
// Proper ARIA labels and descriptions
<button
  aria-label="Delete employee John Doe"
  aria-describedby="delete-help-text"
  onClick={() => handleDelete(employee.id)}
>
  <DeleteIcon />
</button>
<div id="delete-help-text" className="sr-only">
  This action cannot be undone
</div>

// Keyboard navigation
const useKeyboardNavigation = (items: any[], onSelect: (item: any) => void) => {
  const [selectedIndex, setSelectedIndex] = useState(0);
  
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      switch (event.key) {
        case 'ArrowDown':
          setSelectedIndex(prev => Math.min(prev + 1, items.length - 1));
          break;
        case 'ArrowUp':
          setSelectedIndex(prev => Math.max(prev - 1, 0));
          break;
        case 'Enter':
          onSelect(items[selectedIndex]);
          break;
      }
    };
    
    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [items, selectedIndex, onSelect]);
  
  return selectedIndex;
};
```

## Error Handling Patterns

### Error Boundaries
```typescript
class FeatureErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false, error: null };
  }
  
  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }
  
  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    // Log error to monitoring service
    console.error('Feature error:', error, errorInfo);
  }
  
  render() {
    if (this.state.hasError) {
      return <FeatureErrorFallback error={this.state.error} />;
    }
    
    return this.props.children;
  }
}
```

### API Error Handling
```typescript
// Centralized error handling with TanStack Query
const useApiError = () => {
  return useMutation({
    onError: (error: ApiError) => {
      switch (error.status) {
        case 401:
          // Redirect to login
          break;
        case 403:
          // Show access denied
          break;
        case 500:
          // Show generic error
          break;
        default:
          // Show specific error message
      }
    }
  });
};
```

## Real-time Features Implementation

### WebSocket Connection Management
```typescript
class WebSocketManager {
  private socket: Socket | null = null;
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;
  
  connect() {
    this.socket = io(WS_URL, {
      transports: ['websocket'],
      upgrade: false
    });
    
    this.socket.on('connect', this.handleConnect);
    this.socket.on('disconnect', this.handleDisconnect);
    this.socket.on('reconnect_attempt', this.handleReconnectAttempt);
  }
  
  private handleConnect = () => {
    this.reconnectAttempts = 0;
    // Emit authentication
    this.socket?.emit('authenticate', { token: getAuthToken() });
  };
  
  private handleDisconnect = () => {
    // Show connection lost notification
    showNotification('Connection lost. Attempting to reconnect...', 'warning');
  };
  
  private handleReconnectAttempt = () => {
    this.reconnectAttempts++;
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      showNotification('Unable to connect. Please refresh the page.', 'error');
    }
  };
}
```

## Development Workflow

### Git Workflow
1. **Feature branches**: `feature/employee-management`
2. **Commit messages**: Follow conventional commits
3. **Pull requests**: Include tests and documentation
4. **Code review**: Focus on functionality, performance, and accessibility

### Quality Gates
- **TypeScript**: No type errors allowed
- **ESLint**: No linting errors
- **Tests**: Minimum 80% code coverage
- **Accessibility**: No accessibility violations
- **Performance**: Bundle size within limits

### Continuous Integration
```yaml
# .github/workflows/frontend.yml
name: Frontend CI
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
      - run: npm ci
      - run: npm run type-check
      - run: npm run lint
      - run: npm run test:coverage
      - run: npm run build
      - run: npm run test:e2e
```

## Monitoring and Analytics

### Performance Monitoring
```typescript
// Web Vitals tracking
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';

const sendToAnalytics = (metric) => {
  // Send to monitoring service
  console.log(metric);
};

getCLS(sendToAnalytics);
getFID(sendToAnalytics);
getFCP(sendToAnalytics);
getLCP(sendToAnalytics);
getTTFB(sendToAnalytics);
```

### Error Tracking
```typescript
// Error boundary with error reporting
const reportError = (error: Error, errorInfo: ErrorInfo) => {
  // Send to error tracking service (e.g., Sentry)
  console.error('Application error:', error, errorInfo);
};
```

## UI Component Library and Templates

### Component Hierarchy and Organization

The frontend requires a comprehensive set of templates and UI components organized in a hierarchical structure:

#### Core Layout Components
- **AppShell**: Main application wrapper with responsive navigation
- **Navigation**: Role-based menu with hierarchical structure
- **Header**: Top bar with search, notifications, and user menu
- **PageContainer**: Standard page wrapper with consistent spacing

#### Feature-Specific Templates
- **Authentication**: Login/register forms with validation
- **Employee Management**: List views, forms, import/export interfaces
- **Department Management**: Tree structure, CRUD forms
- **Chat System**: Real-time messaging interface with conversation management
- **Email Management**: Composition interface with template selection
- **Notification System**: Real-time notification center
- **Permission Management**: Role-permission matrix interface

#### Common UI Components
- **DataTable**: Sortable, filterable table with pagination
- **FormField**: Standardized form field wrapper with validation
- **FileUpload**: Drag-and-drop file upload with progress
- **LoadingSpinner**: Multi-size loading indicators
- **Modal/Dialog**: Accessible modal system
- **SearchBar**: Global search with auto-complete

### Design System Requirements

#### Typography Scale
```typescript
const typography = {
  headings: {
    h1: { fontSize: '2.5rem', fontWeight: 700, lineHeight: 1.2 },
    h2: { fontSize: '2rem', fontWeight: 600, lineHeight: 1.3 },
    h3: { fontSize: '1.5rem', fontWeight: 600, lineHeight: 1.4 },
    h4: { fontSize: '1.25rem', fontWeight: 500, lineHeight: 1.4 },
    h5: { fontSize: '1.125rem', fontWeight: 500, lineHeight: 1.5 },
    h6: { fontSize: '1rem', fontWeight: 500, lineHeight: 1.5 }
  },
  body: {
    large: { fontSize: '1.125rem', lineHeight: 1.6 },
    normal: { fontSize: '1rem', lineHeight: 1.5 },
    small: { fontSize: '0.875rem', lineHeight: 1.4 }
  }
};
```

#### Color System
```typescript
const colors = {
  primary: {
    50: '#f0f9ff',
    500: '#3b82f6',
    900: '#1e3a8a'
  },
  semantic: {
    success: '#10b981',
    warning: '#f59e0b',
    error: '#ef4444',
    info: '#3b82f6'
  },
  neutral: {
    50: '#f9fafb',
    100: '#f3f4f6',
    500: '#6b7280',
    900: '#111827'
  }
};
```

#### Spacing System
```typescript
const spacing = {
  xs: '0.25rem',   // 4px
  sm: '0.5rem',    // 8px
  md: '1rem',      // 16px
  lg: '1.5rem',    // 24px
  xl: '2rem',      // 32px
  '2xl': '3rem',   // 48px
  '3xl': '4rem'    // 64px
};
```

### Component Implementation Standards

#### Component Structure Template
```typescript
interface ComponentProps {
  // Props interface with clear documentation
  children?: ReactNode;
  className?: string;
  variant?: 'primary' | 'secondary';
  size?: 'sm' | 'md' | 'lg';
  disabled?: boolean;
}

export const Component: FC<ComponentProps> = ({
  children,
  className,
  variant = 'primary',
  size = 'md',
  disabled = false,
  ...props
}) => {
  // Component logic with proper hooks usage
  const classes = clsx(
    'base-classes',
    `variant-${variant}`,
    `size-${size}`,
    { 'disabled': disabled },
    className
  );

  return (
    <div className={classes} {...props}>
      {children}
    </div>
  );
};

// Export with proper TypeScript types
Component.displayName = 'Component';
export type { ComponentProps };
```

#### Accessibility Standards
```typescript
// Example: Accessible button component
const AccessibleButton: FC<ButtonProps> = ({
  children,
  onClick,
  disabled,
  ariaLabel,
  ...props
}) => {
  return (
    <button
      onClick={onClick}
      disabled={disabled}
      aria-label={ariaLabel}
      aria-disabled={disabled}
      className={clsx(
        'focus:outline-none focus:ring-2 focus:ring-primary-500',
        'disabled:opacity-50 disabled:cursor-not-allowed'
      )}
      {...props}
    >
      {children}
    </button>
  );
};
```

### Implementation Priority

#### Phase 1: Foundation (Weeks 1-2)
1. Core layout components (AppShell, Navigation, Header)
2. Authentication templates (Login, Register forms)
3. Basic UI components (DataTable, FormField, LoadingSpinner)
4. Theme system and design tokens

#### Phase 2: Core Features (Weeks 3-6)
1. Employee management templates (List, Form, Detail views)
2. Department management components (Tree, Forms)
3. Chat system interface (Conversations, Messages)
4. Notification system components

#### Phase 3: Advanced Features (Weeks 7-8)
1. Email management interface (Composer, Templates)
2. Permission management components (Role matrix)
3. File upload and import/export functionality
4. Advanced search and filtering

#### Phase 4: Polish (Weeks 9-10)
1. Mobile-responsive components
2. Accessibility enhancements
3. Performance optimizations
4. Comprehensive testing coverage

### Storybook Integration

Each component should include Storybook stories for:
- Default state
- All variants and sizes
- Interactive states (hover, focus, disabled)
- Error states and edge cases
- Accessibility testing scenarios

```typescript
// Example Storybook story
export default {
  title: 'Components/Button',
  component: Button,
  parameters: {
    docs: {
      description: {
        component: 'A versatile button component with multiple variants and sizes.'
      }
    }
  }
} as Meta<typeof Button>;

export const Default: Story<ButtonProps> = {
  args: {
    children: 'Click me',
    variant: 'primary',
    size: 'md'
  }
};

export const AllVariants: Story<ButtonProps> = {
  render: () => (
    <div className="space-x-4">
      <Button variant="primary">Primary</Button>
      <Button variant="secondary">Secondary</Button>
      <Button variant="outline">Outline</Button>
    </div>
  )
};
```

This comprehensive frontend guideline ensures scalable, maintainable, and high-quality React application development that aligns with modern best practices and the specific needs of the employee management system.
</file>

<file path=".kiro/steering/product.md">
# Product Overview

This is a comprehensive employee management system built with a Spring Boot backend and modern React frontend. The system provides enterprise-grade functionality for HR management, employee administration, real-time communication, and organizational workflow management.

## Key Features

### Backend (Spring Boot)
- **Employee Management**: Complete CRUD operations with advanced search and filtering
- **Department Management**: Hierarchical department structure with tree visualization
- **Authentication & Authorization**: JWT-based security with role-based access control
- **Real-time Chat**: WebSocket-powered messaging system between users
- **Email System**: Template-based email communication with bulk sending capabilities
- **Notification System**: Real-time notifications with WebSocket integration
- **Payroll Management**: Comprehensive payroll processing and reporting
- **Permission Management**: Granular role and permission administration
- **RESTful APIs**: Complete REST API coverage for all features
- **Database Integration**: Redis for caching and data persistence
- **Monitoring**: Actuator endpoints for production monitoring

### Frontend (React)
- **Modern React Architecture**: React 18+ with TypeScript and functional components
- **Responsive Design**: Mobile-first design with cross-device compatibility
- **Real-time Features**: WebSocket integration for chat and notifications
- **State Management**: Zustand for global state, TanStack Query for server state
- **UI Components**: Mantine UI library for consistent, accessible components
- **Form Management**: React Hook Form with Zod validation
- **Testing**: Comprehensive testing with Vitest and React Testing Library
- **Performance**: Code splitting, lazy loading, and optimization strategies
- **Accessibility**: WCAG 2.1 compliance with full keyboard navigation

## Purpose
Serves as a complete enterprise employee management solution with modern full-stack architecture, suitable for organizations needing comprehensive HR management capabilities with real-time collaboration features.
</file>

<file path="LOMBOK_COMPATIBILITY_SOLUTION.md">
# Lombok Compatibility Issue - RESOLVED ✅

## Problem
Lombok 1.18.34 had compatibility issues with Java 21, causing compilation failures where getters, setters, and builders were not generated properly.

## Root Cause
- **Java 21 Annotation Processing**: Lombok requires explicit annotation processor configuration for Java 21+
- **Maven Compiler Plugin**: Version 3.11.0 was too old and lacked proper annotation processing support
- **Missing Configuration**: The `annotationProcessorPaths` configuration was missing from maven-compiler-plugin

## Solution Applied ✅

### 1. Updated Lombok Version
- **Upgraded** from `1.18.34` to `1.18.36` (latest stable with Java 21 support)
- **Changed scope** from `optional` to `provided` (recommended for annotation processors)

### 2. Updated Maven Compiler Plugin
- **Upgraded** from `3.11.0` to `3.13.0` (required for proper Java 21 support)
- **Added** `annotationProcessorPaths` configuration pointing to Lombok

### 3. Fixed @Builder.Default Issue
- **Added** `@Builder.Default` annotation to `tokenType` field in `LoginResponse.java`
- **Resolved** builder initialization warnings

### Changes Made:

#### pom.xml Updates:
```xml
<!-- Updated Lombok dependency -->
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <version>1.18.38</version>
    <scope>provided</scope>
</dependency>

<!-- Updated Maven Compiler Plugin -->
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-compiler-plugin</artifactId>
    <version>3.12.1</version>
    <configuration>
        <source>21</source>
        <target>21</target>
        <annotationProcessorPaths>
            <path>
                <groupId>org.projectlombok</groupId>
                <artifactId>lombok</artifactId>
                <version>1.18.38</version>
            </path>
        </annotationProcessorPaths>
    </configuration>
</plugin>

<!-- Removed Lombok exclusion from Spring Boot Plugin -->
<plugin>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-maven-plugin</artifactId>
</plugin>
```

#### LoginResponse.java Fix:
```java
@Builder.Default
private String tokenType = "Bearer";
```

## Current Status ✅
- ✅ **Lombok 1.18.38** installed with proper Java 21 support
- ✅ **Maven Compiler Plugin 3.12.1** with annotation processor configuration
- ✅ **@Builder.Default** issue resolved in LoginResponse
- ✅ **Duplicate RedisConfig** class removed to resolve bean conflicts
- ✅ **Spring Boot Plugin** exclusion removed for proper Lombok processing
- ✅ **All Lombok annotations** now working properly:
  - `@Data`, `@Builder`, `@Getter`, `@Setter` in DTOs
  - `@Getter`, `@Setter` in Entity classes
  - `@Slf4j` for logging (when needed)
- ✅ **Compilation successful** with `mvn clean compile`

## Verification Steps
1. **Clean and compile**: `mvn clean compile`
2. **Run tests**: `mvn test`
3. **Check generated code**: Verify getters/setters are generated in target/classes

## IDE Configuration (if needed)
- **IntelliJ IDEA**: Enable annotation processing in Settings → Build → Compiler → Annotation Processors
- **Eclipse**: Install Lombok plugin and restart IDE
- **VS Code**: Install Lombok extension

## References
- [Lombok Maven Setup](https://projectlombok.org/setup/maven)
- [Java 21 Annotation Processing](https://docs.oracle.com/en/java/javase/21/docs/specs/man/javac.html)
- [Maven Compiler Plugin 3.13.0](https://maven.apache.org/plugins/maven-compiler-plugin/)

**The Lombok compatibility issue is now fully resolved and all annotations should work correctly with Java 21.**
</file>

<file path="README.md">
employee-management-system

spring-boot+react/vite
</file>

<file path="src/main/java/com/example/demo/common/dto/ApiResponse.java">
package com.example.demo.common.dto;

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

/**
 * Standardized API response wrapper for all REST endpoints.
 * 
 * Provides consistent response format across the application with
 * success/error status, data payload, and metadata.
 * 
 * @param <T> Type of the response data
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ApiResponse<T> {
    
    /**
     * Indicates if the request was successful
     */
    private boolean success;
    
    /**
     * Human-readable message describing the result
     */
    private String message;
    
    /**
     * The actual response data
     */
    private T data;
    
    /**
     * Error details if the request failed
     */
    private ErrorResponse error;
    
    /**
     * Timestamp when the response was generated
     */
    @Builder.Default
    private LocalDateTime timestamp = LocalDateTime.now();
    
    /**
     * Request path for debugging purposes
     */
    private String path;
    
    /**
     * Creates a successful response with data
     */
    public static <T> ApiResponse<T> success(T data) {
        return ApiResponse.<T>builder()
                .success(true)
                .message("Operation completed successfully")
                .data(data)
                .build();
    }
    
    /**
     * Creates a successful response with data and custom message
     */
    public static <T> ApiResponse<T> success(T data, String message) {
        return ApiResponse.<T>builder()
                .success(true)
                .message(message)
                .data(data)
                .build();
    }
    
    /**
     * Creates an error response with message
     */
    public static <T> ApiResponse<T> error(String message) {
        return ApiResponse.<T>builder()
                .success(false)
                .message(message)
                .build();
    }
    
    /**
     * Creates an error response with detailed error information
     */
    public static <T> ApiResponse<T> error(String message, ErrorResponse error) {
        return ApiResponse.<T>builder()
                .success(false)
                .message(message)
                .error(error)
                .build();
    }
}
</file>

<file path="src/main/java/com/example/demo/common/dto/ErrorResponse.java">
package com.example.demo.common.dto;

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;

/**
 * Standardized error response structure for API errors.
 * 
 * Provides detailed error information including error codes,
 * validation errors, and debugging information.
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ErrorResponse {
    
    /**
     * Application-specific error code
     */
    private String errorCode;
    
    /**
     * HTTP status code
     */
    private int status;
    
    /**
     * Error message for end users
     */
    private String message;
    
    /**
     * Detailed error description for developers
     */
    private String details;
    
    /**
     * Request path where the error occurred
     */
    private String path;
    
    /**
     * Timestamp when the error occurred
     */
    @Builder.Default
    private LocalDateTime timestamp = LocalDateTime.now();
    
    /**
     * Validation errors for form submissions
     */
    private Map<String, String> validationErrors;
    
    /**
     * List of error messages for multiple errors
     */
    private List<String> errors;
    
    /**
     * Additional context information
     */
    private Map<String, Object> context;
    
    /**
     * Creates a simple error response
     */
    public static ErrorResponse of(String errorCode, int status, String message) {
        return ErrorResponse.builder()
                .errorCode(errorCode)
                .status(status)
                .message(message)
                .build();
    }
    
    /**
     * Creates an error response with validation errors
     */
    public static ErrorResponse withValidationErrors(String errorCode, int status, 
                                                   String message, Map<String, String> validationErrors) {
        return ErrorResponse.builder()
                .errorCode(errorCode)
                .status(status)
                .message(message)
                .validationErrors(validationErrors)
                .build();
    }
}
</file>

<file path="src/main/java/com/example/demo/common/dto/PageResponse.java">
package com.example.demo.common.dto;

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.data.domain.Page;

import java.util.List;

/**
 * Standardized paginated response wrapper for list endpoints.
 * 
 * Provides pagination metadata along with the actual data list
 * for consistent pagination handling across the application.
 * 
 * @param <T> Type of the items in the page
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
public class PageResponse<T> {
    
    /**
     * List of items in the current page
     */
    private List<T> content;
    
    /**
     * Current page number (0-based)
     */
    private int page;
    
    /**
     * Number of items per page
     */
    private int size;
    
    /**
     * Total number of elements across all pages
     */
    private long totalElements;
    
    /**
     * Total number of pages
     */
    private int totalPages;
    
    /**
     * Whether this is the first page
     */
    private boolean first;
    
    /**
     * Whether this is the last page
     */
    private boolean last;
    
    /**
     * Whether there is a next page
     */
    private boolean hasNext;
    
    /**
     * Whether there is a previous page
     */
    private boolean hasPrevious;
    
    /**
     * Number of elements in the current page
     */
    private int numberOfElements;
    
    /**
     * Whether the page is empty
     */
    private boolean empty;
    
    /**
     * Creates a PageResponse from Spring Data Page
     */
    public static <T> PageResponse<T> of(Page<T> page) {
        return PageResponse.<T>builder()
                .content(page.getContent())
                .page(page.getNumber())
                .size(page.getSize())
                .totalElements(page.getTotalElements())
                .totalPages(page.getTotalPages())
                .first(page.isFirst())
                .last(page.isLast())
                .hasNext(page.hasNext())
                .hasPrevious(page.hasPrevious())
                .numberOfElements(page.getNumberOfElements())
                .empty(page.isEmpty())
                .build();
    }
    
    /**
     * Creates a PageResponse with custom content and pagination info
     */
    public static <T> PageResponse<T> of(List<T> content, int page, int size, 
                                       long totalElements, int totalPages) {
        return PageResponse.<T>builder()
                .content(content)
                .page(page)
                .size(size)
                .totalElements(totalElements)
                .totalPages(totalPages)
                .first(page == 0)
                .last(page == totalPages - 1)
                .hasNext(page < totalPages - 1)
                .hasPrevious(page > 0)
                .numberOfElements(content.size())
                .empty(content.isEmpty())
                .build();
    }
}
</file>

<file path="src/main/java/com/example/demo/common/exception/GlobalExceptionHandler.java">
package com.example.demo.common.exception;

import com.example.demo.common.dto.ApiResponse;
import com.example.demo.common.dto.ErrorResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.core.AuthenticationException;
import org.springframework.validation.BindException;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.context.request.WebRequest;
import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException;

import jakarta.validation.ConstraintViolation;
import jakarta.validation.ConstraintViolationException;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * Global exception handler for all REST controllers.
 * 
 * Provides centralized exception handling with standardized
 * error responses and proper HTTP status codes.
 */
@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {

    /**
     * Handles business logic exceptions
     */
    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ApiResponse<Object>> handleBusinessException(
            BusinessException ex, WebRequest request) {
        
        log.warn("Business exception occurred: {} - {}", ex.getErrorCode(), ex.getMessage());
        
        ErrorResponse errorResponse = ErrorResponse.builder()
                .errorCode(ex.getErrorCode())
                .status(HttpStatus.BAD_REQUEST.value())
                .message(ex.getMessage())
                .path(getRequestPath(request))
                .timestamp(LocalDateTime.now())
                .context(ex.getContext() != null ? Map.of("context", ex.getContext()) : null)
                .build();

        ApiResponse<Object> response = ApiResponse.error(ex.getMessage(), errorResponse);
        response.setPath(getRequestPath(request));

        return ResponseEntity.badRequest().body(response);
    }

    /**
     * Handles validation exceptions with field errors
     */
    @ExceptionHandler(ValidationException.class)
    public ResponseEntity<ApiResponse<Object>> handleValidationException(
            ValidationException ex, WebRequest request) {
        
        log.warn("Validation exception occurred: {} field errors", ex.getErrorCount());
        
        ErrorResponse errorResponse = ErrorResponse.builder()
                .errorCode(ex.getErrorCode())
                .status(HttpStatus.BAD_REQUEST.value())
                .message(ex.getMessage())
                .path(getRequestPath(request))
                .timestamp(LocalDateTime.now())
                .validationErrors(ex.getValidationErrors())
                .build();

        ApiResponse<Object> response = ApiResponse.error(ex.getMessage(), errorResponse);
        response.setPath(getRequestPath(request));

        return ResponseEntity.badRequest().body(response);
    }

    /**
     * Handles Bean Validation errors from @Valid annotations
     */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ApiResponse<Object>> handleMethodArgumentNotValid(
            MethodArgumentNotValidException ex, WebRequest request) {
        
        Map<String, String> validationErrors = new HashMap<>();
        ex.getBindingResult().getAllErrors().forEach(error -> {
            String fieldName = ((FieldError) error).getField();
            String errorMessage = error.getDefaultMessage();
            validationErrors.put(fieldName, errorMessage);
        });

        log.warn("Method argument validation failed: {} field errors", validationErrors.size());

        ErrorResponse errorResponse = ErrorResponse.builder()
                .errorCode("VALIDATION_ERROR")
                .status(HttpStatus.BAD_REQUEST.value())
                .message("Validation failed for request parameters")
                .path(getRequestPath(request))
                .timestamp(LocalDateTime.now())
                .validationErrors(validationErrors)
                .build();

        ApiResponse<Object> response = ApiResponse.error("Validation failed", errorResponse);
        response.setPath(getRequestPath(request));

        return ResponseEntity.badRequest().body(response);
    }

    /**
     * Handles bind exceptions from form data binding
     */
    @ExceptionHandler(BindException.class)
    public ResponseEntity<ApiResponse<Object>> handleBindException(
            BindException ex, WebRequest request) {
        
        Map<String, String> validationErrors = new HashMap<>();
        ex.getBindingResult().getAllErrors().forEach(error -> {
            String fieldName = ((FieldError) error).getField();
            String errorMessage = error.getDefaultMessage();
            validationErrors.put(fieldName, errorMessage);
        });

        log.warn("Bind exception occurred: {} field errors", validationErrors.size());

        ErrorResponse errorResponse = ErrorResponse.builder()
                .errorCode("BINDING_ERROR")
                .status(HttpStatus.BAD_REQUEST.value())
                .message("Data binding failed")
                .path(getRequestPath(request))
                .timestamp(LocalDateTime.now())
                .validationErrors(validationErrors)
                .build();

        ApiResponse<Object> response = ApiResponse.error("Data binding failed", errorResponse);
        response.setPath(getRequestPath(request));

        return ResponseEntity.badRequest().body(response);
    }

    /**
     * Handles constraint violation exceptions
     */
    @ExceptionHandler(ConstraintViolationException.class)
    public ResponseEntity<ApiResponse<Object>> handleConstraintViolation(
            ConstraintViolationException ex, WebRequest request) {
        
        Map<String, String> validationErrors = ex.getConstraintViolations()
                .stream()
                .collect(Collectors.toMap(
                    violation -> violation.getPropertyPath().toString(),
                    ConstraintViolation::getMessage,
                    (existing, replacement) -> existing
                ));

        log.warn("Constraint violation occurred: {} violations", validationErrors.size());

        ErrorResponse errorResponse = ErrorResponse.builder()
                .errorCode("CONSTRAINT_VIOLATION")
                .status(HttpStatus.BAD_REQUEST.value())
                .message("Constraint validation failed")
                .path(getRequestPath(request))
                .timestamp(LocalDateTime.now())
                .validationErrors(validationErrors)
                .build();

        ApiResponse<Object> response = ApiResponse.error("Constraint validation failed", errorResponse);
        response.setPath(getRequestPath(request));

        return ResponseEntity.badRequest().body(response);
    }

    /**
     * Handles authentication exceptions
     */
    @ExceptionHandler(AuthenticationException.class)
    public ResponseEntity<ApiResponse<Object>> handleAuthenticationException(
            AuthenticationException ex, WebRequest request) {
        
        log.warn("Authentication failed: {}", ex.getMessage());

        ErrorResponse errorResponse = ErrorResponse.builder()
                .errorCode("AUTHENTICATION_FAILED")
                .status(HttpStatus.UNAUTHORIZED.value())
                .message("Authentication failed")
                .path(getRequestPath(request))
                .timestamp(LocalDateTime.now())
                .build();

        ApiResponse<Object> response = ApiResponse.error("Authentication failed", errorResponse);
        response.setPath(getRequestPath(request));

        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(response);
    }

    /**
     * Handles bad credentials exceptions
     */
    @ExceptionHandler(BadCredentialsException.class)
    public ResponseEntity<ApiResponse<Object>> handleBadCredentialsException(
            BadCredentialsException ex, WebRequest request) {
        
        log.warn("Bad credentials provided");

        ErrorResponse errorResponse = ErrorResponse.builder()
                .errorCode("INVALID_CREDENTIALS")
                .status(HttpStatus.UNAUTHORIZED.value())
                .message("Invalid username or password")
                .path(getRequestPath(request))
                .timestamp(LocalDateTime.now())
                .build();

        ApiResponse<Object> response = ApiResponse.error("Invalid credentials", errorResponse);
        response.setPath(getRequestPath(request));

        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(response);
    }

    /**
     * Handles access denied exceptions
     */
    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity<ApiResponse<Object>> handleAccessDeniedException(
            AccessDeniedException ex, WebRequest request) {
        
        log.warn("Access denied: {}", ex.getMessage());

        ErrorResponse errorResponse = ErrorResponse.builder()
                .errorCode("ACCESS_DENIED")
                .status(HttpStatus.FORBIDDEN.value())
                .message("Access denied")
                .path(getRequestPath(request))
                .timestamp(LocalDateTime.now())
                .build();

        ApiResponse<Object> response = ApiResponse.error("Access denied", errorResponse);
        response.setPath(getRequestPath(request));

        return ResponseEntity.status(HttpStatus.FORBIDDEN).body(response);
    }

    /**
     * Handles method argument type mismatch exceptions
     */
    @ExceptionHandler(MethodArgumentTypeMismatchException.class)
    public ResponseEntity<ApiResponse<Object>> handleMethodArgumentTypeMismatch(
            MethodArgumentTypeMismatchException ex, WebRequest request) {
        
        log.warn("Method argument type mismatch: {} for parameter {}", 
                ex.getValue(), ex.getName());

        ErrorResponse errorResponse = ErrorResponse.builder()
                .errorCode("INVALID_PARAMETER_TYPE")
                .status(HttpStatus.BAD_REQUEST.value())
                .message(String.format("Invalid value '%s' for parameter '%s'", 
                        ex.getValue(), ex.getName()))
                .path(getRequestPath(request))
                .timestamp(LocalDateTime.now())
                .build();

        ApiResponse<Object> response = ApiResponse.error("Invalid parameter type", errorResponse);
        response.setPath(getRequestPath(request));

        return ResponseEntity.badRequest().body(response);
    }

    /**
     * Handles all other unexpected exceptions
     */
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiResponse<Object>> handleGenericException(
            Exception ex, WebRequest request) {
        
        log.error("Unexpected error occurred", ex);

        ErrorResponse errorResponse = ErrorResponse.builder()
                .errorCode("INTERNAL_SERVER_ERROR")
                .status(HttpStatus.INTERNAL_SERVER_ERROR.value())
                .message("An unexpected error occurred")
                .path(getRequestPath(request))
                .timestamp(LocalDateTime.now())
                .build();

        ApiResponse<Object> response = ApiResponse.error("Internal server error", errorResponse);
        response.setPath(getRequestPath(request));

        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
    }

    /**
     * Extracts the request path from WebRequest
     */
    private String getRequestPath(WebRequest request) {
        return request.getDescription(false).replace("uri=", "");
    }
}
</file>

<file path="src/main/java/com/example/demo/common/util/CacheUtil.java">
package com.example.demo.common.util;

import lombok.RequiredArgsConstructor;
import lombok.experimental.UtilityClass;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Component;

import java.time.Duration;
import java.util.Collection;
import java.util.List;
import java.util.Set;
import java.util.concurrent.TimeUnit;

/**
 * Utility class for Redis cache operations.
 * 
 * Provides convenient methods for common caching operations
 * with proper error handling and logging.
 */
@Slf4j
@Component
@RequiredArgsConstructor
public class CacheUtil {

    private final RedisTemplate<String, Object> redisTemplate;

    /**
     * Cache key prefixes for different data types
     */
    public static final String USER_CACHE_PREFIX = "user:";
    public static final String EMPLOYEE_CACHE_PREFIX = "employee:";
    public static final String DEPARTMENT_CACHE_PREFIX = "department:";
    public static final String POSITION_CACHE_PREFIX = "position:";
    public static final String PERMISSION_CACHE_PREFIX = "permission:";
    public static final String SESSION_CACHE_PREFIX = "session:";
    public static final String EMAIL_TEMPLATE_CACHE_PREFIX = "email_template:";
    public static final String JWT_BLACKLIST_PREFIX = "jwt_blacklist:";

    /**
     * Stores a value in cache with expiration
     */
    public void put(String key, Object value, Duration expiration) {
        try {
            redisTemplate.opsForValue().set(key, value, expiration);
            log.debug("Cached value with key: {} for duration: {}", key, expiration);
        } catch (Exception e) {
            log.error("Failed to cache value with key: {}", key, e);
        }
    }

    /**
     * Stores a value in cache with default expiration (10 minutes)
     */
    public void put(String key, Object value) {
        put(key, value, Duration.ofMinutes(10));
    }

    /**
     * Retrieves a value from cache
     */
    @SuppressWarnings("unchecked")
    public <T> T get(String key, Class<T> type) {
        try {
            Object value = redisTemplate.opsForValue().get(key);
            if (value != null && type.isInstance(value)) {
                log.debug("Cache hit for key: {}", key);
                return (T) value;
            }
            log.debug("Cache miss for key: {}", key);
            return null;
        } catch (Exception e) {
            log.error("Failed to retrieve value from cache with key: {}", key, e);
            return null;
        }
    }

    /**
     * Retrieves a value from cache as Object
     */
    public Object get(String key) {
        return get(key, Object.class);
    }

    /**
     * Checks if a key exists in cache
     */
    public boolean exists(String key) {
        try {
            Boolean exists = redisTemplate.hasKey(key);
            return exists != null && exists;
        } catch (Exception e) {
            log.error("Failed to check existence of key: {}", key, e);
            return false;
        }
    }

    /**
     * Removes a value from cache
     */
    public void evict(String key) {
        try {
            redisTemplate.delete(key);
            log.debug("Evicted cache entry with key: {}", key);
        } catch (Exception e) {
            log.error("Failed to evict cache entry with key: {}", key, e);
        }
    }

    /**
     * Removes multiple values from cache
     */
    public void evict(Collection<String> keys) {
        try {
            redisTemplate.delete(keys);
            log.debug("Evicted {} cache entries", keys.size());
        } catch (Exception e) {
            log.error("Failed to evict cache entries", e);
        }
    }

    /**
     * Removes all cache entries matching a pattern
     */
    public void evictByPattern(String pattern) {
        try {
            Set<String> keys = redisTemplate.keys(pattern);
            if (keys != null && !keys.isEmpty()) {
                redisTemplate.delete(keys);
                log.debug("Evicted {} cache entries matching pattern: {}", keys.size(), pattern);
            }
        } catch (Exception e) {
            log.error("Failed to evict cache entries by pattern: {}", pattern, e);
        }
    }

    /**
     * Sets expiration time for a key
     */
    public void expire(String key, Duration expiration) {
        try {
            redisTemplate.expire(key, expiration);
            log.debug("Set expiration for key: {} to: {}", key, expiration);
        } catch (Exception e) {
            log.error("Failed to set expiration for key: {}", key, e);
        }
    }

    /**
     * Gets the remaining time to live for a key
     */
    public Duration getTtl(String key) {
        try {
            Long ttl = redisTemplate.getExpire(key, TimeUnit.SECONDS);
            return ttl != null && ttl > 0 ? Duration.ofSeconds(ttl) : Duration.ZERO;
        } catch (Exception e) {
            log.error("Failed to get TTL for key: {}", key, e);
            return Duration.ZERO;
        }
    }

    /**
     * Increments a numeric value in cache
     */
    public Long increment(String key) {
        try {
            return redisTemplate.opsForValue().increment(key);
        } catch (Exception e) {
            log.error("Failed to increment value for key: {}", key, e);
            return null;
        }
    }

    /**
     * Increments a numeric value by a specific amount
     */
    public Long increment(String key, long delta) {
        try {
            return redisTemplate.opsForValue().increment(key, delta);
        } catch (Exception e) {
            log.error("Failed to increment value for key: {} by: {}", key, delta, e);
            return null;
        }
    }

    /**
     * Adds a value to a set
     */
    public void addToSet(String key, Object... values) {
        try {
            redisTemplate.opsForSet().add(key, values);
            log.debug("Added {} values to set with key: {}", values.length, key);
        } catch (Exception e) {
            log.error("Failed to add values to set with key: {}", key, e);
        }
    }

    /**
     * Removes a value from a set
     */
    public void removeFromSet(String key, Object... values) {
        try {
            redisTemplate.opsForSet().remove(key, values);
            log.debug("Removed {} values from set with key: {}", values.length, key);
        } catch (Exception e) {
            log.error("Failed to remove values from set with key: {}", key, e);
        }
    }

    /**
     * Checks if a value is in a set
     */
    public boolean isInSet(String key, Object value) {
        try {
            Boolean isMember = redisTemplate.opsForSet().isMember(key, value);
            return isMember != null && isMember;
        } catch (Exception e) {
            log.error("Failed to check set membership for key: {}", key, e);
            return false;
        }
    }

    /**
     * Gets all members of a set
     */
    public Set<Object> getSetMembers(String key) {
        try {
            return redisTemplate.opsForSet().members(key);
        } catch (Exception e) {
            log.error("Failed to get set members for key: {}", key, e);
            return Set.of();
        }
    }

    /**
     * Adds a value to a list (left push)
     */
    public void addToList(String key, Object... values) {
        try {
            redisTemplate.opsForList().leftPushAll(key, values);
            log.debug("Added {} values to list with key: {}", values.length, key);
        } catch (Exception e) {
            log.error("Failed to add values to list with key: {}", key, e);
        }
    }

    /**
     * Gets a range of values from a list
     */
    public List<Object> getListRange(String key, long start, long end) {
        try {
            return redisTemplate.opsForList().range(key, start, end);
        } catch (Exception e) {
            log.error("Failed to get list range for key: {}", key, e);
            return List.of();
        }
    }

    /**
     * Gets the size of a list
     */
    public Long getListSize(String key) {
        try {
            return redisTemplate.opsForList().size(key);
        } catch (Exception e) {
            log.error("Failed to get list size for key: {}", key, e);
            return 0L;
        }
    }

    /**
     * Utility methods for generating cache keys
     */
    @UtilityClass
    public static class KeyGenerator {
        
        public static String userKey(Long userId) {
            return USER_CACHE_PREFIX + userId;
        }
        
        public static String employeeKey(Long employeeId) {
            return EMPLOYEE_CACHE_PREFIX + employeeId;
        }
        
        public static String departmentKey(Long departmentId) {
            return DEPARTMENT_CACHE_PREFIX + departmentId;
        }
        
        public static String positionKey(Long positionId) {
            return POSITION_CACHE_PREFIX + positionId;
        }
        
        public static String permissionKey(String username) {
            return PERMISSION_CACHE_PREFIX + username;
        }
        
        public static String sessionKey(String sessionId) {
            return SESSION_CACHE_PREFIX + sessionId;
        }
        
        public static String emailTemplateKey(String templateCode) {
            return EMAIL_TEMPLATE_CACHE_PREFIX + templateCode;
        }
        
        public static String jwtBlacklistKey(String jti) {
            return JWT_BLACKLIST_PREFIX + jti;
        }
    }
}
</file>

<file path="src/main/java/com/example/demo/common/util/DateUtil.java">
package com.example.demo.common.util;

import lombok.experimental.UtilityClass;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.time.temporal.ChronoUnit;

/**
 * Utility class for common date operations.
 * 
 * Provides standardized date formatting, parsing, and calculation
 * methods used throughout the application.
 */
@UtilityClass
public class DateUtil {
    
    public static final String DEFAULT_DATE_FORMAT = "yyyy-MM-dd";
    public static final String DEFAULT_DATETIME_FORMAT = "yyyy-MM-dd HH:mm:ss";
    public static final String ISO_DATE_FORMAT = "yyyy-MM-dd";
    public static final String ISO_DATETIME_FORMAT = "yyyy-MM-dd'T'HH:mm:ss";
    
    private static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT);
    private static final DateTimeFormatter DATETIME_FORMATTER = DateTimeFormatter.ofPattern(DEFAULT_DATETIME_FORMAT);
    
    /**
     * Formats a LocalDate to string using default format
     */
    public static String formatDate(LocalDate date) {
        return date != null ? date.format(DATE_FORMATTER) : null;
    }
    
    /**
     * Formats a LocalDateTime to string using default format
     */
    public static String formatDateTime(LocalDateTime dateTime) {
        return dateTime != null ? dateTime.format(DATETIME_FORMATTER) : null;
    }
    
    /**
     * Formats a LocalDate to string using custom format
     */
    public static String formatDate(LocalDate date, String pattern) {
        if (date == null || pattern == null) {
            return null;
        }
        return date.format(DateTimeFormatter.ofPattern(pattern));
    }
    
    /**
     * Formats a LocalDateTime to string using custom format
     */
    public static String formatDateTime(LocalDateTime dateTime, String pattern) {
        if (dateTime == null || pattern == null) {
            return null;
        }
        return dateTime.format(DateTimeFormatter.ofPattern(pattern));
    }
    
    /**
     * Parses a string to LocalDate using default format
     */
    public static LocalDate parseDate(String dateString) {
        if (dateString == null || dateString.trim().isEmpty()) {
            return null;
        }
        try {
            return LocalDate.parse(dateString, DATE_FORMATTER);
        } catch (DateTimeParseException e) {
            throw new IllegalArgumentException("Invalid date format: " + dateString + 
                    ". Expected format: " + DEFAULT_DATE_FORMAT, e);
        }
    }
    
    /**
     * Parses a string to LocalDateTime using default format
     */
    public static LocalDateTime parseDateTime(String dateTimeString) {
        if (dateTimeString == null || dateTimeString.trim().isEmpty()) {
            return null;
        }
        try {
            return LocalDateTime.parse(dateTimeString, DATETIME_FORMATTER);
        } catch (DateTimeParseException e) {
            throw new IllegalArgumentException("Invalid datetime format: " + dateTimeString + 
                    ". Expected format: " + DEFAULT_DATETIME_FORMAT, e);
        }
    }
    
    /**
     * Calculates the number of days between two dates
     */
    public static long daysBetween(LocalDate startDate, LocalDate endDate) {
        if (startDate == null || endDate == null) {
            return 0;
        }
        return ChronoUnit.DAYS.between(startDate, endDate);
    }
    
    /**
     * Calculates the number of years between two dates
     */
    public static long yearsBetween(LocalDate startDate, LocalDate endDate) {
        if (startDate == null || endDate == null) {
            return 0;
        }
        return ChronoUnit.YEARS.between(startDate, endDate);
    }
    
    /**
     * Checks if a date is in the past
     */
    public static boolean isPast(LocalDate date) {
        return date != null && date.isBefore(LocalDate.now());
    }
    
    /**
     * Checks if a date is in the future
     */
    public static boolean isFuture(LocalDate date) {
        return date != null && date.isAfter(LocalDate.now());
    }
    
    /**
     * Gets the current date as formatted string
     */
    public static String getCurrentDateString() {
        return formatDate(LocalDate.now());
    }
    
    /**
     * Gets the current datetime as formatted string
     */
    public static String getCurrentDateTimeString() {
        return formatDateTime(LocalDateTime.now());
    }
}
</file>

<file path="src/main/java/com/example/demo/common/util/FileUtil.java">
package com.example.demo.common.util;

import lombok.experimental.UtilityClass;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.multipart.MultipartFile;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Arrays;
import java.util.List;
import java.util.UUID;

/**
 * Utility class for file operations.
 * 
 * Provides methods for file upload, download, validation,
 * and management used throughout the application.
 */
@Slf4j
@UtilityClass
public class FileUtil {
    
    // Allowed file extensions for different file types
    public static final List<String> EXCEL_EXTENSIONS = Arrays.asList(".xlsx", ".xls");
    public static final List<String> IMAGE_EXTENSIONS = Arrays.asList(".jpg", ".jpeg", ".png", ".gif", ".bmp");
    public static final List<String> DOCUMENT_EXTENSIONS = Arrays.asList(".pdf", ".doc", ".docx", ".txt");
    
    // Maximum file sizes (in bytes)
    public static final long MAX_EXCEL_FILE_SIZE = 10 * 1024 * 1024; // 10MB
    public static final long MAX_IMAGE_FILE_SIZE = 5 * 1024 * 1024;  // 5MB
    public static final long MAX_DOCUMENT_FILE_SIZE = 20 * 1024 * 1024; // 20MB
    
    /**
     * Validates if a file is a valid Excel file
     */
    public static boolean isValidExcelFile(MultipartFile file) {
        if (file == null || file.isEmpty()) {
            return false;
        }
        
        String filename = file.getOriginalFilename();
        if (filename == null) {
            return false;
        }
        
        String extension = getFileExtension(filename).toLowerCase();
        return EXCEL_EXTENSIONS.contains(extension) && 
               file.getSize() <= MAX_EXCEL_FILE_SIZE;
    }
    
    /**
     * Validates if a file is a valid image file
     */
    public static boolean isValidImageFile(MultipartFile file) {
        if (file == null || file.isEmpty()) {
            return false;
        }
        
        String filename = file.getOriginalFilename();
        if (filename == null) {
            return false;
        }
        
        String extension = getFileExtension(filename).toLowerCase();
        return IMAGE_EXTENSIONS.contains(extension) && 
               file.getSize() <= MAX_IMAGE_FILE_SIZE;
    }
    
    /**
     * Validates if a file is a valid document file
     */
    public static boolean isValidDocumentFile(MultipartFile file) {
        if (file == null || file.isEmpty()) {
            return false;
        }
        
        String filename = file.getOriginalFilename();
        if (filename == null) {
            return false;
        }
        
        String extension = getFileExtension(filename).toLowerCase();
        return DOCUMENT_EXTENSIONS.contains(extension) && 
               file.getSize() <= MAX_DOCUMENT_FILE_SIZE;
    }
    
    /**
     * Gets the file extension from a filename
     */
    public static String getFileExtension(String filename) {
        if (filename == null || filename.isEmpty()) {
            return "";
        }
        
        int lastDotIndex = filename.lastIndexOf('.');
        return lastDotIndex > 0 ? filename.substring(lastDotIndex) : "";
    }
    
    /**
     * Gets the filename without extension
     */
    public static String getFilenameWithoutExtension(String filename) {
        if (filename == null || filename.isEmpty()) {
            return "";
        }
        
        int lastDotIndex = filename.lastIndexOf('.');
        return lastDotIndex > 0 ? filename.substring(0, lastDotIndex) : filename;
    }
    
    /**
     * Generates a unique filename with timestamp
     */
    public static String generateUniqueFilename(String originalFilename) {
        String extension = getFileExtension(originalFilename);
        String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss"));
        String uuid = UUID.randomUUID().toString().substring(0, 8);
        
        return String.format("%s_%s%s", timestamp, uuid, extension);
    }
    
    /**
     * Saves a multipart file to the specified directory
     */
    public static String saveFile(MultipartFile file, String uploadDirectory) throws IOException {
        if (file == null || file.isEmpty()) {
            throw new IllegalArgumentException("File cannot be null or empty");
        }
        
        // Create upload directory if it doesn't exist
        Path uploadPath = Paths.get(uploadDirectory);
        if (!Files.exists(uploadPath)) {
            Files.createDirectories(uploadPath);
        }
        
        // Generate unique filename
        String originalFilename = file.getOriginalFilename();
        String uniqueFilename = generateUniqueFilename(originalFilename);
        
        // Save file
        Path filePath = uploadPath.resolve(uniqueFilename);
        Files.copy(file.getInputStream(), filePath, StandardCopyOption.REPLACE_EXISTING);
        
        log.info("File saved: {} -> {}", originalFilename, uniqueFilename);
        return uniqueFilename;
    }
    
    /**
     * Reads a file as byte array
     */
    public static byte[] readFileAsBytes(String filePath) throws IOException {
        Path path = Paths.get(filePath);
        if (!Files.exists(path)) {
            throw new FileNotFoundException("File not found: " + filePath);
        }
        
        return Files.readAllBytes(path);
    }
    
    /**
     * Reads a file as string
     */
    public static String readFileAsString(String filePath) throws IOException {
        byte[] bytes = readFileAsBytes(filePath);
        return new String(bytes);
    }
    
    /**
     * Writes content to a file
     */
    public static void writeStringToFile(String content, String filePath) throws IOException {
        Path path = Paths.get(filePath);
        
        // Create parent directories if they don't exist
        Path parentDir = path.getParent();
        if (parentDir != null && !Files.exists(parentDir)) {
            Files.createDirectories(parentDir);
        }
        
        Files.write(path, content.getBytes());
        log.info("Content written to file: {}", filePath);
    }
    
    /**
     * Writes byte array to a file
     */
    public static void writeBytesToFile(byte[] bytes, String filePath) throws IOException {
        Path path = Paths.get(filePath);
        
        // Create parent directories if they don't exist
        Path parentDir = path.getParent();
        if (parentDir != null && !Files.exists(parentDir)) {
            Files.createDirectories(parentDir);
        }
        
        Files.write(path, bytes);
        log.info("Bytes written to file: {}", filePath);
    }
    
    /**
     * Deletes a file
     */
    public static boolean deleteFile(String filePath) {
        try {
            Path path = Paths.get(filePath);
            boolean deleted = Files.deleteIfExists(path);
            if (deleted) {
                log.info("File deleted: {}", filePath);
            }
            return deleted;
        } catch (IOException e) {
            log.error("Failed to delete file: {}", filePath, e);
            return false;
        }
    }
    
    /**
     * Checks if a file exists
     */
    public static boolean fileExists(String filePath) {
        return Files.exists(Paths.get(filePath));
    }
    
    /**
     * Gets file size in bytes
     */
    public static long getFileSize(String filePath) throws IOException {
        Path path = Paths.get(filePath);
        if (!Files.exists(path)) {
            throw new FileNotFoundException("File not found: " + filePath);
        }
        
        return Files.size(path);
    }
    
    /**
     * Formats file size in human-readable format
     */
    public static String formatFileSize(long bytes) {
        if (bytes < 1024) {
            return bytes + " B";
        } else if (bytes < 1024 * 1024) {
            return String.format("%.1f KB", bytes / 1024.0);
        } else if (bytes < 1024 * 1024 * 1024) {
            return String.format("%.1f MB", bytes / (1024.0 * 1024.0));
        } else {
            return String.format("%.1f GB", bytes / (1024.0 * 1024.0 * 1024.0));
        }
    }
    
    /**
     * Creates a temporary file with the given content
     */
    public static String createTempFile(String content, String prefix, String suffix) throws IOException {
        Path tempFile = Files.createTempFile(prefix, suffix);
        Files.write(tempFile, content.getBytes());
        
        String tempFilePath = tempFile.toString();
        log.info("Temporary file created: {}", tempFilePath);
        
        return tempFilePath;
    }
    
    /**
     * Creates a temporary file from MultipartFile
     */
    public static String createTempFile(MultipartFile file) throws IOException {
        String originalFilename = file.getOriginalFilename();
        String extension = getFileExtension(originalFilename);
        String prefix = getFilenameWithoutExtension(originalFilename);
        
        Path tempFile = Files.createTempFile(prefix, extension);
        Files.copy(file.getInputStream(), tempFile, StandardCopyOption.REPLACE_EXISTING);
        
        String tempFilePath = tempFile.toString();
        log.info("Temporary file created from upload: {}", tempFilePath);
        
        return tempFilePath;
    }
    
    /**
     * Cleans up old temporary files
     */
    public static void cleanupTempFiles(String tempDirectory, int maxAgeHours) {
        try {
            Path tempDir = Paths.get(tempDirectory);
            if (!Files.exists(tempDir)) {
                return;
            }
            
            long cutoffTime = System.currentTimeMillis() - (maxAgeHours * 60 * 60 * 1000L);
            
            Files.walk(tempDir)
                    .filter(Files::isRegularFile)
                    .filter(path -> {
                        try {
                            return Files.getLastModifiedTime(path).toMillis() < cutoffTime;
                        } catch (IOException e) {
                            return false;
                        }
                    })
                    .forEach(path -> {
                        try {
                            Files.delete(path);
                            log.debug("Cleaned up old temp file: {}", path);
                        } catch (IOException e) {
                            log.warn("Failed to delete old temp file: {}", path, e);
                        }
                    });
                    
        } catch (IOException e) {
            log.error("Failed to cleanup temp files in directory: {}", tempDirectory, e);
        }
    }
}
</file>

<file path="src/main/java/com/example/demo/common/util/StringUtil.java">
package com.example.demo.common.util;

import lombok.experimental.UtilityClass;

import java.util.Collection;
import java.util.regex.Pattern;

/**
 * Utility class for common string operations.
 * 
 * Provides string validation, formatting, and manipulation
 * methods used throughout the application.
 */
@UtilityClass
public class StringUtil {
    
    private static final Pattern EMAIL_PATTERN = Pattern.compile(
            "^[a-zA-Z0-9_+&*-]+(?:\\.[a-zA-Z0-9_+&*-]+)*@" +
            "(?:[a-zA-Z0-9-]+\\.)+[a-zA-Z]{2,7}$"
    );
    
    private static final Pattern PHONE_PATTERN = Pattern.compile(
            "^[+]?[1-9]\\d{1,14}$"
    );
    
    /**
     * Checks if a string is null or empty
     */
    public static boolean isEmpty(String str) {
        return str == null || str.trim().isEmpty();
    }
    
    /**
     * Checks if a string is not null and not empty
     */
    public static boolean isNotEmpty(String str) {
        return !isEmpty(str);
    }
    
    /**
     * Checks if a string is null, empty, or contains only whitespace
     */
    public static boolean isBlank(String str) {
        return str == null || str.trim().isEmpty();
    }
    
    /**
     * Checks if a string is not blank
     */
    public static boolean isNotBlank(String str) {
        return !isBlank(str);
    }
    
    /**
     * Capitalizes the first letter of a string
     */
    public static String capitalize(String str) {
        if (isEmpty(str)) {
            return str;
        }
        return str.substring(0, 1).toUpperCase() + str.substring(1).toLowerCase();
    }
    
    /**
     * Converts a string to camelCase
     */
    public static String toCamelCase(String str) {
        if (isEmpty(str)) {
            return str;
        }
        
        StringBuilder result = new StringBuilder();
        boolean capitalizeNext = false;
        
        for (char c : str.toCharArray()) {
            if (c == ' ' || c == '_' || c == '-') {
                capitalizeNext = true;
            } else if (capitalizeNext) {
                result.append(Character.toUpperCase(c));
                capitalizeNext = false;
            } else {
                result.append(Character.toLowerCase(c));
            }
        }
        
        return result.toString();
    }
    
    /**
     * Validates an email address format
     */
    public static boolean isValidEmail(String email) {
        return isNotEmpty(email) && EMAIL_PATTERN.matcher(email).matches();
    }
    
    /**
     * Validates a phone number format
     */
    public static boolean isValidPhone(String phone) {
        if (isEmpty(phone)) {
            return false;
        }
        // Remove common separators
        String cleanPhone = phone.replaceAll("[\\s\\-\\(\\)]", "");
        return PHONE_PATTERN.matcher(cleanPhone).matches();
    }
    
    /**
     * Masks sensitive information (e.g., email, phone)
     */
    public static String maskEmail(String email) {
        if (isEmpty(email) || !email.contains("@")) {
            return email;
        }
        
        String[] parts = email.split("@");
        String username = parts[0];
        String domain = parts[1];
        
        if (username.length() <= 2) {
            return "*".repeat(username.length()) + "@" + domain;
        }
        
        return username.charAt(0) + "*".repeat(username.length() - 2) + 
               username.charAt(username.length() - 1) + "@" + domain;
    }
    
    /**
     * Masks phone number
     */
    public static String maskPhone(String phone) {
        if (isEmpty(phone) || phone.length() < 4) {
            return "*".repeat(phone.length());
        }
        
        return "*".repeat(phone.length() - 4) + phone.substring(phone.length() - 4);
    }
    
    /**
     * Joins a collection of strings with a delimiter
     */
    public static String join(Collection<String> strings, String delimiter) {
        if (strings == null || strings.isEmpty()) {
            return "";
        }
        return String.join(delimiter, strings);
    }
    
    /**
     * Truncates a string to a maximum length
     */
    public static String truncate(String str, int maxLength) {
        if (isEmpty(str) || str.length() <= maxLength) {
            return str;
        }
        return str.substring(0, maxLength - 3) + "...";
    }
    
    /**
     * Generates a random alphanumeric string
     */
    public static String generateRandomString(int length) {
        String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
        StringBuilder result = new StringBuilder();
        
        for (int i = 0; i < length; i++) {
            int index = (int) (Math.random() * chars.length());
            result.append(chars.charAt(index));
        }
        
        return result.toString();
    }
}
</file>

<file path="src/main/java/com/example/demo/common/util/ValidationUtil.java">
package com.example.demo.common.util;

import lombok.experimental.UtilityClass;

import java.time.LocalDate;
import java.util.regex.Pattern;

/**
 * Utility class for custom validation operations.
 * 
 * Provides business-specific validation methods that complement
 * standard Bean Validation annotations.
 */
@UtilityClass
public class ValidationUtil {
    
    private static final Pattern EMPLOYEE_NUMBER_PATTERN = Pattern.compile("^EMP\\d{6}$");
    private static final Pattern DEPARTMENT_CODE_PATTERN = Pattern.compile("^DEPT\\d{4}$");
    private static final Pattern POSITION_CODE_PATTERN = Pattern.compile("^POS\\d{4}$");
    
    /**
     * Validates employee number format (EMP followed by 6 digits)
     */
    public static boolean isValidEmployeeNumber(String employeeNumber) {
        return StringUtil.isNotEmpty(employeeNumber) && 
               EMPLOYEE_NUMBER_PATTERN.matcher(employeeNumber).matches();
    }
    
    /**
     * Validates department code format (DEPT followed by 4 digits)
     */
    public static boolean isValidDepartmentCode(String departmentCode) {
        return StringUtil.isNotEmpty(departmentCode) && 
               DEPARTMENT_CODE_PATTERN.matcher(departmentCode).matches();
    }
    
    /**
     * Validates position code format (POS followed by 4 digits)
     */
    public static boolean isValidPositionCode(String positionCode) {
        return StringUtil.isNotEmpty(positionCode) && 
               POSITION_CODE_PATTERN.matcher(positionCode).matches();
    }
    
    /**
     * Validates that a date of birth is reasonable for an employee
     */
    public static boolean isValidDateOfBirth(LocalDate dateOfBirth) {
        if (dateOfBirth == null) {
            return false;
        }
        
        LocalDate now = LocalDate.now();
        LocalDate minDate = now.minusYears(100); // Maximum age 100
        LocalDate maxDate = now.minusYears(16);  // Minimum age 16
        
        return !dateOfBirth.isBefore(minDate) && !dateOfBirth.isAfter(maxDate);
    }
    
    /**
     * Validates that a hire date is reasonable
     */
    public static boolean isValidHireDate(LocalDate hireDate) {
        if (hireDate == null) {
            return false;
        }
        
        LocalDate now = LocalDate.now();
        LocalDate minDate = now.minusYears(50); // Company founded max 50 years ago
        LocalDate maxDate = now.plusDays(30);   // Can be hired up to 30 days in future
        
        return !hireDate.isBefore(minDate) && !hireDate.isAfter(maxDate);
    }
    
    /**
     * Validates salary range
     */
    public static boolean isValidSalary(Double salary) {
        return salary != null && salary > 0 && salary <= 1000000; // Max salary 1M
    }
    
    /**
     * Validates that minimum salary is less than maximum salary
     */
    public static boolean isValidSalaryRange(Double minSalary, Double maxSalary) {
        if (minSalary == null || maxSalary == null) {
            return false;
        }
        return minSalary > 0 && maxSalary > 0 && minSalary <= maxSalary;
    }
    
    /**
     * Validates password strength
     */
    public static boolean isValidPassword(String password) {
        if (StringUtil.isEmpty(password) || password.length() < 8) {
            return false;
        }
        
        boolean hasUpper = password.chars().anyMatch(Character::isUpperCase);
        boolean hasLower = password.chars().anyMatch(Character::isLowerCase);
        boolean hasDigit = password.chars().anyMatch(Character::isDigit);
        boolean hasSpecial = password.chars().anyMatch(ch -> "!@#$%^&*()_+-=[]{}|;:,.<>?".indexOf(ch) >= 0);
        
        return hasUpper && hasLower && hasDigit && hasSpecial;
    }
    
    /**
     * Validates username format
     */
    public static boolean isValidUsername(String username) {
        if (StringUtil.isEmpty(username)) {
            return false;
        }
        
        // Username should be 3-20 characters, alphanumeric and underscore only
        Pattern usernamePattern = Pattern.compile("^[a-zA-Z0-9_]{3,20}$");
        return usernamePattern.matcher(username).matches();
    }
    
    /**
     * Validates that a string contains only letters and spaces
     */
    public static boolean isValidName(String name) {
        if (StringUtil.isEmpty(name)) {
            return false;
        }
        
        Pattern namePattern = Pattern.compile("^[a-zA-Z\\s]{2,50}$");
        return namePattern.matcher(name.trim()).matches();
    }
    
    /**
     * Validates postal code format (flexible for different countries)
     */
    public static boolean isValidPostalCode(String postalCode) {
        if (StringUtil.isEmpty(postalCode)) {
            return false;
        }
        
        // Basic validation - alphanumeric, spaces, hyphens, 3-10 characters
        Pattern postalPattern = Pattern.compile("^[a-zA-Z0-9\\s\\-]{3,10}$");
        return postalPattern.matcher(postalCode.trim()).matches();
    }
}
</file>

<file path="src/main/java/com/example/demo/communication/announcement/controller/AnnouncementController.java">
package com.example.demo.communication.announcement.controller;

import com.example.demo.communication.announcement.dto.AnnouncementCreateRequest;
import com.example.demo.communication.announcement.dto.AnnouncementDto;
import com.example.demo.communication.announcement.dto.AnnouncementStatisticsDto;
import com.example.demo.communication.announcement.dto.AnnouncementUpdateRequest;
import com.example.demo.communication.announcement.entity.AnnouncementTarget;
import com.example.demo.communication.announcement.service.AnnouncementService;
import com.example.demo.common.dto.ApiResponse;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/v1/announcements")
@RequiredArgsConstructor
public class AnnouncementController {

    private final AnnouncementService announcementService;

    @PostMapping
    @PreAuthorize("hasAuthority('ANNOUNCEMENT_CREATE')")
    public ResponseEntity<ApiResponse<AnnouncementDto>> createAnnouncement(
            @Valid @RequestBody AnnouncementCreateRequest request,
            Authentication authentication) {
        
        Long authorId = getCurrentUserId(authentication);
        AnnouncementDto announcement = announcementService.createAnnouncement(request, authorId);
        
        return ResponseEntity.status(HttpStatus.CREATED)
                .body(ApiResponse.success(announcement, "Announcement created successfully"));
    }

    @PutMapping("/{id}")
    @PreAuthorize("hasAuthority('ANNOUNCEMENT_UPDATE')")
    public ResponseEntity<ApiResponse<AnnouncementDto>> updateAnnouncement(
            @PathVariable Long id,
            @Valid @RequestBody AnnouncementUpdateRequest request,
            Authentication authentication) {
        
        Long updatedBy = getCurrentUserId(authentication);
        AnnouncementDto announcement = announcementService.updateAnnouncement(id, request, updatedBy);
        
        return ResponseEntity.ok(ApiResponse.success(announcement, "Announcement updated successfully"));
    }

    @GetMapping("/{id}")
    @PreAuthorize("hasAuthority('ANNOUNCEMENT_READ')")
    public ResponseEntity<ApiResponse<AnnouncementDto>> getAnnouncement(@PathVariable Long id) {
        AnnouncementDto announcement = announcementService.getAnnouncement(id);
        return ResponseEntity.ok(ApiResponse.success(announcement));
    }

    @GetMapping
    @PreAuthorize("hasAuthority('ANNOUNCEMENT_READ')")
    public ResponseEntity<ApiResponse<Page<AnnouncementDto>>> getAllAnnouncements(Pageable pageable) {
        Page<AnnouncementDto> announcements = announcementService.getAllAnnouncements(pageable);
        return ResponseEntity.ok(ApiResponse.success(announcements));
    }

    @GetMapping("/published")
    @PreAuthorize("hasAuthority('ANNOUNCEMENT_READ')")
    public ResponseEntity<ApiResponse<Page<AnnouncementDto>>> getPublishedAnnouncements(Pageable pageable) {
        Page<AnnouncementDto> announcements = announcementService.getPublishedAnnouncements(pageable);
        return ResponseEntity.ok(ApiResponse.success(announcements));
    }

    @GetMapping("/active")
    @PreAuthorize("hasAuthority('ANNOUNCEMENT_READ')")
    public ResponseEntity<ApiResponse<Page<AnnouncementDto>>> getActiveAnnouncements(Pageable pageable) {
        Page<AnnouncementDto> announcements = announcementService.getActiveAnnouncements(pageable);
        return ResponseEntity.ok(ApiResponse.success(announcements));
    }

    @GetMapping("/my-announcements")
    @PreAuthorize("hasAuthority('ANNOUNCEMENT_READ')")
    public ResponseEntity<ApiResponse<Page<AnnouncementDto>>> getAnnouncementsForUser(
            @RequestParam(required = false) Long departmentId,
            @RequestParam(required = false) String roleName,
            Pageable pageable,
            Authentication authentication) {
        
        Long userId = getCurrentUserId(authentication);
        Page<AnnouncementDto> announcements = announcementService.getAnnouncementsForUser(
                userId, departmentId, roleName, pageable);
        
        return ResponseEntity.ok(ApiResponse.success(announcements));
    }

    @GetMapping("/by-author/{authorId}")
    @PreAuthorize("hasAuthority('ANNOUNCEMENT_READ')")
    public ResponseEntity<ApiResponse<Page<AnnouncementDto>>> getAnnouncementsByAuthor(
            @PathVariable Long authorId,
            Pageable pageable) {
        
        Page<AnnouncementDto> announcements = announcementService.getAnnouncementsByAuthor(authorId, pageable);
        return ResponseEntity.ok(ApiResponse.success(announcements));
    }

    @GetMapping("/by-target/{targetAudience}")
    @PreAuthorize("hasAuthority('ANNOUNCEMENT_READ')")
    public ResponseEntity<ApiResponse<Page<AnnouncementDto>>> getAnnouncementsByTarget(
            @PathVariable AnnouncementTarget targetAudience,
            Pageable pageable) {
        
        Page<AnnouncementDto> announcements = announcementService.getAnnouncementsByTarget(targetAudience, pageable);
        return ResponseEntity.ok(ApiResponse.success(announcements));
    }

    @PutMapping("/{id}/publish")
    @PreAuthorize("hasAuthority('ANNOUNCEMENT_PUBLISH')")
    public ResponseEntity<ApiResponse<AnnouncementDto>> publishAnnouncement(
            @PathVariable Long id,
            Authentication authentication) {
        
        Long publishedBy = getCurrentUserId(authentication);
        AnnouncementDto announcement = announcementService.publishAnnouncement(id, publishedBy);
        
        return ResponseEntity.ok(ApiResponse.success(announcement, "Announcement published successfully"));
    }

    @PutMapping("/{id}/unpublish")
    @PreAuthorize("hasAuthority('ANNOUNCEMENT_PUBLISH')")
    public ResponseEntity<ApiResponse<AnnouncementDto>> unpublishAnnouncement(
            @PathVariable Long id,
            Authentication authentication) {
        
        Long unpublishedBy = getCurrentUserId(authentication);
        AnnouncementDto announcement = announcementService.unpublishAnnouncement(id, unpublishedBy);
        
        return ResponseEntity.ok(ApiResponse.success(announcement, "Announcement unpublished successfully"));
    }

    @DeleteMapping("/{id}")
    @PreAuthorize("hasAuthority('ANNOUNCEMENT_DELETE')")
    public ResponseEntity<ApiResponse<Void>> deleteAnnouncement(
            @PathVariable Long id,
            Authentication authentication) {
        
        Long deletedBy = getCurrentUserId(authentication);
        announcementService.deleteAnnouncement(id, deletedBy);
        
        return ResponseEntity.ok(ApiResponse.success(null, "Announcement deleted successfully"));
    }

    @GetMapping("/statistics")
    @PreAuthorize("hasAuthority('ANNOUNCEMENT_READ')")
    public ResponseEntity<ApiResponse<AnnouncementStatisticsDto>> getAnnouncementStatistics() {
        AnnouncementStatisticsDto statistics = announcementService.getAnnouncementStatistics();
        return ResponseEntity.ok(ApiResponse.success(statistics));
    }

    @PostMapping("/cleanup-expired")
    @PreAuthorize("hasAuthority('ANNOUNCEMENT_MANAGE')")
    public ResponseEntity<ApiResponse<Integer>> cleanupExpiredAnnouncements() {
        int cleanedUp = announcementService.cleanupExpiredAnnouncements();
        return ResponseEntity.ok(ApiResponse.success(cleanedUp, 
                "Expired announcements cleanup completed"));
    }

    private Long getCurrentUserId(Authentication authentication) {
        // This should extract user ID from the authentication object
        // Implementation depends on your security setup
        return Long.parseLong(authentication.getName());
    }
}
</file>

<file path="src/main/java/com/example/demo/communication/announcement/dto/AnnouncementCreateRequest.java">
package com.example.demo.communication.announcement.dto;

import com.example.demo.communication.announcement.entity.Announcement.AnnouncementPriority;
import com.example.demo.communication.announcement.entity.AnnouncementTarget;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.Data;

import java.time.LocalDate;

@Data
public class AnnouncementCreateRequest {
    @NotBlank(message = "Title is required")
    @Size(max = 200, message = "Title must not exceed 200 characters")
    private String title;
    
    @NotBlank(message = "Content is required")
    private String content;
    
    @NotNull(message = "Target audience is required")
    private AnnouncementTarget targetAudience;
    
    private Long departmentId; // Required if targetAudience is DEPARTMENT
    
    @Size(max = 100, message = "Role name must not exceed 100 characters")
    private String roleName; // Required if targetAudience is ROLE
    
    private LocalDate publishDate;
    
    private LocalDate expiryDate;
    
    private boolean published = false;
    
    private AnnouncementPriority priority = AnnouncementPriority.NORMAL;
}
</file>

<file path="src/main/java/com/example/demo/communication/announcement/dto/AnnouncementDto.java">
package com.example.demo.communication.announcement.dto;

import com.example.demo.communication.announcement.entity.Announcement.AnnouncementPriority;
import com.example.demo.communication.announcement.entity.AnnouncementTarget;
import lombok.Data;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import java.time.Instant;
import java.time.LocalDate;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class AnnouncementDto {
    private Long id;
    private String title;
    private String content;
    private Long authorId;
    private AnnouncementTarget targetAudience;
    private Long departmentId;
    private String roleName;
    private LocalDate publishDate;
    private LocalDate expiryDate;
    private boolean published;
    private AnnouncementPriority priority;
    private Instant createdAt;
    private Instant updatedAt;
    private Long createdBy;
    private Long updatedBy;
    
    // Additional fields for UI
    private String authorName;
    private String departmentName;
    private boolean isExpired;
    private boolean canEdit;
    private boolean canDelete;
    private boolean canPublish;
    private int daysUntilExpiry;
}
</file>

<file path="src/main/java/com/example/demo/communication/announcement/dto/AnnouncementStatisticsDto.java">
package com.example.demo.communication.announcement.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class AnnouncementStatisticsDto {
    private long totalAnnouncements;
    private long publishedAnnouncements;
    private long expiredAnnouncements;
    private long draftAnnouncements;
}
</file>

<file path="src/main/java/com/example/demo/communication/announcement/dto/AnnouncementUpdateRequest.java">
package com.example.demo.communication.announcement.dto;

import com.example.demo.communication.announcement.entity.Announcement.AnnouncementPriority;
import com.example.demo.communication.announcement.entity.AnnouncementTarget;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.Data;

import java.time.LocalDate;

@Data
public class AnnouncementUpdateRequest {
    @NotBlank(message = "Title is required")
    @Size(max = 200, message = "Title must not exceed 200 characters")
    private String title;
    
    @NotBlank(message = "Content is required")
    private String content;
    
    @NotNull(message = "Target audience is required")
    private AnnouncementTarget targetAudience;
    
    private Long departmentId; // Required if targetAudience is DEPARTMENT
    
    @Size(max = 100, message = "Role name must not exceed 100 characters")
    private String roleName; // Required if targetAudience is ROLE
    
    private LocalDate publishDate;
    
    private LocalDate expiryDate;
    
    private boolean published;
    
    private AnnouncementPriority priority = AnnouncementPriority.NORMAL;
}
</file>

<file path="src/main/java/com/example/demo/communication/announcement/entity/AnnouncementTarget.java">
package com.example.demo.communication.announcement.entity;

public enum AnnouncementTarget {
    ALL,          // All employees
    DEPARTMENT,   // Specific department
    ROLE          // Specific role
}
</file>

<file path="src/main/java/com/example/demo/communication/announcement/repository/AnnouncementRepository.java">
package com.example.demo.communication.announcement.repository;

import com.example.demo.communication.announcement.entity.Announcement;
import com.example.demo.communication.announcement.entity.AnnouncementTarget;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDate;
import java.util.List;

@Repository
public interface AnnouncementRepository extends JpaRepository<Announcement, Long> {
    
    /**
     * Find published announcements
     */
    Page<Announcement> findByPublishedTrueOrderByCreatedAtDesc(Pageable pageable);
    
    /**
     * Find announcements by author
     */
    Page<Announcement> findByAuthorIdOrderByCreatedAtDesc(Long authorId, Pageable pageable);
    
    /**
     * Find announcements by target audience
     */
    Page<Announcement> findByTargetAudienceOrderByCreatedAtDesc(AnnouncementTarget targetAudience, Pageable pageable);
    
    /**
     * Find announcements for a specific department
     */
    Page<Announcement> findByTargetAudienceAndDepartmentIdAndPublishedTrueOrderByCreatedAtDesc(
            AnnouncementTarget targetAudience, Long departmentId, Pageable pageable);
    
    /**
     * Find active announcements (published and not expired)
     */
    @Query("SELECT a FROM Announcement a WHERE a.published = true " +
           "AND (a.expiryDate IS NULL OR a.expiryDate >= :currentDate) " +
           "ORDER BY a.createdAt DESC")
    Page<Announcement> findActiveAnnouncements(@Param("currentDate") LocalDate currentDate, Pageable pageable);
    
    /**
     * Find announcements visible to user based on department and role
     */
    @Query("SELECT a FROM Announcement a WHERE a.published = true " +
           "AND (a.expiryDate IS NULL OR a.expiryDate >= :currentDate) " +
           "AND (a.targetAudience = 'ALL' " +
           "     OR (a.targetAudience = 'DEPARTMENT' AND a.departmentId = :departmentId) " +
           "     OR (a.targetAudience = 'ROLE' AND a.roleName = :roleName)) " +
           "ORDER BY a.priority DESC, a.createdAt DESC")
    Page<Announcement> findAnnouncementsForUser(
            @Param("currentDate") LocalDate currentDate,
            @Param("departmentId") Long departmentId,
            @Param("roleName") String roleName,
            Pageable pageable);
    
    /**
     * Find expired announcements
     */
    @Query("SELECT a FROM Announcement a WHERE a.expiryDate IS NOT NULL AND a.expiryDate < :currentDate")
    List<Announcement> findExpiredAnnouncements(@Param("currentDate") LocalDate currentDate);
    
    /**
     * Count published announcements
     */
    long countByPublishedTrue();
    
    /**
     * Count announcements by author
     */
    long countByAuthorId(Long authorId);
}
</file>

<file path="src/main/java/com/example/demo/communication/announcement/service/AnnouncementScheduledService.java">
package com.example.demo.communication.announcement.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
@Slf4j
public class AnnouncementScheduledService {

    private final AnnouncementService announcementService;

    /**
     * Clean up expired announcements daily at 2 AM
     */
    @Scheduled(cron = "0 0 2 * * ?")
    public void cleanupExpiredAnnouncements() {
        try {
            log.info("Starting scheduled cleanup of expired announcements");
            int cleanedUp = announcementService.cleanupExpiredAnnouncements();
            log.info("Scheduled cleanup completed. {} expired announcements processed", cleanedUp);
        } catch (Exception e) {
            log.error("Error during scheduled cleanup of expired announcements: {}", e.getMessage(), e);
        }
    }
}
</file>

<file path="src/main/java/com/example/demo/communication/announcement/service/AnnouncementService.java">
package com.example.demo.communication.announcement.service;

import com.example.demo.communication.announcement.dto.AnnouncementCreateRequest;
import com.example.demo.communication.announcement.dto.AnnouncementDto;
import com.example.demo.communication.announcement.dto.AnnouncementStatisticsDto;
import com.example.demo.communication.announcement.dto.AnnouncementUpdateRequest;
import com.example.demo.communication.announcement.entity.AnnouncementTarget;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import java.util.List;

public interface AnnouncementService {
    
    /**
     * Create a new announcement
     * @param request Announcement creation request
     * @param authorId User ID who is creating the announcement
     * @return Created announcement DTO
     */
    AnnouncementDto createAnnouncement(AnnouncementCreateRequest request, Long authorId);
    
    /**
     * Update an existing announcement
     * @param id Announcement ID
     * @param request Announcement update request
     * @param updatedBy User ID who is updating the announcement
     * @return Updated announcement DTO
     */
    AnnouncementDto updateAnnouncement(Long id, AnnouncementUpdateRequest request, Long updatedBy);
    
    /**
     * Get announcement by ID
     * @param id Announcement ID
     * @return Announcement DTO
     */
    AnnouncementDto getAnnouncement(Long id);
    
    /**
     * Get all announcements with pagination
     * @param pageable Pagination parameters
     * @return Page of announcement DTOs
     */
    Page<AnnouncementDto> getAllAnnouncements(Pageable pageable);
    
    /**
     * Get published announcements
     * @param pageable Pagination parameters
     * @return Page of published announcement DTOs
     */
    Page<AnnouncementDto> getPublishedAnnouncements(Pageable pageable);
    
    /**
     * Get active announcements (published and not expired)
     * @param pageable Pagination parameters
     * @return Page of active announcement DTOs
     */
    Page<AnnouncementDto> getActiveAnnouncements(Pageable pageable);
    
    /**
     * Get announcements for a specific user based on their department and role
     * @param userId User ID
     * @param departmentId User's department ID
     * @param roleName User's role name
     * @param pageable Pagination parameters
     * @return Page of announcement DTOs visible to the user
     */
    Page<AnnouncementDto> getAnnouncementsForUser(Long userId, Long departmentId, String roleName, Pageable pageable);
    
    /**
     * Get announcements by author
     * @param authorId Author user ID
     * @param pageable Pagination parameters
     * @return Page of announcement DTOs
     */
    Page<AnnouncementDto> getAnnouncementsByAuthor(Long authorId, Pageable pageable);
    
    /**
     * Get announcements by target audience
     * @param targetAudience Target audience type
     * @param pageable Pagination parameters
     * @return Page of announcement DTOs
     */
    Page<AnnouncementDto> getAnnouncementsByTarget(AnnouncementTarget targetAudience, Pageable pageable);
    
    /**
     * Publish an announcement
     * @param id Announcement ID
     * @param publishedBy User ID who is publishing
     * @return Updated announcement DTO
     */
    AnnouncementDto publishAnnouncement(Long id, Long publishedBy);
    
    /**
     * Unpublish an announcement
     * @param id Announcement ID
     * @param unpublishedBy User ID who is unpublishing
     * @return Updated announcement DTO
     */
    AnnouncementDto unpublishAnnouncement(Long id, Long unpublishedBy);
    
    /**
     * Delete an announcement
     * @param id Announcement ID
     * @param deletedBy User ID who is deleting
     */
    void deleteAnnouncement(Long id, Long deletedBy);
    
    /**
     * Get announcement statistics
     * @return Announcement statistics
     */
    AnnouncementStatisticsDto getAnnouncementStatistics();
    
    /**
     * Clean up expired announcements
     * @return Number of expired announcements cleaned up
     */
    int cleanupExpiredAnnouncements();
}
</file>

<file path="src/main/java/com/example/demo/communication/announcement/service/AnnouncementValidationService.java">
package com.example.demo.communication.announcement.service;

import com.example.demo.communication.announcement.dto.AnnouncementCreateRequest;
import com.example.demo.communication.announcement.dto.AnnouncementUpdateRequest;
import com.example.demo.communication.announcement.entity.AnnouncementTarget;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.time.LocalDate;

@Service
@RequiredArgsConstructor
@Slf4j
public class AnnouncementValidationService {

    /**
     * Validate announcement creation request
     */
    public void validateCreateRequest(AnnouncementCreateRequest request) {
        validateCommonFields(request.getTargetAudience(), request.getDepartmentId(), 
                           request.getRoleName(), request.getPublishDate(), request.getExpiryDate());
    }

    /**
     * Validate announcement update request
     */
    public void validateUpdateRequest(AnnouncementUpdateRequest request) {
        validateCommonFields(request.getTargetAudience(), request.getDepartmentId(), 
                           request.getRoleName(), request.getPublishDate(), request.getExpiryDate());
    }

    /**
     * Validate common fields across create and update requests
     */
    private void validateCommonFields(AnnouncementTarget targetAudience, Long departmentId, 
                                    String roleName, LocalDate publishDate, LocalDate expiryDate) {
        
        // Validate target audience specific requirements
        if (targetAudience == AnnouncementTarget.DEPARTMENT && departmentId == null) {
            throw new IllegalArgumentException("Department ID is required when target audience is DEPARTMENT");
        }
        
        if (targetAudience == AnnouncementTarget.ROLE && (roleName == null || roleName.trim().isEmpty())) {
            throw new IllegalArgumentException("Role name is required when target audience is ROLE");
        }
        
        // Validate date logic
        if (publishDate != null && publishDate.isBefore(LocalDate.now())) {
            log.warn("Publish date is in the past: {}", publishDate);
        }
        
        if (expiryDate != null) {
            if (expiryDate.isBefore(LocalDate.now())) {
                throw new IllegalArgumentException("Expiry date cannot be in the past");
            }
            
            if (publishDate != null && expiryDate.isBefore(publishDate)) {
                throw new IllegalArgumentException("Expiry date cannot be before publish date");
            }
        }
    }

    /**
     * Check if user can publish announcement
     */
    public boolean canUserPublishAnnouncement(Long userId, AnnouncementTarget targetAudience, Long departmentId) {
        // Add your business logic here
        // For example, check if user has permission to publish to specific departments
        return true; // Simplified for now
    }

    /**
     * Check if user can edit announcement
     */
    public boolean canUserEditAnnouncement(Long userId, Long authorId) {
        // Users can edit their own announcements, or admins can edit any
        return userId.equals(authorId); // Simplified for now
    }

    /**
     * Check if user can delete announcement
     */
    public boolean canUserDeleteAnnouncement(Long userId, Long authorId) {
        // Users can delete their own announcements, or admins can delete any
        return userId.equals(authorId); // Simplified for now
    }
}
</file>

<file path="src/main/java/com/example/demo/communication/announcement/service/impl/AnnouncementServiceImpl.java">
package com.example.demo.communication.announcement.service.impl;

import com.example.demo.communication.announcement.dto.AnnouncementCreateRequest;
import com.example.demo.communication.announcement.dto.AnnouncementDto;
import com.example.demo.communication.announcement.dto.AnnouncementStatisticsDto;
import com.example.demo.communication.announcement.dto.AnnouncementUpdateRequest;
import com.example.demo.communication.announcement.entity.Announcement;
import com.example.demo.communication.announcement.entity.AnnouncementTarget;
import com.example.demo.communication.announcement.repository.AnnouncementRepository;
import com.example.demo.communication.announcement.service.AnnouncementService;
import com.example.demo.communication.notification.service.NotificationService;
import com.example.demo.communication.notification.entity.NotificationType;
import com.example.demo.communication.exception.AnnouncementNotFoundException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.Instant;
import java.time.LocalDate;
import java.time.temporal.ChronoUnit;
import java.util.List;
import java.util.concurrent.CompletableFuture;

@Service
@RequiredArgsConstructor
@Slf4j
public class AnnouncementServiceImpl implements AnnouncementService {

    private final AnnouncementRepository announcementRepository;
    private final NotificationService notificationService;

    @Override
    @Transactional
    public AnnouncementDto createAnnouncement(AnnouncementCreateRequest request, Long authorId) {
        log.info("Creating announcement: {} by user {}", request.getTitle(), authorId);
        
        validateAnnouncementRequest(request);
        
        Announcement announcement = Announcement.builder()
                .title(request.getTitle())
                .content(request.getContent())
                .authorId(authorId)
                .targetAudience(request.getTargetAudience())
                .departmentId(request.getDepartmentId())
                .roleName(request.getRoleName())
                .publishDate(request.getPublishDate())
                .expiryDate(request.getExpiryDate())
                .published(request.isPublished())
                .priority(request.getPriority())
                .createdBy(authorId)
                .build();
        
        Announcement savedAnnouncement = announcementRepository.save(announcement);
        
        // If published immediately, trigger notifications
        if (savedAnnouncement.isPublished()) {
            sendAnnouncementNotifications(savedAnnouncement);
        }
        
        log.info("Announcement created successfully: {}", savedAnnouncement.getId());
        return convertToDto(savedAnnouncement);
    }

    @Override
    @Transactional
    public AnnouncementDto updateAnnouncement(Long id, AnnouncementUpdateRequest request, Long updatedBy) {
        log.info("Updating announcement {} by user {}", id, updatedBy);
        
        Announcement announcement = announcementRepository.findById(id)
                .orElseThrow(() -> new AnnouncementNotFoundException("Announcement not found: " + id));
        
        validateAnnouncementRequest(request);
        
        boolean wasPublished = announcement.isPublished();
        
        announcement.setTitle(request.getTitle());
        announcement.setContent(request.getContent());
        announcement.setTargetAudience(request.getTargetAudience());
        announcement.setDepartmentId(request.getDepartmentId());
        announcement.setRoleName(request.getRoleName());
        announcement.setPublishDate(request.getPublishDate());
        announcement.setExpiryDate(request.getExpiryDate());
        announcement.setPublished(request.isPublished());
        announcement.setPriority(request.getPriority());
        announcement.setUpdatedBy(updatedBy);
        
        Announcement savedAnnouncement = announcementRepository.save(announcement);
        
        // If newly published or content changed while published, send notifications
        if (savedAnnouncement.isPublished() && (!wasPublished || !wasPublished)) {
            sendAnnouncementNotifications(savedAnnouncement);
        }
        
        log.info("Announcement updated successfully: {}", savedAnnouncement.getId());
        return convertToDto(savedAnnouncement);
    }

    @Override
    public AnnouncementDto getAnnouncement(Long id) {
        Announcement announcement = announcementRepository.findById(id)
                .orElseThrow(() -> new AnnouncementNotFoundException("Announcement not found: " + id));
        return convertToDto(announcement);
    }

    @Override
    public Page<AnnouncementDto> getAllAnnouncements(Pageable pageable) {
        Page<Announcement> announcements = announcementRepository.findAll(pageable);
        return announcements.map(this::convertToDto);
    }

    @Override
    public Page<AnnouncementDto> getPublishedAnnouncements(Pageable pageable) {
        Page<Announcement> announcements = announcementRepository.findByPublishedTrueOrderByCreatedAtDesc(pageable);
        return announcements.map(this::convertToDto);
    }

    @Override
    public Page<AnnouncementDto> getActiveAnnouncements(Pageable pageable) {
        Page<Announcement> announcements = announcementRepository.findActiveAnnouncements(LocalDate.now(), pageable);
        return announcements.map(this::convertToDto);
    }

    @Override
    public Page<AnnouncementDto> getAnnouncementsForUser(Long userId, Long departmentId, String roleName, Pageable pageable) {
        Page<Announcement> announcements = announcementRepository.findAnnouncementsForUser(
                LocalDate.now(), departmentId, roleName, pageable);
        return announcements.map(this::convertToDto);
    }

    @Override
    public Page<AnnouncementDto> getAnnouncementsByAuthor(Long authorId, Pageable pageable) {
        Page<Announcement> announcements = announcementRepository.findByAuthorIdOrderByCreatedAtDesc(authorId, pageable);
        return announcements.map(this::convertToDto);
    }

    @Override
    public Page<AnnouncementDto> getAnnouncementsByTarget(AnnouncementTarget targetAudience, Pageable pageable) {
        Page<Announcement> announcements = announcementRepository.findByTargetAudienceOrderByCreatedAtDesc(targetAudience, pageable);
        return announcements.map(this::convertToDto);
    }

    @Override
    @Transactional
    public AnnouncementDto publishAnnouncement(Long id, Long publishedBy) {
        log.info("Publishing announcement {} by user {}", id, publishedBy);
        
        Announcement announcement = announcementRepository.findById(id)
                .orElseThrow(() -> new AnnouncementNotFoundException("Announcement not found: " + id));
        
        if (announcement.isPublished()) {
            throw new IllegalStateException("Announcement is already published");
        }
        
        announcement.setPublished(true);
        announcement.setPublishDate(LocalDate.now());
        announcement.setUpdatedBy(publishedBy);
        
        Announcement savedAnnouncement = announcementRepository.save(announcement);
        
        // Send notifications to target audience
        sendAnnouncementNotifications(savedAnnouncement);
        
        log.info("Announcement published successfully: {}", savedAnnouncement.getId());
        return convertToDto(savedAnnouncement);
    }

    @Override
    @Transactional
    public AnnouncementDto unpublishAnnouncement(Long id, Long unpublishedBy) {
        log.info("Unpublishing announcement {} by user {}", id, unpublishedBy);
        
        Announcement announcement = announcementRepository.findById(id)
                .orElseThrow(() -> new AnnouncementNotFoundException("Announcement not found: " + id));
        
        if (!announcement.isPublished()) {
            throw new IllegalStateException("Announcement is not published");
        }
        
        announcement.setPublished(false);
        announcement.setUpdatedBy(unpublishedBy);
        
        Announcement savedAnnouncement = announcementRepository.save(announcement);
        
        log.info("Announcement unpublished successfully: {}", savedAnnouncement.getId());
        return convertToDto(savedAnnouncement);
    }

    @Override
    @Transactional
    public void deleteAnnouncement(Long id, Long deletedBy) {
        log.info("Deleting announcement {} by user {}", id, deletedBy);
        
        Announcement announcement = announcementRepository.findById(id)
                .orElseThrow(() -> new AnnouncementNotFoundException("Announcement not found: " + id));
        
        announcementRepository.delete(announcement);
        
        log.info("Announcement deleted successfully: {}", id);
    }

    @Override
    public AnnouncementStatisticsDto getAnnouncementStatistics() {
        long total = announcementRepository.count();
        long published = announcementRepository.countByPublishedTrue();
        List<Announcement> expired = announcementRepository.findExpiredAnnouncements(LocalDate.now());
        
        return AnnouncementStatisticsDto.builder()
                .totalAnnouncements(total)
                .publishedAnnouncements(published)
                .expiredAnnouncements(expired.size())
                .draftAnnouncements(total - published)
                .build();
    }

    @Override
    @Transactional
    public int cleanupExpiredAnnouncements() {
        List<Announcement> expiredAnnouncements = announcementRepository.findExpiredAnnouncements(LocalDate.now());
        
        // You might want to archive instead of delete
        // For now, we'll just log them
        log.info("Found {} expired announcements", expiredAnnouncements.size());
        
        return expiredAnnouncements.size();
    }

    private void sendAnnouncementNotifications(Announcement announcement) {
        try {
            String title = "New Announcement: " + announcement.getTitle();
            String content = announcement.getContent();
            
            // This will be handled by the database trigger we created in the migration
            // The trigger automatically creates notifications based on target audience
            log.info("Announcement notifications will be created by database trigger for announcement: {}", 
                    announcement.getId());
            
        } catch (Exception e) {
            log.error("Failed to send announcement notifications for announcement {}: {}", 
                     announcement.getId(), e.getMessage(), e);
        }
    }

    private void validateAnnouncementRequest(Object request) {
        AnnouncementTarget targetAudience;
        Long departmentId;
        String roleName;
        
        if (request instanceof AnnouncementCreateRequest) {
            AnnouncementCreateRequest createRequest = (AnnouncementCreateRequest) request;
            targetAudience = createRequest.getTargetAudience();
            departmentId = createRequest.getDepartmentId();
            roleName = createRequest.getRoleName();
        } else if (request instanceof AnnouncementUpdateRequest) {
            AnnouncementUpdateRequest updateRequest = (AnnouncementUpdateRequest) request;
            targetAudience = updateRequest.getTargetAudience();
            departmentId = updateRequest.getDepartmentId();
            roleName = updateRequest.getRoleName();
        } else {
            return;
        }
        
        if (targetAudience == AnnouncementTarget.DEPARTMENT && departmentId == null) {
            throw new IllegalArgumentException("Department ID is required when target audience is DEPARTMENT");
        }
        
        if (targetAudience == AnnouncementTarget.ROLE && (roleName == null || roleName.trim().isEmpty())) {
            throw new IllegalArgumentException("Role name is required when target audience is ROLE");
        }
    }

    private AnnouncementDto convertToDto(Announcement announcement) {
        AnnouncementDto dto = AnnouncementDto.builder()
                .id(announcement.getId())
                .title(announcement.getTitle())
                .content(announcement.getContent())
                .authorId(announcement.getAuthorId())
                .targetAudience(announcement.getTargetAudience())
                .departmentId(announcement.getDepartmentId())
                .roleName(announcement.getRoleName())
                .publishDate(announcement.getPublishDate())
                .expiryDate(announcement.getExpiryDate())
                .published(announcement.isPublished())
                .priority(announcement.getPriority())
                .createdAt(announcement.getCreatedAt())
                .updatedAt(announcement.getUpdatedAt())
                .createdBy(announcement.getCreatedBy())
                .updatedBy(announcement.getUpdatedBy())
                .build();
        
        // Set additional UI fields
        if (announcement.getExpiryDate() != null) {
            dto.setExpired(announcement.getExpiryDate().isBefore(LocalDate.now()));
            dto.setDaysUntilExpiry((int) ChronoUnit.DAYS.between(LocalDate.now(), announcement.getExpiryDate()));
        }
        
        return dto;
    }
}
</file>

<file path="src/main/java/com/example/demo/communication/chat/controller/ChatController.java">
package com.example.demo.communication.chat.controller;

import com.example.demo.communication.chat.dto.*;
import com.example.demo.communication.chat.service.ChatService;
import com.example.demo.common.dto.ApiResponse;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/v1/chat")
@RequiredArgsConstructor
public class ChatController {

    private final ChatService chatService;

    @PostMapping("/rooms")
    @PreAuthorize("hasAuthority('CHAT_CREATE')")
    public ResponseEntity<ApiResponse<ChatRoomDto>> createChatRoom(
            @Valid @RequestBody CreateChatRoomRequest request,
            Authentication authentication) {
        
        Long userId = getCurrentUserId(authentication);
        ChatRoomDto chatRoom = chatService.createChatRoom(
                request.getName(),
                request.getType(),
                request.getDescription(),
                userId,
                request.getParticipantIds()
        );
        
        return ResponseEntity.status(HttpStatus.CREATED)
                .body(ApiResponse.success(chatRoom, "Chat room created successfully"));
    }

    @GetMapping("/rooms/{roomId}")
    @PreAuthorize("hasAuthority('CHAT_READ')")
    public ResponseEntity<ApiResponse<ChatRoomDto>> getChatRoom(
            @PathVariable Long roomId,
            Authentication authentication) {
        
        Long userId = getCurrentUserId(authentication);
        ChatRoomDto chatRoom = chatService.getChatRoom(roomId, userId);
        
        return ResponseEntity.ok(ApiResponse.success(chatRoom));
    }

    @GetMapping("/rooms")
    @PreAuthorize("hasAuthority('CHAT_READ')")
    public ResponseEntity<ApiResponse<List<ChatRoomDto>>> getUserChatRooms(
            Authentication authentication) {
        
        Long userId = getCurrentUserId(authentication);
        List<ChatRoomDto> chatRooms = chatService.getUserChatRooms(userId);
        
        return ResponseEntity.ok(ApiResponse.success(chatRooms));
    }

    @PostMapping("/messages")
    @PreAuthorize("hasAuthority('CHAT_SEND')")
    public ResponseEntity<ApiResponse<ChatMessageDto>> sendMessage(
            @Valid @RequestBody SendMessageRequest request,
            Authentication authentication) {
        
        Long userId = getCurrentUserId(authentication);
        ChatMessageDto message = chatService.sendMessage(
                request.getRoomId(),
                userId,
                request.getContent(),
                request.getMessageType()
        );
        
        return ResponseEntity.status(HttpStatus.CREATED)
                .body(ApiResponse.success(message, "Message sent successfully"));
    }

    @GetMapping("/rooms/{roomId}/messages")
    @PreAuthorize("hasAuthority('CHAT_READ')")
    public ResponseEntity<ApiResponse<Page<ChatMessageDto>>> getChatMessages(
            @PathVariable Long roomId,
            Pageable pageable,
            Authentication authentication) {
        
        Long userId = getCurrentUserId(authentication);
        Page<ChatMessageDto> messages = chatService.getChatMessages(roomId, userId, pageable);
        
        return ResponseEntity.ok(ApiResponse.success(messages));
    }

    @PutMapping("/messages/{messageId}")
    @PreAuthorize("hasAuthority('CHAT_EDIT')")
    public ResponseEntity<ApiResponse<ChatMessageDto>> editMessage(
            @PathVariable Long messageId,
            @RequestBody String newContent,
            Authentication authentication) {
        
        Long userId = getCurrentUserId(authentication);
        ChatMessageDto message = chatService.editMessage(messageId, userId, newContent);
        
        return ResponseEntity.ok(ApiResponse.success(message, "Message updated successfully"));
    }

    @DeleteMapping("/messages/{messageId}")
    @PreAuthorize("hasAuthority('CHAT_DELETE')")
    public ResponseEntity<ApiResponse<Void>> deleteMessage(
            @PathVariable Long messageId,
            Authentication authentication) {
        
        Long userId = getCurrentUserId(authentication);
        chatService.deleteMessage(messageId, userId);
        
        return ResponseEntity.ok(ApiResponse.success(null, "Message deleted successfully"));
    }

    @PostMapping("/rooms/{roomId}/participants")
    @PreAuthorize("hasAuthority('CHAT_MANAGE')")
    public ResponseEntity<ApiResponse<ChatParticipantDto>> addParticipant(
            @PathVariable Long roomId,
            @RequestParam Long userId,
            Authentication authentication) {
        
        Long addedBy = getCurrentUserId(authentication);
        ChatParticipantDto participant = chatService.addParticipant(roomId, userId, addedBy);
        
        return ResponseEntity.status(HttpStatus.CREATED)
                .body(ApiResponse.success(participant, "Participant added successfully"));
    }

    @DeleteMapping("/rooms/{roomId}/participants/{userId}")
    @PreAuthorize("hasAuthority('CHAT_MANAGE')")
    public ResponseEntity<ApiResponse<Void>> removeParticipant(
            @PathVariable Long roomId,
            @PathVariable Long userId,
            Authentication authentication) {
        
        Long removedBy = getCurrentUserId(authentication);
        chatService.removeParticipant(roomId, userId, removedBy);
        
        return ResponseEntity.ok(ApiResponse.success(null, "Participant removed successfully"));
    }

    @PutMapping("/rooms/{roomId}/read")
    @PreAuthorize("hasAuthority('CHAT_READ')")
    public ResponseEntity<ApiResponse<Void>> markMessagesAsRead(
            @PathVariable Long roomId,
            @RequestParam Long lastReadMessageId,
            Authentication authentication) {
        
        Long userId = getCurrentUserId(authentication);
        chatService.markMessagesAsRead(roomId, userId, lastReadMessageId);
        
        return ResponseEntity.ok(ApiResponse.success(null, "Messages marked as read"));
    }

    @GetMapping("/unread-count")
    @PreAuthorize("hasAuthority('CHAT_READ')")
    public ResponseEntity<ApiResponse<Long>> getUnreadMessageCount(
            Authentication authentication) {
        
        Long userId = getCurrentUserId(authentication);
        Long unreadCount = chatService.getUnreadMessageCount(userId);
        
        return ResponseEntity.ok(ApiResponse.success(unreadCount));
    }

    @GetMapping("/rooms/{roomId}/unread-count")
    @PreAuthorize("hasAuthority('CHAT_READ')")
    public ResponseEntity<ApiResponse<Long>> getUnreadMessageCount(
            @PathVariable Long roomId,
            Authentication authentication) {
        
        Long userId = getCurrentUserId(authentication);
        Long unreadCount = chatService.getUnreadMessageCount(roomId, userId);
        
        return ResponseEntity.ok(ApiResponse.success(unreadCount));
    }

    @GetMapping("/rooms/{roomId}/messages/search")
    @PreAuthorize("hasAuthority('CHAT_READ')")
    public ResponseEntity<ApiResponse<Page<ChatMessageDto>>> searchMessages(
            @PathVariable Long roomId,
            @RequestParam String searchTerm,
            Pageable pageable,
            Authentication authentication) {
        
        Long userId = getCurrentUserId(authentication);
        Page<ChatMessageDto> messages = chatService.searchMessages(roomId, userId, searchTerm, pageable);
        
        return ResponseEntity.ok(ApiResponse.success(messages));
    }

    private Long getCurrentUserId(Authentication authentication) {
        // This should extract user ID from the authentication object
        // Implementation depends on your security setup
        return Long.parseLong(authentication.getName());
    }
}
</file>

<file path="src/main/java/com/example/demo/communication/chat/dto/ChatMessageDto.java">
package com.example.demo.communication.chat.dto;

import com.example.demo.communication.chat.entity.ChatMessageType;
import lombok.Data;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import java.time.Instant;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ChatMessageDto {
    private Long id;
    private Long roomId;
    private Long senderId;
    private String content;
    private ChatMessageType messageType;
    private Instant createdAt;
    private Boolean isEdited;
    private Instant editedAt;
    private Boolean isDeleted;
    private Instant deletedAt;
    
    // Additional fields for UI
    private String senderName;
    private String senderAvatar;
    private boolean isRead;
    private boolean canEdit;
    private boolean canDelete;
}
</file>

<file path="src/main/java/com/example/demo/communication/chat/dto/ChatParticipantDto.java">
package com.example.demo.communication.chat.dto;

import com.example.demo.communication.chat.entity.ChatParticipantRole;
import lombok.Data;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import java.time.Instant;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ChatParticipantDto {
    private Long id;
    private Long roomId;
    private Long userId;
    private ChatParticipantRole role;
    private Instant joinedAt;
    private Instant lastReadAt;
    private Long lastReadMessageId;
    private boolean isMuted;
    private boolean isActive;
    private Instant leftAt;
    
    // Additional fields for UI
    private String userName;
    private String userAvatar;
    private boolean isOnline;
}
</file>

<file path="src/main/java/com/example/demo/communication/chat/dto/ChatRoomDto.java">
package com.example.demo.communication.chat.dto;

import com.example.demo.communication.chat.entity.ChatRoomType;
import lombok.Data;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import java.time.Instant;
import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ChatRoomDto {
    private Long id;
    private String name;
    private ChatRoomType type;
    private String description;
    private String avatarUrl;
    private Long createdBy;
    private boolean isPrivate;
    private boolean isActive;
    private Instant createdAt;
    private Instant updatedAt;
    private Instant lastMessageAt;
    private Long lastMessageId;
    
    // Additional fields for UI
    private Long unreadCount;
    private String lastMessageContent;
    private String lastMessageSender;
    private List<ChatParticipantDto> participants;
    private int participantCount;
}
</file>

<file path="src/main/java/com/example/demo/communication/chat/dto/CreateChatRoomRequest.java">
package com.example.demo.communication.chat.dto;

import com.example.demo.communication.chat.entity.ChatRoomType;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.Data;

import java.util.List;

@Data
public class CreateChatRoomRequest {
    @NotBlank(message = "Room name is required")
    @Size(max = 100, message = "Room name must not exceed 100 characters")
    private String name;
    
    @NotNull(message = "Room type is required")
    private ChatRoomType type;
    
    @Size(max = 500, message = "Description must not exceed 500 characters")
    private String description;
    
    private String avatarUrl;
    
    private boolean isPrivate = false;
    
    private List<Long> participantIds;
}
</file>

<file path="src/main/java/com/example/demo/communication/chat/dto/SendMessageRequest.java">
package com.example.demo.communication.chat.dto;

import com.example.demo.communication.chat.entity.ChatMessageType;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.Data;

@Data
public class SendMessageRequest {
    @NotNull(message = "Room ID is required")
    private Long roomId;
    
    @NotBlank(message = "Message content is required")
    private String content;
    
    private ChatMessageType messageType = ChatMessageType.TEXT;
}
</file>

<file path="src/main/java/com/example/demo/communication/chat/entity/ChatMessage.java">
package com.example.demo.communication.chat.entity;
 
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;
 
import java.time.Instant;

@Entity
@Table(name = "chat_messages", indexes = {
    @Index(name = "idx_chatmessage_room_id", columnList = "room_id"),
    @Index(name = "idx_chatmessage_sender_id", columnList = "sender_id"),
    @Index(name = "idx_chatmessage_created_at", columnList = "created_at")
})
@EntityListeners(AuditingEntityListener.class)
@Getter
@Setter
public class ChatMessage {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
  
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "room_id", nullable = false)
    private ChatRoom room;
  
    @Column(name = "sender_id", nullable = false)
    private Long senderId;         // Message sender
  
    @Column(name = "content", columnDefinition = "TEXT")
    private String content;        // Message content
  
    @Enumerated(EnumType.STRING)
    @Column(name = "message_type", length = 20)
    private ChatMessageType messageType;    // TEXT, IMAGE, FILE, SYSTEM
  
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;     // Timezone-independent timestamp
  
    @Column(name = "is_edited", nullable = false)
    private Boolean isEdited = false;
  
    @Column(name = "edited_at")
    private Instant editedAt;      // Timezone-independent timestamp
  
    @Column(name = "is_deleted", nullable = false)
    private Boolean isDeleted = false;
  
    @Column(name = "deleted_at")
    private Instant deletedAt;     // Timezone-independent timestamp
    
    // Transient fields for display
    @Transient
    private String senderName;
    @Transient
    private String senderAvatar;
    @Transient
    private boolean isRead; // Whether current user has read this message
}
</file>

<file path="src/main/java/com/example/demo/communication/chat/entity/ChatMessageType.java">
package com.example.demo.communication.chat.entity;

public enum ChatMessageType {
    TEXT,
    IMAGE,
    FILE,
    SYSTEM // System messages, e.g., "User A has joined the room"
}
</file>

<file path="src/main/java/com/example/demo/communication/chat/entity/ChatParticipantRole.java">
package com.example.demo.communication.chat.entity;

public enum ChatParticipantRole {
    OWNER,
    ADMIN,
    MEMBER
}
</file>

<file path="src/main/java/com/example/demo/communication/chat/entity/ChatRoomType.java">
package com.example.demo.communication.chat.entity;

public enum ChatRoomType {
    DIRECT, // One-on-one chat
    GROUP,  // Multi-user group chat
    CHANNEL // Broadcast-style channel
}
</file>

<file path="src/main/java/com/example/demo/communication/chat/repository/ChatMessageRepository.java">
package com.example.demo.communication.chat.repository;

import com.example.demo.communication.chat.entity.ChatMessage;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.Instant;
import java.util.List;

@Repository
public interface ChatMessageRepository extends JpaRepository<ChatMessage, Long> {
    
    /**
     * Find messages in a chat room with pagination
     */
    @Query("SELECT cm FROM ChatMessage cm " +
           "WHERE cm.room.id = :roomId AND cm.isDeleted = false " +
           "ORDER BY cm.createdAt DESC")
    Page<ChatMessage> findByRoomIdOrderByCreatedAtDesc(@Param("roomId") Long roomId, Pageable pageable);
    
    /**
     * Find messages after a specific timestamp
     */
    @Query("SELECT cm FROM ChatMessage cm " +
           "WHERE cm.room.id = :roomId AND cm.createdAt > :timestamp AND cm.isDeleted = false " +
           "ORDER BY cm.createdAt ASC")
    List<ChatMessage> findMessagesAfter(@Param("roomId") Long roomId, @Param("timestamp") Instant timestamp);
    
    /**
     * Search messages in a room
     */
    @Query("SELECT cm FROM ChatMessage cm " +
           "WHERE cm.room.id = :roomId AND cm.isDeleted = false " +
           "AND LOWER(cm.content) LIKE LOWER(CONCAT('%', :searchTerm, '%')) " +
           "ORDER BY cm.createdAt DESC")
    Page<ChatMessage> searchMessagesInRoom(@Param("roomId") Long roomId, @Param("searchTerm") String searchTerm, Pageable pageable);
    
    /**
     * Count unread messages for user in room
     */
    @Query("SELECT COUNT(cm) FROM ChatMessage cm " +
           "WHERE cm.room.id = :roomId AND cm.senderId != :userId " +
           "AND cm.createdAt > (SELECT COALESCE(cp.lastReadAt, '1970-01-01T00:00:00Z') " +
           "                   FROM ChatParticipant cp " +
           "                   WHERE cp.room.id = :roomId AND cp.userId = :userId) " +
           "AND cm.isDeleted = false")
    Long countUnreadMessages(@Param("roomId") Long roomId, @Param("userId") Long userId);
    
    /**
     * Find latest message in room
     */
    @Query("SELECT cm FROM ChatMessage cm " +
           "WHERE cm.room.id = :roomId AND cm.isDeleted = false " +
           "ORDER BY cm.createdAt DESC")
    List<ChatMessage> findLatestMessage(@Param("roomId") Long roomId, Pageable pageable);
    
    /**
     * Count total unread messages for user across all rooms
     */
    @Query("SELECT COUNT(cm) FROM ChatMessage cm " +
           "JOIN ChatParticipant cp ON cm.room.id = cp.room.id " +
           "WHERE cp.userId = :userId AND cm.senderId != :userId " +
           "AND cm.createdAt > COALESCE(cp.lastReadAt, '1970-01-01T00:00:00Z') " +
           "AND cm.isDeleted = false AND cp.isActive = true")
    Long countTotalUnreadMessages(@Param("userId") Long userId);
}
</file>

<file path="src/main/java/com/example/demo/communication/chat/repository/ChatParticipantRepository.java">
package com.example.demo.communication.chat.repository;

import com.example.demo.communication.chat.entity.ChatParticipant;
import com.example.demo.communication.chat.entity.ChatParticipantRole;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.Instant;
import java.util.List;
import java.util.Optional;

@Repository
public interface ChatParticipantRepository extends JpaRepository<ChatParticipant, Long> {
    
    /**
     * Find participant by room and user
     */
    Optional<ChatParticipant> findByRoomIdAndUserId(Long roomId, Long userId);
    
    /**
     * Find active participants in a room
     */
    List<ChatParticipant> findByRoomIdAndIsActiveTrue(Long roomId);
    
    /**
     * Find participants by user ID
     */
    List<ChatParticipant> findByUserIdAndIsActiveTrue(Long userId);
    
    /**
     * Check if user is participant in room
     */
    boolean existsByRoomIdAndUserIdAndIsActiveTrue(Long roomId, Long userId);
    
    /**
     * Find participants with specific role in room
     */
    List<ChatParticipant> findByRoomIdAndRoleAndIsActiveTrue(Long roomId, ChatParticipantRole role);
    
    /**
     * Update last read timestamp for participant
     */
    @Modifying
    @Query("UPDATE ChatParticipant cp SET cp.lastReadAt = :timestamp, cp.lastReadMessageId = :messageId " +
           "WHERE cp.room.id = :roomId AND cp.userId = :userId")
    void updateLastRead(@Param("roomId") Long roomId, @Param("userId") Long userId, 
                       @Param("timestamp") Instant timestamp, @Param("messageId") Long messageId);
    
    /**
     * Remove participant from room (soft delete)
     */
    @Modifying
    @Query("UPDATE ChatParticipant cp SET cp.isActive = false, cp.leftAt = :leftAt " +
           "WHERE cp.room.id = :roomId AND cp.userId = :userId")
    void removeParticipant(@Param("roomId") Long roomId, @Param("userId") Long userId, @Param("leftAt") Instant leftAt);
    
    /**
     * Count active participants in room
     */
    long countByRoomIdAndIsActiveTrue(Long roomId);
}
</file>

<file path="src/main/java/com/example/demo/communication/chat/repository/ChatRoomRepository.java">
package com.example.demo.communication.chat.repository;

import com.example.demo.communication.chat.entity.ChatRoom;
import com.example.demo.communication.chat.entity.ChatRoomType;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface ChatRoomRepository extends JpaRepository<ChatRoom, Long> {
    
    /**
     * Find chat rooms by type
     */
    List<ChatRoom> findByType(ChatRoomType type);
    
    /**
     * Find active chat rooms by creator
     */
    List<ChatRoom> findByCreatedByAndIsActiveTrue(Long createdBy);
    
    /**
     * Find chat rooms where user is a participant
     */
    @Query("SELECT DISTINCT cr FROM ChatRoom cr " +
           "JOIN cr.participants cp " +
           "WHERE cp.userId = :userId AND cp.isActive = true AND cr.isActive = true " +
           "ORDER BY cr.lastMessageAt DESC NULLS LAST")
    List<ChatRoom> findUserChatRooms(@Param("userId") Long userId);
    
    /**
     * Find direct chat room between two users
     */
    @Query("SELECT cr FROM ChatRoom cr " +
           "WHERE cr.type = 'DIRECT' AND cr.isActive = true " +
           "AND EXISTS (SELECT 1 FROM ChatParticipant cp1 WHERE cp1.room = cr AND cp1.userId = :userId1 AND cp1.isActive = true) " +
           "AND EXISTS (SELECT 1 FROM ChatParticipant cp2 WHERE cp2.room = cr AND cp2.userId = :userId2 AND cp2.isActive = true)")
    Optional<ChatRoom> findDirectChatRoom(@Param("userId1") Long userId1, @Param("userId2") Long userId2);
    
    /**
     * Check if user has access to chat room
     */
    @Query("SELECT COUNT(cr) > 0 FROM ChatRoom cr " +
           "JOIN cr.participants cp " +
           "WHERE cr.id = :roomId AND cp.userId = :userId AND cp.isActive = true")
    boolean hasUserAccess(@Param("roomId") Long roomId, @Param("userId") Long userId);
}
</file>

<file path="src/main/java/com/example/demo/communication/chat/service/ChatService.java">
package com.example.demo.communication.chat.service;

import com.example.demo.communication.chat.dto.ChatMessageDto;
import com.example.demo.communication.chat.dto.ChatRoomDto;
import com.example.demo.communication.chat.dto.ChatParticipantDto;
import com.example.demo.communication.chat.entity.ChatRoomType;
import com.example.demo.communication.chat.entity.ChatMessageType;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import java.util.List;

public interface ChatService {
    
    /**
     * Create a new chat room
     * @param name Room name
     * @param type Room type (DIRECT, GROUP, CHANNEL)
     * @param description Room description
     * @param createdBy Creator user ID
     * @param participantIds Initial participant user IDs
     * @return Created chat room DTO
     */
    ChatRoomDto createChatRoom(String name, ChatRoomType type, String description, Long createdBy, List<Long> participantIds);
    
    /**
     * Get chat room by ID
     * @param roomId Room ID
     * @param userId Current user ID (for permission check)
     * @return Chat room DTO
     */
    ChatRoomDto getChatRoom(Long roomId, Long userId);
    
    /**
     * Get user's chat rooms
     * @param userId User ID
     * @return List of chat room DTOs
     */
    List<ChatRoomDto> getUserChatRooms(Long userId);
    
    /**
     * Send message to chat room
     * @param roomId Room ID
     * @param senderId Sender user ID
     * @param content Message content
     * @param messageType Message type
     * @return Created message DTO
     */
    ChatMessageDto sendMessage(Long roomId, Long senderId, String content, ChatMessageType messageType);
    
    /**
     * Get chat messages for room
     * @param roomId Room ID
     * @param userId Current user ID (for permission check)
     * @param pageable Pagination parameters
     * @return Page of message DTOs
     */
    Page<ChatMessageDto> getChatMessages(Long roomId, Long userId, Pageable pageable);
    
    /**
     * Edit message
     * @param messageId Message ID
     * @param userId User ID (must be message sender)
     * @param newContent New message content
     * @return Updated message DTO
     */
    ChatMessageDto editMessage(Long messageId, Long userId, String newContent);
    
    /**
     * Delete message
     * @param messageId Message ID
     * @param userId User ID (must be message sender or room admin)
     */
    void deleteMessage(Long messageId, Long userId);
    
    /**
     * Add participant to chat room
     * @param roomId Room ID
     * @param userId User ID to add
     * @param addedBy User ID who is adding (must have permission)
     * @return Chat participant DTO
     */
    ChatParticipantDto addParticipant(Long roomId, Long userId, Long addedBy);
    
    /**
     * Remove participant from chat room
     * @param roomId Room ID
     * @param userId User ID to remove
     * @param removedBy User ID who is removing (must have permission)
     */
    void removeParticipant(Long roomId, Long userId, Long removedBy);
    
    /**
     * Mark messages as read
     * @param roomId Room ID
     * @param userId User ID
     * @param lastReadMessageId Last message ID read
     */
    void markMessagesAsRead(Long roomId, Long userId, Long lastReadMessageId);
    
    /**
     * Get unread message count for user
     * @param userId User ID
     * @return Total unread message count across all rooms
     */
    Long getUnreadMessageCount(Long userId);
    
    /**
     * Get unread message count for specific room
     * @param roomId Room ID
     * @param userId User ID
     * @return Unread message count for the room
     */
    Long getUnreadMessageCount(Long roomId, Long userId);
    
    /**
     * Search messages in room
     * @param roomId Room ID
     * @param userId Current user ID (for permission check)
     * @param searchTerm Search term
     * @param pageable Pagination parameters
     * @return Page of matching message DTOs
     */
    Page<ChatMessageDto> searchMessages(Long roomId, Long userId, String searchTerm, Pageable pageable);
}
</file>

<file path="src/main/java/com/example/demo/communication/chat/service/impl/ChatServiceImpl.java">
package com.example.demo.communication.chat.service.impl;

import com.example.demo.communication.chat.dto.ChatMessageDto;
import com.example.demo.communication.chat.dto.ChatRoomDto;
import com.example.demo.communication.chat.dto.ChatParticipantDto;
import com.example.demo.communication.chat.entity.*;
import com.example.demo.communication.chat.repository.ChatMessageRepository;
import com.example.demo.communication.chat.repository.ChatParticipantRepository;
import com.example.demo.communication.chat.repository.ChatRoomRepository;
import com.example.demo.communication.chat.service.ChatService;
import com.example.demo.communication.exception.ChatRoomNotFoundException;
import com.example.demo.communication.exception.ChatMessageNotFoundException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.Instant;
import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class ChatServiceImpl implements ChatService {

    private final ChatRoomRepository chatRoomRepository;
    private final ChatMessageRepository chatMessageRepository;
    private final ChatParticipantRepository chatParticipantRepository;
    private final SimpMessagingTemplate messagingTemplate;

    @Override
    @Transactional
    public ChatRoomDto createChatRoom(String name, ChatRoomType type, String description, Long createdBy, List<Long> participantIds) {
        log.info("Creating chat room: name={}, type={}, createdBy={}", name, type, createdBy);
        
        ChatRoom chatRoom = ChatRoom.builder()
                .name(name)
                .type(type)
                .description(description)
                .createdBy(createdBy)
                .isActive(true)
                .build();
        
        ChatRoom savedRoom = chatRoomRepository.save(chatRoom);
        
        // Add creator as owner
        ChatParticipant owner = ChatParticipant.builder()
                .room(savedRoom)
                .userId(createdBy)
                .role(ChatParticipantRole.OWNER)
                .joinedAt(Instant.now())
                .isActive(true)
                .build();
        chatParticipantRepository.save(owner);
        
        // Add other participants as members
        if (participantIds != null && !participantIds.isEmpty()) {
            List<ChatParticipant> participants = participantIds.stream()
                    .filter(userId -> !userId.equals(createdBy)) // Don't add creator twice
                    .map(userId -> ChatParticipant.builder()
                            .room(savedRoom)
                            .userId(userId)
                            .role(ChatParticipantRole.MEMBER)
                            .joinedAt(Instant.now())
                            .isActive(true)
                            .build())
                    .collect(Collectors.toList());
            chatParticipantRepository.saveAll(participants);
        }
        
        return convertToDto(savedRoom);
    }

    @Override
    public ChatRoomDto getChatRoom(Long roomId, Long userId) {
        ChatRoom room = chatRoomRepository.findById(roomId)
                .orElseThrow(() -> new ChatRoomNotFoundException("Chat room not found: " + roomId));
        
        if (!chatRoomRepository.hasUserAccess(roomId, userId)) {
            throw new AccessDeniedException("User does not have access to this chat room");
        }
        
        return convertToDto(room);
    }

    @Override
    public List<ChatRoomDto> getUserChatRooms(Long userId) {
        List<ChatRoom> rooms = chatRoomRepository.findUserChatRooms(userId);
        return rooms.stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional
    public ChatMessageDto sendMessage(Long roomId, Long senderId, String content, ChatMessageType messageType) {
        ChatRoom room = chatRoomRepository.findById(roomId)
                .orElseThrow(() -> new ChatRoomNotFoundException("Chat room not found: " + roomId));
        
        if (!chatRoomRepository.hasUserAccess(roomId, senderId)) {
            throw new AccessDeniedException("User does not have access to this chat room");
        }
        
        ChatMessage message = new ChatMessage();
        message.setRoom(room);
        message.setSenderId(senderId);
        message.setContent(content);
        message.setMessageType(messageType != null ? messageType : ChatMessageType.TEXT);
        message.setIsEdited(false);
        message.setIsDeleted(false);
        
        ChatMessage savedMessage = chatMessageRepository.save(message);
        
        // Update room's last message info
        room.setLastMessageAt(savedMessage.getCreatedAt());
        room.setLastMessageId(savedMessage.getId());
        chatRoomRepository.save(room);
        
        ChatMessageDto messageDto = convertToDto(savedMessage);
        
        // Send real-time notification to room participants
        messagingTemplate.convertAndSend("/topic/chat/room/" + roomId, messageDto);
        
        log.info("Message sent to room {}: {}", roomId, savedMessage.getId());
        return messageDto;
    }

    @Override
    public Page<ChatMessageDto> getChatMessages(Long roomId, Long userId, Pageable pageable) {
        if (!chatRoomRepository.hasUserAccess(roomId, userId)) {
            throw new AccessDeniedException("User does not have access to this chat room");
        }
        
        Page<ChatMessage> messages = chatMessageRepository.findByRoomIdOrderByCreatedAtDesc(roomId, pageable);
        return messages.map(this::convertToDto);
    }

    @Override
    @Transactional
    public ChatMessageDto editMessage(Long messageId, Long userId, String newContent) {
        ChatMessage message = chatMessageRepository.findById(messageId)
                .orElseThrow(() -> new ChatMessageNotFoundException("Message not found: " + messageId));
        
        if (!message.getSenderId().equals(userId)) {
            throw new AccessDeniedException("Only message sender can edit the message");
        }
        
        if (message.getIsDeleted()) {
            throw new IllegalStateException("Cannot edit deleted message");
        }
        
        message.setContent(newContent);
        message.setIsEdited(true);
        message.setEditedAt(Instant.now());
        
        ChatMessage savedMessage = chatMessageRepository.save(message);
        ChatMessageDto messageDto = convertToDto(savedMessage);
        
        // Send real-time update
        messagingTemplate.convertAndSend("/topic/chat/room/" + message.getRoom().getId() + "/edit", messageDto);
        
        return messageDto;
    }

    @Override
    @Transactional
    public void deleteMessage(Long messageId, Long userId) {
        ChatMessage message = chatMessageRepository.findById(messageId)
                .orElseThrow(() -> new ChatMessageNotFoundException("Message not found: " + messageId));
        
        // Check if user can delete (sender or room admin/owner)
        boolean canDelete = message.getSenderId().equals(userId) || 
                           isRoomAdminOrOwner(message.getRoom().getId(), userId);
        
        if (!canDelete) {
            throw new AccessDeniedException("User does not have permission to delete this message");
        }
        
        message.setIsDeleted(true);
        message.setDeletedAt(Instant.now());
        chatMessageRepository.save(message);
        
        // Send real-time update
        messagingTemplate.convertAndSend("/topic/chat/room/" + message.getRoom().getId() + "/delete", 
                                       java.util.Map.of("messageId", messageId));
        
        log.info("Message deleted: {}", messageId);
    }

    @Override
    @Transactional
    public ChatParticipantDto addParticipant(Long roomId, Long userId, Long addedBy) {
        ChatRoom room = chatRoomRepository.findById(roomId)
                .orElseThrow(() -> new ChatRoomNotFoundException("Chat room not found: " + roomId));
        
        if (!isRoomAdminOrOwner(roomId, addedBy)) {
            throw new AccessDeniedException("Only room admin or owner can add participants");
        }
        
        // Check if user is already a participant
        if (chatParticipantRepository.existsByRoomIdAndUserIdAndIsActiveTrue(roomId, userId)) {
            throw new IllegalStateException("User is already a participant in this room");
        }
        
        ChatParticipant participant = ChatParticipant.builder()
                .room(room)
                .userId(userId)
                .role(ChatParticipantRole.MEMBER)
                .joinedAt(Instant.now())
                .isActive(true)
                .build();
        
        ChatParticipant savedParticipant = chatParticipantRepository.save(participant);
        
        // Send system message
        sendMessage(roomId, addedBy, "User joined the room", ChatMessageType.SYSTEM);
        
        return convertToDto(savedParticipant);
    }

    @Override
    @Transactional
    public void removeParticipant(Long roomId, Long userId, Long removedBy) {
        if (!isRoomAdminOrOwner(roomId, removedBy) && !userId.equals(removedBy)) {
            throw new AccessDeniedException("Only room admin/owner or the user themselves can remove participant");
        }
        
        chatParticipantRepository.removeParticipant(roomId, userId, Instant.now());
        
        // Send system message
        sendMessage(roomId, removedBy, "User left the room", ChatMessageType.SYSTEM);
        
        log.info("Participant removed from room {}: {}", roomId, userId);
    }

    @Override
    @Transactional
    public void markMessagesAsRead(Long roomId, Long userId, Long lastReadMessageId) {
        chatParticipantRepository.updateLastRead(roomId, userId, Instant.now(), lastReadMessageId);
        log.debug("Messages marked as read for user {} in room {}", userId, roomId);
    }

    @Override
    public Long getUnreadMessageCount(Long userId) {
        return chatMessageRepository.countTotalUnreadMessages(userId);
    }

    @Override
    public Long getUnreadMessageCount(Long roomId, Long userId) {
        return chatMessageRepository.countUnreadMessages(roomId, userId);
    }

    @Override
    public Page<ChatMessageDto> searchMessages(Long roomId, Long userId, String searchTerm, Pageable pageable) {
        if (!chatRoomRepository.hasUserAccess(roomId, userId)) {
            throw new AccessDeniedException("User does not have access to this chat room");
        }
        
        Page<ChatMessage> messages = chatMessageRepository.searchMessagesInRoom(roomId, searchTerm, pageable);
        return messages.map(this::convertToDto);
    }

    private boolean isRoomAdminOrOwner(Long roomId, Long userId) {
        List<ChatParticipant> adminParticipants = chatParticipantRepository
                .findByRoomIdAndRoleAndIsActiveTrue(roomId, ChatParticipantRole.ADMIN);
        List<ChatParticipant> ownerParticipants = chatParticipantRepository
                .findByRoomIdAndRoleAndIsActiveTrue(roomId, ChatParticipantRole.OWNER);
        
        return adminParticipants.stream().anyMatch(p -> p.getUserId().equals(userId)) ||
               ownerParticipants.stream().anyMatch(p -> p.getUserId().equals(userId));
    }

    private ChatRoomDto convertToDto(ChatRoom room) {
        return ChatRoomDto.builder()
                .id(room.getId())
                .name(room.getName())
                .type(room.getType())
                .description(room.getDescription())
                .avatarUrl(room.getAvatarUrl())
                .createdBy(room.getCreatedBy())
                .isPrivate(room.isPrivate())
                .isActive(room.isActive())
                .createdAt(room.getCreatedAt())
                .updatedAt(room.getUpdatedAt())
                .lastMessageAt(room.getLastMessageAt())
                .lastMessageId(room.getLastMessageId())
                .build();
    }

    private ChatMessageDto convertToDto(ChatMessage message) {
        return ChatMessageDto.builder()
                .id(message.getId())
                .roomId(message.getRoom().getId())
                .senderId(message.getSenderId())
                .content(message.getContent())
                .messageType(message.getMessageType())
                .createdAt(message.getCreatedAt())
                .isEdited(message.getIsEdited())
                .editedAt(message.getEditedAt())
                .isDeleted(message.getIsDeleted())
                .deletedAt(message.getDeletedAt())
                .build();
    }

    private ChatParticipantDto convertToDto(ChatParticipant participant) {
        return ChatParticipantDto.builder()
                .id(participant.getId())
                .roomId(participant.getRoom().getId())
                .userId(participant.getUserId())
                .role(participant.getRole())
                .joinedAt(participant.getJoinedAt())
                .lastReadAt(participant.getLastReadAt())
                .lastReadMessageId(participant.getLastReadMessageId())
                .isMuted(participant.isMuted())
                .isActive(participant.isActive())
                .leftAt(participant.getLeftAt())
                .build();
    }
}
</file>

<file path="src/main/java/com/example/demo/communication/chat/websocket/ChatWebSocketHandler.java">
package com.example.demo.communication.chat.websocket;

import com.example.demo.communication.chat.dto.ChatMessageDto;
import com.example.demo.communication.chat.dto.SendMessageRequest;
import com.example.demo.communication.chat.service.ChatService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.messaging.handler.annotation.DestinationVariable;
import org.springframework.messaging.handler.annotation.MessageMapping;
import org.springframework.messaging.handler.annotation.Payload;
import org.springframework.messaging.handler.annotation.SendTo;
import org.springframework.messaging.simp.SimpMessageHeaderAccessor;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import org.springframework.stereotype.Controller;

import java.security.Principal;

@Controller
@RequiredArgsConstructor
@Slf4j
public class ChatWebSocketHandler {

    private final ChatService chatService;
    private final SimpMessagingTemplate messagingTemplate;

    /**
     * Handle incoming chat messages
     */
    @MessageMapping("/chat/room/{roomId}/send")
    @SendTo("/topic/chat/room/{roomId}")
    public ChatMessageDto sendMessage(
            @DestinationVariable Long roomId,
            @Payload SendMessageRequest request,
            SimpMessageHeaderAccessor headerAccessor,
            Principal principal) {
        
        try {
            Long userId = getUserIdFromPrincipal(principal);
            log.info("Received message from user {} for room {}: {}", userId, roomId, request.getContent());
            
            ChatMessageDto message = chatService.sendMessage(
                    roomId,
                    userId,
                    request.getContent(),
                    request.getMessageType()
            );
            
            log.info("Message sent successfully: {}", message.getId());
            return message;
            
        } catch (Exception e) {
            log.error("Error sending message to room {}: {}", roomId, e.getMessage(), e);
            // Send error message back to sender
            messagingTemplate.convertAndSendToUser(
                    principal.getName(),
                    "/queue/errors",
                    "Failed to send message: " + e.getMessage()
            );
            return null;
        }
    }

    /**
     * Handle typing indicators
     */
    @MessageMapping("/chat/room/{roomId}/typing")
    public void handleTyping(
            @DestinationVariable Long roomId,
            @Payload TypingIndicator typingIndicator,
            Principal principal) {
        
        try {
            Long userId = getUserIdFromPrincipal(principal);
            typingIndicator.setUserId(userId);
            
            // Broadcast typing indicator to all room participants except sender
            messagingTemplate.convertAndSend(
                    "/topic/chat/room/" + roomId + "/typing",
                    typingIndicator
            );
            
        } catch (Exception e) {
            log.error("Error handling typing indicator for room {}: {}", roomId, e.getMessage());
        }
    }

    /**
     * Handle user joining a room
     */
    @MessageMapping("/chat/room/{roomId}/join")
    public void handleJoinRoom(
            @DestinationVariable Long roomId,
            Principal principal) {
        
        try {
            Long userId = getUserIdFromPrincipal(principal);
            log.info("User {} joining room {}", userId, roomId);
            
            // Notify other participants that user joined
            UserPresence presence = new UserPresence(userId, true);
            messagingTemplate.convertAndSend(
                    "/topic/chat/room/" + roomId + "/presence",
                    presence
            );
            
        } catch (Exception e) {
            log.error("Error handling room join for room {}: {}", roomId, e.getMessage());
        }
    }

    /**
     * Handle user leaving a room
     */
    @MessageMapping("/chat/room/{roomId}/leave")
    public void handleLeaveRoom(
            @DestinationVariable Long roomId,
            Principal principal) {
        
        try {
            Long userId = getUserIdFromPrincipal(principal);
            log.info("User {} leaving room {}", userId, roomId);
            
            // Notify other participants that user left
            UserPresence presence = new UserPresence(userId, false);
            messagingTemplate.convertAndSend(
                    "/topic/chat/room/" + roomId + "/presence",
                    presence
            );
            
        } catch (Exception e) {
            log.error("Error handling room leave for room {}: {}", roomId, e.getMessage());
        }
    }

    /**
     * Handle message read receipts
     */
    @MessageMapping("/chat/room/{roomId}/read")
    public void handleMessageRead(
            @DestinationVariable Long roomId,
            @Payload ReadReceipt readReceipt,
            Principal principal) {
        
        try {
            Long userId = getUserIdFromPrincipal(principal);
            
            // Update read status in database
            chatService.markMessagesAsRead(roomId, userId, readReceipt.getLastReadMessageId());
            
            // Notify other participants about read receipt
            readReceipt.setUserId(userId);
            messagingTemplate.convertAndSend(
                    "/topic/chat/room/" + roomId + "/read",
                    readReceipt
            );
            
        } catch (Exception e) {
            log.error("Error handling read receipt for room {}: {}", roomId, e.getMessage());
        }
    }

    private Long getUserIdFromPrincipal(Principal principal) {
        if (principal == null || principal.getName() == null) {
            throw new IllegalArgumentException("User not authenticated");
        }
        
        try {
            return Long.parseLong(principal.getName());
        } catch (NumberFormatException e) {
            throw new IllegalArgumentException("Invalid user ID format");
        }
    }

    // Inner classes for WebSocket message payloads
    public static class TypingIndicator {
        private Long userId;
        private boolean isTyping;
        
        // Constructors, getters, setters
        public TypingIndicator() {}
        
        public TypingIndicator(Long userId, boolean isTyping) {
            this.userId = userId;
            this.isTyping = isTyping;
        }
        
        public Long getUserId() { return userId; }
        public void setUserId(Long userId) { this.userId = userId; }
        public boolean isTyping() { return isTyping; }
        public void setTyping(boolean typing) { isTyping = typing; }
    }

    public static class UserPresence {
        private Long userId;
        private boolean isOnline;
        
        public UserPresence() {}
        
        public UserPresence(Long userId, boolean isOnline) {
            this.userId = userId;
            this.isOnline = isOnline;
        }
        
        public Long getUserId() { return userId; }
        public void setUserId(Long userId) { this.userId = userId; }
        public boolean isOnline() { return isOnline; }
        public void setOnline(boolean online) { isOnline = online; }
    }

    public static class ReadReceipt {
        private Long userId;
        private Long lastReadMessageId;
        
        public ReadReceipt() {}
        
        public ReadReceipt(Long userId, Long lastReadMessageId) {
            this.userId = userId;
            this.lastReadMessageId = lastReadMessageId;
        }
        
        public Long getUserId() { return userId; }
        public void setUserId(Long userId) { this.userId = userId; }
        public Long getLastReadMessageId() { return lastReadMessageId; }
        public void setLastReadMessageId(Long lastReadMessageId) { this.lastReadMessageId = lastReadMessageId; }
    }
}
</file>

<file path="src/main/java/com/example/demo/communication/email/dto/EmailLogDto.java">
package com.example.demo.communication.email.dto;

import com.example.demo.communication.email.entity.EmailStatus;
import com.example.demo.communication.email.entity.EmailPriority;
import lombok.Data;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import java.time.Instant;
import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class EmailLogDto {
    
    private Long id;
    
    private String toEmail;
    
    private List<String> ccEmails;
    
    private List<String> bccEmails;
    
    private String subject;
    
    private String content;
    
    private String templateCode;
    
    private EmailStatus status;
    
    private String errorMessage;
    
    private Integer retryCount;
    
    private Instant sentAt;
    
    private Instant createdAt;
    
    private Long sentBy;
    
    private String sentByName; // Sender name for display
    
    private String messageId;
    
    private EmailPriority priority;
}
</file>

<file path="src/main/java/com/example/demo/communication/email/dto/EmailStatisticsDto.java">
package com.example.demo.communication.email.dto;

import lombok.Data;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import java.time.Instant;
import java.util.Map;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class EmailStatisticsDto {
    
    private long totalEmails;
    
    private long sentEmails;
    
    private long pendingEmails;
    
    private long failedEmails;
    
    private long bouncedEmails;
    
    private long deliveredEmails;
    
    private long openedEmails;
    
    private long clickedEmails;
    
    private double successRate; // Percentage of successfully sent emails
    
    private double deliveryRate; // Percentage of delivered emails
    
    private double openRate; // Percentage of opened emails
    
    private double clickRate; // Percentage of clicked emails
    
    private Map<String, Long> emailsByTemplate; // Email count by template
    
    private Map<String, Long> emailsByStatus; // Email count by status
    
    private Instant periodStart; // Statistics period start
    
    private Instant periodEnd; // Statistics period end
    
    private long averageRetryCount; // Average retry count for failed emails
}
</file>

<file path="src/main/java/com/example/demo/communication/email/dto/EmailTemplateDto.java">
package com.example.demo.communication.email.dto;

import com.example.demo.communication.email.entity.TemplateType;
import com.example.demo.communication.email.entity.TemplateCategory;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Data;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import java.time.Instant;
import java.util.List;
import java.util.Map;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class EmailTemplateDto {
    
    private Long id;
    
    @NotBlank(message = "Template name is required")
    @Size(max = 100, message = "Template name must not exceed 100 characters")
    private String name;
    
    @NotBlank(message = "Template code is required")
    @Size(max = 50, message = "Template code must not exceed 50 characters")
    private String code;
    
    @NotBlank(message = "Subject is required")
    @Size(max = 255, message = "Subject must not exceed 255 characters")
    private String subject;
    
    @NotBlank(message = "Content is required")
    private String content;
    
    private TemplateType templateType;
    
    private TemplateCategory category;
    
    @Size(max = 500, message = "Description must not exceed 500 characters")
    private String description;
    
    private List<String> variables; // Available template variables
    
    private boolean isDefault;
    
    private boolean enabled;
    
    private Instant createdAt;
    
    private Instant updatedAt;
    
    private Long createdBy;
    
    private String createdByName; // Creator name for display
    
    private Long updatedBy;
    
    private String updatedByName; // Updater name for display
}
</file>

<file path="src/main/java/com/example/demo/communication/email/entity/EmailPriority.java">
package com.example.demo.communication.email.entity;

public enum EmailPriority {
    HIGH,
    NORMAL,
    LOW
}
</file>

<file path="src/main/java/com/example/demo/communication/email/entity/EmailStatus.java">
package com.example.demo.communication.email.entity;

public enum EmailStatus {
    PENDING,
    SENT,
    FAILED,
    BOUNCED,
    DELIVERED,
    OPENED,
    CLICKED
}
</file>

<file path="src/main/java/com/example/demo/communication/email/entity/TemplateCategory.java">
package com.example.demo.communication.email.entity;

public enum TemplateCategory {
    WELCOME,
    NOTIFICATION,
    REMINDER,
    MARKETING,
    PASSWORD_RESET
}
</file>

<file path="src/main/java/com/example/demo/communication/email/entity/TemplateType.java">
package com.example.demo.communication.email.entity;

public enum TemplateType {
    HTML,
    TEXT,
    MIXED
}
</file>

<file path="src/main/java/com/example/demo/communication/email/exception/EmailLogNotFoundException.java">
package com.example.demo.communication.email.exception;

/**
 * Exception thrown when email log is not found
 */
public class EmailLogNotFoundException extends RuntimeException {
    
    public EmailLogNotFoundException(String message) {
        super(message);
    }
    
    public EmailLogNotFoundException(Long emailLogId) {
        super("Email log not found with ID: " + emailLogId);
    }
}
</file>

<file path="src/main/java/com/example/demo/communication/email/exception/EmailSendingException.java">
package com.example.demo.communication.email.exception;

/**
 * Exception thrown when email sending fails
 */
public class EmailSendingException extends RuntimeException {
    
    public EmailSendingException(String message) {
        super(message);
    }
    
    public EmailSendingException(String message, Throwable cause) {
        super(message, cause);
    }
}
</file>

<file path="src/main/java/com/example/demo/communication/email/exception/TemplateNotFoundException.java">
package com.example.demo.communication.email.exception;

/**
 * Exception thrown when email template is not found
 */
public class TemplateNotFoundException extends RuntimeException {
    
    public TemplateNotFoundException(String templateCode) {
        super("Email template not found with code: " + templateCode);
    }
}
</file>

<file path="src/main/java/com/example/demo/communication/email/repository/EmailLogRepository.java">
package com.example.demo.communication.email.repository;

import com.example.demo.communication.email.entity.EmailLog;
import com.example.demo.communication.email.entity.EmailStatus;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.Instant;
import java.util.List;

@Repository
public interface EmailLogRepository extends JpaRepository<EmailLog, Long> {
    
    /**
     * Find email logs by recipient
     * @param toEmail Recipient email
     * @param pageable Pagination parameters
     * @return Page of email logs
     */
    Page<EmailLog> findByToEmail(String toEmail, Pageable pageable);
    
    /**
     * Find email logs by status
     * @param status Email status
     * @param pageable Pagination parameters
     * @return Page of email logs
     */
    Page<EmailLog> findByStatus(EmailStatus status, Pageable pageable);
    
    /**
     * Find email logs by template code
     * @param templateCode Template code
     * @param pageable Pagination parameters
     * @return Page of email logs
     */
    Page<EmailLog> findByTemplateCode(String templateCode, Pageable pageable);
    
    /**
     * Find email logs by sender
     * @param sentBy Sender user ID
     * @param pageable Pagination parameters
     * @return Page of email logs
     */
    Page<EmailLog> findBySentBy(Long sentBy, Pageable pageable);
    
    /**
     * Find failed emails for retry
     * @param status Email status (FAILED)
     * @param maxRetryCount Maximum retry count
     * @return List of failed emails
     */
    List<EmailLog> findByStatusAndRetryCountLessThan(EmailStatus status, Integer maxRetryCount);
    
    /**
     * Find emails sent within date range
     * @param startDate Start date
     * @param endDate End date
     * @param pageable Pagination parameters
     * @return Page of email logs
     */
    @Query("SELECT e FROM EmailLog e WHERE e.sentAt BETWEEN :startDate AND :endDate")
    Page<EmailLog> findBySentAtBetween(@Param("startDate") Instant startDate, 
                                       @Param("endDate") Instant endDate, 
                                       Pageable pageable);
    
    /**
     * Count emails by status
     * @param status Email status
     * @return Count of emails
     */
    long countByStatus(EmailStatus status);
    
    /**
     * Count emails sent by user
     * @param sentBy User ID
     * @return Count of emails
     */
    long countBySentBy(Long sentBy);
    
    /**
     * Count emails using template
     * @param templateCode Template code
     * @return Count of emails
     */
    long countByTemplateCode(String templateCode);
    
    /**
     * Find recent email logs
     * @param limit Number of recent logs
     * @return List of recent email logs
     */
    @Query("SELECT e FROM EmailLog e ORDER BY e.createdAt DESC")
    List<EmailLog> findRecentEmailLogs(Pageable pageable);
    
    /**
     * Get email statistics by date range
     * @param startDate Start date
     * @param endDate End date
     * @return Email statistics
     */
    @Query("SELECT e.status, COUNT(e) FROM EmailLog e WHERE e.createdAt BETWEEN :startDate AND :endDate GROUP BY e.status")
    List<Object[]> getEmailStatisticsByDateRange(@Param("startDate") Instant startDate, 
                                                  @Param("endDate") Instant endDate);
}
</file>

<file path="src/main/java/com/example/demo/communication/email/service/EmailService.java">
package com.example.demo.communication.email.service;

import com.example.demo.communication.email.dto.EmailRequest;
import com.example.demo.communication.email.dto.BulkEmailRequest;
import com.example.demo.communication.email.dto.EmailLogDto;
import com.example.demo.communication.email.dto.EmailStatisticsDto;
import com.example.demo.communication.email.exception.EmailSendingException;
import com.example.demo.communication.email.exception.TemplateNotFoundException;
import com.example.demo.communication.email.exception.EmailLogNotFoundException;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;

public interface EmailService {
    
    /**
     * Send a single email
     * @param emailRequest Email request details
     * @return CompletableFuture for async processing
     * @throws EmailSendingException if email sending fails
     */
    CompletableFuture<Void> sendEmail(EmailRequest emailRequest);
    
    /**
     * Send templated email
     * @param toEmail Recipient email
     * @param templateCode Template code
     * @param variables Template variables
     * @return CompletableFuture for async processing
     * @throws TemplateNotFoundException if template not found
     * @throws EmailSendingException if email sending fails
     */
    CompletableFuture<Void> sendTemplatedEmail(String toEmail, String templateCode, Map<String, Object> variables);
    
    /**
     * Send bulk emails
     * @param bulkEmailRequest Bulk email request
     * @return CompletableFuture for async processing
     * @throws EmailSendingException if bulk email sending fails
     */
    CompletableFuture<Void> sendBulkEmails(BulkEmailRequest bulkEmailRequest);
    
    /**
     * Send bulk templated emails
     * @param recipients List of recipient emails
     * @param templateCode Template code
     * @param variables Template variables
     * @return CompletableFuture for async processing
     * @throws TemplateNotFoundException if template not found
     * @throws EmailSendingException if bulk email sending fails
     */
    CompletableFuture<Void> sendBulkTemplatedEmails(List<String> recipients, String templateCode, Map<String, Object> variables);
    
    /**
     * Get email logs with pagination
     * @param pageable Pagination parameters
     * @return Page of email log DTOs
     */
    Page<EmailLogDto> getEmailLogs(Pageable pageable);
    
    /**
     * Get email logs by recipient
     * @param toEmail Recipient email
     * @param pageable Pagination parameters
     * @return Page of email log DTOs
     */
    Page<EmailLogDto> getEmailLogsByRecipient(String toEmail, Pageable pageable);
    
    /**
     * Get email logs by status
     * @param status Email status
     * @param pageable Pagination parameters
     * @return Page of email log DTOs
     */
    Page<EmailLogDto> getEmailLogsByStatus(String status, Pageable pageable);
    
    /**
     * Get email logs by template
     * @param templateCode Template code
     * @param pageable Pagination parameters
     * @return Page of email log DTOs
     */
    Page<EmailLogDto> getEmailLogsByTemplate(String templateCode, Pageable pageable);
    
    /**
     * Retry failed email
     * @param emailLogId Email log ID
     * @return CompletableFuture for async processing
     * @throws EmailLogNotFoundException if email log not found
     * @throws EmailSendingException if retry fails
     */
    CompletableFuture<Void> retryFailedEmail(Long emailLogId);
    
    /**
     * Get email sending statistics
     * @return Email statistics
     */
    EmailStatisticsDto getEmailStatistics();
}
</file>

<file path="src/main/java/com/example/demo/communication/email/service/EmailTemplateService.java">
package com.example.demo.communication.email.service;

import com.example.demo.communication.email.dto.EmailTemplateDto;
import com.example.demo.communication.email.entity.TemplateCategory;
import com.example.demo.communication.email.exception.TemplateNotFoundException;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import java.util.List;
import java.util.Map;

public interface EmailTemplateService {
    
    /**
     * Create a new email template
     * @param templateDto Template data
     * @return Created template DTO
     */
    EmailTemplateDto createTemplate(EmailTemplateDto templateDto);
    
    /**
     * Update an existing email template
     * @param id Template ID
     * @param templateDto Updated template data
     * @return Updated template DTO
     * @throws TemplateNotFoundException if template not found
     */
    EmailTemplateDto updateTemplate(Long id, EmailTemplateDto templateDto);
    
    /**
     * Get template by ID
     * @param id Template ID
     * @return Template DTO
     * @throws TemplateNotFoundException if template not found
     */
    EmailTemplateDto getTemplate(Long id);
    
    /**
     * Get template by code
     * @param code Template code
     * @return Template DTO
     * @throws TemplateNotFoundException if template not found
     */
    EmailTemplateDto getTemplateByCode(String code);
    
    /**
     * Get all templates with pagination
     * @param pageable Pagination parameters
     * @return Page of template DTOs
     */
    Page<EmailTemplateDto> getAllTemplates(Pageable pageable);
    
    /**
     * Get templates by category
     * @param category Template category
     * @return List of template DTOs
     */
    List<EmailTemplateDto> getTemplatesByCategory(TemplateCategory category);
    
    /**
     * Get enabled templates
     * @return List of enabled template DTOs
     */
    List<EmailTemplateDto> getEnabledTemplates();
    
    /**
     * Search templates by name or description
     * @param searchTerm Search term
     * @param pageable Pagination parameters
     * @return Page of matching template DTOs
     */
    Page<EmailTemplateDto> searchTemplates(String searchTerm, Pageable pageable);
    
    /**
     * Delete template
     * @param id Template ID
     * @throws TemplateNotFoundException if template not found
     */
    void deleteTemplate(Long id);
    
    /**
     * Enable/disable template
     * @param id Template ID
     * @param enabled Whether to enable or disable
     * @throws TemplateNotFoundException if template not found
     */
    void toggleTemplateStatus(Long id, boolean enabled);
    
    /**
     * Set template as default for category
     * @param id Template ID
     * @throws TemplateNotFoundException if template not found
     */
    void setAsDefault(Long id);
    
    /**
     * Process template with variables
     * @param templateCode Template code
     * @param variables Template variables
     * @return Processed template content
     * @throws TemplateNotFoundException if template not found
     */
    String processTemplate(String templateCode, Map<String, Object> variables);
    
    /**
     * Validate template syntax
     * @param content Template content
     * @return Validation result
     */
    boolean validateTemplate(String content);
    
    /**
     * Get template variables
     * @param templateCode Template code
     * @return List of available variables
     * @throws TemplateNotFoundException if template not found
     */
    List<String> getTemplateVariables(String templateCode);
}
</file>

<file path="src/main/java/com/example/demo/communication/email/service/impl/EmailServiceImpl.java">
package com.example.demo.communication.email.service.impl;

import com.example.demo.communication.email.dto.EmailRequest;
import com.example.demo.communication.email.dto.BulkEmailRequest;
import com.example.demo.communication.email.dto.EmailLogDto;
import com.example.demo.communication.email.dto.EmailStatisticsDto;
import com.example.demo.communication.email.entity.EmailLog;
import com.example.demo.communication.email.entity.EmailStatus;
import com.example.demo.communication.email.entity.EmailPriority;
import com.example.demo.communication.email.exception.EmailSendingException;
import com.example.demo.communication.email.exception.TemplateNotFoundException;
import com.example.demo.communication.email.exception.EmailLogNotFoundException;
import com.example.demo.communication.email.repository.EmailLogRepository;
import com.example.demo.communication.email.repository.EmailTemplateRepository;
import com.example.demo.communication.email.service.EmailService;
import com.example.demo.communication.email.service.EmailTemplateService;
import com.example.demo.communication.email.util.EmailTemplateProcessor;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import jakarta.mail.MessagingException;
import jakarta.mail.internet.MimeMessage;
import java.time.Instant;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class EmailServiceImpl implements EmailService {
    
    private final JavaMailSender mailSender;
    private final EmailLogRepository emailLogRepository;
    private final EmailTemplateRepository emailTemplateRepository;
    private final EmailTemplateService emailTemplateService;
    private final EmailTemplateProcessor templateProcessor;
    
    @Override
    @Async
    public CompletableFuture<Void> sendEmail(EmailRequest emailRequest) {
        try {
            // Create and send email
            MimeMessage message = mailSender.createMimeMessage();
            MimeMessageHelper helper = new MimeMessageHelper(message, true);
            
            helper.setTo(emailRequest.getToEmail());
            if (emailRequest.getCcEmails() != null && !emailRequest.getCcEmails().isEmpty()) {
                helper.setCc(emailRequest.getCcEmails().toArray(new String[0]));
            }
            if (emailRequest.getBccEmails() != null && !emailRequest.getBccEmails().isEmpty()) {
                helper.setBcc(emailRequest.getBccEmails().toArray(new String[0]));
            }
            helper.setSubject(emailRequest.getSubject());
            helper.setText(emailRequest.getContent(), emailRequest.isHtml());
            
            mailSender.send(message);
            
            // Log email
            EmailLog emailLog = EmailLog.builder()
                    .toEmail(emailRequest.getToEmail())
                    .ccEmails(emailRequest.getCcEmails() != null ? 
                            String.join(",", emailRequest.getCcEmails()) : null)
                    .bccEmails(emailRequest.getBccEmails() != null ? 
                            String.join(",", emailRequest.getBccEmails()) : null)
                    .subject(emailRequest.getSubject())
                    .content(emailRequest.getContent())
                    .status(EmailStatus.SENT)
                    .sentAt(Instant.now())
                    .sentBy(emailRequest.getSentBy())
                    .priority(emailRequest.getPriority())
                    .build();
            
            emailLogRepository.save(emailLog);
            
            log.info("Email sent successfully to: {}", emailRequest.getToEmail());
            return CompletableFuture.completedFuture(null);
            
        } catch (MessagingException e) {
            log.error("Failed to send email to: {}", emailRequest.getToEmail(), e);
            throw new EmailSendingException("Failed to send email", e);
        } catch (Exception e) {
            log.error("Unexpected error while sending email to: {}", emailRequest.getToEmail(), e);
            throw new EmailSendingException("Unexpected error while sending email", e);
        }
    }
    
    @Override
    @Async
    public CompletableFuture<Void> sendTemplatedEmail(String toEmail, String templateCode, Map<String, Object> variables) {
        try {
            // Get template
            var templateDto = emailTemplateService.getTemplateByCode(templateCode);
            
            // Process template
            String subject = templateProcessor.processTemplate(templateDto.getSubject(), variables);
            String content = templateProcessor.processTemplate(templateDto.getContent(), variables);
            
            // Create and send email
            MimeMessage message = mailSender.createMimeMessage();
            MimeMessageHelper helper = new MimeMessageHelper(message, true);
            
            helper.setTo(toEmail);
            helper.setSubject(subject);
            helper.setText(content, true); // HTML content
            
            mailSender.send(message);
            
            // Log email
            EmailLog emailLog = EmailLog.builder()
                    .toEmail(toEmail)
                    .subject(subject)
                    .content(content)
                    .templateCode(templateCode)
                    .status(EmailStatus.SENT)
                    .sentAt(Instant.now())
                    .priority(EmailPriority.NORMAL)
                    .build();
            
            emailLogRepository.save(emailLog);
            
            log.info("Templated email sent successfully to: {} using template: {}", toEmail, templateCode);
            return CompletableFuture.completedFuture(null);
            
        } catch (TemplateNotFoundException e) {
            log.error("Template not found: {}", templateCode, e);
            throw e;
        } catch (MessagingException e) {
            log.error("Failed to send templated email to: {} using template: {}", toEmail, templateCode, e);
            throw new EmailSendingException("Failed to send templated email", e);
        } catch (Exception e) {
            log.error("Unexpected error while sending templated email to: {} using template: {}", toEmail, templateCode, e);
            throw new EmailSendingException("Unexpected error while sending templated email", e);
        }
    }
    
    @Override
    @Async
    public CompletableFuture<Void> sendBulkEmails(BulkEmailRequest bulkEmailRequest) {
        // Implementation for bulk emails
        return CompletableFuture.completedFuture(null);
    }
    
    @Override
    @Async
    public CompletableFuture<Void> sendBulkTemplatedEmails(List<String> recipients, String templateCode, Map<String, Object> variables) {
        // Implementation for bulk templated emails
        return CompletableFuture.completedFuture(null);
    }
    
    @Override
    public Page<EmailLogDto> getEmailLogs(Pageable pageable) {
        // Implementation for getting email logs
        return null;
    }
    
    @Override
    public Page<EmailLogDto> getEmailLogsByRecipient(String toEmail, Pageable pageable) {
        // Implementation for getting email logs by recipient
        return null;
    }
    
    @Override
    public Page<EmailLogDto> getEmailLogsByStatus(String status, Pageable pageable) {
        // Implementation for getting email logs by status
        return null;
    }
    
    @Override
    public Page<EmailLogDto> getEmailLogsByTemplate(String templateCode, Pageable pageable) {
        // Implementation for getting email logs by template
        return null;
    }
    
    @Override
    @Async
    public CompletableFuture<Void> retryFailedEmail(Long emailLogId) {
        // Implementation for retrying failed email
        return CompletableFuture.completedFuture(null);
    }
    
    @Override
    public EmailStatisticsDto getEmailStatistics() {
        // Implementation for getting email statistics
        return null;
    }
}
</file>

<file path="src/main/java/com/example/demo/communication/email/service/impl/EmailTemplateServiceImpl.java">
package com.example.demo.communication.email.service.impl;

import com.example.demo.communication.email.dto.EmailTemplateDto;
import com.example.demo.communication.email.entity.EmailTemplate;
import com.example.demo.communication.email.entity.TemplateCategory;
import com.example.demo.communication.email.exception.TemplateNotFoundException;
import com.example.demo.communication.email.repository.EmailTemplateRepository;
import com.example.demo.communication.email.service.EmailTemplateService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.modelmapper.ModelMapper;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class EmailTemplateServiceImpl implements EmailTemplateService {
    
    private final EmailTemplateRepository emailTemplateRepository;
    private final ModelMapper modelMapper;
    
    @Override
    public EmailTemplateDto createTemplate(EmailTemplateDto templateDto) {
        EmailTemplate template = modelMapper.map(templateDto, EmailTemplate.class);
        EmailTemplate savedTemplate = emailTemplateRepository.save(template);
        return modelMapper.map(savedTemplate, EmailTemplateDto.class);
    }
    
    @Override
    public EmailTemplateDto updateTemplate(Long id, EmailTemplateDto templateDto) {
        EmailTemplate existingTemplate = emailTemplateRepository.findById(id)
                .orElseThrow(() -> new TemplateNotFoundException("Template not found with id: " + id));
        
        // Update fields
        existingTemplate.setName(templateDto.getName());
        existingTemplate.setCode(templateDto.getCode());
        existingTemplate.setSubject(templateDto.getSubject());
        existingTemplate.setContent(templateDto.getContent());
        existingTemplate.setTemplateType(templateDto.getTemplateType());
        existingTemplate.setCategory(templateDto.getCategory());
        existingTemplate.setDescription(templateDto.getDescription());
        existingTemplate.setDefault(templateDto.isDefault());
        existingTemplate.setEnabled(templateDto.isEnabled());
        
        EmailTemplate updatedTemplate = emailTemplateRepository.save(existingTemplate);
        return modelMapper.map(updatedTemplate, EmailTemplateDto.class);
    }
    
    @Override
    public EmailTemplateDto getTemplate(Long id) {
        EmailTemplate template = emailTemplateRepository.findById(id)
                .orElseThrow(() -> new TemplateNotFoundException("Template not found with id: " + id));
        return modelMapper.map(template, EmailTemplateDto.class);
    }
    
    @Override
    public EmailTemplateDto getTemplateByCode(String code) {
        EmailTemplate template = emailTemplateRepository.findByCode(code)
                .orElseThrow(() -> new TemplateNotFoundException("Template not found with code: " + code));
        return modelMapper.map(template, EmailTemplateDto.class);
    }
    
    @Override
    public Page<EmailTemplateDto> getAllTemplates(Pageable pageable) {
        return emailTemplateRepository.findAll(pageable)
                .map(template -> modelMapper.map(template, EmailTemplateDto.class));
    }
    
    @Override
    public List<EmailTemplateDto> getTemplatesByCategory(TemplateCategory category) {
        return emailTemplateRepository.findByCategory(category).stream()
                .map(template -> modelMapper.map(template, EmailTemplateDto.class))
                .collect(Collectors.toList());
    }
    
    @Override
    public List<EmailTemplateDto> getEnabledTemplates() {
        return emailTemplateRepository.findByEnabledTrue().stream()
                .map(template -> modelMapper.map(template, EmailTemplateDto.class))
                .collect(Collectors.toList());
    }
    
    @Override
    public Page<EmailTemplateDto> searchTemplates(String searchTerm, Pageable pageable) {
        return emailTemplateRepository.findByNameContainingOrDescriptionContaining(searchTerm, searchTerm, pageable)
                .map(template -> modelMapper.map(template, EmailTemplateDto.class));
    }
    
    @Override
    public void deleteTemplate(Long id) {
        if (!emailTemplateRepository.existsById(id)) {
            throw new TemplateNotFoundException("Template not found with id: " + id);
        }
        emailTemplateRepository.deleteById(id);
    }
    
    @Override
    public void toggleTemplateStatus(Long id, boolean enabled) {
        EmailTemplate template = emailTemplateRepository.findById(id)
                .orElseThrow(() -> new TemplateNotFoundException("Template not found with id: " + id));
        template.setEnabled(enabled);
        emailTemplateRepository.save(template);
    }
    
    @Override
    public void setAsDefault(Long id) {
        EmailTemplate template = emailTemplateRepository.findById(id)
                .orElseThrow(() -> new TemplateNotFoundException("Template not found with id: " + id));
        
        // Set current template as default
        template.setDefault(true);
        
        // Unset other templates in the same category
        if (template.getCategory() != null) {
            emailTemplateRepository.findByCategoryAndIsDefaultTrue(template.getCategory())
                    .ifPresent(t -> {
                        t.setDefault(false);
                        emailTemplateRepository.save(t);
                    });
        }
        
        emailTemplateRepository.save(template);
    }
    
    @Override
    public String processTemplate(String templateCode, Map<String, Object> variables) {
        // Implementation for processing template with variables
        return null;
    }
    
    @Override
    public boolean validateTemplate(String content) {
        // Implementation for validating template syntax
        return false;
    }
    
    @Override
    public List<String> getTemplateVariables(String templateCode) {
        // Implementation for getting template variables
        return null;
    }
}
</file>

<file path="src/main/java/com/example/demo/communication/email/util/EmailTemplateProcessor.java">
package com.example.demo.communication.email.util;

import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.List;
import java.util.ArrayList;

/**
 * Utility class for processing email templates with variable substitution
 */
@Component
@Slf4j
public class EmailTemplateProcessor {
    
    private static final Pattern VARIABLE_PATTERN = Pattern.compile("\\{\\{([^}]+)\\}\\}");
    
    /**
     * Process template content by replacing variables with actual values
     * @param templateContent Template content with variables in {{variable}} format
     * @param variables Map of variable names to values
     * @return Processed content with variables replaced
     */
    public String processTemplate(String templateContent, Map<String, Object> variables) {
        if (templateContent == null || templateContent.isEmpty()) {
            return templateContent;
        }
        
        if (variables == null || variables.isEmpty()) {
            log.warn("No variables provided for template processing");
            return templateContent;
        }
        
        String processedContent = templateContent;
        Matcher matcher = VARIABLE_PATTERN.matcher(templateContent);
        
        while (matcher.find()) {
            String variableName = matcher.group(1).trim();
            String placeholder = matcher.group(0);
            
            Object value = variables.get(variableName);
            String replacement = value != null ? value.toString() : "";
            
            processedContent = processedContent.replace(placeholder, replacement);
            
            if (value == null) {
                log.warn("Variable '{}' not found in provided variables map", variableName);
            }
        }
        
        return processedContent;
    }
    
    /**
     * Extract all variable names from template content
     * @param templateContent Template content
     * @return List of variable names found in the template
     */
    public List<String> extractVariables(String templateContent) {
        List<String> variables = new ArrayList<>();
        
        if (templateContent == null || templateContent.isEmpty()) {
            return variables;
        }
        
        Matcher matcher = VARIABLE_PATTERN.matcher(templateContent);
        
        while (matcher.find()) {
            String variableName = matcher.group(1).trim();
            if (!variables.contains(variableName)) {
                variables.add(variableName);
            }
        }
        
        return variables;
    }
    
    /**
     * Validate template syntax
     * @param templateContent Template content to validate
     * @return true if template syntax is valid
     */
    public boolean validateTemplate(String templateContent) {
        if (templateContent == null) {
            return false;
        }
        
        try {
            // Check for balanced braces
            int openBraces = 0;
            for (int i = 0; i < templateContent.length() - 1; i++) {
                if (templateContent.charAt(i) == '{' && templateContent.charAt(i + 1) == '{') {
                    openBraces++;
                    i++; // Skip next character
                } else if (templateContent.charAt(i) == '}' && templateContent.charAt(i + 1) == '}') {
                    openBraces--;
                    i++; // Skip next character
                    if (openBraces < 0) {
                        return false; // More closing braces than opening
                    }
                }
            }
            
            return openBraces == 0; // All braces should be balanced
        } catch (Exception e) {
            log.error("Error validating template: {}", e.getMessage());
            return false;
        }
    }
    
    /**
     * Preview template with sample data
     * @param templateContent Template content
     * @param sampleVariables Sample variable values
     * @return Preview of processed template
     */
    public String previewTemplate(String templateContent, Map<String, Object> sampleVariables) {
        try {
            return processTemplate(templateContent, sampleVariables);
        } catch (Exception e) {
            log.error("Error previewing template: {}", e.getMessage());
            return "Error processing template: " + e.getMessage();
        }
    }
}
</file>

<file path="src/main/java/com/example/demo/communication/exception/AnnouncementNotFoundException.java">
package com.example.demo.communication.exception;

public class AnnouncementNotFoundException extends RuntimeException {
    public AnnouncementNotFoundException(String message) {
        super(message);
    }
    
    public AnnouncementNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }
}
</file>

<file path="src/main/java/com/example/demo/communication/exception/ChatMessageNotFoundException.java">
package com.example.demo.communication.exception;

public class ChatMessageNotFoundException extends RuntimeException {
    public ChatMessageNotFoundException(String message) {
        super(message);
    }
    
    public ChatMessageNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }
}
</file>

<file path="src/main/java/com/example/demo/communication/exception/ChatRoomNotFoundException.java">
package com.example.demo.communication.exception;

public class ChatRoomNotFoundException extends RuntimeException {
    public ChatRoomNotFoundException(String message) {
        super(message);
    }
    
    public ChatRoomNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }
}
</file>

<file path="src/main/java/com/example/demo/communication/exception/NotificationException.java">
package com.example.demo.communication.exception;

public class NotificationException extends RuntimeException {
    public NotificationException(String message) {
        super(message);
    }
    
    public NotificationException(String message, Throwable cause) {
        super(message, cause);
    }
}
</file>

<file path="src/main/java/com/example/demo/communication/notification/dto/NotificationCreateRequest.java">
package com.example.demo.communication.notification.dto;

import com.example.demo.communication.notification.entity.NotificationType;
import com.example.demo.communication.notification.entity.NotificationPriority;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.Data;

import java.time.Instant;
import java.util.List;

@Data
public class NotificationCreateRequest {
    @NotNull(message = "User ID is required")
    private Long userId;
    
    private List<Long> userIds; // For bulk notifications
    
    @NotBlank(message = "Title is required")
    @Size(max = 255, message = "Title must not exceed 255 characters")
    private String title;
    
    @NotBlank(message = "Content is required")
    private String content;
    
    @NotNull(message = "Type is required")
    private NotificationType type;
    
    private NotificationPriority priority = NotificationPriority.NORMAL;
    
    private Long referenceId;
    
    private String referenceType;
    
    @Size(max = 500, message = "Action URL must not exceed 500 characters")
    private String actionUrl;
    
    private String metadata;
    
    private Instant expiresAt;
}
</file>

<file path="src/main/java/com/example/demo/communication/notification/dto/NotificationDto.java">
package com.example.demo.communication.notification.dto;

import com.example.demo.communication.notification.entity.NotificationType;
import com.example.demo.communication.notification.entity.NotificationPriority;
import lombok.Data;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import java.time.Instant;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class NotificationDto {
    private Long id;
    private Long userId;
    private String title;
    private String content;
    private NotificationType type;
    private NotificationPriority priority;
    private Boolean isRead;
    private Instant readAt;
    private Instant createdAt;
    private Long senderId;
    private Long referenceId;
    private String referenceType;
    private String actionUrl;
    private String metadata;
    private Instant expiresAt;
    
    // Additional fields for UI
    private String senderName;
    private String timeAgo;
    private boolean canMarkAsRead;
}
</file>

<file path="src/main/java/com/example/demo/communication/notification/dto/NotificationMarkReadRequest.java">
package com.example.demo.communication.notification.dto;

import jakarta.validation.constraints.NotNull;
import lombok.Data;

import java.util.List;

@Data
public class NotificationMarkReadRequest {
    @NotNull(message = "Notification ID is required")
    private Long notificationId;
    
    private List<Long> notificationIds; // For bulk mark as read
    
    private boolean markAll = false; // Mark all notifications as read
}
</file>

<file path="src/main/java/com/example/demo/communication/notification/entity/NotificationPriority.java">
package com.example.demo.communication.notification.entity;

public enum NotificationPriority {
    LOW,
    NORMAL,
    HIGH,
    URGENT
}
</file>

<file path="src/main/java/com/example/demo/communication/notification/entity/NotificationType.java">
package com.example.demo.communication.notification.entity;

public enum NotificationType {
    SYSTEM,           // System notifications
    ANNOUNCEMENT,     // Company announcements
    CHAT_MESSAGE,     // New chat message
    EMAIL,            // Email notifications
    TASK_ASSIGNMENT,  // Task assignments
    PAYROLL,          // Payroll related
    EMPLOYEE_UPDATE,  // Employee information updates
    DEPARTMENT_UPDATE // Department changes
}
</file>

<file path="src/main/java/com/example/demo/communication/notification/repository/NotificationRepository.java">
package com.example.demo.communication.notification.repository;

import com.example.demo.communication.notification.entity.Notification;
import com.example.demo.communication.notification.entity.NotificationType;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.Instant;
import java.util.List;

@Repository
public interface NotificationRepository extends JpaRepository<Notification, Long> {
    
    /**
     * Find notifications for a user with pagination
     */
    Page<Notification> findByUserIdOrderByCreatedAtDesc(Long userId, Pageable pageable);
    
    /**
     * Find unread notifications for a user
     */
    Page<Notification> findByUserIdAndIsReadFalseOrderByCreatedAtDesc(Long userId, Pageable pageable);
    
    /**
     * Find notifications by type for a user
     */
    Page<Notification> findByUserIdAndTypeOrderByCreatedAtDesc(Long userId, NotificationType type, Pageable pageable);
    
    /**
     * Count unread notifications for a user
     */
    long countByUserIdAndIsReadFalse(Long userId);
    
    /**
     * Count unread notifications by type for a user
     */
    long countByUserIdAndTypeAndIsReadFalse(Long userId, NotificationType type);
    
    /**
     * Find notifications by reference
     */
    List<Notification> findByReferenceTypeAndReferenceId(String referenceType, Long referenceId);
    
    /**
     * Mark notification as read
     */
    @Modifying
    @Query("UPDATE Notification n SET n.isRead = true, n.readAt = :readAt WHERE n.id = :id AND n.userId = :userId")
    int markAsRead(@Param("id") Long id, @Param("userId") Long userId, @Param("readAt") Instant readAt);
    
    /**
     * Mark all notifications as read for a user
     */
    @Modifying
    @Query("UPDATE Notification n SET n.isRead = true, n.readAt = :readAt WHERE n.userId = :userId AND n.isRead = false")
    int markAllAsRead(@Param("userId") Long userId, @Param("readAt") Instant readAt);
    
    /**
     * Delete expired notifications
     */
    @Modifying
    @Query("DELETE FROM Notification n WHERE n.expiresAt IS NOT NULL AND n.expiresAt < :now")
    int deleteExpiredNotifications(@Param("now") Instant now);
    
    /**
     * Find notifications sent by a user
     */
    Page<Notification> findBySenderIdOrderByCreatedAtDesc(Long senderId, Pageable pageable);
    
    /**
     * Find recent notifications for a user (last 24 hours)
     */
    @Query("SELECT n FROM Notification n WHERE n.userId = :userId AND n.createdAt > :since ORDER BY n.createdAt DESC")
    List<Notification> findRecentNotifications(@Param("userId") Long userId, @Param("since") Instant since);
}
</file>

<file path="src/main/java/com/example/demo/communication/notification/service/impl/NotificationServiceImpl.java">
package com.example.demo.communication.notification.service.impl;

import com.example.demo.communication.notification.dto.NotificationDto;
import com.example.demo.communication.notification.dto.NotificationCreateRequest;
import com.example.demo.communication.notification.entity.Notification;
import com.example.demo.communication.notification.entity.NotificationType;
import com.example.demo.communication.notification.entity.NotificationPriority;
import com.example.demo.communication.notification.repository.NotificationRepository;
import com.example.demo.communication.notification.service.NotificationService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class NotificationServiceImpl implements NotificationService {

    private final NotificationRepository notificationRepository;
    private final SimpMessagingTemplate messagingTemplate;
    private final RedisTemplate<String, Object> redisTemplate;

    @Override
    @Transactional
    public NotificationDto createNotification(NotificationCreateRequest request, Long senderId) {
        log.info("Creating notification for user {}: {}", request.getUserId(), request.getTitle());
        
        Notification notification = Notification.builder()
                .userId(request.getUserId())
                .title(request.getTitle())
                .content(request.getContent())
                .type(request.getType())
                .priority(request.getPriority())
                .senderId(senderId)
                .referenceId(request.getReferenceId())
                .referenceType(request.getReferenceType())
                .actionUrl(request.getActionUrl())
                .metadata(request.getMetadata())
                .expiresAt(request.getExpiresAt())
                .isRead(false)
                .build();
        
        Notification savedNotification = notificationRepository.save(notification);
        NotificationDto notificationDto = convertToDto(savedNotification);
        
        // Send real-time notification via WebSocket
        sendRealTimeNotification(notificationDto);
        
        // Cache notification count in Redis
        updateUnreadCountCache(request.getUserId());
        
        log.info("Notification created successfully: {}", savedNotification.getId());
        return notificationDto;
    }

    @Override
    @Transactional
    public List<NotificationDto> createBulkNotifications(NotificationCreateRequest request, Long senderId) {
        log.info("Creating bulk notifications for {} users: {}", request.getUserIds().size(), request.getTitle());
        
        List<Notification> notifications = request.getUserIds().stream()
                .map(userId -> Notification.builder()
                        .userId(userId)
                        .title(request.getTitle())
                        .content(request.getContent())
                        .type(request.getType())
                        .priority(request.getPriority())
                        .senderId(senderId)
                        .referenceId(request.getReferenceId())
                        .referenceType(request.getReferenceType())
                        .actionUrl(request.getActionUrl())
                        .metadata(request.getMetadata())
                        .expiresAt(request.getExpiresAt())
                        .isRead(false)
                        .build())
                .collect(Collectors.toList());
        
        List<Notification> savedNotifications = notificationRepository.saveAll(notifications);
        List<NotificationDto> notificationDtos = savedNotifications.stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
        
        // Send real-time notifications
        notificationDtos.forEach(this::sendRealTimeNotification);
        
        // Update cache for all users
        request.getUserIds().forEach(this::updateUnreadCountCache);
        
        log.info("Bulk notifications created successfully: {} notifications", savedNotifications.size());
        return notificationDtos;
    }

    @Override
    @Async
    public CompletableFuture<NotificationDto> sendNotificationAsync(Long userId, String title, String content, 
                                                                   NotificationType type, Long senderId) {
        try {
            NotificationCreateRequest request = new NotificationCreateRequest();
            request.setUserId(userId);
            request.setTitle(title);
            request.setContent(content);
            request.setType(type);
            request.setPriority(NotificationPriority.NORMAL);
            
            NotificationDto notification = createNotification(request, senderId);
            return CompletableFuture.completedFuture(notification);
            
        } catch (Exception e) {
            log.error("Failed to send notification async to user {}: {}", userId, e.getMessage(), e);
            return CompletableFuture.failedFuture(e);
        }
    }

    @Override
    public Page<NotificationDto> getUserNotifications(Long userId, Pageable pageable) {
        Page<Notification> notifications = notificationRepository.findByUserIdOrderByCreatedAtDesc(userId, pageable);
        return notifications.map(this::convertToDto);
    }

    @Override
    public Page<NotificationDto> getUnreadNotifications(Long userId, Pageable pageable) {
        Page<Notification> notifications = notificationRepository.findByUserIdAndIsReadFalseOrderByCreatedAtDesc(userId, pageable);
        return notifications.map(this::convertToDto);
    }

    @Override
    public Page<NotificationDto> getNotificationsByType(Long userId, NotificationType type, Pageable pageable) {
        Page<Notification> notifications = notificationRepository.findByUserIdAndTypeOrderByCreatedAtDesc(userId, type, pageable);
        return notifications.map(this::convertToDto);
    }

    @Override
    @Transactional
    public boolean markAsRead(Long notificationId, Long userId) {
        int updated = notificationRepository.markAsRead(notificationId, userId, Instant.now());
        
        if (updated > 0) {
            updateUnreadCountCache(userId);
            
            // Send real-time update
            messagingTemplate.convertAndSendToUser(
                    userId.toString(),
                    "/queue/notifications/read",
                    java.util.Map.of("notificationId", notificationId, "isRead", true)
            );
            
            log.debug("Notification {} marked as read for user {}", notificationId, userId);
            return true;
        }
        
        return false;
    }

    @Override
    @Transactional
    public int markMultipleAsRead(List<Long> notificationIds, Long userId) {
        int totalUpdated = 0;
        
        for (Long notificationId : notificationIds) {
            if (markAsRead(notificationId, userId)) {
                totalUpdated++;
            }
        }
        
        log.info("Marked {} notifications as read for user {}", totalUpdated, userId);
        return totalUpdated;
    }

    @Override
    @Transactional
    public int markAllAsRead(Long userId) {
        int updated = notificationRepository.markAllAsRead(userId, Instant.now());
        
        if (updated > 0) {
            updateUnreadCountCache(userId);
            
            // Send real-time update
            messagingTemplate.convertAndSendToUser(
                    userId.toString(),
                    "/queue/notifications/read-all",
                    java.util.Map.of("count", updated)
            );
            
            log.info("Marked all {} notifications as read for user {}", updated, userId);
        }
        
        return updated;
    }

    @Override
    public long getUnreadCount(Long userId) {
        // Try to get from cache first
        String cacheKey = "notification:unread:" + userId;
        Long cachedCount = (Long) redisTemplate.opsForValue().get(cacheKey);
        
        if (cachedCount != null) {
            return cachedCount;
        }
        
        // If not in cache, get from database and cache it
        long count = notificationRepository.countByUserIdAndIsReadFalse(userId);
        redisTemplate.opsForValue().set(cacheKey, count, java.time.Duration.ofMinutes(5));
        
        return count;
    }

    @Override
    public long getUnreadCountByType(Long userId, NotificationType type) {
        return notificationRepository.countByUserIdAndTypeAndIsReadFalse(userId, type);
    }

    @Override
    @Transactional
    public boolean deleteNotification(Long notificationId, Long userId) {
        return notificationRepository.findById(notificationId)
                .filter(notification -> notification.getUserId().equals(userId))
                .map(notification -> {
                    notificationRepository.delete(notification);
                    updateUnreadCountCache(userId);
                    log.debug("Notification {} deleted for user {}", notificationId, userId);
                    return true;
                })
                .orElse(false);
    }

    @Override
    @Transactional
    public int cleanupExpiredNotifications() {
        int deleted = notificationRepository.deleteExpiredNotifications(Instant.now());
        log.info("Cleaned up {} expired notifications", deleted);
        return deleted;
    }

    @Override
    public List<NotificationDto> getRecentNotifications(Long userId) {
        Instant since = Instant.now().minus(24, ChronoUnit.HOURS);
        List<Notification> notifications = notificationRepository.findRecentNotifications(userId, since);
        return notifications.stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    @Override
    @Async
    public CompletableFuture<NotificationDto> sendSystemNotification(Long userId, String title, String content) {
        return sendNotificationAsync(userId, title, content, NotificationType.SYSTEM, null);
    }

    @Override
    @Async
    public CompletableFuture<List<NotificationDto>> sendAnnouncementNotifications(List<Long> userIds, String title, 
                                                                                 String content, Long announcementId, Long senderId) {
        try {
            NotificationCreateRequest request = new NotificationCreateRequest();
            request.setUserIds(userIds);
            request.setTitle(title);
            request.setContent(content);
            request.setType(NotificationType.ANNOUNCEMENT);
            request.setPriority(NotificationPriority.NORMAL);
            request.setReferenceId(announcementId);
            request.setReferenceType("ANNOUNCEMENT");
            request.setActionUrl("/announcements/" + announcementId);
            
            List<NotificationDto> notifications = createBulkNotifications(request, senderId);
            return CompletableFuture.completedFuture(notifications);
            
        } catch (Exception e) {
            log.error("Failed to send announcement notifications: {}", e.getMessage(), e);
            return CompletableFuture.failedFuture(e);
        }
    }

    private void sendRealTimeNotification(NotificationDto notification) {
        try {
            // Send to user's personal notification queue
            messagingTemplate.convertAndSendToUser(
                    notification.getUserId().toString(),
                    "/queue/notifications",
                    notification
            );
            
            // Also publish to Redis for other instances (if using multiple app instances)
            redisTemplate.convertAndSend("notifications:" + notification.getUserId(), notification);
            
        } catch (Exception e) {
            log.error("Failed to send real-time notification to user {}: {}", 
                     notification.getUserId(), e.getMessage());
        }
    }

    private void updateUnreadCountCache(Long userId) {
        try {
            String cacheKey = "notification:unread:" + userId;
            long count = notificationRepository.countByUserIdAndIsReadFalse(userId);
            redisTemplate.opsForValue().set(cacheKey, count, java.time.Duration.ofMinutes(5));
            
            // Send real-time unread count update
            messagingTemplate.convertAndSendToUser(
                    userId.toString(),
                    "/queue/notifications/count",
                    java.util.Map.of("unreadCount", count)
            );
            
        } catch (Exception e) {
            log.error("Failed to update unread count cache for user {}: {}", userId, e.getMessage());
        }
    }

    private NotificationDto convertToDto(Notification notification) {
        return NotificationDto.builder()
                .id(notification.getId())
                .userId(notification.getUserId())
                .title(notification.getTitle())
                .content(notification.getContent())
                .type(notification.getType())
                .priority(notification.getPriority())
                .isRead(notification.getIsRead())
                .readAt(notification.getReadAt())
                .createdAt(notification.getCreatedAt())
                .senderId(notification.getSenderId())
                .referenceId(notification.getReferenceId())
                .referenceType(notification.getReferenceType())
                .actionUrl(notification.getActionUrl())
                .metadata(notification.getMetadata())
                .expiresAt(notification.getExpiresAt())
                .canMarkAsRead(!notification.getIsRead())
                .build();
    }
}
</file>

<file path="src/main/java/com/example/demo/communication/notification/service/NotificationService.java">
package com.example.demo.communication.notification.service;

import com.example.demo.communication.notification.dto.NotificationDto;
import com.example.demo.communication.notification.dto.NotificationCreateRequest;
import com.example.demo.communication.notification.entity.NotificationType;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import java.util.List;
import java.util.concurrent.CompletableFuture;

public interface NotificationService {
    
    /**
     * Create a single notification
     * @param request Notification creation request
     * @param senderId User ID who is sending the notification
     * @return Created notification DTO
     */
    NotificationDto createNotification(NotificationCreateRequest request, Long senderId);
    
    /**
     * Create bulk notifications
     * @param request Notification creation request with multiple user IDs
     * @param senderId User ID who is sending the notification
     * @return List of created notification DTOs
     */
    List<NotificationDto> createBulkNotifications(NotificationCreateRequest request, Long senderId);
    
    /**
     * Send notification asynchronously with real-time delivery
     * @param userId Recipient user ID
     * @param title Notification title
     * @param content Notification content
     * @param type Notification type
     * @param senderId Sender user ID (optional)
     * @return CompletableFuture for async processing
     */
    CompletableFuture<NotificationDto> sendNotificationAsync(Long userId, String title, String content, 
                                                            NotificationType type, Long senderId);
    
    /**
     * Get notifications for a user
     * @param userId User ID
     * @param pageable Pagination parameters
     * @return Page of notification DTOs
     */
    Page<NotificationDto> getUserNotifications(Long userId, Pageable pageable);
    
    /**
     * Get unread notifications for a user
     * @param userId User ID
     * @param pageable Pagination parameters
     * @return Page of unread notification DTOs
     */
    Page<NotificationDto> getUnreadNotifications(Long userId, Pageable pageable);
    
    /**
     * Get notifications by type for a user
     * @param userId User ID
     * @param type Notification type
     * @param pageable Pagination parameters
     * @return Page of notification DTOs
     */
    Page<NotificationDto> getNotificationsByType(Long userId, NotificationType type, Pageable pageable);
    
    /**
     * Mark notification as read
     * @param notificationId Notification ID
     * @param userId User ID
     * @return true if successfully marked as read
     */
    boolean markAsRead(Long notificationId, Long userId);
    
    /**
     * Mark multiple notifications as read
     * @param notificationIds List of notification IDs
     * @param userId User ID
     * @return Number of notifications marked as read
     */
    int markMultipleAsRead(List<Long> notificationIds, Long userId);
    
    /**
     * Mark all notifications as read for a user
     * @param userId User ID
     * @return Number of notifications marked as read
     */
    int markAllAsRead(Long userId);
    
    /**
     * Get unread notification count for a user
     * @param userId User ID
     * @return Unread notification count
     */
    long getUnreadCount(Long userId);
    
    /**
     * Get unread notification count by type for a user
     * @param userId User ID
     * @param type Notification type
     * @return Unread notification count for the type
     */
    long getUnreadCountByType(Long userId, NotificationType type);
    
    /**
     * Delete notification
     * @param notificationId Notification ID
     * @param userId User ID (must be the recipient)
     * @return true if successfully deleted
     */
    boolean deleteNotification(Long notificationId, Long userId);
    
    /**
     * Clean up expired notifications
     * @return Number of expired notifications deleted
     */
    int cleanupExpiredNotifications();
    
    /**
     * Get recent notifications for a user (last 24 hours)
     * @param userId User ID
     * @return List of recent notification DTOs
     */
    List<NotificationDto> getRecentNotifications(Long userId);
    
    /**
     * Send system notification to user
     * @param userId User ID
     * @param title Notification title
     * @param content Notification content
     * @return CompletableFuture for async processing
     */
    CompletableFuture<NotificationDto> sendSystemNotification(Long userId, String title, String content);
    
    /**
     * Send announcement notification to multiple users
     * @param userIds List of user IDs
     * @param title Notification title
     * @param content Notification content
     * @param announcementId Reference to announcement
     * @param senderId Sender user ID
     * @return CompletableFuture for async processing
     */
    CompletableFuture<List<NotificationDto>> sendAnnouncementNotifications(List<Long> userIds, String title, 
                                                                          String content, Long announcementId, Long senderId);
}
</file>

<file path="src/main/java/com/example/demo/communication/notification/websocket/NotificationWebSocketHandler.java">
package com.example.demo.communication.notification.websocket;

import com.example.demo.communication.notification.service.NotificationService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.messaging.handler.annotation.MessageMapping;
import org.springframework.messaging.handler.annotation.Payload;
import org.springframework.messaging.simp.SimpMessageHeaderAccessor;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import org.springframework.stereotype.Controller;

import java.security.Principal;

@Controller
@RequiredArgsConstructor
@Slf4j
public class NotificationWebSocketHandler {

    private final NotificationService notificationService;
    private final SimpMessagingTemplate messagingTemplate;

    /**
     * Handle user subscription to notifications
     */
    @MessageMapping("/notifications/subscribe")
    public void subscribeToNotifications(
            SimpMessageHeaderAccessor headerAccessor,
            Principal principal) {
        
        try {
            Long userId = getUserIdFromPrincipal(principal);
            log.info("User {} subscribed to notifications", userId);
            
            // Send current unread count
            long unreadCount = notificationService.getUnreadCount(userId);
            messagingTemplate.convertAndSendToUser(
                    userId.toString(),
                    "/queue/notifications/count",
                    java.util.Map.of("unreadCount", unreadCount)
            );
            
        } catch (Exception e) {
            log.error("Error handling notification subscription: {}", e.getMessage());
        }
    }

    /**
     * Handle marking notification as read via WebSocket
     */
    @MessageMapping("/notifications/read")
    public void markNotificationAsRead(
            @Payload NotificationReadMessage message,
            Principal principal) {
        
        try {
            Long userId = getUserIdFromPrincipal(principal);
            
            boolean success = notificationService.markAsRead(message.getNotificationId(), userId);
            
            if (success) {
                // Send confirmation back to user
                messagingTemplate.convertAndSendToUser(
                        userId.toString(),
                        "/queue/notifications/read-confirm",
                        java.util.Map.of(
                                "notificationId", message.getNotificationId(),
                                "success", true
                        )
                );
            }
            
        } catch (Exception e) {
            log.error("Error marking notification as read via WebSocket: {}", e.getMessage());
        }
    }

    /**
     * Handle user presence for notifications
     */
    @MessageMapping("/notifications/presence")
    public void handleNotificationPresence(
            @Payload PresenceMessage message,
            Principal principal) {
        
        try {
            Long userId = getUserIdFromPrincipal(principal);
            log.debug("User {} notification presence: {}", userId, message.isOnline());
            
            // You can implement presence-based notification logic here
            // For example, queue notifications when user is offline
            
        } catch (Exception e) {
            log.error("Error handling notification presence: {}", e.getMessage());
        }
    }

    private Long getUserIdFromPrincipal(Principal principal) {
        if (principal == null || principal.getName() == null) {
            throw new IllegalArgumentException("User not authenticated");
        }
        
        try {
            return Long.parseLong(principal.getName());
        } catch (NumberFormatException e) {
            throw new IllegalArgumentException("Invalid user ID format");
        }
    }

    // Inner classes for WebSocket message payloads
    public static class NotificationReadMessage {
        private Long notificationId;
        
        public NotificationReadMessage() {}
        
        public NotificationReadMessage(Long notificationId) {
            this.notificationId = notificationId;
        }
        
        public Long getNotificationId() { return notificationId; }
        public void setNotificationId(Long notificationId) { this.notificationId = notificationId; }
    }

    public static class PresenceMessage {
        private boolean online;
        
        public PresenceMessage() {}
        
        public PresenceMessage(boolean online) {
            this.online = online;
        }
        
        public boolean isOnline() { return online; }
        public void setOnline(boolean online) { this.online = online; }
    }
}
</file>

<file path="src/main/java/com/example/demo/config/FlywayConfig.java">
package com.example.demo.config;

import org.flywaydb.core.Flyway;
import org.flywaydb.core.api.configuration.FluentConfiguration;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.autoconfigure.flyway.FlywayConfigurationCustomizer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.DependsOn;

import javax.sql.DataSource;

/**
 * Flyway Configuration for database migrations.
 * 
 * Configures Flyway for versioned database schema management
 * with proper migration validation and rollback capabilities.
 */
@Configuration
public class FlywayConfig {

    /**
     * Flyway configuration customizer for additional settings
     */
    @Bean
    public FlywayConfigurationCustomizer flywayConfigurationCustomizer() {
        return new FlywayConfigurationCustomizer() {
            @Override
            public void customize(FluentConfiguration configuration) {
                // Enable validation of migrations
                configuration.validateOnMigrate(true);
                
                // Allow out of order migrations in development
                configuration.outOfOrder(false);
                
                // Set baseline version
                configuration.baselineVersion("0");
                configuration.baselineDescription("Initial baseline");
                
                // Configure migration locations
                configuration.locations("classpath:db/migration");
                
                // Set table name for migration history
                configuration.table("flyway_schema_history");
                
                // Configure encoding
                configuration.encoding("UTF-8");
                
                // Set placeholders for environment-specific values
                configuration.placeholderReplacement(true);
                configuration.placeholders(java.util.Map.of(
                    "database.name", "employee_management"
                ));
                
                // Configure callbacks for custom migration logic
                configuration.callbacks("com.example.demo.config.FlywayConfig$MigrationCallback");
            }
        };
    }

    /**
     * Custom Flyway instance with enhanced configuration
     */
    @Bean
    @DependsOn("dataSource")
    public Flyway flyway(@Qualifier("dataSource") DataSource dataSource) {
        return Flyway.configure()
                .dataSource(dataSource)
                .locations("classpath:db/migration")
                .baselineOnMigrate(true)
                .validateOnMigrate(true)
                .outOfOrder(false)
                .table("flyway_schema_history")
                .encoding("UTF-8")
                .placeholderReplacement(true)
                .load();
    }

    /**
     * Migration validation service
     */
    @Bean
    public MigrationValidator migrationValidator(Flyway flyway) {
        return new MigrationValidator(flyway);
    }

    /**
     * Custom migration callback for logging and validation
     */
    public static class MigrationCallback implements org.flywaydb.core.api.callback.Callback {
        
        @Override
        public boolean supports(org.flywaydb.core.api.callback.Event event, 
                              org.flywaydb.core.api.callback.Context context) {
            return event == org.flywaydb.core.api.callback.Event.BEFORE_MIGRATE ||
                   event == org.flywaydb.core.api.callback.Event.AFTER_MIGRATE ||
                   event == org.flywaydb.core.api.callback.Event.BEFORE_EACH_MIGRATE ||
                   event == org.flywaydb.core.api.callback.Event.AFTER_EACH_MIGRATE;
        }

        @Override
        public void handle(org.flywaydb.core.api.callback.Event event, 
                          org.flywaydb.core.api.callback.Context context) {
            switch (event) {
                case BEFORE_MIGRATE:
                    System.out.println("Starting database migration...");
                    break;
                case AFTER_MIGRATE:
                    System.out.println("Database migration completed successfully.");
                    break;
                case BEFORE_EACH_MIGRATE:
                    System.out.println("Executing migration: " + 
                        context.getMigrationInfo().getDescription());
                    break;
                case AFTER_EACH_MIGRATE:
                    System.out.println("Completed migration: " + 
                        context.getMigrationInfo().getDescription());
                    break;
                case AFTER_BASELINE:
                    break;
                case AFTER_BASELINE_ERROR:
                    break;
                case AFTER_BASELINE_OPERATION_FINISH:
                    break;
                case AFTER_CLEAN:
                    break;
                case AFTER_CLEAN_ERROR:
                    break;
                case AFTER_CLEAN_OPERATION_FINISH:
                    break;
                case AFTER_EACH_MIGRATE_ERROR:
                    break;
                case AFTER_EACH_MIGRATE_STATEMENT:
                    break;
                case AFTER_EACH_MIGRATE_STATEMENT_ERROR:
                    break;
                case AFTER_EACH_UNDO:
                    break;
                case AFTER_EACH_UNDO_ERROR:
                    break;
                case AFTER_EACH_UNDO_STATEMENT:
                    break;
                case AFTER_EACH_UNDO_STATEMENT_ERROR:
                    break;
                case AFTER_INFO:
                    break;
                case AFTER_INFO_ERROR:
                    break;
                case AFTER_INFO_OPERATION_FINISH:
                    break;
                case AFTER_MIGRATE_APPLIED:
                    break;
                case AFTER_MIGRATE_ERROR:
                    break;
                case AFTER_MIGRATE_OPERATION_FINISH:
                    break;
                case AFTER_REPAIR:
                    break;
                case AFTER_REPAIR_ERROR:
                    break;
                case AFTER_REPAIR_OPERATION_FINISH:
                    break;
                case AFTER_UNDO:
                    break;
                case AFTER_UNDO_ERROR:
                    break;
                case AFTER_UNDO_OPERATION_FINISH:
                    break;
                case AFTER_VALIDATE:
                    break;
                case AFTER_VALIDATE_ERROR:
                    break;
                case AFTER_VALIDATE_OPERATION_FINISH:
                    break;
                case AFTER_VERSIONED:
                    break;
                case BEFORE_BASELINE:
                    break;
                case BEFORE_CLEAN:
                    break;
                case BEFORE_CONNECT:
                    break;
                case BEFORE_CREATE_SCHEMA:
                    break;
                case BEFORE_EACH_MIGRATE_STATEMENT:
                    break;
                case BEFORE_EACH_UNDO:
                    break;
                case BEFORE_EACH_UNDO_STATEMENT:
                    break;
                case BEFORE_INFO:
                    break;
                case BEFORE_REPAIR:
                    break;
                case BEFORE_REPEATABLES:
                    break;
                case BEFORE_UNDO:
                    break;
                case BEFORE_VALIDATE:
                    break;
                case CREATE_SCHEMA:
                    break;
                default:
                    break;
            }
        }

        @Override
        public boolean canHandleInTransaction(org.flywaydb.core.api.callback.Event event, 
                                            org.flywaydb.core.api.callback.Context context) {
            return true;
        }

        @Override
        public String getCallbackName() {
            return "MigrationCallback";
        }
    }

    /**
     * Service for validating and managing migrations
     */
    public static class MigrationValidator {
        private final Flyway flyway;

        public MigrationValidator(Flyway flyway) {
            this.flyway = flyway;
        }

        /**
         * Validates all pending migrations
         */
        public boolean validateMigrations() {
            try {
                flyway.validate();
                return true;
            } catch (Exception e) {
                System.err.println("Migration validation failed: " + e.getMessage());
                return false;
            }
        }

        /**
         * Gets information about pending migrations
         */
        public org.flywaydb.core.api.MigrationInfo[] getPendingMigrations() {
            return flyway.info().pending();
        }

        /**
         * Gets information about applied migrations
         */
        public org.flywaydb.core.api.MigrationInfo[] getAppliedMigrations() {
            return flyway.info().applied();
        }

        /**
         * Repairs the migration history table
         */
        public void repairMigrations() {
            flyway.repair();
        }

        /**
         * Creates a baseline for existing databases
         */
        public void baseline() {
            flyway.baseline();
        }
    }
}
</file>

<file path="src/main/java/com/example/demo/DemoApplication.java">
package com.example.demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;
import org.springframework.scheduling.annotation.EnableAsync;

/**
 * Main Spring Boot application class for Employee Management System.
 * 
 * This application provides comprehensive employee management functionality
 * with hybrid PostgreSQL + Redis architecture for optimal performance.
 * 
 * Features:
 * - Employee, Department, and Position management
 * - JWT-based authentication and authorization
 * - Real-time chat and notifications via WebSocket
 * - Email communication system
 * - Payroll management
 * - File import/export capabilities
 */
@SpringBootApplication
@EnableJpaAuditing
@EnableCaching
@EnableAsync
public class DemoApplication {

    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}
</file>

<file path="src/main/java/com/example/demo/department/dto/DepartmentCreateRequest.java">
package com.example.demo.department.dto;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import jakarta.validation.constraints.Min;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class DepartmentCreateRequest {
    
    @NotBlank(message = "Department name is required")
    @Size(min = 2, max = 100, message = "Department name must be between 2 and 100 characters")
    private String name;
    
    @NotBlank(message = "Department code is required")
    @Size(min = 2, max = 20, message = "Department code must be between 2 and 20 characters")
    private String code;
    
    @Size(max = 500, message = "Description must not exceed 500 characters")
    private String description;
    
    private Long parentId;
    
    @Min(value = 0, message = "Sort order must be non-negative")
    private Integer sortOrder = 0;
    
    @Size(max = 255, message = "Location must not exceed 255 characters")
    private String location;
    
    private Long managerId;
    
    private boolean enabled = true;
}
</file>

<file path="src/main/java/com/example/demo/department/dto/DepartmentDto.java">
package com.example.demo.department.dto;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import jakarta.validation.constraints.Min;
import java.time.Instant;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class DepartmentDto {
    
    private Long id;
    
    @NotBlank(message = "Department name is required")
    @Size(min = 2, max = 100, message = "Department name must be between 2 and 100 characters")
    private String name;
    
    @Size(max = 500, message = "Description must not exceed 500 characters")
    private String description;
    
    private Long parentId;
    
    private String depPath;
    
    private Boolean isParent;
    
    @Min(value = 0, message = "Level must be non-negative")
    private Integer level;
    
    @Min(value = 0, message = "Sort order must be non-negative")
    private Integer sortOrder;
    
    @Size(max = 20, message = "Department code must not exceed 20 characters")
    private String code;
    
    @Size(max = 255, message = "Location must not exceed 255 characters")
    private String location;
    
    private Long managerId;
    
    private String managerName; // Transient field for display
    
    private boolean enabled;
    
    private Instant createdAt;
    private Instant updatedAt;
    
    private Long createdBy;
    
    private Long updatedBy;
    
    private String createdByName; // Transient field for display
    
    private String updatedByName; // Transient field for display
    
    private List<DepartmentDto> children;
    
    private DepartmentDto parent;
    
    private Long employeeCount; // Number of employees in this department
}
</file>

<file path="src/main/java/com/example/demo/department/dto/DepartmentStatisticsDto.java">
package com.example.demo.department.dto;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class DepartmentStatisticsDto {
    
    private Long departmentId;
    
    private String departmentName;
    
    private Long directEmployeeCount; // Employees directly in this department
    
    private Long totalEmployeeCount; // Employees in this department and all subdepartments
    
    private Long directChildCount; // Direct child departments
    
    private Long totalChildCount; // All descendant departments
    
    private Integer maxDepth; // Maximum depth of subdepartments
    
    private boolean hasManager;
    
    private String managerName;
}
</file>

<file path="src/main/java/com/example/demo/department/dto/DepartmentTreeDto.java">
package com.example.demo.department.dto;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;

import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class DepartmentTreeDto {
    
    private Long id;
    
    private String name;
    
    private String code;
    
    private Long parentId;
    
    private Integer level;
    
    private Integer sortOrder;
    
    private boolean enabled;
    
    private boolean hasChildren;
    
    private Long employeeCount;
    
    private String managerName;
    
    private List<DepartmentTreeDto> children;
    
    // Additional fields for tree display
    private boolean expanded; // For UI tree expansion state
    
    private boolean selectable; // Whether this node can be selected
    
    private String icon; // Icon for tree node display
}
</file>

<file path="src/main/java/com/example/demo/department/dto/DepartmentUpdateRequest.java">
package com.example.demo.department.dto;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import jakarta.validation.constraints.Min;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class DepartmentUpdateRequest {
    
    @NotBlank(message = "Department name is required")
    @Size(min = 2, max = 100, message = "Department name must be between 2 and 100 characters")
    private String name;
    
    @Size(max = 500, message = "Description must not exceed 500 characters")
    private String description;
    
    @Min(value = 0, message = "Sort order must be non-negative")
    private Integer sortOrder;
    
    @Size(max = 255, message = "Location must not exceed 255 characters")
    private String location;
    
    private Long managerId;
    
    private boolean enabled;
}
</file>

<file path="src/main/java/com/example/demo/department/entity/Department.java">
package com.example.demo.department.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.Instant;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "departments", indexes = {
    @Index(name = "idx_department_name", columnList = "name"),
    @Index(name = "idx_department_code", columnList = "code"),
    @Index(name = "idx_department_parent_id", columnList = "parent_id"),
    @Index(name = "idx_department_dep_path", columnList = "dep_path"),
    @Index(name = "idx_department_enabled", columnList = "enabled"),
    @Index(name = "idx_department_manager_id", columnList = "manager_id")
})
@EntityListeners(AuditingEntityListener.class)
@Getter
@Setter
public class Department {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "name", nullable = false, length = 100)
    private String name;
    
    @Column(name = "code", unique = true, nullable = false, length = 20)
    private String code;
    
    @Column(name = "description", length = 500)
    private String description;
    
    @Column(name = "location", length = 255)
    private String location;
    
    @Column(name = "parent_id")
    private Long parentId;
    
    @Column(name = "dep_path", length = 500)
    private String depPath;
    
    @Column(name = "is_parent", nullable = false)
    private Boolean isParent = false;
    
    @Column(name = "enabled", nullable = false)
    private Boolean enabled = true;
    
    @Column(name = "level")
    private Integer level = 0;
    
    @Column(name = "sort_order")
    private Integer sortOrder = 0;
    
    @Column(name = "manager_id")
    private Long managerId;
    
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;
    
    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;
    
    @Column(name = "created_by")
    private Long createdBy;
    
    @Column(name = "updated_by")
    private Long updatedBy;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "parent_id", insertable = false, updatable = false)
    private Department parent;
    
    @OneToMany(mappedBy = "parent", fetch = FetchType.LAZY)
    private Set<Department> children = new HashSet<>();
    
    // Employee relationship is defined in the Employee entity
    
    @Transient
    private Long employeeCount;
}
</file>

<file path="src/main/java/com/example/demo/department/exception/DepartmentAlreadyExistsException.java">
package com.example.demo.department.exception;

import com.example.demo.common.exception.BusinessException;

public class DepartmentAlreadyExistsException extends BusinessException {
    
    public DepartmentAlreadyExistsException(String message) {
        super(message);
    }
    
    public DepartmentAlreadyExistsException(String message, Throwable cause) {
        super("DEPARTMENT_ALREADY_EXISTS", message, cause);
    }
    
    public static DepartmentAlreadyExistsException byName(String name) {
        return new DepartmentAlreadyExistsException(
            "Department with name '" + name + "' already exists"
        );
    }
    
    public static DepartmentAlreadyExistsException byCode(String code) {
        return new DepartmentAlreadyExistsException(
            "Department with code '" + code + "' already exists"
        );
    }
}
</file>

<file path="src/main/java/com/example/demo/department/exception/DepartmentHierarchyException.java">
package com.example.demo.department.exception;

import com.example.demo.common.exception.BusinessException;

public class DepartmentHierarchyException extends BusinessException {
    
    public DepartmentHierarchyException(String message) {
        super(message);
    }
    
    public DepartmentHierarchyException(String message, Throwable cause) {
        super("DEPARTMENT_HIERARCHY_ERROR", message, cause);
    }
    
    public static DepartmentHierarchyException circularReference(Long departmentId, Long parentId) {
        return new DepartmentHierarchyException(
            "Moving department " + departmentId + " to parent " + parentId + " would create a circular reference"
        );
    }
    
    public static DepartmentHierarchyException hasChildren(Long departmentId) {
        return new DepartmentHierarchyException(
            "Cannot delete department " + departmentId + " because it has child departments"
        );
    }
    
    public static DepartmentHierarchyException invalidParent(Long parentId) {
        return new DepartmentHierarchyException(
            "Invalid parent department ID: " + parentId
        );
    }
}
</file>

<file path="src/main/java/com/example/demo/department/exception/DepartmentInUseException.java">
package com.example.demo.department.exception;

import com.example.demo.common.exception.BusinessException;

public class DepartmentInUseException extends BusinessException {
    
    public DepartmentInUseException(String message) {
        super(message);
    }
    
    public DepartmentInUseException(String message, Throwable cause) {
        super("DEPARTMENT_IN_USE", message, cause);
    }
    
    public static DepartmentInUseException hasEmployees(Long departmentId, long employeeCount) {
        return new DepartmentInUseException(
            "Cannot delete department " + departmentId + " because it has " + employeeCount + " employees"
        );
    }
    
    public static DepartmentInUseException hasPositions(Long departmentId, long positionCount) {
        return new DepartmentInUseException(
            "Cannot delete department " + departmentId + " because it has " + positionCount + " positions"
        );
    }
}
</file>

<file path="src/main/java/com/example/demo/department/exception/DepartmentNotFoundException.java">
package com.example.demo.department.exception;

import com.example.demo.common.exception.BusinessException;

public class DepartmentNotFoundException extends BusinessException {
    
    public DepartmentNotFoundException(String message) {
        super(message);
    }
    
    public DepartmentNotFoundException(String message, Throwable cause) {
        super("DEPARTMENT_NOT_FOUND", message, cause);
    }
    
    public DepartmentNotFoundException(Long departmentId) {
        super("Department not found with ID: " + departmentId);
    }
    
    public DepartmentNotFoundException(String field, String value) {
        super("Department not found with " + field + ": " + value);
    }
}
</file>

<file path="src/main/java/com/example/demo/department/README.md">
# Department Management Module

## Overview

The Department Management Module provides comprehensive functionality for managing hierarchical department structures within the employee management system. It supports tree-based organization with parent-child relationships, path-based queries, and various administrative operations.

## Features

### Core Functionality
- **Hierarchical Structure**: Support for multi-level department trees with parent-child relationships
- **Path-Based Organization**: Automatic path generation (e.g., `/COMP/IT/DEV`) for efficient queries
- **CRUD Operations**: Complete Create, Read, Update, Delete operations with validation
- **Tree Operations**: Move departments, rebuild paths, and maintain hierarchy integrity
- **Search and Filtering**: Search by name, filter by level, and various query options

### Advanced Features
- **Circular Reference Prevention**: Automatic validation to prevent invalid hierarchy moves
- **Dependency Checking**: Validation before deletion to ensure data integrity
- **Statistics and Analytics**: Department statistics including employee counts and hierarchy depth
- **Caching**: Redis-based caching for improved performance
- **Audit Trail**: Automatic tracking of creation and modification timestamps

## API Endpoints

### Department CRUD
- `POST /api/departments` - Create new department
- `GET /api/departments/{id}` - Get department by ID
- `GET /api/departments/code/{code}` - Get department by code
- `PUT /api/departments/{id}` - Update department
- `DELETE /api/departments/{id}` - Delete department

### Hierarchy Operations
- `GET /api/departments/tree` - Get complete department tree
- `GET /api/departments/{id}/subtree` - Get department subtree
- `GET /api/departments/{id}/children` - Get direct children
- `GET /api/departments/root` - Get root departments
- `GET /api/departments/level/{level}` - Get departments by level

### Search and Query
- `GET /api/departments` - Get all departments (flat list)
- `GET /api/departments/search?q={term}` - Search departments by name

### Administrative Operations
- `PUT /api/departments/{id}/move?parentId={parentId}` - Move department
- `PUT /api/departments/{id}/enabled?enabled={true|false}` - Enable/disable department
- `PUT /api/departments/{id}/sort-order?sortOrder={order}` - Update sort order
- `POST /api/departments/rebuild-paths` - Rebuild all department paths (maintenance)

### Analytics and Information
- `GET /api/departments/{id}/path` - Get path from root to department
- `GET /api/departments/{id}/ancestors` - Get ancestor departments
- `GET /api/departments/{id}/descendants` - Get descendant departments
- `GET /api/departments/{id}/statistics` - Get department statistics
- `GET /api/departments/{id}/can-delete` - Check if department can be deleted

## Data Model

### Department Entity
```java
@Entity
@Table(name = "departments")
public class Department {
    private Long id;                    // Primary key
    private String name;                // Department name
    private String code;                // Unique department code
    private String description;         // Optional description
    private String location;            // Physical location
    private Long parentId;              // Parent department ID
    private String depPath;             // Full path (e.g., /COMP/IT/DEV)
    private Boolean isParent;           // Has child departments
    private Boolean enabled;            // Active status
    private Integer level;              // Hierarchy level (0 for root)
    private Integer sortOrder;          // Sort order within parent
    private Long managerId;             // Department manager employee ID
    private Instant createdAt;          // Creation timestamp
    private Instant updatedAt;          // Last update timestamp
    private Long createdBy;             // Creator user ID
    private Long updatedBy;             // Last updater user ID
}
```

### Key Features
- **Hierarchical Relationships**: Self-referencing foreign key for parent-child relationships
- **Path-Based Queries**: Automatic path generation for efficient subtree queries
- **Audit Fields**: Automatic tracking of creation and modification
- **Soft Hierarchy**: Support for both parent and leaf departments
- **Flexible Organization**: Sort order and enable/disable functionality

## Database Schema

### Tables
- `departments` - Main department table with hierarchical structure
- Indexes on frequently queried fields (name, code, parent_id, dep_path, level)
- Triggers for automatic path generation and hierarchy maintenance

### Key Constraints
- Unique constraint on department code
- Self-referencing foreign key for hierarchy
- Check constraints for data validation
- Cascade rules for referential integrity

## Security

### Permission-Based Access Control
- `DEPARTMENT_CREATE` - Create new departments
- `DEPARTMENT_READ` - View department information
- `DEPARTMENT_UPDATE` - Modify existing departments
- `DEPARTMENT_DELETE` - Delete departments
- `DEPARTMENT_ADMIN` - Administrative operations (rebuild paths)

### Validation
- Input validation on all fields
- Business rule validation (circular references, dependencies)
- Authorization checks on all endpoints
- Audit logging for security events

## Performance Optimizations

### Caching Strategy
- Redis caching for frequently accessed department data
- Cache invalidation on modifications
- Cached department trees and hierarchies

### Database Optimizations
- Indexes on frequently queried fields
- Path-based queries for efficient subtree operations
- Optimized recursive queries using PostgreSQL CTEs
- Connection pooling and query optimization

## Error Handling

### Custom Exceptions
- `DepartmentNotFoundException` - Department not found
- `DepartmentAlreadyExistsException` - Duplicate name/code
- `DepartmentHierarchyException` - Hierarchy violations
- `DepartmentInUseException` - Cannot delete due to dependencies

### Validation
- Input validation with detailed error messages
- Business rule validation
- Referential integrity checks
- Graceful error responses with proper HTTP status codes

## Testing

### Unit Tests
- Service layer tests with Mockito
- Repository tests with @DataJpaTest
- Controller tests with @WebMvcTest
- Exception handling tests

### Integration Tests
- Full API integration tests
- Database integration tests
- Security integration tests
- Performance tests

## Usage Examples

### Creating a Department
```java
DepartmentCreateRequest request = new DepartmentCreateRequest();
request.setName("Software Development");
request.setCode("DEV");
request.setDescription("Software development team");
request.setParentId(2L); // IT Department
request.setEnabled(true);

DepartmentDto created = departmentService.createDepartment(request);
```

### Getting Department Tree
```java
List<DepartmentTreeDto> tree = departmentService.getDepartmentTree();
// Returns hierarchical structure with children populated
```

### Moving a Department
```java
departmentService.moveDepartment(5L, 3L); // Move dept 5 under dept 3
// Automatically updates paths and validates hierarchy
```

### Searching Departments
```java
List<DepartmentDto> results = departmentService.searchDepartments("engineering");
// Returns all departments with "engineering" in the name
```

## Configuration

### Application Properties
```properties
# Caching configuration
spring.cache.type=redis
spring.cache.redis.time-to-live=600000

# Database configuration
spring.jpa.hibernate.ddl-auto=validate
spring.flyway.enabled=true
```

### Redis Configuration
- Department data cached with TTL
- Cache keys: `departments::{id}`, `departmentTree::tree`
- Automatic cache eviction on modifications

## Maintenance

### Path Rebuilding
The system includes a maintenance operation to rebuild all department paths:
```java
departmentService.rebuildDepartmentPaths();
```

This operation:
- Recalculates all department paths
- Updates hierarchy levels
- Fixes any inconsistencies
- Should be run during maintenance windows

### Monitoring
- Spring Boot Actuator endpoints for health checks
- Custom metrics for department operations
- Performance monitoring for tree operations
- Cache hit/miss ratios

## Future Enhancements

### Planned Features
- Department templates for quick setup
- Bulk operations for multiple departments
- Department history and versioning
- Advanced reporting and analytics
- Integration with organizational charts

### Performance Improvements
- Materialized path optimization
- Lazy loading for large hierarchies
- Pagination for tree operations
- Background processing for maintenance operations
</file>

<file path="src/main/java/com/example/demo/department/repository/DepartmentRepository.java">
package com.example.demo.department.repository;

import com.example.demo.department.entity.Department;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface DepartmentRepository extends JpaRepository<Department, Long> {
    
    /**
     * Find department by name
     * @param name Department name
     * @return Optional department
     */
    Optional<Department> findByName(String name);
    
    /**
     * Find departments by parent ID
     * @param parentId Parent department ID
     * @return List of child departments
     */
    List<Department> findByParentIdOrderBySortOrder(Long parentId);
    
    /**
     * Find root departments (parentId is null)
     * @return List of root departments
     */
    List<Department> findByParentIdIsNullOrderBySortOrder();
    
    /**
     * Find departments by level
     * @param level Hierarchy level
     * @return List of departments at specified level
     */
    List<Department> findByLevel(Integer level);
    
    /**
     * Find departments by path prefix (for subtree queries)
     * @param pathPrefix Path prefix to match
     * @return List of departments in subtree
     */
    List<Department> findByDepPathStartingWithOrderByDepPath(String pathPrefix);
    
    /**
     * Find enabled departments
     * @return List of enabled departments
     */
    List<Department> findByEnabledTrueOrderByDepPath();
    
    /**
     * Find departments by name containing (case insensitive)
     * @param name Name search term
     * @return List of matching departments
     */
    List<Department> findByNameContainingIgnoreCaseOrderByName(String name);
    
    /**
     * Find departments by code
     * @param code Department code
     * @return Optional department
     */
    Optional<Department> findByCode(String code);
    
    /**
     * Check if department name exists
     * @param name Department name
     * @return true if exists
     */
    boolean existsByName(String name);
    
    /**
     * Check if department code exists
     * @param code Department code
     * @return true if exists
     */
    boolean existsByCode(String code);
    
    /**
     * Check if department has children
     * @param parentId Parent department ID
     * @return true if has children
     */
    boolean existsByParentId(Long parentId);
    
    /**
     * Count departments by parent ID
     * @param parentId Parent department ID
     * @return Count of child departments
     */
    long countByParentId(Long parentId);
    
    /**
     * Find departments by manager ID
     * @param managerId Manager employee ID
     * @return List of departments managed by the employee
     */
    List<Department> findByManagerId(Long managerId);
    
    /**
     * Find all departments with employee count using native query
     * @return List of departments with employee count
     */
    @Query(value = """
        SELECT d.*, COALESCE(e.employee_count, 0) as employee_count
        FROM departments d
        LEFT JOIN (
            SELECT department_id, COUNT(*) as employee_count
            FROM employees
            WHERE status = 'ACTIVE'
            GROUP BY department_id
        ) e ON d.id = e.department_id
        ORDER BY d.dep_path
        """, nativeQuery = true)
    List<Department> findAllWithEmployeeCount();
    
    /**
     * Find department hierarchy using recursive CTE
     * @param rootId Root department ID
     * @return List of departments in hierarchy
     */
    @Query(value = """
        WITH RECURSIVE department_hierarchy AS (
            SELECT id, name, code, parent_id, dep_path, level, sort_order, enabled
            FROM departments
            WHERE id = :rootId
            UNION ALL
            SELECT d.id, d.name, d.code, d.parent_id, d.dep_path, d.level, d.sort_order, d.enabled
            FROM departments d
            INNER JOIN department_hierarchy dh ON d.parent_id = dh.id
        )
        SELECT * FROM department_hierarchy
        ORDER BY dep_path, sort_order
        """, nativeQuery = true)
    List<Department> findHierarchy(@Param("rootId") Long rootId);
}
</file>

<file path="src/main/java/com/example/demo/department/service/DepartmentService.java">
package com.example.demo.department.service;

import com.example.demo.department.dto.DepartmentDto;
import com.example.demo.department.dto.DepartmentTreeDto;
import com.example.demo.department.dto.DepartmentCreateRequest;
import com.example.demo.department.dto.DepartmentUpdateRequest;
import com.example.demo.department.dto.DepartmentStatisticsDto;

import java.util.List;

public interface DepartmentService {
    
    /**
     * Create a new department
     * @param request Department creation request
     * @return Created department DTO
     * @throws DepartmentAlreadyExistsException if name or code already exists
     * @throws DepartmentNotFoundException if parent department not found
     */
    DepartmentDto createDepartment(DepartmentCreateRequest request);
    
    /**
     * Update an existing department
     * @param id Department ID
     * @param request Department update request
     * @return Updated department DTO
     * @throws DepartmentNotFoundException if department not found
     * @throws DepartmentAlreadyExistsException if name or code conflicts
     */
    DepartmentDto updateDepartment(Long id, DepartmentUpdateRequest request);
    
    /**
     * Get department by ID
     * @param id Department ID
     * @return Department DTO
     * @throws DepartmentNotFoundException if department not found
     */
    DepartmentDto getDepartmentById(Long id);
    
    /**
     * Get department by code
     * @param code Department code
     * @return Department DTO
     * @throws DepartmentNotFoundException if department not found
     */
    DepartmentDto getDepartmentByCode(String code);
    
    /**
     * Get all departments as flat list
     * @return List of department DTOs
     */
    List<DepartmentDto> getAllDepartments();
    
    /**
     * Get department tree structure
     * @return List of root department tree DTOs with children
     */
    List<DepartmentTreeDto> getDepartmentTree();
    
    /**
     * Get department subtree starting from specified department
     * @param departmentId Root department ID for subtree
     * @return Department tree DTO with children
     * @throws DepartmentNotFoundException if department not found
     */
    DepartmentTreeDto getDepartmentSubtree(Long departmentId);
    
    /**
     * Get child departments of specified parent
     * @param parentId Parent department ID (null for root departments)
     * @return List of child department DTOs
     */
    List<DepartmentDto> getChildDepartments(Long parentId);
    
    /**
     * Get departments by level in hierarchy
     * @param level Hierarchy level (0 for root)
     * @return List of department DTOs at specified level
     */
    List<DepartmentDto> getDepartmentsByLevel(Integer level);
    
    /**
     * Search departments by name
     * @param searchTerm Search term for department name
     * @return List of matching department DTOs
     */
    List<DepartmentDto> searchDepartments(String searchTerm);
    
    /**
     * Delete department by ID
     * @param id Department ID
     * @throws DepartmentNotFoundException if department not found
     * @throws DepartmentHierarchyException if department has children
     * @throws DepartmentInUseException if department has employees
     */
    void deleteDepartment(Long id);
    
    /**
     * Move department to new parent
     * @param departmentId Department ID to move
     * @param newParentId New parent department ID (null for root)
     * @throws DepartmentNotFoundException if department or parent not found
     * @throws DepartmentHierarchyException if move would create circular reference
     */
    void moveDepartment(Long departmentId, Long newParentId);
    
    /**
     * Enable or disable department
     * @param id Department ID
     * @param enabled Enable/disable flag
     * @throws DepartmentNotFoundException if department not found
     */
    void setDepartmentEnabled(Long id, boolean enabled);
    
    /**
     * Update department sort order
     * @param id Department ID
     * @param sortOrder New sort order
     * @throws DepartmentNotFoundException if department not found
     */
    void updateSortOrder(Long id, Integer sortOrder);
    
    /**
     * Get department path from root to specified department
     * @param departmentId Department ID
     * @return List of department DTOs representing path from root
     * @throws DepartmentNotFoundException if department not found
     */
    List<DepartmentDto> getDepartmentPath(Long departmentId);
    
    /**
     * Get all ancestor departments of specified department
     * @param departmentId Department ID
     * @return List of ancestor department DTOs
     * @throws DepartmentNotFoundException if department not found
     */
    List<DepartmentDto> getAncestorDepartments(Long departmentId);
    
    /**
     * Get all descendant departments of specified department
     * @param departmentId Department ID
     * @return List of descendant department DTOs
     * @throws DepartmentNotFoundException if department not found
     */
    List<DepartmentDto> getDescendantDepartments(Long departmentId);
    
    /**
     * Check if department can be deleted
     * @param id Department ID
     * @return true if department can be safely deleted
     * @throws DepartmentNotFoundException if department not found
     */
    boolean canDeleteDepartment(Long id);
    
    /**
     * Get department statistics
     * @param departmentId Department ID
     * @return Department statistics including employee count, child count, etc.
     * @throws DepartmentNotFoundException if department not found
     */
    DepartmentStatisticsDto getDepartmentStatistics(Long departmentId);
    
    /**
     * Rebuild department paths (maintenance operation)
     * This method recalculates all department paths and levels
     */
    void rebuildDepartmentPaths();
}
</file>

<file path="src/main/java/com/example/demo/department/service/impl/DepartmentServiceImpl.java">
package com.example.demo.department.service.impl;

import com.example.demo.department.dto.*;
import com.example.demo.department.entity.Department;
import com.example.demo.department.exception.*;
import com.example.demo.department.repository.DepartmentRepository;
import com.example.demo.department.service.DepartmentService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.*;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
@Transactional
public class DepartmentServiceImpl implements DepartmentService {
    
    private final DepartmentRepository departmentRepository;
    
    @Override
    @CacheEvict(value = {"departments", "departmentTree"}, allEntries = true)
    public DepartmentDto createDepartment(DepartmentCreateRequest request) {
        log.info("Creating department with name: {}", request.getName());
        
        // Validate unique constraints
        if (departmentRepository.existsByName(request.getName())) {
            throw DepartmentAlreadyExistsException.byName(request.getName());
        }
        
        if (departmentRepository.existsByCode(request.getCode())) {
            throw DepartmentAlreadyExistsException.byCode(request.getCode());
        }
        
        // Validate parent department if specified
        if (request.getParentId() != null) {
            if (!departmentRepository.existsById(request.getParentId())) {
                throw new DepartmentNotFoundException(request.getParentId());
            }
        }
        
        Department department = new Department();
        department.setName(request.getName());
        department.setCode(request.getCode());
        department.setDescription(request.getDescription());
        department.setParentId(request.getParentId());
        department.setLocation(request.getLocation());
        department.setManagerId(request.getManagerId());
        department.setEnabled(request.isEnabled());
        department.setSortOrder(request.getSortOrder());
        
        Department saved = departmentRepository.save(department);
        log.info("Department created successfully with ID: {}", saved.getId());
        
        return convertToDto(saved);
    }
    
    @Override
    @CacheEvict(value = {"departments", "departmentTree"}, allEntries = true)
    public DepartmentDto updateDepartment(Long id, DepartmentUpdateRequest request) {
        log.info("Updating department with ID: {}", id);
        
        Department department = departmentRepository.findById(id)
            .orElseThrow(() -> new DepartmentNotFoundException(id));
        
        // Validate unique constraints (excluding current department)
        departmentRepository.findByName(request.getName())
            .ifPresent(existing -> {
                if (!existing.getId().equals(id)) {
                    throw DepartmentAlreadyExistsException.byName(request.getName());
                }
            });
        
        department.setName(request.getName());
        department.setDescription(request.getDescription());
        department.setLocation(request.getLocation());
        department.setManagerId(request.getManagerId());
        department.setEnabled(request.isEnabled());
        department.setSortOrder(request.getSortOrder());
        
        Department updated = departmentRepository.save(department);
        log.info("Department updated successfully with ID: {}", updated.getId());
        
        return convertToDto(updated);
    }
    
    @Override
    @Cacheable(value = "departments", key = "#id")
    public DepartmentDto getDepartmentById(Long id) {
        Department department = departmentRepository.findById(id)
            .orElseThrow(() -> new DepartmentNotFoundException(id));
        return convertToDto(department);
    }
    
    @Override
    @Cacheable(value = "departments", key = "#code")
    public DepartmentDto getDepartmentByCode(String code) {
        Department department = departmentRepository.findByCode(code)
            .orElseThrow(() -> new DepartmentNotFoundException("code", code));
        return convertToDto(department);
    }
    
    @Override
    @Cacheable(value = "departments", key = "'all'")
    public List<DepartmentDto> getAllDepartments() {
        List<Department> departments = departmentRepository.findAll();
        return departments.stream()
            .map(this::convertToDto)
            .collect(Collectors.toList());
    }
    
    @Override
    @Cacheable(value = "departmentTree", key = "'tree'")
    public List<DepartmentTreeDto> getDepartmentTree() {
        List<Department> rootDepartments = departmentRepository.findByParentIdIsNullOrderBySortOrder();
        return rootDepartments.stream()
            .map(this::buildDepartmentTree)
            .collect(Collectors.toList());
    }
    
    @Override
    public DepartmentTreeDto getDepartmentSubtree(Long departmentId) {
        Department department = departmentRepository.findById(departmentId)
            .orElseThrow(() -> new DepartmentNotFoundException(departmentId));
        return buildDepartmentTree(department);
    }
    
    @Override
    public List<DepartmentDto> getChildDepartments(Long parentId) {
        List<Department> children = departmentRepository.findByParentIdOrderBySortOrder(parentId);
        return children.stream()
            .map(this::convertToDto)
            .collect(Collectors.toList());
    }
    
    @Override
    public List<DepartmentDto> getDepartmentsByLevel(Integer level) {
        List<Department> departments = departmentRepository.findByLevel(level);
        return departments.stream()
            .map(this::convertToDto)
            .collect(Collectors.toList());
    }
    
    @Override
    public List<DepartmentDto> searchDepartments(String searchTerm) {
        List<Department> departments = departmentRepository.findByNameContainingIgnoreCaseOrderByName(searchTerm);
        return departments.stream()
            .map(this::convertToDto)
            .collect(Collectors.toList());
    }
    
    @Override
    @CacheEvict(value = {"departments", "departmentTree"}, allEntries = true)
    public void deleteDepartment(Long id) {
        log.info("Deleting department with ID: {}", id);
        
        Department department = departmentRepository.findById(id)
            .orElseThrow(() -> new DepartmentNotFoundException(id));
        
        // Check if department has children
        if (departmentRepository.existsByParentId(id)) {
            throw DepartmentHierarchyException.hasChildren(id);
        }
        
        // Check if department has employees (this would require Employee entity)
        // For now, we'll skip this check as Employee entity is not yet implemented
        
        departmentRepository.delete(department);
        log.info("Department deleted successfully with ID: {}", id);
    }
    
    @Override
    @CacheEvict(value = {"departments", "departmentTree"}, allEntries = true)
    public void moveDepartment(Long departmentId, Long newParentId) {
        log.info("Moving department {} to new parent {}", departmentId, newParentId);
        
        Department department = departmentRepository.findById(departmentId)
            .orElseThrow(() -> new DepartmentNotFoundException(departmentId));
        
        // Validate new parent exists if specified
        if (newParentId != null) {
            if (!departmentRepository.existsById(newParentId)) {
                throw new DepartmentNotFoundException(newParentId);
            }
            
            // Check for circular reference
            if (wouldCreateCircularReference(departmentId, newParentId)) {
                throw DepartmentHierarchyException.circularReference(departmentId, newParentId);
            }
        }
        
        department.setParentId(newParentId);
        departmentRepository.save(department);
        
        log.info("Department moved successfully");
    }
    
    @Override
    @CacheEvict(value = {"departments", "departmentTree"}, allEntries = true)
    public void setDepartmentEnabled(Long id, boolean enabled) {
        Department department = departmentRepository.findById(id)
            .orElseThrow(() -> new DepartmentNotFoundException(id));
        
        department.setEnabled(enabled);
        departmentRepository.save(department);
        
        log.info("Department {} enabled status set to: {}", id, enabled);
    }
    
    @Override
    @CacheEvict(value = {"departments", "departmentTree"}, allEntries = true)
    public void updateSortOrder(Long id, Integer sortOrder) {
        Department department = departmentRepository.findById(id)
            .orElseThrow(() -> new DepartmentNotFoundException(id));
        
        department.setSortOrder(sortOrder);
        departmentRepository.save(department);
        
        log.info("Department {} sort order updated to: {}", id, sortOrder);
    }
    
    @Override
    public List<DepartmentDto> getDepartmentPath(Long departmentId) {
        Department department = departmentRepository.findById(departmentId)
            .orElseThrow(() -> new DepartmentNotFoundException(departmentId));
        
        List<DepartmentDto> path = new ArrayList<>();
        Department current = department;
        
        while (current != null) {
            path.add(0, convertToDto(current)); // Add to beginning to maintain order
            if (current.getParentId() != null) {
                current = departmentRepository.findById(current.getParentId()).orElse(null);
            } else {
                current = null;
            }
        }
        
        return path;
    }
    
    @Override
    public List<DepartmentDto> getAncestorDepartments(Long departmentId) {
        List<DepartmentDto> path = getDepartmentPath(departmentId);
        // Remove the department itself, keep only ancestors
        if (!path.isEmpty()) {
            path.remove(path.size() - 1);
        }
        return path;
    }
    
    @Override
    public List<DepartmentDto> getDescendantDepartments(Long departmentId) {
        Department department = departmentRepository.findById(departmentId)
            .orElseThrow(() -> new DepartmentNotFoundException(departmentId));
        
        String pathPrefix = department.getDepPath() + "/";
        List<Department> descendants = departmentRepository.findByDepPathStartingWithOrderByDepPath(pathPrefix);
        
        return descendants.stream()
            .map(this::convertToDto)
            .collect(Collectors.toList());
    }
    
    @Override
    public boolean canDeleteDepartment(Long id) {
        if (!departmentRepository.existsById(id)) {
            throw new DepartmentNotFoundException(id);
        }
        
        // Check if has children
        if (departmentRepository.existsByParentId(id)) {
            return false;
        }
        
        // Check if has employees (would require Employee entity)
        // For now, assume it can be deleted if no children
        return true;
    }
    
    @Override
    public DepartmentStatisticsDto getDepartmentStatistics(Long departmentId) {
        Department department = departmentRepository.findById(departmentId)
            .orElseThrow(() -> new DepartmentNotFoundException(departmentId));
        
        long directChildCount = departmentRepository.countByParentId(departmentId);
        List<DepartmentDto> descendants = getDescendantDepartments(departmentId);
        
        return DepartmentStatisticsDto.builder()
            .departmentId(departmentId)
            .departmentName(department.getName())
            .directEmployeeCount(0L) // Would require Employee entity
            .totalEmployeeCount(0L) // Would require Employee entity
            .directChildCount(directChildCount)
            .totalChildCount((long) descendants.size())
            .maxDepth(calculateMaxDepth(departmentId))
            .hasManager(department.getManagerId() != null)
            .managerName(null) // Would require Employee entity
            .build();
    }
    
    @Override
    @CacheEvict(value = {"departments", "departmentTree"}, allEntries = true)
    public void rebuildDepartmentPaths() {
        log.info("Rebuilding department paths");
        
        // This would typically be done by the database trigger
        // But we can implement it here for maintenance purposes
        List<Department> rootDepartments = departmentRepository.findByParentIdIsNullOrderBySortOrder();
        
        for (Department root : rootDepartments) {
            rebuildPathsRecursively(root, null, 0);
        }
        
        log.info("Department paths rebuilt successfully");
    }
    
    private void rebuildPathsRecursively(Department department, String parentPath, int level) {
        String newPath = (parentPath == null) ? "/" + department.getCode() : parentPath + "/" + department.getCode();
        department.setDepPath(newPath);
        department.setLevel(level);
        
        boolean hasChildren = departmentRepository.existsByParentId(department.getId());
        department.setIsParent(hasChildren);
        
        departmentRepository.save(department);
        
        // Process children
        List<Department> children = departmentRepository.findByParentIdOrderBySortOrder(department.getId());
        for (Department child : children) {
            rebuildPathsRecursively(child, newPath, level + 1);
        }
    }
    
    private boolean wouldCreateCircularReference(Long departmentId, Long newParentId) {
        if (newParentId == null) {
            return false;
        }
        
        if (departmentId.equals(newParentId)) {
            return true;
        }
        
        // Check if newParentId is a descendant of departmentId
        List<DepartmentDto> descendants = getDescendantDepartments(departmentId);
        return descendants.stream()
            .anyMatch(dept -> dept.getId().equals(newParentId));
    }
    
    private Integer calculateMaxDepth(Long departmentId) {
        List<DepartmentDto> descendants = getDescendantDepartments(departmentId);
        if (descendants.isEmpty()) {
            return 0;
        }
        
        Department department = departmentRepository.findById(departmentId).orElse(null);
        if (department == null) {
            return 0;
        }
        
        int currentLevel = department.getLevel();
        return descendants.stream()
            .mapToInt(dept -> dept.getLevel() - currentLevel)
            .max()
            .orElse(0);
    }
    
    private DepartmentTreeDto buildDepartmentTree(Department department) {
        List<Department> children = departmentRepository.findByParentIdOrderBySortOrder(department.getId());
        
        List<DepartmentTreeDto> childrenDto = children.stream()
            .map(this::buildDepartmentTree)
            .collect(Collectors.toList());
        
        return DepartmentTreeDto.builder()
            .id(department.getId())
            .name(department.getName())
            .code(department.getCode())
            .parentId(department.getParentId())
            .level(department.getLevel())
            .sortOrder(department.getSortOrder())
            .enabled(department.getEnabled())
            .hasChildren(!children.isEmpty())
            .employeeCount(department.getEmployeeCount())
            .children(childrenDto)
            .expanded(false)
            .selectable(true)
            .build();
    }
    
    private DepartmentDto convertToDto(Department department) {
        return DepartmentDto.builder()
            .id(department.getId())
            .name(department.getName())
            .code(department.getCode())
            .description(department.getDescription())
            .location(department.getLocation())
            .parentId(department.getParentId())
            .depPath(department.getDepPath())
            .isParent(department.getIsParent())
            .level(department.getLevel())
            .sortOrder(department.getSortOrder())
            .managerId(department.getManagerId())
            .enabled(department.getEnabled())
            .createdAt(department.getCreatedAt())
            .updatedAt(department.getUpdatedAt())
            .createdBy(department.getCreatedBy())
            .updatedBy(department.getUpdatedBy())
            .employeeCount(department.getEmployeeCount())
            .build();
    }
}
</file>

<file path="src/main/java/com/example/demo/employee/dto/EmployeeCreateRequest.java">
package com.example.demo.employee.dto;

import com.example.demo.employee.entity.EmployeeStatus;
import com.example.demo.employee.entity.EmploymentType;
import com.example.demo.employee.entity.Gender;
import com.example.demo.employee.entity.MaritalStatus;
import com.example.demo.employee.entity.PayType;
import jakarta.validation.constraints.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDate;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class EmployeeCreateRequest {

    @NotBlank(message = "First name is required")
    @Size(min = 2, max = 50, message = "First name must be between 2 and 50 characters")
    private String firstName;

    @NotBlank(message = "Last name is required")
    @Size(min = 2, max = 50, message = "Last name must be between 2 and 50 characters")
    private String lastName;

    @NotBlank(message = "Email is required")
    @Email(message = "Email should be valid")
    @Size(max = 100, message = "Email must not exceed 100 characters")
    private String email;

    @Pattern(regexp = "^[+]?[0-9\\s\\-\\(\\)]{7,20}$", message = "Phone number format is invalid")
    private String phone;

    @Pattern(regexp = "^[+]?[0-9\\s\\-\\(\\)]{7,20}$", message = "Mobile phone number format is invalid")
    private String mobilePhone;

    @Size(max = 255, message = "Address must not exceed 255 characters")
    private String address;

    @Size(max = 100, message = "City must not exceed 100 characters")
    private String city;

    @Size(max = 100, message = "State must not exceed 100 characters")
    private String state;

    @Size(max = 20, message = "Zip code must not exceed 20 characters")
    private String zipCode;

    @Size(max = 100, message = "Country must not exceed 100 characters")
    private String country;

    private String dateOfBirth; // Will be encrypted by service

    private Gender gender;

    private MaritalStatus maritalStatus;

    @Size(max = 50, message = "Nationality must not exceed 50 characters")
    private String nationality;

    @NotNull(message = "Department is required")
    private Long departmentId;

    private Long positionId;

    private Long managerId;

    @NotNull(message = "Hire date is required")
    @PastOrPresent(message = "Hire date cannot be in the future")
    private LocalDate hireDate;

    @NotNull(message = "Employee status is required")
    private EmployeeStatus status = EmployeeStatus.ACTIVE;

    @NotNull(message = "Employment type is required")
    private EmploymentType employmentType = EmploymentType.FULL_TIME;

    @NotNull(message = "Pay type is required")
    private PayType payType = PayType.SALARY;

    @DecimalMin(value = "0.0", inclusive = true, message = "Salary must be non-negative")
    @Digits(integer = 10, fraction = 2, message = "Salary format is invalid")
    private BigDecimal salary;

    @DecimalMin(value = "0.0", inclusive = true, message = "Hourly rate must be non-negative")
    @Digits(integer = 6, fraction = 2, message = "Hourly rate format is invalid")
    private BigDecimal hourlyRate;

    private String bankAccount; // Will be encrypted by service
    private String taxId; // Will be encrypted by service

    private Boolean enabled = true;
}
</file>

<file path="src/main/java/com/example/demo/employee/dto/EmployeeDto.java">
package com.example.demo.employee.dto;

import com.example.demo.employee.entity.EmployeeStatus;
import com.example.demo.employee.entity.EmploymentType;
import com.example.demo.employee.entity.Gender;
import com.example.demo.employee.entity.MaritalStatus;
import com.example.demo.employee.entity.PayType;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;

import jakarta.validation.constraints.*;
import java.time.LocalDate;
import java.time.Instant;
import java.math.BigDecimal;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class EmployeeDto {
  
    private Long id;
  
    @NotBlank(message = "Employee number is required")
    @Size(max = 20, message = "Employee number must not exceed 20 characters")
    private String employeeNumber;
  
    @NotBlank(message = "First name is required")
    @Size(min = 2, max = 50, message = "First name must be between 2 and 50 characters")
    private String firstName;
  
    @NotBlank(message = "Last name is required")
    @Size(min = 2, max = 50, message = "Last name must be between 2 and 50 characters")
    private String lastName;
  
    @NotBlank(message = "Email is required")
    @Email(message = "Email should be valid")
    @Size(max = 100, message = "Email must not exceed 100 characters")
    private String email;
  
    @Pattern(regexp = "^[+]?[0-9\\s\\-\\(\\)]{7,20}$", message = "Phone number format is invalid")
    private String phone;
  
    @Pattern(regexp = "^[+]?[0-9\\s\\-\\(\\)]{7,20}$", message = "Mobile phone number format is invalid")
    private String mobilePhone;
  
    @Size(max = 255, message = "Address must not exceed 255 characters")
    private String address;
  
    @Size(max = 100, message = "City must not exceed 100 characters")
    private String city;
  
    @Size(max = 100, message = "State must not exceed 100 characters")
    private String state;
  
    @Size(max = 20, message = "Zip code must not exceed 20 characters")
    private String zipCode;
  
    @Size(max = 100, message = "Country must not exceed 100 characters")
    private String country;
  
    // Sensitive fields are strings in DTO, service layer handles encryption/decryption
    private String dateOfBirth;
  
    private Gender gender;
  
    private MaritalStatus maritalStatus;
  
    @Size(max = 50, message = "Nationality must not exceed 50 characters")
    private String nationality;
  
    @NotNull(message = "Department is required")
    private Long departmentId;
  
    private String departmentName; // Transient field for display
  
    private Long positionId;
  
    private String positionName; // Transient field for display
  
    private Long managerId;
  
    private String managerName; // Transient field for display
  
    @NotNull(message = "Hire date is required")
    @PastOrPresent(message = "Hire date cannot be in the future")
    private LocalDate hireDate;
  
    private LocalDate terminationDate;
  
    @NotNull(message = "Employee status is required")
    private EmployeeStatus status;
  
    private EmploymentType employmentType;
  
    private PayType payType;
  
    @DecimalMin(value = "0.0", inclusive = true, message = "Salary must be non-negative")
    @Digits(integer = 10, fraction = 2, message = "Salary format is invalid")
    private BigDecimal salary;
  
    @DecimalMin(value = "0.0", inclusive = true, message = "Hourly rate must be non-negative")
    @Digits(integer = 6, fraction = 2, message = "Hourly rate format is invalid")
    private BigDecimal hourlyRate;
  
    // Sensitive fields are strings in DTO (masked for display)
    private String bankAccount;
    private String taxId;
  
    private boolean enabled;
  
    private Instant createdAt;
  
    private Instant updatedAt;
  
    private String fullName; // firstName + lastName
}
</file>

<file path="src/main/java/com/example/demo/employee/dto/EmployeeImportResult.java">
package com.example.demo.employee.dto;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;

import java.util.List;
import java.util.ArrayList;

/**
 * DTO representing the result of an employee import operation
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class EmployeeImportResult {
    
    private int totalRecords;
    private int successfulImports;
    private int failedImports;
    private int skippedRecords;
    
    @Builder.Default
    private List<EmployeeImportError> errors = new ArrayList<>();
    
    @Builder.Default
    private List<EmployeeDto> importedEmployees = new ArrayList<>();
    
    @Builder.Default
    private List<String> warnings = new ArrayList<>();
    
    private String importSummary;
    private long processingTimeMs;
    
    /**
     * Add an import error
     */
    public void addError(int rowNumber, String field, String value, String errorMessage) {
        errors.add(EmployeeImportError.builder()
                .rowNumber(rowNumber)
                .field(field)
                .value(value)
                .errorMessage(errorMessage)
                .build());
    }
    
    /**
     * Add a warning message
     */
    public void addWarning(String warning) {
        warnings.add(warning);
    }
    
    /**
     * Add an imported employee
     */
    public void addImportedEmployee(EmployeeDto employee) {
        importedEmployees.add(employee);
    }
    
    /**
     * Check if import was successful (no errors)
     */
    public boolean isSuccessful() {
        return errors.isEmpty();
    }
    
    /**
     * Check if import has warnings
     */
    public boolean hasWarnings() {
        return !warnings.isEmpty();
    }
    
    /**
     * Get success rate as percentage
     */
    public double getSuccessRate() {
        if (totalRecords == 0) return 0.0;
        return (double) successfulImports / totalRecords * 100.0;
    }
    
    /**
     * Generate import summary
     */
    public void generateSummary() {
        StringBuilder summary = new StringBuilder();
        summary.append("Import completed: ");
        summary.append(successfulImports).append(" successful, ");
        summary.append(failedImports).append(" failed, ");
        summary.append(skippedRecords).append(" skipped ");
        summary.append("out of ").append(totalRecords).append(" total records.");
        
        if (hasWarnings()) {
            summary.append(" ").append(warnings.size()).append(" warnings generated.");
        }
        
        this.importSummary = summary.toString();
    }
    
    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    @Builder
    public static class EmployeeImportError {
        private int rowNumber;
        private String field;
        private String value;
        private String errorMessage;
        
        @Override
        public String toString() {
            return String.format("Row %d, Field '%s', Value '%s': %s", 
                    rowNumber, field, value, errorMessage);
        }
    }
}
</file>

<file path="src/main/java/com/example/demo/employee/dto/EmployeeSearchCriteria.java">
package com.example.demo.employee.dto;

import com.example.demo.employee.entity.EmployeeStatus;
import com.example.demo.employee.entity.EmploymentType;
import com.example.demo.employee.entity.Gender;
import com.example.demo.employee.entity.MaritalStatus;
import com.example.demo.employee.entity.PayType;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;

/**
 * DTO for advanced employee search criteria
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class EmployeeSearchCriteria {
    
    // Basic search
    private String searchTerm; // Search in name, email, employee number
    
    // Personal information
    private String firstName;
    private String lastName;
    private String email;
    private String employeeNumber;
    private Gender gender;
    private MaritalStatus maritalStatus;
    private String nationality;
    
    // Contact information
    private String phone;
    private String city;
    private String state;
    private String country;
    
    // Employment details
    private List<Long> departmentIds;
    private List<Long> positionIds;
    private List<Long> managerIds;
    private List<EmployeeStatus> statuses;
    private List<EmploymentType> employmentTypes;
    private List<PayType> payTypes;
    
    // Date ranges
    private LocalDate hireDateFrom;
    private LocalDate hireDateTo;
    private LocalDate terminationDateFrom;
    private LocalDate terminationDateTo;
    private LocalDate dateOfBirthFrom;
    private LocalDate dateOfBirthTo;
    
    // Salary ranges
    private BigDecimal salaryFrom;
    private BigDecimal salaryTo;
    private BigDecimal hourlyRateFrom;
    private BigDecimal hourlyRateTo;
    
    // Status filters
    private Boolean enabled;
    private Boolean hasManager; // true = has manager, false = no manager, null = both
    private Boolean hasDirectReports; // true = has direct reports, false = no direct reports, null = both
    
    // Age range (calculated from date of birth)
    private Integer ageFrom;
    private Integer ageTo;
    
    // Years of service range
    private Integer yearsOfServiceFrom;
    private Integer yearsOfServiceTo;
    
    // Sorting options
    private String sortBy; // field name to sort by
    private String sortDirection; // ASC or DESC
    
    // Additional filters
    private List<String> excludeEmployeeNumbers; // Exclude specific employees
    private List<Long> includeEmployeeIds; // Include only specific employees
    
    /**
     * Check if any search criteria is specified
     */
    public boolean hasAnyCriteria() {
        return searchTerm != null || firstName != null || lastName != null || 
               email != null || employeeNumber != null || gender != null || 
               maritalStatus != null || nationality != null || phone != null || 
               city != null || state != null || country != null ||
               (departmentIds != null && !departmentIds.isEmpty()) ||
               (positionIds != null && !positionIds.isEmpty()) ||
               (managerIds != null && !managerIds.isEmpty()) ||
               (statuses != null && !statuses.isEmpty()) ||
               (employmentTypes != null && !employmentTypes.isEmpty()) ||
               (payTypes != null && !payTypes.isEmpty()) ||
               hireDateFrom != null || hireDateTo != null ||
               terminationDateFrom != null || terminationDateTo != null ||
               dateOfBirthFrom != null || dateOfBirthTo != null ||
               salaryFrom != null || salaryTo != null ||
               hourlyRateFrom != null || hourlyRateTo != null ||
               enabled != null || hasManager != null || hasDirectReports != null ||
               ageFrom != null || ageTo != null ||
               yearsOfServiceFrom != null || yearsOfServiceTo != null ||
               (excludeEmployeeNumbers != null && !excludeEmployeeNumbers.isEmpty()) ||
               (includeEmployeeIds != null && !includeEmployeeIds.isEmpty());
    }
    
    /**
     * Check if basic search term is specified
     */
    public boolean hasSearchTerm() {
        return searchTerm != null && !searchTerm.trim().isEmpty();
    }
    
    /**
     * Check if date range criteria is specified
     */
    public boolean hasDateRangeCriteria() {
        return hireDateFrom != null || hireDateTo != null ||
               terminationDateFrom != null || terminationDateTo != null ||
               dateOfBirthFrom != null || dateOfBirthTo != null;
    }
    
    /**
     * Check if salary range criteria is specified
     */
    public boolean hasSalaryRangeCriteria() {
        return salaryFrom != null || salaryTo != null ||
               hourlyRateFrom != null || hourlyRateTo != null;
    }
}
</file>

<file path="src/main/java/com/example/demo/employee/dto/EmployeeUpdateRequest.java">
package com.example.demo.employee.dto;

import com.example.demo.employee.entity.EmployeeStatus;
import com.example.demo.employee.entity.EmploymentType;
import com.example.demo.employee.entity.Gender;
import com.example.demo.employee.entity.MaritalStatus;
import com.example.demo.employee.entity.PayType;
import jakarta.validation.constraints.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDate;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class EmployeeUpdateRequest {

    @NotBlank(message = "First name is required")
    @Size(min = 2, max = 50, message = "First name must be between 2 and 50 characters")
    private String firstName;

    @NotBlank(message = "Last name is required")
    @Size(min = 2, max = 50, message = "Last name must be between 2 and 50 characters")
    private String lastName;

    @NotBlank(message = "Email is required")
    @Email(message = "Email should be valid")
    @Size(max = 100, message = "Email must not exceed 100 characters")
    private String email;

    @Pattern(regexp = "^[+]?[0-9\\s\\-\\(\\)]{7,20}$", message = "Phone number format is invalid")
    private String phone;

    @Pattern(regexp = "^[+]?[0-9\\s\\-\\(\\)]{7,20}$", message = "Mobile phone number format is invalid")
    private String mobilePhone;

    @Size(max = 255, message = "Address must not exceed 255 characters")
    private String address;

    @Size(max = 100, message = "City must not exceed 100 characters")
    private String city;

    @Size(max = 100, message = "State must not exceed 100 characters")
    private String state;

    @Size(max = 20, message = "Zip code must not exceed 20 characters")
    private String zipCode;

    @Size(max = 100, message = "Country must not exceed 100 characters")
    private String country;

    private String dateOfBirth; // Will be encrypted by service

    private Gender gender;
    
    private MaritalStatus maritalStatus;

    @Size(max = 50, message = "Nationality must not exceed 50 characters")
    private String nationality;

    @NotNull(message = "Department is required")
    private Long departmentId;

    private Long positionId;

    private Long managerId;

    @NotNull(message = "Hire date is required")
    @PastOrPresent(message = "Hire date cannot be in the future")
    private LocalDate hireDate;
    
    private LocalDate terminationDate;

    @NotNull(message = "Employee status is required")
    private EmployeeStatus status;
    
    @NotNull(message = "Employment type is required")
    private EmploymentType employmentType;

    @NotNull(message = "Pay type is required")
    private PayType payType;

    @DecimalMin(value = "0.0", inclusive = true, message = "Salary must be non-negative")
    @Digits(integer = 10, fraction = 2, message = "Salary format is invalid")
    private BigDecimal salary;

    @DecimalMin(value = "0.0", inclusive = true, message = "Hourly rate must be non-negative")
    @Digits(integer = 6, fraction = 2, message = "Hourly rate format is invalid")
    private BigDecimal hourlyRate;

    private String bankAccount; // Will be encrypted by service
    private String taxId; // Will be encrypted by service

    @NotNull(message = "Enabled status is required")
    private Boolean enabled;
}
</file>

<file path="src/main/java/com/example/demo/employee/entity/EmployeeStatus.java">
package com.example.demo.employee.entity;

public enum EmployeeStatus {
    ACTIVE("Active"),
    INACTIVE("Inactive"),
    TERMINATED("Terminated"),
    ON_LEAVE("On Leave"),
    PROBATION("Probation"),
    SUSPENDED("Suspended");
    
    private final String displayName;
    
    EmployeeStatus(String displayName) {
        this.displayName = displayName;
    }
    
    public String getDisplayName() {
        return displayName;
    }
}
</file>

<file path="src/main/java/com/example/demo/employee/entity/EmploymentType.java">
package com.example.demo.employee.entity;

public enum EmploymentType {
    FULL_TIME("Full Time"),
    PART_TIME("Part Time"),
    CONTRACT("Contract"),
    TEMPORARY("Temporary"),
    INTERN("Intern"),
    CONSULTANT("Consultant");
    
    private final String displayName;
    
    EmploymentType(String displayName) {
        this.displayName = displayName;
    }
    
    public String getDisplayName() {
        return displayName;
    }
}
</file>

<file path="src/main/java/com/example/demo/employee/entity/Gender.java">
package com.example.demo.employee.entity;

public enum Gender {
    MALE("Male"),
    FEMALE("Female"),
    OTHER("Other"),
    PREFER_NOT_TO_SAY("Prefer not to say");
    
    private final String displayName;
    
    Gender(String displayName) {
        this.displayName = displayName;
    }
    
    public String getDisplayName() {
        return displayName;
    }
}
</file>

<file path="src/main/java/com/example/demo/employee/entity/MaritalStatus.java">
package com.example.demo.employee.entity;

public enum MaritalStatus {
    SINGLE("Single"),
    MARRIED("Married"),
    DIVORCED("Divorced"),
    WIDOWED("Widowed"),
    SEPARATED("Separated"),
    DOMESTIC_PARTNERSHIP("Domestic Partnership");
    
    private final String displayName;
    
    MaritalStatus(String displayName) {
        this.displayName = displayName;
    }
    
    public String getDisplayName() {
        return displayName;
    }
}
</file>

<file path="src/main/java/com/example/demo/employee/entity/PayType.java">
package com.example.demo.employee.entity;

public enum PayType {
    SALARY("Salary"),
    HOURLY("Hourly");
    
    private final String displayName;
    
    PayType(String displayName) {
        this.displayName = displayName;
    }
    
    public String getDisplayName() {
        return displayName;
    }
}
</file>

<file path="src/main/java/com/example/demo/employee/exception/EmployeeAlreadyExistsException.java">
package com.example.demo.employee.exception;

import com.example.demo.common.exception.BusinessException;

public class EmployeeAlreadyExistsException extends BusinessException {
    
    public EmployeeAlreadyExistsException(String message) {
        super(message);
    }
    
    public static EmployeeAlreadyExistsException byEmployeeNumber(String employeeNumber) {
        return new EmployeeAlreadyExistsException("Employee already exists with employee number: " + employeeNumber);
    }
    
    public static EmployeeAlreadyExistsException byEmail(String email) {
        return new EmployeeAlreadyExistsException("Employee already exists with email: " + email);
    }
}
</file>

<file path="src/main/java/com/example/demo/employee/exception/EmployeeExportException.java">
package com.example.demo.employee.exception;

/**
 * Exception thrown when employee export operations fail
 */
public class EmployeeExportException extends RuntimeException {
    
    private final String exportFormat;
    private final int recordCount;
    
    public EmployeeExportException(String message) {
        super(message);
        this.exportFormat = null;
        this.recordCount = -1;
    }
    
    public EmployeeExportException(String message, Throwable cause) {
        super(message, cause);
        this.exportFormat = null;
        this.recordCount = -1;
    }
    
    public EmployeeExportException(String message, String exportFormat) {
        super(message);
        this.exportFormat = exportFormat;
        this.recordCount = -1;
    }
    
    public EmployeeExportException(String message, String exportFormat, int recordCount) {
        super(message);
        this.exportFormat = exportFormat;
        this.recordCount = recordCount;
    }
    
    public EmployeeExportException(String message, String exportFormat, int recordCount, Throwable cause) {
        super(message, cause);
        this.exportFormat = exportFormat;
        this.recordCount = recordCount;
    }
    
    public String getExportFormat() {
        return exportFormat;
    }
    
    public int getRecordCount() {
        return recordCount;
    }
    
    @Override
    public String getMessage() {
        StringBuilder message = new StringBuilder(super.getMessage());
        
        if (exportFormat != null) {
            message.append(" (Format: ").append(exportFormat);
            
            if (recordCount > 0) {
                message.append(", Records: ").append(recordCount);
            }
            
            message.append(")");
        }
        
        return message.toString();
    }
}
</file>

<file path="src/main/java/com/example/demo/employee/exception/EmployeeImportException.java">
package com.example.demo.employee.exception;

/**
 * Exception thrown when employee import operations fail
 */
public class EmployeeImportException extends RuntimeException {
    
    private final String fileName;
    private final int rowNumber;
    private final String field;
    
    public EmployeeImportException(String message) {
        super(message);
        this.fileName = null;
        this.rowNumber = -1;
        this.field = null;
    }
    
    public EmployeeImportException(String message, Throwable cause) {
        super(message, cause);
        this.fileName = null;
        this.rowNumber = -1;
        this.field = null;
    }
    
    public EmployeeImportException(String message, String fileName) {
        super(message);
        this.fileName = fileName;
        this.rowNumber = -1;
        this.field = null;
    }
    
    public EmployeeImportException(String message, String fileName, int rowNumber) {
        super(message);
        this.fileName = fileName;
        this.rowNumber = rowNumber;
        this.field = null;
    }
    
    public EmployeeImportException(String message, String fileName, int rowNumber, String field) {
        super(message);
        this.fileName = fileName;
        this.rowNumber = rowNumber;
        this.field = field;
    }
    
    public EmployeeImportException(String message, String fileName, int rowNumber, String field, Throwable cause) {
        super(message, cause);
        this.fileName = fileName;
        this.rowNumber = rowNumber;
        this.field = field;
    }
    
    public String getFileName() {
        return fileName;
    }
    
    public int getRowNumber() {
        return rowNumber;
    }
    
    public String getField() {
        return field;
    }
    
    @Override
    public String getMessage() {
        StringBuilder message = new StringBuilder(super.getMessage());
        
        if (fileName != null) {
            message.append(" (File: ").append(fileName);
            
            if (rowNumber > 0) {
                message.append(", Row: ").append(rowNumber);
            }
            
            if (field != null) {
                message.append(", Field: ").append(field);
            }
            
            message.append(")");
        }
        
        return message.toString();
    }
}
</file>

<file path="src/main/java/com/example/demo/employee/exception/EmployeeNotFoundException.java">
package com.example.demo.employee.exception;

import com.example.demo.common.exception.BusinessException;

public class EmployeeNotFoundException extends BusinessException {
    
    public EmployeeNotFoundException(String message) {
        super(message);
    }
    
    public EmployeeNotFoundException(Long id) {
        super("Employee not found with id: " + id);
    }
    
    public static EmployeeNotFoundException byEmployeeNumber(String employeeNumber) {
        return new EmployeeNotFoundException("Employee not found with employee number: " + employeeNumber);
    }
    
    public static EmployeeNotFoundException byEmail(String email) {
        return new EmployeeNotFoundException("Employee not found with email: " + email);
    }
}
</file>

<file path="src/main/java/com/example/demo/employee/repository/EmployeeRepository.java">
package com.example.demo.employee.repository;

import com.example.demo.employee.entity.Employee;
import com.example.demo.employee.entity.EmployeeStatus;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

@Repository
public interface EmployeeRepository extends JpaRepository<Employee, Long> {
    
    /**
     * Find employee by employee number
     */
    Optional<Employee> findByEmployeeNumber(String employeeNumber);
    
    /**
     * Find employee by email
     */
    Optional<Employee> findByEmail(String email);
    
    /**
     * Find employees by department ID
     */
    Page<Employee> findByDepartmentId(Long departmentId, Pageable pageable);
    
    /**
     * Find employees by department ID (list version)
     */
    List<Employee> findByDepartmentId(Long departmentId);
    
    /**
     * Find employees by position ID
     */
    Page<Employee> findByPositionId(Long positionId, Pageable pageable);
    
    /**
     * Find employees by manager ID
     */
    Page<Employee> findByManagerId(Long managerId, Pageable pageable);
    
    /**
     * Find employees by status
     */
    Page<Employee> findByStatus(EmployeeStatus status, Pageable pageable);
    
    /**
     * Find employees by hire date range
     */
    Page<Employee> findByHireDateBetween(LocalDate startDate, LocalDate endDate, Pageable pageable);
    
    /**
     * Find employees by first name containing (case insensitive)
     */
    Page<Employee> findByFirstNameContainingIgnoreCase(String firstName, Pageable pageable);
    
    /**
     * Find employees by last name containing (case insensitive)
     */
    Page<Employee> findByLastNameContainingIgnoreCase(String lastName, Pageable pageable);
    
    /**
     * Find employees by first name or last name containing (case insensitive)
     */
    Page<Employee> findByFirstNameContainingIgnoreCaseOrLastNameContainingIgnoreCase(
        String firstName, String lastName, Pageable pageable);
    
    /**
     * Find employees by email containing (case insensitive)
     */
    Page<Employee> findByEmailContainingIgnoreCase(String email, Pageable pageable);
    
    /**
     * Find enabled employees
     */
    Page<Employee> findByEnabledTrue(Pageable pageable);
    
    /**
     * Check if employee number exists
     */
    boolean existsByEmployeeNumber(String employeeNumber);
    
    /**
     * Check if email exists
     */
    boolean existsByEmail(String email);
    
    /**
     * Count employees by department ID
     */
    long countByDepartmentId(Long departmentId);
    
    /**
     * Count employees by position ID
     */
    long countByPositionId(Long positionId);
    
    /**
     * Count employees by status
     */
    long countByStatus(EmployeeStatus status);
    
    /**
     * Find employees by IDs
     */
    List<Employee> findByIdIn(List<Long> ids);
    
    /**
     * Search employees by name (first or last name)
     */
    @Query("SELECT e FROM Employee e WHERE " +
           "LOWER(CONCAT(e.firstName, ' ', e.lastName)) LIKE LOWER(CONCAT('%', :searchTerm, '%')) OR " +
           "LOWER(e.firstName) LIKE LOWER(CONCAT('%', :searchTerm, '%')) OR " +
           "LOWER(e.lastName) LIKE LOWER(CONCAT('%', :searchTerm, '%')) OR " +
           "LOWER(e.email) LIKE LOWER(CONCAT('%', :searchTerm, '%')) OR " +
           "LOWER(e.employeeNumber) LIKE LOWER(CONCAT('%', :searchTerm, '%'))")
    Page<Employee> searchEmployees(@Param("searchTerm") String searchTerm, Pageable pageable);
}
</file>

<file path="src/main/java/com/example/demo/employee/service/EmployeeExportService.java">
package com.example.demo.employee.service;

import com.example.demo.employee.dto.EmployeeExportRequest;
import com.example.demo.employee.dto.EmployeeSearchCriteria;

import java.io.ByteArrayOutputStream;
import java.util.List;
import java.util.Map;

/**
 * Service interface for employee export operations
 */
public interface EmployeeExportService {
    
    /**
     * Export employees to Excel format
     * @param request Export request with criteria and options
     * @return Excel file as byte array
     */
    byte[] exportToExcel(EmployeeExportRequest request);
    
    /**
     * Export employees to CSV format
     * @param request Export request with criteria and options
     * @return CSV file as byte array
     */
    byte[] exportToCsv(EmployeeExportRequest request);
    
    /**
     * Export employees to PDF format
     * @param request Export request with criteria and options
     * @return PDF file as byte array
     */
    byte[] exportToPdf(EmployeeExportRequest request);
    
    /**
     * Export employees based on search criteria
     * @param criteria Search criteria to filter employees
     * @param request Export request with format and options
     * @return Exported file as byte array
     */
    byte[] exportEmployees(EmployeeSearchCriteria criteria, EmployeeExportRequest request);
    
    /**
     * Export specific employees by IDs
     * @param employeeIds List of employee IDs to export
     * @param request Export request with format and options
     * @return Exported file as byte array
     */
    byte[] exportEmployeesByIds(List<Long> employeeIds, EmployeeExportRequest request);
    
    /**
     * Export employees to output stream
     * @param request Export request with criteria and options
     * @param outputStream Output stream to write to
     */
    void exportToStream(EmployeeExportRequest request, ByteArrayOutputStream outputStream);
    
    /**
     * Get export statistics
     * @param criteria Search criteria to filter employees
     * @return Map with export statistics
     */
    Map<String, Object> getExportStatistics(EmployeeSearchCriteria criteria);
    
    /**
     * Validate export request
     * @param request Export request to validate
     * @return List of validation errors, empty if valid
     */
    List<String> validateExportRequest(EmployeeExportRequest request);
    
    /**
     * Get supported export formats
     * @return List of supported export formats
     */
    List<EmployeeExportRequest.ExportFormat> getSupportedFormats();
    
    /**
     * Get maximum number of records allowed per export
     * @return Maximum record count
     */
    int getMaxExportRecords();
    
    /**
     * Check if user has permission to export sensitive data
     * @param userId User ID requesting export
     * @return true if user can export sensitive data
     */
    boolean canExportSensitiveData(Long userId);
    
    /**
     * Generate export filename
     * @param request Export request
     * @return Generated filename with extension
     */
    String generateExportFilename(EmployeeExportRequest request);
    
    /**
     * Get export template for specific format
     * @param format Export format
     * @return Template as byte array
     */
    byte[] getExportTemplate(EmployeeExportRequest.ExportFormat format);
}
</file>

<file path="src/main/java/com/example/demo/employee/service/EmployeeImportService.java">
package com.example.demo.employee.service;

import com.example.demo.employee.dto.EmployeeImportResult;
import org.springframework.web.multipart.MultipartFile;

import java.io.InputStream;
import java.util.List;
import java.util.Map;

/**
 * Service interface for employee import operations
 */
public interface EmployeeImportService {
    
    /**
     * Import employees from Excel file
     * @param file Excel file containing employee data
     * @param options Import options and configurations
     * @return Import result with success/failure details
     */
    EmployeeImportResult importFromExcel(MultipartFile file, Map<String, Object> options);
    
    /**
     * Import employees from Excel input stream
     * @param inputStream Excel file input stream
     * @param fileName Original file name
     * @param options Import options and configurations
     * @return Import result with success/failure details
     */
    EmployeeImportResult importFromExcel(InputStream inputStream, String fileName, Map<String, Object> options);
    
    /**
     * Import employees from CSV file
     * @param file CSV file containing employee data
     * @param options Import options and configurations
     * @return Import result with success/failure details
     */
    EmployeeImportResult importFromCsv(MultipartFile file, Map<String, Object> options);
    
    /**
     * Import employees from CSV input stream
     * @param inputStream CSV file input stream
     * @param fileName Original file name
     * @param options Import options and configurations
     * @return Import result with success/failure details
     */
    EmployeeImportResult importFromCsv(InputStream inputStream, String fileName, Map<String, Object> options);
    
    /**
     * Validate import file format and structure
     * @param file File to validate
     * @return Validation result with errors if any
     */
    EmployeeImportResult validateImportFile(MultipartFile file);
    
    /**
     * Get import template as Excel file
     * @param includeExamples Whether to include example data
     * @return Excel template as byte array
     */
    byte[] getImportTemplate(boolean includeExamples);
    
    /**
     * Get supported file formats for import
     * @return List of supported file extensions
     */
    List<String> getSupportedFormats();
    
    /**
     * Get maximum file size allowed for import
     * @return Maximum file size in bytes
     */
    long getMaxFileSize();
    
    /**
     * Get maximum number of records allowed per import
     * @return Maximum record count
     */
    int getMaxRecordCount();
    
    /**
     * Preview import data without actually importing
     * @param file File to preview
     * @param maxRows Maximum rows to preview
     * @return Preview of import data
     */
    EmployeeImportResult previewImport(MultipartFile file, int maxRows);
    
    /**
     * Get field mapping for import columns
     * @return Map of column names to entity field names
     */
    Map<String, String> getFieldMapping();
    
    /**
     * Get required fields for import
     * @return List of required field names
     */
    List<String> getRequiredFields();
    
    /**
     * Get optional fields for import
     * @return List of optional field names
     */
    List<String> getOptionalFields();
}
</file>

<file path="src/main/java/com/example/demo/employee/util/EmployeeValidationUtil.java">
package com.example.demo.employee.util;

import com.example.demo.employee.dto.EmployeeCreateRequest;
import com.example.demo.employee.dto.EmployeeUpdateRequest;
import com.example.demo.employee.entity.Employee;
import com.example.demo.employee.entity.EmployeeStatus;
import com.example.demo.employee.entity.PayType;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.Period;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;

/**
 * Utility class for employee data validation
 */
public class EmployeeValidationUtil {
    
    // Regex patterns for validation
    private static final Pattern EMAIL_PATTERN = Pattern.compile(
        "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$"
    );
    
    private static final Pattern PHONE_PATTERN = Pattern.compile(
        "^[+]?[0-9\\s\\-\\(\\)]{7,20}$"
    );
    
    private static final Pattern EMPLOYEE_NUMBER_PATTERN = Pattern.compile(
        "^[A-Z0-9\\-]{3,20}$"
    );
    
    private static final Pattern NAME_PATTERN = Pattern.compile(
        "^[a-zA-Z\\s\\-\\.]{2,50}$"
    );
    
    // Constants
    private static final int MIN_AGE = 16;
    private static final int MAX_AGE = 100;
    private static final int MIN_NAME_LENGTH = 2;
    private static final int MAX_NAME_LENGTH = 50;
    private static final BigDecimal MIN_SALARY = new BigDecimal("0.01");
    private static final BigDecimal MAX_SALARY = new BigDecimal("10000000.00");
    private static final BigDecimal MIN_HOURLY_RATE = new BigDecimal("0.01");
    private static final BigDecimal MAX_HOURLY_RATE = new BigDecimal("1000.00");
    
    /**
     * Validate employee create request
     */
    public static List<String> validateCreateRequest(EmployeeCreateRequest request) {
        List<String> errors = new ArrayList<>();
        
        // Validate required fields
        if (request.getFirstName() == null || request.getFirstName().trim().isEmpty()) {
            errors.add("First name is required");
        } else if (!isValidName(request.getFirstName())) {
            errors.add("First name contains invalid characters or is too long/short");
        }
        
        if (request.getLastName() == null || request.getLastName().trim().isEmpty()) {
            errors.add("Last name is required");
        } else if (!isValidName(request.getLastName())) {
            errors.add("Last name contains invalid characters or is too long/short");
        }
        
        if (request.getEmail() == null || request.getEmail().trim().isEmpty()) {
            errors.add("Email is required");
        } else if (!isValidEmail(request.getEmail())) {
            errors.add("Email format is invalid");
        }
        
        if (request.getDepartmentId() == null) {
            errors.add("Department is required");
        }
        
        if (request.getPositionId() == null) {
            errors.add("Position is required");
        }
        
        if (request.getHireDate() == null) {
            errors.add("Hire date is required");
        } else if (request.getHireDate().isAfter(LocalDate.now())) {
            errors.add("Hire date cannot be in the future");
        }
        
        if (request.getStatus() == null) {
            errors.add("Employee status is required");
        }
        
        if (request.getPayType() == null) {
            errors.add("Pay type is required");
        }
        
        // Validate optional fields
        validateOptionalFields(request.getPhone(), request.getMobilePhone(), 
                             request.getDateOfBirth(), request.getSalary(), 
                             request.getHourlyRate(), request.getPayType(), errors);
        
        return errors;
    }
    
    /**
     * Validate employee update request
     */
    public static List<String> validateUpdateRequest(EmployeeUpdateRequest request) {
        List<String> errors = new ArrayList<>();
        
        // Validate required fields (all fields in update request should be non-null if provided)
        if (request.getFirstName() != null && !isValidName(request.getFirstName())) {
            errors.add("First name contains invalid characters or is too long/short");
        }
        
        if (request.getLastName() != null && !isValidName(request.getLastName())) {
            errors.add("Last name contains invalid characters or is too long/short");
        }
        
        if (request.getEmail() != null && !isValidEmail(request.getEmail())) {
            errors.add("Email format is invalid");
        }
        
        if (request.getHireDate() != null && request.getHireDate().isAfter(LocalDate.now())) {
            errors.add("Hire date cannot be in the future");
        }
        
        // Validate termination date
        if (request.getTerminationDate() != null && request.getHireDate() != null) {
            if (request.getTerminationDate().isBefore(request.getHireDate())) {
                errors.add("Termination date cannot be before hire date");
            }
        }
        
        // Validate status consistency
        if (request.getStatus() == EmployeeStatus.TERMINATED && request.getTerminationDate() == null) {
            errors.add("Termination date is required when status is TERMINATED");
        }
        
        if (request.getStatus() != EmployeeStatus.TERMINATED && request.getTerminationDate() != null) {
            errors.add("Termination date should only be set when status is TERMINATED");
        }
        
        // Validate optional fields
        validateOptionalFields(request.getPhone(), request.getMobilePhone(), 
                             request.getDateOfBirth(), request.getSalary(), 
                             request.getHourlyRate(), null, errors);
        
        return errors;
    }
    
    /**
     * Validate employee entity
     */
    public static List<String> validateEmployee(Employee employee) {
        List<String> errors = new ArrayList<>();
        
        if (employee == null) {
            errors.add("Employee cannot be null");
            return errors;
        }
        
        // Validate business rules
        if (employee.getManagerId() != null && employee.getManagerId().equals(employee.getId())) {
            errors.add("Employee cannot be their own manager");
        }
        
        if (employee.getStatus() == EmployeeStatus.TERMINATED && employee.getTerminationDate() == null) {
            errors.add("Terminated employee must have termination date");
        }
        
        if (employee.getPayType() == PayType.SALARY && employee.getSalary() == null) {
            errors.add("Salaried employee must have salary amount");
        }
        
        if (employee.getPayType() == PayType.HOURLY && employee.getHourlyRate() == null) {
            errors.add("Hourly employee must have hourly rate");
        }
        
        return errors;
    }
    
    /**
     * Validate email format
     */
    public static boolean isValidEmail(String email) {
        return email != null && EMAIL_PATTERN.matcher(email.trim()).matches();
    }
    
    /**
     * Validate phone number format
     */
    public static boolean isValidPhone(String phone) {
        return phone == null || phone.trim().isEmpty() || PHONE_PATTERN.matcher(phone.trim()).matches();
    }
    
    /**
     * Validate employee number format
     */
    public static boolean isValidEmployeeNumber(String employeeNumber) {
        return employeeNumber != null && EMPLOYEE_NUMBER_PATTERN.matcher(employeeNumber.trim()).matches();
    }
    
    /**
     * Validate name format
     */
    public static boolean isValidName(String name) {
        if (name == null || name.trim().isEmpty()) {
            return false;
        }
        String trimmed = name.trim();
        return trimmed.length() >= MIN_NAME_LENGTH && 
               trimmed.length() <= MAX_NAME_LENGTH && 
               NAME_PATTERN.matcher(trimmed).matches();
    }
    
    /**
     * Validate date of birth
     */
    public static boolean isValidDateOfBirth(String dateOfBirth) {
        if (dateOfBirth == null || dateOfBirth.trim().isEmpty()) {
            return true; // Optional field
        }
        
        try {
            LocalDate birthDate = LocalDate.parse(dateOfBirth);
            LocalDate now = LocalDate.now();
            
            if (birthDate.isAfter(now)) {
                return false; // Cannot be in the future
            }
            
            int age = Period.between(birthDate, now).getYears();
            return age >= MIN_AGE && age <= MAX_AGE;
        } catch (Exception e) {
            return false;
        }
    }
    
    /**
     * Validate salary amount
     */
    public static boolean isValidSalary(BigDecimal salary) {
        return salary == null || 
               (salary.compareTo(MIN_SALARY) >= 0 && salary.compareTo(MAX_SALARY) <= 0);
    }
    
    /**
     * Validate hourly rate
     */
    public static boolean isValidHourlyRate(BigDecimal hourlyRate) {
        return hourlyRate == null || 
               (hourlyRate.compareTo(MIN_HOURLY_RATE) >= 0 && hourlyRate.compareTo(MAX_HOURLY_RATE) <= 0);
    }
    
    /**
     * Check if employee can be deleted
     */
    public static boolean canDeleteEmployee(Employee employee) {
        if (employee == null) {
            return false;
        }
        
        // Cannot delete if employee has direct reports
        return employee.getDirectReports() == null || employee.getDirectReports().isEmpty();
    }
    
    /**
     * Validate manager assignment
     */
    public static boolean isValidManagerAssignment(Long employeeId, Long managerId) {
        if (managerId == null) {
            return true; // No manager is valid (e.g., CEO)
        }
        
        return !managerId.equals(employeeId); // Cannot be self-manager
    }
    
    /**
     * Validate optional fields helper method
     */
    private static void validateOptionalFields(String phone, String mobilePhone, String dateOfBirth, 
                                             BigDecimal salary, BigDecimal hourlyRate, PayType payType, 
                                             List<String> errors) {
        if (!isValidPhone(phone)) {
            errors.add("Phone number format is invalid");
        }
        
        if (!isValidPhone(mobilePhone)) {
            errors.add("Mobile phone number format is invalid");
        }
        
        if (!isValidDateOfBirth(dateOfBirth)) {
            errors.add("Date of birth is invalid or employee age is outside allowed range");
        }
        
        if (!isValidSalary(salary)) {
            errors.add("Salary amount is outside allowed range");
        }
        
        if (!isValidHourlyRate(hourlyRate)) {
            errors.add("Hourly rate is outside allowed range");
        }
        
        // Validate pay type consistency
        if (payType == PayType.SALARY && salary == null) {
            errors.add("Salary is required for salaried employees");
        }
        
        if (payType == PayType.HOURLY && hourlyRate == null) {
            errors.add("Hourly rate is required for hourly employees");
        }
    }
}
</file>

<file path="src/main/java/com/example/demo/payroll/dto/PayrollCalculationRequest.java">
package com.example.demo.payroll.dto;

import jakarta.validation.Valid;
import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class PayrollCalculationRequest {
    @NotNull(message = "Employee ID is required")
    private Long employeeId;
    
    @NotNull(message = "Payroll period ID is required")
    private Long payrollPeriodId;
    
    @NotNull(message = "Base salary is required")
    @DecimalMin(value = "0.0", message = "Base salary must be non-negative")
    private BigDecimal baseSalary;
    
    @DecimalMin(value = "0.0", message = "Overtime hours must be non-negative")
    private BigDecimal overtimeHours;
    
    @DecimalMin(value = "0.0", message = "Bonus amount must be non-negative")
    private BigDecimal bonusAmount;
    
    @Valid
    private List<ComponentOverride> componentOverrides;
    
    private String notes;
    
    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class ComponentOverride {
        @NotNull(message = "Salary component ID is required")
        private Long salaryComponentId;
        
        @NotNull(message = "Override amount is required")
        @DecimalMin(value = "0.0", message = "Override amount must be non-negative")
        private BigDecimal amount;
        
        private String reason;
    }
}
</file>

<file path="src/main/java/com/example/demo/payroll/dto/PayrollLedgerComponentDto.java">
package com.example.demo.payroll.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class PayrollLedgerComponentDto {
    private Long id;
    private Long payrollLedgerId;
    private Long salaryComponentId;
    private String componentName;
    private String componentType;
    private BigDecimal amount;
    private BigDecimal calculationBase;
    private BigDecimal percentageApplied;
    private String notes;
}
</file>

<file path="src/main/java/com/example/demo/payroll/dto/PayrollReportRequest.java">
package com.example.demo.payroll.dto;

import com.example.demo.payroll.entity.PayrollLedgerStatus;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDate;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class PayrollReportRequest {
    private Long payrollPeriodId;
    private List<Long> employeeIds;
    private List<Long> departmentIds;
    private PayrollLedgerStatus status;
    private LocalDate startDate;
    private LocalDate endDate;
    private String reportType; // SUMMARY, DETAILED, TAX_REPORT, DEPARTMENT_SUMMARY
    private String format; // PDF, EXCEL, CSV
}
</file>

<file path="src/main/java/com/example/demo/payroll/dto/PayrollSummaryDto.java">
package com.example.demo.payroll.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class PayrollSummaryDto {
    private Long payrollPeriodId;
    private String periodName;
    private Long totalEmployees;
    private Long processedEmployees;
    private Long pendingEmployees;
    private Long approvedEmployees;
    private Long paidEmployees;
    private BigDecimal totalGrossPay;
    private BigDecimal totalDeductions;
    private BigDecimal totalTaxes;
    private BigDecimal totalNetPay;
    private BigDecimal averageNetPay;
    private BigDecimal totalOvertimePay;
    private BigDecimal totalBonuses;
}
</file>

<file path="src/main/java/com/example/demo/payroll/dto/SalaryComponentDto.java">
package com.example.demo.payroll.dto;

import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class SalaryComponentDto {
    private Long id;
    
    @NotBlank(message = "Component name is required")
    private String componentName;
    
    @NotBlank(message = "Component type is required")
    private String componentType;
    
    @DecimalMin(value = "0.0", message = "Amount must be non-negative")
    private BigDecimal amount;
    
    @DecimalMin(value = "0.0", message = "Percentage must be non-negative")
    private BigDecimal percentage;
    
    private Boolean isTaxable;
    private Boolean isMandatory;
    private Integer calculationOrder;
    private String description;
    private Boolean isActive;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
</file>

<file path="src/main/java/com/example/demo/payroll/entity/PaymentMethod.java">
package com.example.demo.payroll.entity;

public enum PaymentMethod {
    BANK_TRANSFER,
    CHECK,
    CASH,
    OTHER
}
</file>

<file path="src/main/java/com/example/demo/payroll/entity/PayrollAudit.java">
package com.example.demo.payroll.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;

@Entity
@Table(name = "payroll_audits", indexes = {
    @Index(name = "idx_payroll_audit_ledger_id", columnList = "payroll_ledger_id"),
    @Index(name = "idx_payroll_audit_action", columnList = "action"),
    @Index(name = "idx_payroll_audit_created_at", columnList = "created_at")
})
@Data
@NoArgsConstructor
@AllArgsConstructor
@EntityListeners(AuditingEntityListener.class)
public class PayrollAudit {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @NotNull
    @Column(name = "payroll_ledger_id", nullable = false)
    private Long payrollLedgerId;
    
    @NotNull
    @Column(name = "action", nullable = false, length = 50)
    private String action; // CREATED, CALCULATED, APPROVED, PAID, REJECTED, CANCELLED
    
    @Column(name = "old_status", length = 50)
    private String oldStatus;
    
    @Column(name = "new_status", length = 50)
    private String newStatus;
    
    @Column(name = "changes", columnDefinition = "TEXT")
    private String changes; // JSON string of changes
    
    @Column(name = "reason", length = 500)
    private String reason;
    
    @NotNull
    @Column(name = "performed_by", nullable = false)
    private Long performedBy;
    
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;
    
    // Relationships
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "payroll_ledger_id", insertable = false, updatable = false)
    private PayrollLedger payrollLedger;
}
</file>

<file path="src/main/java/com/example/demo/payroll/entity/PayrollLedger.java">
package com.example.demo.payroll.entity;

import com.example.demo.employee.entity.Employee;
import jakarta.persistence.*;
import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "payroll_ledgers", indexes = {
    @Index(name = "idx_payroll_employee_id", columnList = "employee_id"),
    @Index(name = "idx_payroll_period_id", columnList = "payroll_period_id"),
    @Index(name = "idx_payroll_status", columnList = "status"),
    @Index(name = "idx_payroll_pay_date", columnList = "pay_date")
})
@Data
@NoArgsConstructor
@AllArgsConstructor
@EntityListeners(AuditingEntityListener.class)
public class PayrollLedger {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @NotNull
    @Column(name = "employee_id", nullable = false)
    private Long employeeId;
    
    @NotNull
    @Column(name = "payroll_period_id", nullable = false)
    private Long payrollPeriodId;
    
    @NotNull
    @DecimalMin(value = "0.0", inclusive = true)
    @Column(name = "base_salary", nullable = false, precision = 15, scale = 2)
    private BigDecimal baseSalary;
    
    @DecimalMin(value = "0.0", inclusive = true)
    @Column(name = "gross_pay", precision = 15, scale = 2)
    private BigDecimal grossPay = BigDecimal.ZERO;
    
    @DecimalMin(value = "0.0", inclusive = true)
    @Column(name = "total_deductions", precision = 15, scale = 2)
    private BigDecimal totalDeductions = BigDecimal.ZERO;
    
    @DecimalMin(value = "0.0", inclusive = true)
    @Column(name = "total_taxes", precision = 15, scale = 2)
    private BigDecimal totalTaxes = BigDecimal.ZERO;
    
    @DecimalMin(value = "0.0", inclusive = true)
    @Column(name = "net_pay", precision = 15, scale = 2)
    private BigDecimal netPay = BigDecimal.ZERO;
    
    @Column(name = "overtime_hours", precision = 8, scale = 2)
    private BigDecimal overtimeHours = BigDecimal.ZERO;
    
    @Column(name = "overtime_pay", precision = 15, scale = 2)
    private BigDecimal overtimePay = BigDecimal.ZERO;
    
    @Column(name = "bonus_amount", precision = 15, scale = 2)
    private BigDecimal bonusAmount = BigDecimal.ZERO;
    
    @NotNull
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false)
    private PayrollLedgerStatus status = PayrollLedgerStatus.PENDING;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "payment_method")
    private PaymentMethod paymentMethod;
    
    @Column(name = "pay_date")
    private LocalDate payDate;
    
    @Column(name = "payment_reference", length = 100)
    private String paymentReference;
    
    @Column(name = "notes", length = 1000)
    private String notes;
    
    @Column(name = "approved_by")
    private Long approvedBy;
    
    @Column(name = "approved_at")
    private LocalDateTime approvedAt;
    
    @Column(name = "paid_by")
    private Long paidBy;
    
    @Column(name = "paid_at")
    private LocalDateTime paidAt;
    
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;
    
    @LastModifiedDate
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    @Column(name = "created_by")
    private Long createdBy;
    
    @Column(name = "updated_by")
    private Long updatedBy;
    
    // Relationships
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "employee_id", insertable = false, updatable = false)
    private Employee employee;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "payroll_period_id", insertable = false, updatable = false)
    private PayrollPeriod payrollPeriod;
    
    @OneToMany(mappedBy = "payrollLedgerId", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<PayrollLedgerComponent> components = new ArrayList<>();
    
    // Helper methods
    public void calculateTotals() {
        this.grossPay = this.baseSalary.add(this.overtimePay).add(this.bonusAmount);
        this.netPay = this.grossPay.subtract(this.totalDeductions).subtract(this.totalTaxes);
    }
    
    public boolean isProcessed() {
        return this.status == PayrollLedgerStatus.CALCULATED || 
               this.status == PayrollLedgerStatus.APPROVED || 
               this.status == PayrollLedgerStatus.PAID;
    }
}
</file>

<file path="src/main/java/com/example/demo/payroll/entity/PayrollLedgerComponent.java">
package com.example.demo.payroll.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.math.BigDecimal;
import java.time.LocalDateTime;

@Entity
@Table(name = "payroll_ledger_components", indexes = {
    @Index(name = "idx_payroll_ledger_component_ledger_id", columnList = "payroll_ledger_id"),
    @Index(name = "idx_payroll_ledger_component_salary_component_id", columnList = "salary_component_id")
})
@Data
@NoArgsConstructor
@AllArgsConstructor
@EntityListeners(AuditingEntityListener.class)
public class PayrollLedgerComponent {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @NotNull
    @Column(name = "payroll_ledger_id", nullable = false)
    private Long payrollLedgerId;
    
    @NotNull
    @Column(name = "salary_component_id", nullable = false)
    private Long salaryComponentId;
    
    @NotNull
    @DecimalMin(value = "0.0", inclusive = true)
    @Column(name = "amount", nullable = false, precision = 15, scale = 2)
    private BigDecimal amount;
    
    @Column(name = "calculation_base", precision = 15, scale = 2)
    private BigDecimal calculationBase;
    
    @Column(name = "percentage_applied", precision = 5, scale = 2)
    private BigDecimal percentageApplied;
    
    @Column(name = "notes", length = 500)
    private String notes;
    
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;
    
    // Relationships
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "payroll_ledger_id", insertable = false, updatable = false)
    private PayrollLedger payrollLedger;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "salary_component_id", insertable = false, updatable = false)
    private SalaryComponent salaryComponent;
}
</file>

<file path="src/main/java/com/example/demo/payroll/entity/PayrollLedgerStatus.java">
package com.example.demo.payroll.entity;

public enum PayrollLedgerStatus {
    PENDING,
    CALCULATED,
    APPROVED,
    PAID,
    REJECTED,
    CANCELLED
}
</file>

<file path="src/main/java/com/example/demo/payroll/entity/PayrollPeriod.java">
package com.example.demo.payroll.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDate;
import java.time.LocalDateTime;

@Entity
@Table(name = "payroll_periods")
@Data
@NoArgsConstructor
@AllArgsConstructor
@EntityListeners(AuditingEntityListener.class)
public class PayrollPeriod {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @NotNull
    @Column(name = "period_name", nullable = false, length = 100)
    private String periodName;
    
    @NotNull
    @Column(name = "start_date", nullable = false)
    private LocalDate startDate;
    
    @NotNull
    @Column(name = "end_date", nullable = false)
    private LocalDate endDate;
    
    @NotNull
    @Enumerated(EnumType.STRING)
    @Column(name = "period_type", nullable = false)
    private PayrollPeriodType periodType;
    
    @NotNull
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false)
    private PayrollPeriodStatus status = PayrollPeriodStatus.OPEN;
    
    @Column(name = "pay_date")
    private LocalDate payDate;
    
    @Column(name = "description", length = 500)
    private String description;
    
    @Column(name = "is_active", nullable = false)
    private Boolean isActive = true;
    
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;
    
    @LastModifiedDate
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
}
</file>

<file path="src/main/java/com/example/demo/payroll/entity/PayrollPeriodStatus.java">
package com.example.demo.payroll.entity;

public enum PayrollPeriodStatus {
    OPEN,
    CLOSED,
    PROCESSING,
    COMPLETED
}
</file>

<file path="src/main/java/com/example/demo/payroll/entity/PayrollPeriodType.java">
package com.example.demo.payroll.entity;

public enum PayrollPeriodType {
    MONTHLY,
    BI_WEEKLY,
    WEEKLY,
    CUSTOM
}
</file>

<file path="src/main/java/com/example/demo/payroll/entity/SalaryComponent.java">
package com.example.demo.payroll.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.math.BigDecimal;
import java.time.LocalDateTime;

@Entity
@Table(name = "salary_components")
@Data
@NoArgsConstructor
@AllArgsConstructor
@EntityListeners(AuditingEntityListener.class)
public class SalaryComponent {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @NotNull
    @Column(name = "component_name", nullable = false, length = 100)
    private String componentName;
    
    @NotNull
    @Column(name = "component_type", nullable = false, length = 50)
    private String componentType; // EARNING, DEDUCTION, TAX
    
    @NotNull
    @DecimalMin(value = "0.0", inclusive = true)
    @Column(name = "amount", nullable = false, precision = 15, scale = 2)
    private BigDecimal amount;
    
    @Column(name = "percentage", precision = 5, scale = 2)
    private BigDecimal percentage;
    
    @Column(name = "is_taxable", nullable = false)
    private Boolean isTaxable = false;
    
    @Column(name = "is_mandatory", nullable = false)
    private Boolean isMandatory = false;
    
    @Column(name = "calculation_order", nullable = false)
    private Integer calculationOrder = 0;
    
    @Column(name = "description", length = 500)
    private String description;
    
    @Column(name = "is_active", nullable = false)
    private Boolean isActive = true;
    
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;
    
    @LastModifiedDate
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
}
</file>

<file path="src/main/java/com/example/demo/payroll/exception/PayrollCalculationException.java">
package com.example.demo.payroll.exception;

import com.example.demo.common.exception.BusinessException;

public class PayrollCalculationException extends BusinessException {
    public PayrollCalculationException(String message) {
        super(message);
    }
    
    public PayrollCalculationException(String message, Throwable cause) {
        super(message, cause);
    }
}
</file>

<file path="src/main/java/com/example/demo/payroll/exception/PayrollNotFoundException.java">
package com.example.demo.payroll.exception;

import com.example.demo.common.exception.BusinessException;

public class PayrollNotFoundException extends BusinessException {
    public PayrollNotFoundException(String message) {
        super(message);
    }
    
    public PayrollNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }
}
</file>

<file path="src/main/java/com/example/demo/payroll/exception/PayrollPeriodException.java">
package com.example.demo.payroll.exception;

import com.example.demo.common.exception.BusinessException;

public class PayrollPeriodException extends BusinessException {
    public PayrollPeriodException(String message) {
        super(message);
    }
    
    public PayrollPeriodException(String message, Throwable cause) {
        super(message, cause);
    }
}
</file>

<file path="src/main/java/com/example/demo/payroll/exception/PayrollValidationException.java">
package com.example.demo.payroll.exception;

import com.example.demo.common.exception.ValidationException;

public class PayrollValidationException extends ValidationException {
    public PayrollValidationException(String message) {
        super(message);
    }
    
    public PayrollValidationException(String message, Throwable cause) {
        super(message, cause);
    }
}
</file>

<file path="src/main/java/com/example/demo/payroll/repository/PayrollAuditRepository.java">
package com.example.demo.payroll.repository;

import com.example.demo.payroll.entity.PayrollAudit;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;

@Repository
public interface PayrollAuditRepository extends JpaRepository<PayrollAudit, Long> {
    
    List<PayrollAudit> findByPayrollLedgerId(Long payrollLedgerId);
    
    Page<PayrollAudit> findByPayrollLedgerIdOrderByCreatedAtDesc(Long payrollLedgerId, Pageable pageable);
    
    List<PayrollAudit> findByAction(String action);
    
    List<PayrollAudit> findByPerformedBy(Long performedBy);
    
    @Query("SELECT pa FROM PayrollAudit pa WHERE pa.createdAt BETWEEN :startDate AND :endDate ORDER BY pa.createdAt DESC")
    List<PayrollAudit> findByCreatedAtBetween(@Param("startDate") LocalDateTime startDate, 
                                            @Param("endDate") LocalDateTime endDate);
    
    @Query("SELECT pa FROM PayrollAudit pa WHERE pa.payrollLedgerId = :ledgerId AND pa.action = :action ORDER BY pa.createdAt DESC")
    List<PayrollAudit> findByPayrollLedgerIdAndAction(@Param("ledgerId") Long payrollLedgerId, 
                                                     @Param("action") String action);
    
    @Query("SELECT COUNT(pa) FROM PayrollAudit pa WHERE pa.action = :action AND pa.createdAt >= :fromDate")
    long countByActionSince(@Param("action") String action, @Param("fromDate") LocalDateTime fromDate);
}
</file>

<file path="src/main/java/com/example/demo/payroll/repository/PayrollLedgerRepository.java">
package com.example.demo.payroll.repository;

import com.example.demo.payroll.entity.PayrollLedger;
import com.example.demo.payroll.entity.PayrollLedgerStatus;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

@Repository
public interface PayrollLedgerRepository extends JpaRepository<PayrollLedger, Long> {
    
    List<PayrollLedger> findByEmployeeId(Long employeeId);
    
    List<PayrollLedger> findByPayrollPeriodId(Long payrollPeriodId);
    
    List<PayrollLedger> findByStatus(PayrollLedgerStatus status);
    
    Optional<PayrollLedger> findByEmployeeIdAndPayrollPeriodId(Long employeeId, Long payrollPeriodId);
    
    Page<PayrollLedger> findByEmployeeIdOrderByCreatedAtDesc(Long employeeId, Pageable pageable);
    
    @Query("SELECT pl FROM PayrollLedger pl WHERE pl.payDate BETWEEN :startDate AND :endDate")
    List<PayrollLedger> findByPayDateBetween(@Param("startDate") LocalDate startDate, 
                                           @Param("endDate") LocalDate endDate);
    
    @Query("SELECT pl FROM PayrollLedger pl JOIN FETCH pl.employee e JOIN FETCH pl.payrollPeriod pp WHERE pl.status = :status")
    List<PayrollLedger> findByStatusWithEmployeeAndPeriod(@Param("status") PayrollLedgerStatus status);
    
    @Query("SELECT COUNT(pl) FROM PayrollLedger pl WHERE pl.status = :status")
    long countByStatus(@Param("status") PayrollLedgerStatus status);
    
    @Query("SELECT SUM(pl.netPay) FROM PayrollLedger pl WHERE pl.payrollPeriodId = :periodId AND pl.status = 'PAID'")
    Optional<java.math.BigDecimal> getTotalNetPayForPeriod(@Param("periodId") Long periodId);
    
    @Query("SELECT pl FROM PayrollLedger pl WHERE pl.employeeId IN :employeeIds AND pl.payrollPeriodId = :periodId")
    List<PayrollLedger> findByEmployeeIdsAndPeriod(@Param("employeeIds") List<Long> employeeIds, 
                                                  @Param("periodId") Long periodId);
}
</file>

<file path="src/main/java/com/example/demo/payroll/repository/PayrollPeriodRepository.java">
package com.example.demo.payroll.repository;

import com.example.demo.payroll.entity.PayrollPeriod;
import com.example.demo.payroll.entity.PayrollPeriodStatus;
import com.example.demo.payroll.entity.PayrollPeriodType;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

@Repository
public interface PayrollPeriodRepository extends JpaRepository<PayrollPeriod, Long> {
    
    List<PayrollPeriod> findByStatus(PayrollPeriodStatus status);
    
    List<PayrollPeriod> findByPeriodType(PayrollPeriodType periodType);
    
    List<PayrollPeriod> findByIsActiveTrue();
    
    Page<PayrollPeriod> findByIsActiveTrueOrderByStartDateDesc(Pageable pageable);
    
    @Query("SELECT pp FROM PayrollPeriod pp WHERE pp.startDate <= :date AND pp.endDate >= :date AND pp.isActive = true")
    Optional<PayrollPeriod> findCurrentPeriodForDate(@Param("date") LocalDate date);
    
    @Query("SELECT pp FROM PayrollPeriod pp WHERE pp.startDate BETWEEN :startDate AND :endDate")
    List<PayrollPeriod> findPeriodsInDateRange(@Param("startDate") LocalDate startDate, 
                                             @Param("endDate") LocalDate endDate);
    
    @Query("SELECT pp FROM PayrollPeriod pp WHERE pp.status = 'OPEN' AND pp.isActive = true ORDER BY pp.startDate")
    List<PayrollPeriod> findOpenPeriods();
    
    @Query("SELECT pp FROM PayrollPeriod pp WHERE pp.endDate < :date AND pp.status != 'COMPLETED'")
    List<PayrollPeriod> findOverduePeriods(@Param("date") LocalDate date);
    
    boolean existsByPeriodNameIgnoreCase(String periodName);
    
    @Query("SELECT pp FROM PayrollPeriod pp WHERE pp.startDate <= :endDate AND pp.endDate >= :startDate")
    List<PayrollPeriod> findOverlappingPeriods(@Param("startDate") LocalDate startDate, 
                                             @Param("endDate") LocalDate endDate);
}
</file>

<file path="src/main/java/com/example/demo/payroll/repository/SalaryComponentRepository.java">
package com.example.demo.payroll.repository;

import com.example.demo.payroll.entity.SalaryComponent;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface SalaryComponentRepository extends JpaRepository<SalaryComponent, Long> {
    
    List<SalaryComponent> findByComponentType(String componentType);
    
    List<SalaryComponent> findByIsActiveTrue();
    
    List<SalaryComponent> findByIsMandatoryTrue();
    
    List<SalaryComponent> findByIsTaxableTrue();
    
    Page<SalaryComponent> findByIsActiveTrueOrderByCalculationOrder(Pageable pageable);
    
    @Query("SELECT sc FROM SalaryComponent sc WHERE sc.componentType = :type AND sc.isActive = true ORDER BY sc.calculationOrder")
    List<SalaryComponent> findActiveByTypeOrderByCalculationOrder(@Param("type") String componentType);
    
    @Query("SELECT sc FROM SalaryComponent sc WHERE sc.isActive = true ORDER BY sc.calculationOrder")
    List<SalaryComponent> findAllActiveOrderByCalculationOrder();
    
    boolean existsByComponentNameIgnoreCase(String componentName);
    
    @Query("SELECT MAX(sc.calculationOrder) FROM SalaryComponent sc WHERE sc.componentType = :type")
    Integer findMaxCalculationOrderByType(@Param("type") String componentType);
    
    @Query("SELECT sc FROM SalaryComponent sc WHERE sc.componentName LIKE %:name% AND sc.isActive = true")
    List<SalaryComponent> findByComponentNameContainingIgnoreCaseAndIsActiveTrue(@Param("name") String name);
}
</file>

<file path="src/main/java/com/example/demo/payroll/service/impl/PayrollCalculationServiceImpl.java">
package com.example.demo.payroll.service.impl;

import com.example.demo.employee.entity.Employee;
import com.example.demo.employee.repository.EmployeeRepository;
import com.example.demo.payroll.dto.PayrollCalculationRequest;
import com.example.demo.payroll.entity.*;
import com.example.demo.payroll.repository.PayrollLedgerRepository;
import com.example.demo.payroll.repository.PayrollPeriodRepository;
import com.example.demo.payroll.repository.SalaryComponentRepository;
import com.example.demo.payroll.service.PayrollCalculationService;
import com.example.demo.payroll.exception.PayrollCalculationException;
import com.example.demo.payroll.exception.PayrollValidationException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
@Transactional
public class PayrollCalculationServiceImpl implements PayrollCalculationService {
    
    private final PayrollLedgerRepository payrollLedgerRepository;
    private final PayrollPeriodRepository payrollPeriodRepository;
    private final SalaryComponentRepository salaryComponentRepository;
    private final EmployeeRepository employeeRepository;
    
    private static final BigDecimal OVERTIME_MULTIPLIER = new BigDecimal("1.5");
    private static final int DECIMAL_SCALE = 2;
    
    @Override
    public PayrollLedger calculatePayroll(PayrollCalculationRequest request) {
        log.info("Calculating payroll for employee {} in period {}", 
                request.getEmployeeId(), request.getPayrollPeriodId());
        
        validateCalculation(request);
        
        Employee employee = employeeRepository.findById(request.getEmployeeId())
                .orElseThrow(() -> new PayrollValidationException("Employee not found: " + request.getEmployeeId()));
        
        PayrollPeriod period = payrollPeriodRepository.findById(request.getPayrollPeriodId())
                .orElseThrow(() -> new PayrollValidationException("Payroll period not found: " + request.getPayrollPeriodId()));
        
        // Check if payroll already exists for this employee and period
        payrollLedgerRepository.findByEmployeeIdAndPayrollPeriodId(
                request.getEmployeeId(), request.getPayrollPeriodId())
                .ifPresent(existing -> {
                    throw new PayrollValidationException("Payroll already exists for this employee and period");
                });
        
        PayrollLedger ledger = new PayrollLedger();
        ledger.setEmployeeId(request.getEmployeeId());
        ledger.setPayrollPeriodId(request.getPayrollPeriodId());
        ledger.setBaseSalary(request.getBaseSalary() != null ? request.getBaseSalary() : employee.getSalary());
        ledger.setOvertimeHours(request.getOvertimeHours() != null ? request.getOvertimeHours() : BigDecimal.ZERO);
        ledger.setBonusAmount(request.getBonusAmount() != null ? request.getBonusAmount() : BigDecimal.ZERO);
        ledger.setNotes(request.getNotes());
        ledger.setStatus(PayrollLedgerStatus.PENDING);
        
        // Calculate overtime pay
        if (ledger.getOvertimeHours().compareTo(BigDecimal.ZERO) > 0) {
            BigDecimal hourlyRate = calculateHourlyRate(ledger.getBaseSalary());
            ledger.setOvertimePay(calculateOvertimePay(ledger.getOvertimeHours(), hourlyRate));
        }
        
        // Calculate gross pay
        ledger.setGrossPay(ledger.getBaseSalary()
                .add(ledger.getOvertimePay())
                .add(ledger.getBonusAmount()));
        
        // Calculate deductions and taxes
        List<SalaryComponent> activeComponents = salaryComponentRepository.findAllActiveOrderByCalculationOrder();
        Map<Long, BigDecimal> overrides = request.getComponentOverrides() != null ?
                request.getComponentOverrides().stream()
                        .collect(Collectors.toMap(
                                PayrollCalculationRequest.ComponentOverride::getSalaryComponentId,
                                PayrollCalculationRequest.ComponentOverride::getAmount)) :
                Map.of();
        
        List<PayrollLedgerComponent> components = calculateComponents(ledger, activeComponents, overrides);
        
        // Calculate totals
        BigDecimal totalDeductions = components.stream()
                .filter(c -> "DEDUCTION".equals(c.getSalaryComponent().getComponentType()))
                .map(PayrollLedgerComponent::getAmount)
                .reduce(BigDecimal.ZERO, BigDecimal::add);
        
        BigDecimal totalTaxes = components.stream()
                .filter(c -> "TAX".equals(c.getSalaryComponent().getComponentType()))
                .map(PayrollLedgerComponent::getAmount)
                .reduce(BigDecimal.ZERO, BigDecimal::add);
        
        ledger.setTotalDeductions(totalDeductions);
        ledger.setTotalTaxes(totalTaxes);
        ledger.setNetPay(ledger.getGrossPay().subtract(totalDeductions).subtract(totalTaxes));
        ledger.setStatus(PayrollLedgerStatus.CALCULATED);
        
        // Save ledger first
        PayrollLedger savedLedger = payrollLedgerRepository.save(ledger);
        
        // Set ledger ID for components and save
        components.forEach(component -> component.setPayrollLedgerId(savedLedger.getId()));
        savedLedger.setComponents(components);
        
        log.info("Payroll calculated successfully for employee {} with net pay {}", 
                request.getEmployeeId(), savedLedger.getNetPay());
        
        return savedLedger;
    }
    
    @Override
    public List<PayrollLedger> calculatePayrollForPeriod(Long payrollPeriodId, List<Long> employeeIds) {
        log.info("Calculating payroll for {} employees in period {}", employeeIds.size(), payrollPeriodId);
        
        List<PayrollLedger> results = new ArrayList<>();
        
        for (Long employeeId : employeeIds) {
            try {
                Employee employee = employeeRepository.findById(employeeId)
                        .orElseThrow(() -> new PayrollValidationException("Employee not found: " + employeeId));
                
                PayrollCalculationRequest request = new PayrollCalculationRequest();
                request.setEmployeeId(employeeId);
                request.setPayrollPeriodId(payrollPeriodId);
                request.setBaseSalary(employee.getSalary());
                
                PayrollLedger ledger = calculatePayroll(request);
                results.add(ledger);
                
            } catch (Exception e) {
                log.error("Failed to calculate payroll for employee {}: {}", employeeId, e.getMessage());
                // Continue with other employees
            }
        }
        
        log.info("Calculated payroll for {} out of {} employees", results.size(), employeeIds.size());
        return results;
    }
    
    @Override
    public PayrollLedger recalculatePayroll(Long payrollLedgerId) {
        PayrollLedger existing = payrollLedgerRepository.findById(payrollLedgerId)
                .orElseThrow(() -> new PayrollValidationException("Payroll ledger not found: " + payrollLedgerId));
        
        if (existing.getStatus() == PayrollLedgerStatus.PAID) {
            throw new PayrollValidationException("Cannot recalculate paid payroll");
        }
        
        PayrollCalculationRequest request = new PayrollCalculationRequest();
        request.setEmployeeId(existing.getEmployeeId());
        request.setPayrollPeriodId(existing.getPayrollPeriodId());
        request.setBaseSalary(existing.getBaseSalary());
        request.setOvertimeHours(existing.getOvertimeHours());
        request.setBonusAmount(existing.getBonusAmount());
        
        // Delete existing and create new
        payrollLedgerRepository.delete(existing);
        return calculatePayroll(request);
    }
    
    @Override
    public BigDecimal calculateOvertimePay(BigDecimal overtimeHours, BigDecimal hourlyRate) {
        if (overtimeHours == null || hourlyRate == null) {
            return BigDecimal.ZERO;
        }
        return overtimeHours.multiply(hourlyRate).multiply(OVERTIME_MULTIPLIER)
                .setScale(DECIMAL_SCALE, RoundingMode.HALF_UP);
    }
    
    @Override
    public BigDecimal calculateTaxes(BigDecimal grossPay, Long employeeId) {
        // Simplified tax calculation - in real implementation, this would use tax tables
        BigDecimal taxRate = new BigDecimal("0.20"); // 20% tax rate
        return grossPay.multiply(taxRate).setScale(DECIMAL_SCALE, RoundingMode.HALF_UP);
    }
    
    @Override
    public BigDecimal calculateDeductions(BigDecimal grossPay, Long employeeId, List<Long> componentIds) {
        List<SalaryComponent> deductionComponents = salaryComponentRepository.findAllById(componentIds)
                .stream()
                .filter(c -> "DEDUCTION".equals(c.getComponentType()))
                .collect(Collectors.toList());
        
        BigDecimal totalDeductions = BigDecimal.ZERO;
        
        for (SalaryComponent component : deductionComponents) {
            BigDecimal amount;
            if (component.getPercentage() != null) {
                amount = grossPay.multiply(component.getPercentage().divide(new BigDecimal("100")));
            } else {
                amount = component.getAmount();
            }
            totalDeductions = totalDeductions.add(amount);
        }
        
        return totalDeductions.setScale(DECIMAL_SCALE, RoundingMode.HALF_UP);
    }
    
    @Override
    public void validateCalculation(PayrollCalculationRequest request) {
        if (request.getEmployeeId() == null) {
            throw new PayrollValidationException("Employee ID is required");
        }
        if (request.getPayrollPeriodId() == null) {
            throw new PayrollValidationException("Payroll period ID is required");
        }
        if (request.getBaseSalary() != null && request.getBaseSalary().compareTo(BigDecimal.ZERO) < 0) {
            throw new PayrollValidationException("Base salary cannot be negative");
        }
        if (request.getOvertimeHours() != null && request.getOvertimeHours().compareTo(BigDecimal.ZERO) < 0) {
            throw new PayrollValidationException("Overtime hours cannot be negative");
        }
        if (request.getBonusAmount() != null && request.getBonusAmount().compareTo(BigDecimal.ZERO) < 0) {
            throw new PayrollValidationException("Bonus amount cannot be negative");
        }
    }
    
    private BigDecimal calculateHourlyRate(BigDecimal monthlySalary) {
        // Assuming 160 working hours per month (40 hours/week * 4 weeks)
        BigDecimal workingHoursPerMonth = new BigDecimal("160");
        return monthlySalary.divide(workingHoursPerMonth, DECIMAL_SCALE, RoundingMode.HALF_UP);
    }
    
    private List<PayrollLedgerComponent> calculateComponents(PayrollLedger ledger, 
                                                           List<SalaryComponent> components,
                                                           Map<Long, BigDecimal> overrides) {
        List<PayrollLedgerComponent> ledgerComponents = new ArrayList<>();
        BigDecimal calculationBase = ledger.getGrossPay();
        
        for (SalaryComponent component : components) {
            PayrollLedgerComponent ledgerComponent = new PayrollLedgerComponent();
            ledgerComponent.setSalaryComponentId(component.getId());
            ledgerComponent.setCalculationBase(calculationBase);
            
            BigDecimal amount;
            if (overrides.containsKey(component.getId())) {
                amount = overrides.get(component.getId());
                ledgerComponent.setNotes("Override applied");
            } else if (component.getPercentage() != null) {
                amount = calculationBase.multiply(component.getPercentage().divide(new BigDecimal("100")));
                ledgerComponent.setPercentageApplied(component.getPercentage());
            } else {
                amount = component.getAmount();
            }
            
            ledgerComponent.setAmount(amount.setScale(DECIMAL_SCALE, RoundingMode.HALF_UP));
            ledgerComponents.add(ledgerComponent);
        }
        
        return ledgerComponents;
    }
}
</file>

<file path="src/main/java/com/example/demo/payroll/service/PayrollCalculationService.java">
package com.example.demo.payroll.service;

import com.example.demo.payroll.dto.PayrollCalculationRequest;
import com.example.demo.payroll.entity.PayrollLedger;

import java.math.BigDecimal;
import java.util.List;

/**
 * Service interface for payroll calculations
 */
public interface PayrollCalculationService {
    
    /**
     * Calculate payroll for a single employee
     */
    PayrollLedger calculatePayroll(PayrollCalculationRequest request);
    
    /**
     * Calculate payroll for multiple employees in a period
     */
    List<PayrollLedger> calculatePayrollForPeriod(Long payrollPeriodId, List<Long> employeeIds);
    
    /**
     * Recalculate an existing payroll ledger
     */
    PayrollLedger recalculatePayroll(Long payrollLedgerId);
    
    /**
     * Calculate overtime pay based on hours and rate
     */
    BigDecimal calculateOvertimePay(BigDecimal overtimeHours, BigDecimal hourlyRate);
    
    /**
     * Calculate tax amount based on gross pay and tax rules
     */
    BigDecimal calculateTaxes(BigDecimal grossPay, Long employeeId);
    
    /**
     * Calculate total deductions for an employee
     */
    BigDecimal calculateDeductions(BigDecimal grossPay, Long employeeId, List<Long> componentIds);
    
    /**
     * Validate payroll calculation rules
     */
    void validateCalculation(PayrollCalculationRequest request);
}
</file>

<file path="src/main/java/com/example/demo/payroll/service/PayrollService.java">
package com.example.demo.payroll.service;

import com.example.demo.common.dto.PageResponse;
import com.example.demo.payroll.dto.*;
import com.example.demo.payroll.entity.PayrollLedgerStatus;
import org.springframework.data.domain.Pageable;

import java.time.LocalDate;
import java.util.List;

/**
 * Service interface for payroll management
 */
public interface PayrollService {
    
    // Payroll Ledger Operations
    PayrollLedgerDto createPayrollLedger(PayrollCalculationRequest request);
    PayrollLedgerDto updatePayrollLedger(Long id, PayrollLedgerDto payrollLedgerDto);
    PayrollLedgerDto getPayrollLedgerById(Long id);
    void deletePayrollLedger(Long id);
    
    // Payroll Ledger Queries
    PageResponse<PayrollLedgerDto> getPayrollLedgers(Pageable pageable);
    List<PayrollLedgerDto> getPayrollLedgersByEmployee(Long employeeId);
    List<PayrollLedgerDto> getPayrollLedgersByPeriod(Long payrollPeriodId);
    List<PayrollLedgerDto> getPayrollLedgersByStatus(PayrollLedgerStatus status);
    PageResponse<PayrollLedgerDto> getPayrollLedgersByEmployeeWithPaging(Long employeeId, Pageable pageable);
    
    // Payroll Processing
    List<PayrollLedgerDto> processPayrollForPeriod(Long payrollPeriodId, List<Long> employeeIds);
    PayrollLedgerDto approvePayroll(Long payrollLedgerId, String reason);
    PayrollLedgerDto rejectPayroll(Long payrollLedgerId, String reason);
    PayrollLedgerDto markAsPaid(Long payrollLedgerId, String paymentReference);
    
    // Payroll Period Operations
    PayrollPeriodDto createPayrollPeriod(PayrollPeriodDto payrollPeriodDto);
    PayrollPeriodDto updatePayrollPeriod(Long id, PayrollPeriodDto payrollPeriodDto);
    PayrollPeriodDto getPayrollPeriodById(Long id);
    void deletePayrollPeriod(Long id);
    PageResponse<PayrollPeriodDto> getPayrollPeriods(Pageable pageable);
    List<PayrollPeriodDto> getActivePayrollPeriods();
    PayrollPeriodDto getCurrentPayrollPeriod();
    PayrollPeriodDto closePayrollPeriod(Long id);
    
    // Salary Component Operations
    SalaryComponentDto createSalaryComponent(SalaryComponentDto salaryComponentDto);
    SalaryComponentDto updateSalaryComponent(Long id, SalaryComponentDto salaryComponentDto);
    SalaryComponentDto getSalaryComponentById(Long id);
    void deleteSalaryComponent(Long id);
    PageResponse<SalaryComponentDto> getSalaryComponents(Pageable pageable);
    List<SalaryComponentDto> getActiveSalaryComponents();
    List<SalaryComponentDto> getSalaryComponentsByType(String componentType);
    
    // Reporting and Analytics
    PayrollSummaryDto getPayrollSummary(Long payrollPeriodId);
    List<PayrollSummaryDto> getPayrollSummaryByDateRange(LocalDate startDate, LocalDate endDate);
    byte[] generatePayrollReport(PayrollReportRequest request);
}
</file>

<file path="src/main/java/com/example/demo/position/controller/PositionController.java">
package com.example.demo.position.controller;

import com.example.demo.common.dto.ApiResponse;
import com.example.demo.position.dto.*;
import com.example.demo.position.enums.PositionCategory;
import com.example.demo.position.enums.PositionLevel;
import com.example.demo.position.service.PositionService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/positions")
@RequiredArgsConstructor
@Slf4j
public class PositionController {

    private final PositionService positionService;

    @PostMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('HR_MANAGER')")
    public ResponseEntity<ApiResponse<PositionDto>> createPosition(@Valid @RequestBody PositionCreateRequest request) {
        log.info("Creating new position with code: {}", request.getCode());
        PositionDto createdPosition = positionService.createPosition(request);
        return ResponseEntity.status(HttpStatus.CREATED)
                .body(ApiResponse.success(createdPosition, "Position created successfully"));
    }

    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('HR_MANAGER')")
    public ResponseEntity<ApiResponse<PositionDto>> updatePosition(
            @PathVariable Long id,
            @Valid @RequestBody PositionUpdateRequest request) {
        log.info("Updating position with ID: {}", id);
        PositionDto updatedPosition = positionService.updatePosition(id, request);
        return ResponseEntity.ok(ApiResponse.success(updatedPosition, "Position updated successfully"));
    }

    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('HR_MANAGER') or hasRole('HR_EMPLOYEE') or hasRole('MANAGER')")
    public ResponseEntity<ApiResponse<PositionDto>> getPositionById(@PathVariable Long id) {
        log.info("Fetching position with ID: {}", id);
        PositionDto position = positionService.getPositionById(id);
        return ResponseEntity.ok(ApiResponse.success(position, "Position retrieved successfully"));
    }

    @GetMapping("/code/{code}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('HR_MANAGER') or hasRole('HR_EMPLOYEE') or hasRole('MANAGER')")
    public ResponseEntity<ApiResponse<PositionDto>> getPositionByCode(@PathVariable String code) {
        log.info("Fetching position with code: {}", code);
        PositionDto position = positionService.getPositionByCode(code);
        return ResponseEntity.ok(ApiResponse.success(position, "Position retrieved successfully"));
    }

    @GetMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('HR_MANAGER') or hasRole('HR_EMPLOYEE') or hasRole('MANAGER')")
    public ResponseEntity<ApiResponse<Page<PositionDto>>> getAllPositions(
            @PageableDefault(size = 20, sort = "jobTitle") Pageable pageable) {
        log.info("Fetching all positions with pagination");
        Page<PositionDto> positions = positionService.getAllPositions(pageable);
        return ResponseEntity.ok(ApiResponse.success(positions, "Positions retrieved successfully"));
    }

    @GetMapping("/search")
    @PreAuthorize("hasRole('ADMIN') or hasRole('HR_MANAGER') or hasRole('HR_EMPLOYEE') or hasRole('MANAGER')")
    public ResponseEntity<ApiResponse<Page<PositionDto>>> searchPositions(
            @ModelAttribute PositionSearchCriteria criteria,
            @PageableDefault(size = 20, sort = "jobTitle") Pageable pageable) {
        log.info("Searching positions with criteria: {}", criteria);
        Page<PositionDto> positions = positionService.searchPositions(criteria, pageable);
        return ResponseEntity.ok(ApiResponse.success(positions, "Position search completed successfully"));
    }

    @GetMapping("/department/{departmentId}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('HR_MANAGER') or hasRole('HR_EMPLOYEE') or hasRole('MANAGER')")
    public ResponseEntity<ApiResponse<List<PositionDto>>> getPositionsByDepartment(@PathVariable Long departmentId) {
        log.info("Fetching positions for department ID: {}", departmentId);
        List<PositionDto> positions = positionService.getPositionsByDepartment(departmentId);
        return ResponseEntity.ok(ApiResponse.success(positions, "Department positions retrieved successfully"));
    }

    @GetMapping("/category/{category}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('HR_MANAGER') or hasRole('HR_EMPLOYEE') or hasRole('MANAGER')")
    public ResponseEntity<ApiResponse<List<PositionDto>>> getPositionsByCategory(@PathVariable PositionCategory category) {
        log.info("Fetching positions for category: {}", category);
        List<PositionDto> positions = positionService.getPositionsByCategory(category);
        return ResponseEntity.ok(ApiResponse.success(positions, "Category positions retrieved successfully"));
    }

    @GetMapping("/level/{level}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('HR_MANAGER') or hasRole('HR_EMPLOYEE') or hasRole('MANAGER')")
    public ResponseEntity<ApiResponse<List<PositionDto>>> getPositionsByLevel(@PathVariable PositionLevel level) {
        log.info("Fetching positions for level: {}", level);
        List<PositionDto> positions = positionService.getPositionsByLevel(level);
        return ResponseEntity.ok(ApiResponse.success(positions, "Level positions retrieved successfully"));
    }

    @GetMapping("/enabled")
    @PreAuthorize("hasRole('ADMIN') or hasRole('HR_MANAGER') or hasRole('HR_EMPLOYEE') or hasRole('MANAGER')")
    public ResponseEntity<ApiResponse<Page<PositionDto>>> getEnabledPositions(
            @PageableDefault(size = 20, sort = "jobTitle") Pageable pageable) {
        log.info("Fetching enabled positions");
        Page<PositionDto> positions = positionService.getEnabledPositions(pageable);
        return ResponseEntity.ok(ApiResponse.success(positions, "Enabled positions retrieved successfully"));
    }

    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('HR_MANAGER')")
    public ResponseEntity<ApiResponse<Void>> deletePosition(@PathVariable Long id) {
        log.info("Deleting position with ID: {}", id);
        positionService.deletePosition(id);
        return ResponseEntity.ok(ApiResponse.success(null, "Position deleted successfully"));
    }

    @PatchMapping("/{id}/status")
    @PreAuthorize("hasRole('ADMIN') or hasRole('HR_MANAGER')")
    public ResponseEntity<ApiResponse<PositionDto>> togglePositionStatus(
            @PathVariable Long id,
            @RequestParam boolean enabled) {
        log.info("Toggling position status for ID: {} to {}", id, enabled);
        PositionDto updatedPosition = positionService.togglePositionStatus(id, enabled);
        return ResponseEntity.ok(ApiResponse.success(updatedPosition, "Position status updated successfully"));
    }

    @GetMapping("/exists/{code}")
    @PreAuthorize("hasRole('ADMIN') or hasRole('HR_MANAGER') or hasRole('HR_EMPLOYEE')")
    public ResponseEntity<ApiResponse<Boolean>> checkPositionCodeExists(@PathVariable String code) {
        log.info("Checking if position code exists: {}", code);
        boolean exists = positionService.existsByCode(code);
        return ResponseEntity.ok(ApiResponse.success(exists, "Position code check completed"));
    }

    @GetMapping("/statistics")
    @PreAuthorize("hasRole('ADMIN') or hasRole('HR_MANAGER')")
    public ResponseEntity<ApiResponse<PositionStatisticsDto>> getPositionStatistics() {
        log.info("Fetching position statistics");
        PositionStatisticsDto statistics = positionService.getPositionStatistics();
        return ResponseEntity.ok(ApiResponse.success(statistics, "Position statistics retrieved successfully"));
    }
}
</file>

<file path="src/main/java/com/example/demo/position/dto/PositionCreateRequest.java">
package com.example.demo.position.dto;

import com.example.demo.position.enums.EmploymentType;
import com.example.demo.position.enums.PositionCategory;
import com.example.demo.position.enums.PositionLevel;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.Data;

import java.math.BigDecimal;

@Data
public class PositionCreateRequest {
    @NotBlank(message = "Job title is required")
    @Size(max = 100, message = "Job title must not exceed 100 characters")
    private String jobTitle;

    @Size(max = 100, message = "Professional title must not exceed 100 characters")
    private String professionalTitle;

    @NotBlank(message = "Position code is required")
    @Size(max = 20, message = "Position code must not exceed 20 characters")
    private String code;

    @Size(max = 1000, message = "Description must not exceed 1000 characters")
    private String description;

    @Size(max = 2000, message = "Requirements must not exceed 2000 characters")
    private String requirements;

    @Size(max = 2000, message = "Responsibilities must not exceed 2000 characters")
    private String responsibilities;

    @NotNull(message = "Position category is required")
    private PositionCategory category;

    @Size(max = 10, message = "Salary grade must not exceed 10 characters")
    private String salaryGrade;

    @NotNull(message = "Department ID is required")
    private Long departmentId;

    @NotNull(message = "Position level is required")
    private PositionLevel level;

    private Boolean enabled = true;

    private BigDecimal minSalary;

    private BigDecimal maxSalary;

    @Size(max = 1000, message = "Required skills must not exceed 1000 characters")
    private String requiredSkills;

    @Size(max = 500, message = "Required education must not exceed 500 characters")
    private String requiredEducation;

    private Integer requiredExperience;

    @Size(max = 1000, message = "Benefits must not exceed 1000 characters")
    private String benefits;

    @Size(max = 255, message = "Work location must not exceed 255 characters")
    private String workLocation;

    @NotNull(message = "Employment type is required")
    private EmploymentType employmentType;

    private Boolean isManagerial = false;
}
</file>

<file path="src/main/java/com/example/demo/position/dto/PositionDto.java">
package com.example.demo.position.dto;

import com.example.demo.position.enums.EmploymentType;
import com.example.demo.position.enums.PositionCategory;
import com.example.demo.position.enums.PositionLevel;
import lombok.Data;

import java.math.BigDecimal;
import java.time.Instant;

@Data
public class PositionDto {
    private Long id;
    private String jobTitle;
    private String professionalTitle;
    private String code;
    private String description;
    private String requirements;
    private String responsibilities;
    private PositionCategory category;
    private String salaryGrade;
    private Long departmentId;
    private String departmentName;
    private PositionLevel level;
    private Boolean enabled;
    private BigDecimal minSalary;
    private BigDecimal maxSalary;
    private String requiredSkills;
    private String requiredEducation;
    private Integer requiredExperience;
    private String benefits;
    private String workLocation;
    private EmploymentType employmentType;
    private Boolean isManagerial;
    private Instant createdAt;
    private Instant updatedAt;
    private Long createdBy;
    private Long updatedBy;
    private Integer employeeCount;
}
</file>

<file path="src/main/java/com/example/demo/position/dto/PositionSearchCriteria.java">
package com.example.demo.position.dto;

import com.example.demo.position.enums.EmploymentType;
import com.example.demo.position.enums.PositionCategory;
import com.example.demo.position.enums.PositionLevel;
import lombok.Data;

import java.math.BigDecimal;

@Data
public class PositionSearchCriteria {
    private String jobTitle;
    private String professionalTitle;
    private String code;
    private PositionCategory category;
    private Long departmentId;
    private PositionLevel level;
    private Boolean enabled;
    private BigDecimal minSalaryFrom;
    private BigDecimal minSalaryTo;
    private BigDecimal maxSalaryFrom;
    private BigDecimal maxSalaryTo;
    private String requiredSkills;
    private String requiredEducation;
    private Integer minExperience;
    private Integer maxExperience;
    private String workLocation;
    private EmploymentType employmentType;
    private Boolean isManagerial;
    private String sortBy = "jobTitle";
    private String sortDirection = "ASC";
}
</file>

<file path="src/main/java/com/example/demo/position/dto/PositionStatisticsDto.java">
package com.example.demo.position.dto;

import lombok.Data;

import java.util.Map;

@Data
public class PositionStatisticsDto {
    private Long totalPositions;
    private Long enabledPositions;
    private Long disabledPositions;
    private Map<String, Long> positionsByCategory;
    private Map<String, Long> positionsByLevel;
    private Map<String, Long> positionsByEmploymentType;
    private Map<String, Long> positionsByDepartment;
    private Long managerialPositions;
    private Long nonManagerialPositions;
    private Double averageMinSalary;
    private Double averageMaxSalary;
}
</file>

<file path="src/main/java/com/example/demo/position/dto/PositionUpdateRequest.java">
package com.example.demo.position.dto;

import com.example.demo.position.enums.EmploymentType;
import com.example.demo.position.enums.PositionCategory;
import com.example.demo.position.enums.PositionLevel;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.Data;

import java.math.BigDecimal;

@Data
public class PositionUpdateRequest {
    @NotBlank(message = "Job title is required")
    @Size(max = 100, message = "Job title must not exceed 100 characters")
    private String jobTitle;

    @Size(max = 100, message = "Professional title must not exceed 100 characters")
    private String professionalTitle;

    @Size(max = 1000, message = "Description must not exceed 1000 characters")
    private String description;

    @Size(max = 2000, message = "Requirements must not exceed 2000 characters")
    private String requirements;

    @Size(max = 2000, message = "Responsibilities must not exceed 2000 characters")
    private String responsibilities;

    @NotNull(message = "Position category is required")
    private PositionCategory category;

    @Size(max = 10, message = "Salary grade must not exceed 10 characters")
    private String salaryGrade;

    @NotNull(message = "Department ID is required")
    private Long departmentId;

    @NotNull(message = "Position level is required")
    private PositionLevel level;

    private Boolean enabled;

    private BigDecimal minSalary;

    private BigDecimal maxSalary;

    @Size(max = 1000, message = "Required skills must not exceed 1000 characters")
    private String requiredSkills;

    @Size(max = 500, message = "Required education must not exceed 500 characters")
    private String requiredEducation;

    private Integer requiredExperience;

    @Size(max = 1000, message = "Benefits must not exceed 1000 characters")
    private String benefits;

    @Size(max = 255, message = "Work location must not exceed 255 characters")
    private String workLocation;

    @NotNull(message = "Employment type is required")
    private EmploymentType employmentType;

    private Boolean isManagerial;
}
</file>

<file path="src/main/java/com/example/demo/position/entity/Position.java">
package com.example.demo.position.entity;

import com.example.demo.department.entity.Department;
import com.example.demo.employee.entity.Employee;
import com.example.demo.position.enums.EmploymentType;
import com.example.demo.position.enums.PositionCategory;
import com.example.demo.position.enums.PositionLevel;
import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.Data;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "positions", indexes = {
    @Index(name = "idx_position_job_title", columnList = "job_title"),
    @Index(name = "idx_position_code", columnList = "code"),
    @Index(name = "idx_position_department_id", columnList = "department_id"),
    @Index(name = "idx_position_level", columnList = "level"),
    @Index(name = "idx_position_enabled", columnList = "enabled"),
    @Index(name = "idx_position_category", columnList = "category")
})
@EntityListeners(AuditingEntityListener.class)
@Data
public class Position {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotBlank(message = "Job title is required")
    @Column(name = "job_title", nullable = false, length = 100)
    private String jobTitle;

    @Column(name = "professional_title", length = 100)
    private String professionalTitle;

    @NotBlank(message = "Position code is required")
    @Column(name = "code", unique = true, nullable = false, length = 20)
    private String code;

    @Column(name = "description", length = 1000)
    private String description;

    @Column(name = "requirements", length = 2000)
    private String requirements;

    @Column(name = "responsibilities", length = 2000)
    private String responsibilities;

    @NotNull(message = "Position category is required")
    @Enumerated(EnumType.STRING)
    @Column(name = "category", nullable = false, length = 20)
    private PositionCategory category = PositionCategory.TECHNICAL;

    @Column(name = "salary_grade", length = 10)
    private String salaryGrade;

    @NotNull(message = "Department is required")
    @Column(name = "department_id", nullable = false)
    private Long departmentId;

    @NotNull(message = "Position level is required")
    @Enumerated(EnumType.STRING)
    @Column(name = "level", nullable = false, length = 20)
    private PositionLevel level = PositionLevel.JUNIOR;

    @Column(name = "enabled", nullable = false)
    private Boolean enabled = true;

    @Column(name = "min_salary", precision = 12, scale = 2)
    private BigDecimal minSalary;

    @Column(name = "max_salary", precision = 12, scale = 2)
    private BigDecimal maxSalary;

    @Column(name = "required_skills", length = 1000)
    private String requiredSkills;

    @Column(name = "required_education", length = 500)
    private String requiredEducation;

    @Column(name = "required_experience")
    private Integer requiredExperience;

    @Column(name = "benefits", length = 1000)
    private String benefits;

    @Column(name = "work_location", length = 255)
    private String workLocation;

    @NotNull(message = "Employment type is required")
    @Enumerated(EnumType.STRING)
    @Column(name = "employment_type", nullable = false, length = 20)
    private EmploymentType employmentType = EmploymentType.FULL_TIME;

    @Column(name = "is_managerial", nullable = false)
    private Boolean isManagerial = false;

    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;

    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;

    @Column(name = "created_by")
    private Long createdBy;

    @Column(name = "updated_by")
    private Long updatedBy;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "department_id", insertable = false, updatable = false,
            foreignKey = @ForeignKey(name = "fk_position_department"))
    private Department department;

    @OneToMany(mappedBy = "position", fetch = FetchType.LAZY)
    private Set<Employee> employees = new HashSet<>();
}
</file>

<file path="src/main/java/com/example/demo/position/enums/EmploymentType.java">
package com.example.demo.position.enums;

public enum EmploymentType {
    FULL_TIME,
    PART_TIME,
    CONTRACT,
    INTERNSHIP,
    TEMPORARY
}
</file>

<file path="src/main/java/com/example/demo/position/enums/PositionCategory.java">
package com.example.demo.position.enums;

public enum PositionCategory {
    TECHNICAL,
    MANAGEMENT,
    ADMINISTRATIVE,
    SALES,
    HR,
    FINANCE,
    MARKETING,
    OPERATIONS,
    SUPPORT,
    OTHER
}
</file>

<file path="src/main/java/com/example/demo/position/enums/PositionLevel.java">
package com.example.demo.position.enums;

public enum PositionLevel {
    JUNIOR,
    MID,
    SENIOR,
    LEAD,
    MANAGER,
    DIRECTOR,
    VP,
    EXECUTIVE
}
</file>

<file path="src/main/java/com/example/demo/position/exception/PositionAlreadyExistsException.java">
package com.example.demo.position.exception;

import com.example.demo.common.exception.BusinessException;

public class PositionAlreadyExistsException extends BusinessException {
    public PositionAlreadyExistsException(String message) {
        super(message);
    }

    public PositionAlreadyExistsException(String message, Throwable cause) {
        super("POSITION_ALREADY_EXISTS", message, cause);
    }

    public static PositionAlreadyExistsException forCode(String code) {
        return new PositionAlreadyExistsException("Position already exists with code: " + code);
    }
}
</file>

<file path="src/main/java/com/example/demo/position/exception/PositionInUseException.java">
package com.example.demo.position.exception;

import com.example.demo.common.exception.BusinessException;

public class PositionInUseException extends BusinessException {
    public PositionInUseException(String message) {
        super(message);
    }

    public PositionInUseException(String message, Throwable cause) {
        super("POSITION_IN_USE", message, cause);
    }

    public PositionInUseException(Long positionId, int employeeCount) {
        super("Position with ID " + positionId + " cannot be deleted as it is assigned to " + employeeCount + " employee(s)");
    }
}
</file>

<file path="src/main/java/com/example/demo/position/exception/PositionNotFoundException.java">
package com.example.demo.position.exception;

import com.example.demo.common.exception.BusinessException;

public class PositionNotFoundException extends BusinessException {
    public PositionNotFoundException(String message) {
        super(message);
    }

    public PositionNotFoundException(String message, Throwable cause) {
        super("POSITION_NOT_FOUND", message, cause);
    }

    public PositionNotFoundException(Long positionId) {
        super("Position not found with ID: " + positionId);
    }

    public PositionNotFoundException(String field, String value) {
        super("Position not found with " + field + ": " + value);
    }
}
</file>

<file path="src/main/java/com/example/demo/position/repository/PositionRepository.java">
package com.example.demo.position.repository;

import com.example.demo.position.entity.Position;
import com.example.demo.position.enums.PositionCategory;
import com.example.demo.position.enums.PositionLevel;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface PositionRepository extends JpaRepository<Position, Long>, JpaSpecificationExecutor<Position> {

    /**
     * Find a position by its unique code.
     *
     * @param code The position code.
     * @return An Optional containing the found position or empty if not found.
     */
    Optional<Position> findByCode(String code);

    /**
     * Check if a position with the given code exists.
     *
     * @param code The position code.
     * @return true if a position with the code exists, false otherwise.
     */
    boolean existsByCode(String code);

    /**
     * Find all positions within a specific department.
     *
     * @param departmentId The ID of the department.
     * @return A list of positions in the specified department.
     */
    List<Position> findByDepartmentId(Long departmentId);

    /**
     * Find all positions matching a specific level.
     *
     * @param level The position level.
     * @return A list of positions with the specified level.
     */
    List<Position> findByLevel(PositionLevel level);

    /**
     * Find all positions belonging to a specific category.
     *
     * @param category The position category.
     * @return A list of positions in the specified category.
     */
    List<Position> findByCategory(PositionCategory category);

    /**
     * Find all enabled positions with pagination.
     *
     * @param pageable Pagination information.
     * @return A Page of enabled positions.
     */
    Page<Position> findByEnabledTrue(Pageable pageable);

    /**
     * Search for positions by job title.
     *
     * @param jobTitle The job title to search for (case-insensitive).
     * @param pageable Pagination information.
     * @return A Page of positions matching the job title.
     */
    Page<Position> findByJobTitleContainingIgnoreCase(String jobTitle, Pageable pageable);

    /**
     * Custom query to find positions by department and filter by job title.
     *
     * @param departmentId The ID of the department.
     * @param jobTitle     A part of the job title to search for.
     * @return A list of matching positions.
     */
    @Query("SELECT p FROM Position p WHERE p.departmentId = :departmentId AND lower(p.jobTitle) LIKE lower(concat('%', :jobTitle, '%'))")
    List<Position> findByDepartmentAndJobTitle(@Param("departmentId") Long departmentId, @Param("jobTitle") String jobTitle);
}
</file>

<file path="src/main/java/com/example/demo/position/service/impl/PositionServiceImpl.java">
package com.example.demo.position.service.impl;

import com.example.demo.department.entity.Department;
import com.example.demo.department.repository.DepartmentRepository;
import com.example.demo.position.dto.*;
import com.example.demo.position.entity.Position;
import com.example.demo.position.enums.PositionCategory;
import com.example.demo.position.enums.PositionLevel;
import com.example.demo.position.exception.PositionAlreadyExistsException;
import com.example.demo.position.exception.PositionInUseException;
import com.example.demo.position.exception.PositionNotFoundException;
import com.example.demo.position.repository.PositionRepository;
import com.example.demo.position.service.PositionService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
@Transactional
public class PositionServiceImpl implements PositionService {

    private final PositionRepository positionRepository;
    private final DepartmentRepository departmentRepository;

    @Override
    public PositionDto createPosition(PositionCreateRequest request) {
        log.info("Creating new position with code: {}", request.getCode());

        // Check if position code already exists
        if (positionRepository.existsByCode(request.getCode())) {
            throw PositionAlreadyExistsException.forCode(request.getCode());
        }

        // Validate department exists
        if (!departmentRepository.existsById(request.getDepartmentId())) {
            throw new IllegalArgumentException("Department not found with ID: " + request.getDepartmentId());
        }

        Position position = new Position();
        position.setJobTitle(request.getJobTitle());
        position.setProfessionalTitle(request.getProfessionalTitle());
        position.setCode(request.getCode());
        position.setDescription(request.getDescription());
        position.setRequirements(request.getRequirements());
        position.setResponsibilities(request.getResponsibilities());
        position.setCategory(request.getCategory());
        position.setSalaryGrade(request.getSalaryGrade());
        position.setDepartmentId(request.getDepartmentId());
        position.setLevel(request.getLevel());
        position.setEnabled(request.getEnabled());
        position.setMinSalary(request.getMinSalary());
        position.setMaxSalary(request.getMaxSalary());
        position.setRequiredSkills(request.getRequiredSkills());
        position.setRequiredEducation(request.getRequiredEducation());
        position.setRequiredExperience(request.getRequiredExperience());
        position.setBenefits(request.getBenefits());
        position.setWorkLocation(request.getWorkLocation());
        position.setEmploymentType(request.getEmploymentType());
        position.setIsManagerial(request.getIsManagerial());

        Position savedPosition = positionRepository.save(position);
        log.info("Position created successfully with ID: {}", savedPosition.getId());

        return convertToDto(savedPosition);
    }

    @Override
    public PositionDto updatePosition(Long id, PositionUpdateRequest request) {
        log.info("Updating position with ID: {}", id);

        Position position = positionRepository.findById(id)
                .orElseThrow(() -> new PositionNotFoundException(id));

        // Validate department exists
        if (!departmentRepository.existsById(request.getDepartmentId())) {
            throw new IllegalArgumentException("Department not found with ID: " + request.getDepartmentId());
        }

        position.setJobTitle(request.getJobTitle());
        position.setProfessionalTitle(request.getProfessionalTitle());
        position.setDescription(request.getDescription());
        position.setRequirements(request.getRequirements());
        position.setResponsibilities(request.getResponsibilities());
        position.setCategory(request.getCategory());
        position.setSalaryGrade(request.getSalaryGrade());
        position.setDepartmentId(request.getDepartmentId());
        position.setLevel(request.getLevel());
        position.setEnabled(request.getEnabled());
        position.setMinSalary(request.getMinSalary());
        position.setMaxSalary(request.getMaxSalary());
        position.setRequiredSkills(request.getRequiredSkills());
        position.setRequiredEducation(request.getRequiredEducation());
        position.setRequiredExperience(request.getRequiredExperience());
        position.setBenefits(request.getBenefits());
        position.setWorkLocation(request.getWorkLocation());
        position.setEmploymentType(request.getEmploymentType());
        position.setIsManagerial(request.getIsManagerial());

        Position updatedPosition = positionRepository.save(position);
        log.info("Position updated successfully with ID: {}", updatedPosition.getId());

        return convertToDto(updatedPosition);
    }

    @Override
    @Transactional(readOnly = true)
    public PositionDto getPositionById(Long id) {
        Position position = positionRepository.findById(id)
                .orElseThrow(() -> new PositionNotFoundException(id));
        return convertToDto(position);
    }

    @Override
    @Transactional(readOnly = true)
    public PositionDto getPositionByCode(String code) {
        Position position = positionRepository.findByCode(code)
                .orElseThrow(() -> new PositionNotFoundException("code", code));
        return convertToDto(position);
    }

    @Override
    @Transactional(readOnly = true)
    public Page<PositionDto> getAllPositions(Pageable pageable) {
        return positionRepository.findAll(pageable)
                .map(this::convertToDto);
    }

    @Override
    @Transactional(readOnly = true)
    public Page<PositionDto> searchPositions(PositionSearchCriteria criteria, Pageable pageable) {
        Specification<Position> spec = buildSearchSpecification(criteria);
        return positionRepository.findAll(spec, pageable)
                .map(this::convertToDto);
    }

    @Override
    @Transactional(readOnly = true)
    public List<PositionDto> getPositionsByDepartment(Long departmentId) {
        return positionRepository.findByDepartmentId(departmentId)
                .stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public List<PositionDto> getPositionsByCategory(PositionCategory category) {
        return positionRepository.findByCategory(category)
                .stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public List<PositionDto> getPositionsByLevel(PositionLevel level) {
        return positionRepository.findByLevel(level)
                .stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public Page<PositionDto> getEnabledPositions(Pageable pageable) {
        return positionRepository.findByEnabledTrue(pageable)
                .map(this::convertToDto);
    }

    @Override
    public void deletePosition(Long id) {
        log.info("Deleting position with ID: {}", id);

        Position position = positionRepository.findById(id)
                .orElseThrow(() -> new PositionNotFoundException(id));

        // Check if position is in use by employees
        int employeeCount = position.getEmployees().size();
        if (employeeCount > 0) {
            throw new PositionInUseException(id, employeeCount);
        }

        positionRepository.delete(position);
        log.info("Position deleted successfully with ID: {}", id);
    }

    @Override
    public PositionDto togglePositionStatus(Long id, boolean enabled) {
        log.info("Toggling position status for ID: {} to {}", id, enabled);

        Position position = positionRepository.findById(id)
                .orElseThrow(() -> new PositionNotFoundException(id));

        position.setEnabled(enabled);
        Position updatedPosition = positionRepository.save(position);

        log.info("Position status updated successfully for ID: {}", id);
        return convertToDto(updatedPosition);
    }

    @Override
    @Transactional(readOnly = true)
    public boolean existsByCode(String code) {
        return positionRepository.existsByCode(code);
    }

    @Override
    @Transactional(readOnly = true)
    public PositionStatisticsDto getPositionStatistics() {
        List<Position> allPositions = positionRepository.findAll();
        
        PositionStatisticsDto stats = new PositionStatisticsDto();
        stats.setTotalPositions((long) allPositions.size());
        
        long enabledCount = allPositions.stream().mapToLong(p -> p.getEnabled() ? 1 : 0).sum();
        stats.setEnabledPositions(enabledCount);
        stats.setDisabledPositions(stats.getTotalPositions() - enabledCount);
        
        // Group by category
        Map<String, Long> categoryStats = allPositions.stream()
                .collect(Collectors.groupingBy(p -> p.getCategory().name(), Collectors.counting()));
        stats.setPositionsByCategory(categoryStats);
        
        // Group by level
        Map<String, Long> levelStats = allPositions.stream()
                .collect(Collectors.groupingBy(p -> p.getLevel().name(), Collectors.counting()));
        stats.setPositionsByLevel(levelStats);
        
        // Group by employment type
        Map<String, Long> employmentTypeStats = allPositions.stream()
                .collect(Collectors.groupingBy(p -> p.getEmploymentType().name(), Collectors.counting()));
        stats.setPositionsByEmploymentType(employmentTypeStats);
        
        // Managerial vs non-managerial
        long managerialCount = allPositions.stream().mapToLong(p -> p.getIsManagerial() ? 1 : 0).sum();
        stats.setManagerialPositions(managerialCount);
        stats.setNonManagerialPositions(stats.getTotalPositions() - managerialCount);
        
        // Average salaries
        double avgMinSalary = allPositions.stream()
                .filter(p -> p.getMinSalary() != null)
                .mapToDouble(p -> p.getMinSalary().doubleValue())
                .average()
                .orElse(0.0);
        stats.setAverageMinSalary(avgMinSalary);
        
        double avgMaxSalary = allPositions.stream()
                .filter(p -> p.getMaxSalary() != null)
                .mapToDouble(p -> p.getMaxSalary().doubleValue())
                .average()
                .orElse(0.0);
        stats.setAverageMaxSalary(avgMaxSalary);
        
        return stats;
    }

    @Override
    public PositionDto convertToDto(Position position) {
        PositionDto dto = new PositionDto();
        dto.setId(position.getId());
        dto.setJobTitle(position.getJobTitle());
        dto.setProfessionalTitle(position.getProfessionalTitle());
        dto.setCode(position.getCode());
        dto.setDescription(position.getDescription());
        dto.setRequirements(position.getRequirements());
        dto.setResponsibilities(position.getResponsibilities());
        dto.setCategory(position.getCategory());
        dto.setSalaryGrade(position.getSalaryGrade());
        dto.setDepartmentId(position.getDepartmentId());
        dto.setLevel(position.getLevel());
        dto.setEnabled(position.getEnabled());
        dto.setMinSalary(position.getMinSalary());
        dto.setMaxSalary(position.getMaxSalary());
        dto.setRequiredSkills(position.getRequiredSkills());
        dto.setRequiredEducation(position.getRequiredEducation());
        dto.setRequiredExperience(position.getRequiredExperience());
        dto.setBenefits(position.getBenefits());
        dto.setWorkLocation(position.getWorkLocation());
        dto.setEmploymentType(position.getEmploymentType());
        dto.setIsManagerial(position.getIsManagerial());
        dto.setCreatedAt(position.getCreatedAt());
        dto.setUpdatedAt(position.getUpdatedAt());
        dto.setCreatedBy(position.getCreatedBy());
        dto.setUpdatedBy(position.getUpdatedBy());
        
        // Set department name if department is loaded
        if (position.getDepartment() != null) {
            dto.setDepartmentName(position.getDepartment().getName());
        }
        
        // Set employee count
        dto.setEmployeeCount(position.getEmployees().size());
        
        return dto;
    }

    @Override
    public Position convertToEntity(PositionDto dto) {
        Position position = new Position();
        position.setId(dto.getId());
        position.setJobTitle(dto.getJobTitle());
        position.setProfessionalTitle(dto.getProfessionalTitle());
        position.setCode(dto.getCode());
        position.setDescription(dto.getDescription());
        position.setRequirements(dto.getRequirements());
        position.setResponsibilities(dto.getResponsibilities());
        position.setCategory(dto.getCategory());
        position.setSalaryGrade(dto.getSalaryGrade());
        position.setDepartmentId(dto.getDepartmentId());
        position.setLevel(dto.getLevel());
        position.setEnabled(dto.getEnabled());
        position.setMinSalary(dto.getMinSalary());
        position.setMaxSalary(dto.getMaxSalary());
        position.setRequiredSkills(dto.getRequiredSkills());
        position.setRequiredEducation(dto.getRequiredEducation());
        position.setRequiredExperience(dto.getRequiredExperience());
        position.setBenefits(dto.getBenefits());
        position.setWorkLocation(dto.getWorkLocation());
        position.setEmploymentType(dto.getEmploymentType());
        position.setIsManagerial(dto.getIsManagerial());
        position.setCreatedAt(dto.getCreatedAt());
        position.setUpdatedAt(dto.getUpdatedAt());
        position.setCreatedBy(dto.getCreatedBy());
        position.setUpdatedBy(dto.getUpdatedBy());
        
        return position;
    }

    private Specification<Position> buildSearchSpecification(PositionSearchCriteria criteria) {
        return (root, query, criteriaBuilder) -> {
            var predicates = new java.util.ArrayList<jakarta.persistence.criteria.Predicate>();

            if (criteria.getJobTitle() != null && !criteria.getJobTitle().trim().isEmpty()) {
                predicates.add(criteriaBuilder.like(
                        criteriaBuilder.lower(root.get("jobTitle")),
                        "%" + criteria.getJobTitle().toLowerCase() + "%"
                ));
            }

            if (criteria.getProfessionalTitle() != null && !criteria.getProfessionalTitle().trim().isEmpty()) {
                predicates.add(criteriaBuilder.like(
                        criteriaBuilder.lower(root.get("professionalTitle")),
                        "%" + criteria.getProfessionalTitle().toLowerCase() + "%"
                ));
            }

            if (criteria.getCode() != null && !criteria.getCode().trim().isEmpty()) {
                predicates.add(criteriaBuilder.like(
                        criteriaBuilder.lower(root.get("code")),
                        "%" + criteria.getCode().toLowerCase() + "%"
                ));
            }

            if (criteria.getCategory() != null) {
                predicates.add(criteriaBuilder.equal(root.get("category"), criteria.getCategory()));
            }

            if (criteria.getDepartmentId() != null) {
                predicates.add(criteriaBuilder.equal(root.get("departmentId"), criteria.getDepartmentId()));
            }

            if (criteria.getLevel() != null) {
                predicates.add(criteriaBuilder.equal(root.get("level"), criteria.getLevel()));
            }

            if (criteria.getEnabled() != null) {
                predicates.add(criteriaBuilder.equal(root.get("enabled"), criteria.getEnabled()));
            }

            if (criteria.getEmploymentType() != null) {
                predicates.add(criteriaBuilder.equal(root.get("employmentType"), criteria.getEmploymentType()));
            }

            if (criteria.getIsManagerial() != null) {
                predicates.add(criteriaBuilder.equal(root.get("isManagerial"), criteria.getIsManagerial()));
            }

            if (criteria.getMinSalaryFrom() != null) {
                predicates.add(criteriaBuilder.greaterThanOrEqualTo(root.get("minSalary"), criteria.getMinSalaryFrom()));
            }

            if (criteria.getMinSalaryTo() != null) {
                predicates.add(criteriaBuilder.lessThanOrEqualTo(root.get("minSalary"), criteria.getMinSalaryTo()));
            }

            if (criteria.getMaxSalaryFrom() != null) {
                predicates.add(criteriaBuilder.greaterThanOrEqualTo(root.get("maxSalary"), criteria.getMaxSalaryFrom()));
            }

            if (criteria.getMaxSalaryTo() != null) {
                predicates.add(criteriaBuilder.lessThanOrEqualTo(root.get("maxSalary"), criteria.getMaxSalaryTo()));
            }

            if (criteria.getMinExperience() != null) {
                predicates.add(criteriaBuilder.greaterThanOrEqualTo(root.get("requiredExperience"), criteria.getMinExperience()));
            }

            if (criteria.getMaxExperience() != null) {
                predicates.add(criteriaBuilder.lessThanOrEqualTo(root.get("requiredExperience"), criteria.getMaxExperience()));
            }

            if (criteria.getWorkLocation() != null && !criteria.getWorkLocation().trim().isEmpty()) {
                predicates.add(criteriaBuilder.like(
                        criteriaBuilder.lower(root.get("workLocation")),
                        "%" + criteria.getWorkLocation().toLowerCase() + "%"
                ));
            }

            return criteriaBuilder.and(predicates.toArray(new jakarta.persistence.criteria.Predicate[0]));
        };
    }
}
</file>

<file path="src/main/java/com/example/demo/position/service/PositionService.java">
package com.example.demo.position.service;

import com.example.demo.position.dto.PositionCreateRequest;
import com.example.demo.position.dto.PositionDto;
import com.example.demo.position.dto.PositionSearchCriteria;
import com.example.demo.position.dto.PositionStatisticsDto;
import com.example.demo.position.dto.PositionUpdateRequest;
import com.example.demo.position.entity.Position;
import com.example.demo.position.enums.PositionCategory;
import com.example.demo.position.enums.PositionLevel;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import java.util.List;

public interface PositionService {
    
    /**
     * Create a new position.
     *
     * @param request The position creation request.
     * @return The created position DTO.
     */
    PositionDto createPosition(PositionCreateRequest request);

    /**
     * Update an existing position.
     *
     * @param id The position ID.
     * @param request The position update request.
     * @return The updated position DTO.
     */
    PositionDto updatePosition(Long id, PositionUpdateRequest request);

    /**
     * Get a position by ID.
     *
     * @param id The position ID.
     * @return The position DTO.
     */
    PositionDto getPositionById(Long id);

    /**
     * Get a position by code.
     *
     * @param code The position code.
     * @return The position DTO.
     */
    PositionDto getPositionByCode(String code);

    /**
     * Get all positions with pagination.
     *
     * @param pageable Pagination information.
     * @return A page of position DTOs.
     */
    Page<PositionDto> getAllPositions(Pageable pageable);

    /**
     * Search positions based on criteria.
     *
     * @param criteria The search criteria.
     * @param pageable Pagination information.
     * @return A page of position DTOs matching the criteria.
     */
    Page<PositionDto> searchPositions(PositionSearchCriteria criteria, Pageable pageable);

    /**
     * Get positions by department.
     *
     * @param departmentId The department ID.
     * @return A list of position DTOs in the department.
     */
    List<PositionDto> getPositionsByDepartment(Long departmentId);

    /**
     * Get positions by category.
     *
     * @param category The position category.
     * @return A list of position DTOs in the category.
     */
    List<PositionDto> getPositionsByCategory(PositionCategory category);

    /**
     * Get positions by level.
     *
     * @param level The position level.
     * @return A list of position DTOs at the level.
     */
    List<PositionDto> getPositionsByLevel(PositionLevel level);

    /**
     * Get only enabled positions.
     *
     * @param pageable Pagination information.
     * @return A page of enabled position DTOs.
     */
    Page<PositionDto> getEnabledPositions(Pageable pageable);

    /**
     * Delete a position by ID.
     *
     * @param id The position ID.
     */
    void deletePosition(Long id);

    /**
     * Enable or disable a position.
     *
     * @param id The position ID.
     * @param enabled Whether to enable or disable the position.
     * @return The updated position DTO.
     */
    PositionDto togglePositionStatus(Long id, boolean enabled);

    /**
     * Check if a position code exists.
     *
     * @param code The position code.
     * @return true if the code exists, false otherwise.
     */
    boolean existsByCode(String code);

    /**
     * Get position statistics.
     *
     * @return Position statistics.
     */
    PositionStatisticsDto getPositionStatistics();

    /**
     * Convert entity to DTO.
     *
     * @param position The position entity.
     * @return The position DTO.
     */
    PositionDto convertToDto(Position position);

    /**
     * Convert DTO to entity.
     *
     * @param dto The position DTO.
     * @return The position entity.
     */
    Position convertToEntity(PositionDto dto);
}
</file>

<file path="src/main/java/com/example/demo/security/controller/AuthController.java">
package com.example.demo.security.controller;

import com.example.demo.common.dto.ApiResponse;
import com.example.demo.security.dto.LoginRequest;
import com.example.demo.security.dto.LoginResponse;
import com.example.demo.security.service.AuthenticationService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

/**
 * Authentication Controller
 * 
 * Handles user authentication operations including login, logout, and token refresh.
 * All endpoints in this controller are publicly accessible.
 */
@RestController
@RequestMapping("/api/auth")
@RequiredArgsConstructor
@Slf4j
@Tag(name = "Authentication", description = "User authentication and token management")
public class AuthController {
    
    private final AuthenticationService authenticationService;
    
    /**
     * Authenticate user with username and password
     * 
     * @param loginRequest Login credentials containing username and password
     * @return JWT token and user information upon successful authentication
     */
    @PostMapping("/login")
    @Operation(
        summary = "User login",
        description = "Authenticate user with username and password. Returns JWT token upon success."
    )
    @ApiResponses(value = {
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "200", 
            description = "Login successful"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "401", 
            description = "Invalid credentials"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "423", 
            description = "Account locked due to too many failed attempts"
        )
    })
    public ResponseEntity<ApiResponse<LoginResponse>> login(
            @Valid @RequestBody LoginRequest loginRequest,
            HttpServletRequest request) {
        
        log.info("Login attempt for username: {}", loginRequest.getUsername());
        
        try {
            LoginResponse loginResponse = authenticationService.authenticate(loginRequest);
            
            log.info("Login successful for username: {}", loginRequest.getUsername());
            
            return ResponseEntity.ok(
                ApiResponse.success(loginResponse, "Login successful")
            );
            
        } catch (Exception e) {
            log.warn("Login failed for username: {} - {}", loginRequest.getUsername(), e.getMessage());
            throw e; // Let global exception handler deal with it
        }
    }
    
    /**
     * Logout user by invalidating JWT token
     * 
     * @param request HTTP request containing Authorization header with JWT token
     * @return Success message upon successful logout
     */
    @PostMapping("/logout")
    @Operation(
        summary = "User logout",
        description = "Invalidate JWT token and logout user. Token will be blacklisted."
    )
    @ApiResponses(value = {
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "200", 
            description = "Logout successful"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "400", 
            description = "Invalid or missing token"
        )
    })
    public ResponseEntity<ApiResponse<Void>> logout(HttpServletRequest request) {
        
        String authHeader = request.getHeader("Authorization");
        
        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            return ResponseEntity.badRequest().body(
                ApiResponse.error("Missing or invalid Authorization header")
            );
        }
        
        String token = authHeader.substring(7);
        String username = authenticationService.getUsernameFromToken(token);
        
        log.info("Logout request for user: {}", username);
        
        try {
            authenticationService.logout(token);
            
            log.info("Logout successful for user: {}", username);
            
            return ResponseEntity.ok(
                ApiResponse.success(null, "Logout successful")
            );
            
        } catch (Exception e) {
            log.warn("Logout failed for user: {} - {}", username, e.getMessage());
            throw e;
        }
    }
    
    /**
     * Refresh JWT token
     * 
     * @param refreshToken Refresh token from the original login response
     * @return New JWT token with extended expiration
     */
    @PostMapping("/refresh-token")
    @Operation(
        summary = "Refresh JWT token",
        description = "Generate new JWT token using refresh token. Extends user session."
    )
    @ApiResponses(value = {
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "200", 
            description = "Token refreshed successfully"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "401", 
            description = "Invalid or expired refresh token"
        )
    })
    public ResponseEntity<ApiResponse<LoginResponse>> refreshToken(
            @Parameter(description = "Refresh token", required = true)
            @RequestParam String refreshToken) {
        
        log.info("Token refresh request");
        
        try {
            LoginResponse loginResponse = authenticationService.refreshToken(refreshToken);
            
            log.info("Token refresh successful for user: {}", loginResponse.getUser().getUsername());
            
            return ResponseEntity.ok(
                ApiResponse.success(loginResponse, "Token refreshed successfully")
            );
            
        } catch (Exception e) {
            log.warn("Token refresh failed - {}", e.getMessage());
            throw e;
        }
    }
    
    /**
     * Validate JWT token
     * 
     * @param request HTTP request containing Authorization header with JWT token
     * @return Token validation status
     */
    @GetMapping("/validate-token")
    @Operation(
        summary = "Validate JWT token",
        description = "Check if JWT token is valid and not expired"
    )
    @ApiResponses(value = {
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "200", 
            description = "Token validation result"
        )
    })
    public ResponseEntity<ApiResponse<Boolean>> validateToken(HttpServletRequest request) {
        
        String authHeader = request.getHeader("Authorization");
        
        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            return ResponseEntity.ok(
                ApiResponse.success(false, "Missing or invalid Authorization header")
            );
        }
        
        String token = authHeader.substring(7);
        
        try {
            boolean isValid = authenticationService.validateToken(token);
            String message = isValid ? "Token is valid" : "Token is invalid or expired";
            
            return ResponseEntity.ok(
                ApiResponse.success(isValid, message)
            );
            
        } catch (Exception e) {
            log.warn("Token validation error - {}", e.getMessage());
            return ResponseEntity.ok(
                ApiResponse.success(false, "Token validation failed")
            );
        }
    }
}
</file>

<file path="src/main/java/com/example/demo/security/controller/RoleController.java">
package com.example.demo.security.controller;

import com.example.demo.common.dto.ApiResponse;
import com.example.demo.security.dto.RoleDto;
import com.example.demo.security.service.RoleService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Set;

/**
 * Role Management Controller
 * 
 * Handles role management operations including CRUD operations and resource assignments.
 * All endpoints require authentication and appropriate permissions.
 */
@RestController
@RequestMapping("/api/roles")
@RequiredArgsConstructor
@Slf4j
@Tag(name = "Role Management", description = "Role CRUD operations and resource management")
@SecurityRequirement(name = "bearerAuth")
public class RoleController {
    
    private final RoleService roleService;
    
    /**
     * Get all roles
     * 
     * @return List of all roles
     */
    @GetMapping
    @Operation(
        summary = "Get all roles",
        description = "Retrieve list of all roles. Requires ROLE_READ permission."
    )
    @ApiResponses(value = {
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "200", 
            description = "Roles retrieved successfully"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "403", 
            description = "Insufficient permissions"
        )
    })
    @PreAuthorize("hasAuthority('ROLE_READ')")
    public ResponseEntity<ApiResponse<List<RoleDto>>> getAllRoles() {
        
        log.info("Fetching all roles");
        
        List<RoleDto> roles = roleService.getAllRoles();
        
        log.info("Retrieved {} roles", roles.size());
        
        return ResponseEntity.ok(
            ApiResponse.success(roles, "Roles retrieved successfully")
        );
    }
    
    /**
     * Get all roles with pagination
     * 
     * @param pageable Pagination parameters
     * @return Paginated list of roles
     */
    @GetMapping("/paginated")
    @Operation(
        summary = "Get all roles with pagination",
        description = "Retrieve paginated list of all roles. Requires ROLE_READ permission."
    )
    @ApiResponses(value = {
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "200", 
            description = "Roles retrieved successfully"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "403", 
            description = "Insufficient permissions"
        )
    })
    @PreAuthorize("hasAuthority('ROLE_READ')")
    public ResponseEntity<ApiResponse<Page<RoleDto>>> getAllRolesPaginated(
            @PageableDefault(size = 20) Pageable pageable) {
        
        log.info("Fetching all roles with pagination: {}", pageable);
        
        Page<RoleDto> roles = roleService.getAllRoles(pageable);
        
        log.info("Retrieved {} roles", roles.getTotalElements());
        
        return ResponseEntity.ok(
            ApiResponse.success(roles, "Roles retrieved successfully")
        );
    }    

    /**
     * Get role by ID
     * 
     * @param id Role ID
     * @return Role details
     */
    @GetMapping("/{id}")
    @Operation(
        summary = "Get role by ID",
        description = "Retrieve role details by ID. Requires ROLE_READ permission."
    )
    @ApiResponses(value = {
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "200", 
            description = "Role found"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "404", 
            description = "Role not found"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "403", 
            description = "Insufficient permissions"
        )
    })
    @PreAuthorize("hasAuthority('ROLE_READ')")
    public ResponseEntity<ApiResponse<RoleDto>> getRoleById(
            @Parameter(description = "Role ID", required = true)
            @PathVariable Long id) {
        
        log.info("Fetching role with ID: {}", id);
        
        RoleDto role = roleService.getRoleById(id);
        
        log.info("Retrieved role: {}", role.getName());
        
        return ResponseEntity.ok(
            ApiResponse.success(role, "Role retrieved successfully")
        );
    }
    
    /**
     * Search roles by name
     * 
     * @param searchTerm Search term for role name
     * @return List of matching roles
     */
    @GetMapping("/search")
    @Operation(
        summary = "Search roles",
        description = "Search roles by name. Requires ROLE_READ permission."
    )
    @ApiResponses(value = {
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "200", 
            description = "Search completed successfully"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "403", 
            description = "Insufficient permissions"
        )
    })
    @PreAuthorize("hasAuthority('ROLE_READ')")
    public ResponseEntity<ApiResponse<List<RoleDto>>> searchRoles(
            @Parameter(description = "Search term", required = true)
            @RequestParam String searchTerm) {
        
        log.info("Searching roles with term: '{}'", searchTerm);
        
        List<RoleDto> roles = roleService.searchRoles(searchTerm);
        
        log.info("Found {} roles matching search term", roles.size());
        
        return ResponseEntity.ok(
            ApiResponse.success(roles, "Search completed successfully")
        );
    }
    
    /**
     * Create new role
     * 
     * @param roleDto Role creation data
     * @return Created role details
     */
    @PostMapping
    @Operation(
        summary = "Create new role",
        description = "Create a new role. Requires ROLE_CREATE permission."
    )
    @ApiResponses(value = {
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "201", 
            description = "Role created successfully"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "400", 
            description = "Invalid role data"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "409", 
            description = "Role name already exists"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "403", 
            description = "Insufficient permissions"
        )
    })
    @PreAuthorize("hasAuthority('ROLE_CREATE')")
    public ResponseEntity<ApiResponse<RoleDto>> createRole(
            @Valid @RequestBody RoleDto roleDto) {
        
        log.info("Creating new role with name: {}", roleDto.getName());
        
        RoleDto createdRole = roleService.createRole(roleDto);
        
        log.info("Role created successfully with ID: {}", createdRole.getId());
        
        return ResponseEntity.status(HttpStatus.CREATED).body(
            ApiResponse.success(createdRole, "Role created successfully")
        );
    }  
  
    /**
     * Update existing role
     * 
     * @param id Role ID
     * @param roleDto Updated role data
     * @return Updated role details
     */
    @PutMapping("/{id}")
    @Operation(
        summary = "Update role",
        description = "Update existing role details. Requires ROLE_UPDATE permission."
    )
    @ApiResponses(value = {
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "200", 
            description = "Role updated successfully"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "400", 
            description = "Invalid role data"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "404", 
            description = "Role not found"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "403", 
            description = "Insufficient permissions"
        )
    })
    @PreAuthorize("hasAuthority('ROLE_UPDATE')")
    public ResponseEntity<ApiResponse<RoleDto>> updateRole(
            @Parameter(description = "Role ID", required = true)
            @PathVariable Long id,
            @Valid @RequestBody RoleDto roleDto) {
        
        log.info("Updating role with ID: {}", id);
        
        RoleDto updatedRole = roleService.updateRole(id, roleDto);
        
        log.info("Role updated successfully: {}", updatedRole.getName());
        
        return ResponseEntity.ok(
            ApiResponse.success(updatedRole, "Role updated successfully")
        );
    }
    
    /**
     * Delete role
     * 
     * @param id Role ID
     * @return Success message
     */
    @DeleteMapping("/{id}")
    @Operation(
        summary = "Delete role",
        description = "Delete role. Requires ROLE_DELETE permission."
    )
    @ApiResponses(value = {
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "200", 
            description = "Role deleted successfully"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "404", 
            description = "Role not found"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "409", 
            description = "Role is in use and cannot be deleted"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "403", 
            description = "Insufficient permissions"
        )
    })
    @PreAuthorize("hasAuthority('ROLE_DELETE')")
    public ResponseEntity<ApiResponse<Void>> deleteRole(
            @Parameter(description = "Role ID", required = true)
            @PathVariable Long id) {
        
        log.info("Deleting role with ID: {}", id);
        
        roleService.deleteRole(id);
        
        log.info("Role deleted successfully with ID: {}", id);
        
        return ResponseEntity.ok(
            ApiResponse.success(null, "Role deleted successfully")
        );
    }
    
    /**
     * Enable or disable role
     * 
     * @param id Role ID
     * @param enabled Enable/disable flag
     * @return Success message
     */
    @PatchMapping("/{id}/enabled")
    @Operation(
        summary = "Enable/disable role",
        description = "Enable or disable role. Requires ROLE_UPDATE permission."
    )
    @ApiResponses(value = {
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "200", 
            description = "Role status updated successfully"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "404", 
            description = "Role not found"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "403", 
            description = "Insufficient permissions"
        )
    })
    @PreAuthorize("hasAuthority('ROLE_UPDATE')")
    public ResponseEntity<ApiResponse<Void>> setRoleEnabled(
            @Parameter(description = "Role ID", required = true)
            @PathVariable Long id,
            @Parameter(description = "Enable/disable flag", required = true)
            @RequestParam boolean enabled) {
        
        log.info("Setting role {} enabled status to: {}", id, enabled);
        
        roleService.setRoleEnabled(id, enabled);
        
        String action = enabled ? "enabled" : "disabled";
        log.info("Role {} successfully {}", id, action);
        
        return ResponseEntity.ok(
            ApiResponse.success(null, "Role " + action + " successfully")
        );
    }  
  
    /**
     * Assign resources to role
     * 
     * @param id Role ID
     * @param resourceIds Set of resource IDs to assign
     * @return Success message
     */
    @PostMapping("/{id}/resources")
    @Operation(
        summary = "Assign resources to role",
        description = "Assign one or more resources to role. Requires RESOURCE_ASSIGN permission."
    )
    @ApiResponses(value = {
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "200", 
            description = "Resources assigned successfully"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "404", 
            description = "Role or resource not found"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "403", 
            description = "Insufficient permissions"
        )
    })
    @PreAuthorize("hasAuthority('RESOURCE_ASSIGN')")
    public ResponseEntity<ApiResponse<Void>> assignResourcesToRole(
            @Parameter(description = "Role ID", required = true)
            @PathVariable Long id,
            @Parameter(description = "Resource IDs to assign", required = true)
            @RequestBody Set<Long> resourceIds) {
        
        log.info("Assigning resources {} to role ID: {}", resourceIds, id);
        
        roleService.assignResourcesToRole(id, resourceIds);
        
        log.info("Resources assigned successfully to role ID: {}", id);
        
        return ResponseEntity.ok(
            ApiResponse.success(null, "Resources assigned successfully")
        );
    }
    
    /**
     * Remove resources from role
     * 
     * @param id Role ID
     * @param resourceIds Set of resource IDs to remove
     * @return Success message
     */
    @DeleteMapping("/{id}/resources")
    @Operation(
        summary = "Remove resources from role",
        description = "Remove one or more resources from role. Requires RESOURCE_ASSIGN permission."
    )
    @ApiResponses(value = {
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "200", 
            description = "Resources removed successfully"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "404", 
            description = "Role not found"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "403", 
            description = "Insufficient permissions"
        )
    })
    @PreAuthorize("hasAuthority('RESOURCE_ASSIGN')")
    public ResponseEntity<ApiResponse<Void>> removeResourcesFromRole(
            @Parameter(description = "Role ID", required = true)
            @PathVariable Long id,
            @Parameter(description = "Resource IDs to remove", required = true)
            @RequestBody Set<Long> resourceIds) {
        
        log.info("Removing resources {} from role ID: {}", resourceIds, id);
        
        roleService.removeResourcesFromRole(id, resourceIds);
        
        log.info("Resources removed successfully from role ID: {}", id);
        
        return ResponseEntity.ok(
            ApiResponse.success(null, "Resources removed successfully")
        );
    }
    
    /**
     * Get role permissions
     * 
     * @param id Role ID
     * @return Set of role permissions
     */
    @GetMapping("/{id}/permissions")
    @Operation(
        summary = "Get role permissions",
        description = "Retrieve all permissions for role. Requires ROLE_READ permission."
    )
    @ApiResponses(value = {
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "200", 
            description = "Role permissions retrieved successfully"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "404", 
            description = "Role not found"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "403", 
            description = "Insufficient permissions"
        )
    })
    @PreAuthorize("hasAuthority('ROLE_READ')")
    public ResponseEntity<ApiResponse<Set<String>>> getRolePermissions(
            @Parameter(description = "Role ID", required = true)
            @PathVariable Long id) {
        
        log.info("Fetching permissions for role ID: {}", id);
        
        Set<String> permissions = roleService.getRolePermissions(id);
        
        log.info("Retrieved {} permissions for role ID: {}", permissions.size(), id);
        
        return ResponseEntity.ok(
            ApiResponse.success(permissions, "Role permissions retrieved successfully")
        );
    }
}
</file>

<file path="src/main/java/com/example/demo/security/controller/UserController.java">
package com.example.demo.security.controller;

import com.example.demo.common.dto.ApiResponse;
import com.example.demo.security.dto.UserCreateRequest;
import com.example.demo.security.dto.UserDto;
import com.example.demo.security.dto.UserUpdateRequest;
import com.example.demo.security.service.UserService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.Set;

/**
 * User Management Controller
 * 
 * Handles user management operations including CRUD operations, role assignments,
 * and user permissions. All endpoints require authentication and appropriate permissions.
 */
@RestController
@RequestMapping("/api/users")
@RequiredArgsConstructor
@Slf4j
@Tag(name = "User Management", description = "User CRUD operations and role management")
@SecurityRequirement(name = "bearerAuth")
public class UserController {
    
    private final UserService userService;    

    /**
     * Get all users with pagination
     * 
     * @param pageable Pagination parameters
     * @return Paginated list of users
     */
    @GetMapping
    @Operation(
        summary = "Get all users",
        description = "Retrieve paginated list of all users. Requires USER_READ permission."
    )
    @ApiResponses(value = {
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "200", 
            description = "Users retrieved successfully"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "403", 
            description = "Insufficient permissions"
        )
    })
    @PreAuthorize("hasAuthority('USER_READ')")
    public ResponseEntity<ApiResponse<Page<UserDto>>> getAllUsers(
            @PageableDefault(size = 20) Pageable pageable) {
        
        log.info("Fetching all users with pagination: {}", pageable);
        
        Page<UserDto> users = userService.getAllUsers(pageable);
        
        log.info("Retrieved {} users", users.getTotalElements());
        
        return ResponseEntity.ok(
            ApiResponse.success(users, "Users retrieved successfully")
        );
    }
    
    /**
     * Get user by ID
     * 
     * @param id User ID
     * @return User details
     */
    @GetMapping("/{id}")
    @Operation(
        summary = "Get user by ID",
        description = "Retrieve user details by ID. Requires USER_READ permission."
    )
    @ApiResponses(value = {
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "200", 
            description = "User found"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "404", 
            description = "User not found"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "403", 
            description = "Insufficient permissions"
        )
    })
    @PreAuthorize("hasAuthority('USER_READ')")
    public ResponseEntity<ApiResponse<UserDto>> getUserById(
            @Parameter(description = "User ID", required = true)
            @PathVariable Long id) {
        
        log.info("Fetching user with ID: {}", id);
        
        UserDto user = userService.getUserById(id);
        
        log.info("Retrieved user: {}", user.getUsername());
        
        return ResponseEntity.ok(
            ApiResponse.success(user, "User retrieved successfully")
        );
    }    
    
/**
     * Search users by criteria
     * 
     * @param searchTerm Search term for username, first name, or last name
     * @param pageable Pagination parameters
     * @return Paginated list of matching users
     */
    @GetMapping("/search")
    @Operation(
        summary = "Search users",
        description = "Search users by username, first name, or last name. Requires USER_READ permission."
    )
    @ApiResponses(value = {
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "200", 
            description = "Search completed successfully"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "403", 
            description = "Insufficient permissions"
        )
    })
    @PreAuthorize("hasAuthority('USER_READ')")
    public ResponseEntity<ApiResponse<Page<UserDto>>> searchUsers(
            @Parameter(description = "Search term", required = true)
            @RequestParam String searchTerm,
            @PageableDefault(size = 20) Pageable pageable) {
        
        log.info("Searching users with term: '{}', pagination: {}", searchTerm, pageable);
        
        Page<UserDto> users = userService.searchUsers(searchTerm, pageable);
        
        log.info("Found {} users matching search term", users.getTotalElements());
        
        return ResponseEntity.ok(
            ApiResponse.success(users, "Search completed successfully")
        );
    }
    
    /**
     * Create new user
     * 
     * @param createRequest User creation data
     * @return Created user details
     */
    @PostMapping
    @Operation(
        summary = "Create new user",
        description = "Create a new user account. Requires USER_CREATE permission."
    )
    @ApiResponses(value = {
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "201", 
            description = "User created successfully"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "400", 
            description = "Invalid user data"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "409", 
            description = "Username or email already exists"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "403", 
            description = "Insufficient permissions"
        )
    })
    @PreAuthorize("hasAuthority('USER_CREATE')")
    public ResponseEntity<ApiResponse<UserDto>> createUser(
            @Valid @RequestBody UserCreateRequest createRequest) {
        
        log.info("Creating new user with username: {}", createRequest.getUsername());
        
        UserDto createdUser = userService.createUser(createRequest);
        
        log.info("User created successfully with ID: {}", createdUser.getId());
        
        return ResponseEntity.status(HttpStatus.CREATED).body(
            ApiResponse.success(createdUser, "User created successfully")
        );
    }    

    /**
     * Update existing user
     * 
     * @param id User ID
     * @param updateRequest Updated user data
     * @return Updated user details
     */
    @PutMapping("/{id}")
    @Operation(
        summary = "Update user",
        description = "Update existing user details. Requires USER_UPDATE permission."
    )
    @ApiResponses(value = {
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "200", 
            description = "User updated successfully"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "400", 
            description = "Invalid user data"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "404", 
            description = "User not found"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "403", 
            description = "Insufficient permissions"
        )
    })
    @PreAuthorize("hasAuthority('USER_UPDATE')")
    public ResponseEntity<ApiResponse<UserDto>> updateUser(
            @Parameter(description = "User ID", required = true)
            @PathVariable Long id,
            @Valid @RequestBody UserUpdateRequest updateRequest) {
        
        log.info("Updating user with ID: {}", id);
        
        UserDto updatedUser = userService.updateUser(id, updateRequest);
        
        log.info("User updated successfully: {}", updatedUser.getUsername());
        
        return ResponseEntity.ok(
            ApiResponse.success(updatedUser, "User updated successfully")
        );
    }
    
    /**
     * Delete user
     * 
     * @param id User ID
     * @return Success message
     */
    @DeleteMapping("/{id}")
    @Operation(
        summary = "Delete user",
        description = "Delete user account. Requires USER_DELETE permission."
    )
    @ApiResponses(value = {
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "200", 
            description = "User deleted successfully"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "404", 
            description = "User not found"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "403", 
            description = "Insufficient permissions"
        )
    })
    @PreAuthorize("hasAuthority('USER_DELETE')")
    public ResponseEntity<ApiResponse<Void>> deleteUser(
            @Parameter(description = "User ID", required = true)
            @PathVariable Long id) {
        
        log.info("Deleting user with ID: {}", id);
        
        userService.deleteUser(id);
        
        log.info("User deleted successfully with ID: {}", id);
        
        return ResponseEntity.ok(
            ApiResponse.success(null, "User deleted successfully")
        );
    }    

    /**
     * Enable or disable user
     * 
     * @param id User ID
     * @param enabled Enable/disable flag
     * @return Success message
     */
    @PatchMapping("/{id}/enabled")
    @Operation(
        summary = "Enable/disable user",
        description = "Enable or disable user account. Requires USER_UPDATE permission."
    )
    @ApiResponses(value = {
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "200", 
            description = "User status updated successfully"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "404", 
            description = "User not found"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "403", 
            description = "Insufficient permissions"
        )
    })
    @PreAuthorize("hasAuthority('USER_UPDATE')")
    public ResponseEntity<ApiResponse<Void>> setUserEnabled(
            @Parameter(description = "User ID", required = true)
            @PathVariable Long id,
            @Parameter(description = "Enable/disable flag", required = true)
            @RequestParam boolean enabled) {
        
        log.info("Setting user {} enabled status to: {}", id, enabled);
        
        userService.setUserEnabled(id, enabled);
        
        String action = enabled ? "enabled" : "disabled";
        log.info("User {} successfully {}", id, action);
        
        return ResponseEntity.ok(
            ApiResponse.success(null, "User " + action + " successfully")
        );
    }
    
    /**
     * Get user roles
     * 
     * @param id User ID
     * @return User roles
     */
    @GetMapping("/{id}/roles")
    @Operation(
        summary = "Get user roles",
        description = "Retrieve roles assigned to user. Requires USER_READ permission."
    )
    @ApiResponses(value = {
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "200", 
            description = "User roles retrieved successfully"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "404", 
            description = "User not found"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "403", 
            description = "Insufficient permissions"
        )
    })
    @PreAuthorize("hasAuthority('USER_READ')")
    public ResponseEntity<ApiResponse<UserDto>> getUserRoles(
            @Parameter(description = "User ID", required = true)
            @PathVariable Long id) {
        
        log.info("Fetching roles for user ID: {}", id);
        
        UserDto user = userService.getUserById(id);
        
        log.info("Retrieved {} roles for user: {}", 
                user.getRoles() != null ? user.getRoles().size() : 0, 
                user.getUsername());
        
        return ResponseEntity.ok(
            ApiResponse.success(user, "User roles retrieved successfully")
        );
    }    

    /**
     * Assign roles to user
     * 
     * @param id User ID
     * @param roleIds Set of role IDs to assign
     * @return Success message
     */
    @PostMapping("/{id}/roles")
    @Operation(
        summary = "Assign roles to user",
        description = "Assign one or more roles to user. Requires ROLE_ASSIGN permission."
    )
    @ApiResponses(value = {
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "200", 
            description = "Roles assigned successfully"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "404", 
            description = "User or role not found"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "403", 
            description = "Insufficient permissions"
        )
    })
    @PreAuthorize("hasAuthority('ROLE_ASSIGN')")
    public ResponseEntity<ApiResponse<Void>> assignRolesToUser(
            @Parameter(description = "User ID", required = true)
            @PathVariable Long id,
            @Parameter(description = "Role IDs to assign", required = true)
            @RequestBody Set<Long> roleIds) {
        
        log.info("Assigning roles {} to user ID: {}", roleIds, id);
        
        userService.assignRolesToUser(id, roleIds);
        
        log.info("Roles assigned successfully to user ID: {}", id);
        
        return ResponseEntity.ok(
            ApiResponse.success(null, "Roles assigned successfully")
        );
    }
    
    /**
     * Remove roles from user
     * 
     * @param id User ID
     * @param roleIds Set of role IDs to remove
     * @return Success message
     */
    @DeleteMapping("/{id}/roles")
    @Operation(
        summary = "Remove roles from user",
        description = "Remove one or more roles from user. Requires ROLE_ASSIGN permission."
    )
    @ApiResponses(value = {
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "200", 
            description = "Roles removed successfully"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "404", 
            description = "User not found"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "403", 
            description = "Insufficient permissions"
        )
    })
    @PreAuthorize("hasAuthority('ROLE_ASSIGN')")
    public ResponseEntity<ApiResponse<Void>> removeRolesFromUser(
            @Parameter(description = "User ID", required = true)
            @PathVariable Long id,
            @Parameter(description = "Role IDs to remove", required = true)
            @RequestBody Set<Long> roleIds) {
        
        log.info("Removing roles {} from user ID: {}", roleIds, id);
        
        userService.removeRolesFromUser(id, roleIds);
        
        log.info("Roles removed successfully from user ID: {}", id);
        
        return ResponseEntity.ok(
            ApiResponse.success(null, "Roles removed successfully")
        );
    }    

    /**
     * Get user permissions
     * 
     * @param id User ID
     * @return Set of user permissions
     */
    @GetMapping("/{id}/permissions")
    @Operation(
        summary = "Get user permissions",
        description = "Retrieve all permissions for user. Requires USER_READ permission."
    )
    @ApiResponses(value = {
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "200", 
            description = "User permissions retrieved successfully"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "404", 
            description = "User not found"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "403", 
            description = "Insufficient permissions"
        )
    })
    @PreAuthorize("hasAuthority('USER_READ')")
    public ResponseEntity<ApiResponse<Set<String>>> getUserPermissions(
            @Parameter(description = "User ID", required = true)
            @PathVariable Long id) {
        
        log.info("Fetching permissions for user ID: {}", id);
        
        Set<String> permissions = userService.getUserPermissions(id);
        
        log.info("Retrieved {} permissions for user ID: {}", permissions.size(), id);
        
        return ResponseEntity.ok(
            ApiResponse.success(permissions, "User permissions retrieved successfully")
        );
    }
    
    /**
     * Change user password
     * 
     * @param id User ID
     * @param oldPassword Current password
     * @param newPassword New password
     * @return Success message
     */
    @PatchMapping("/{id}/password")
    @Operation(
        summary = "Change user password",
        description = "Change user password. Requires current password verification."
    )
    @ApiResponses(value = {
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "200", 
            description = "Password changed successfully"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "400", 
            description = "Invalid current password"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "404", 
            description = "User not found"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "403", 
            description = "Insufficient permissions"
        )
    })
    @PreAuthorize("hasAuthority('USER_UPDATE') or #id == authentication.principal.id")
    public ResponseEntity<ApiResponse<Void>> changePassword(
            @Parameter(description = "User ID", required = true)
            @PathVariable Long id,
            @Parameter(description = "Current password", required = true)
            @RequestParam String oldPassword,
            @Parameter(description = "New password", required = true)
            @RequestParam String newPassword) {
        
        log.info("Password change request for user ID: {}", id);
        
        userService.changePassword(id, oldPassword, newPassword);
        
        log.info("Password changed successfully for user ID: {}", id);
        
        return ResponseEntity.ok(
            ApiResponse.success(null, "Password changed successfully")
        );
    }    
 
   /**
     * Reset user password (admin function)
     * 
     * @param id User ID
     * @param newPassword New password
     * @return Success message
     */
    @PatchMapping("/{id}/password/reset")
    @Operation(
        summary = "Reset user password",
        description = "Reset user password (admin function). Requires PASSWORD_RESET permission."
    )
    @ApiResponses(value = {
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "200", 
            description = "Password reset successfully"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "404", 
            description = "User not found"
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
            responseCode = "403", 
            description = "Insufficient permissions"
        )
    })
    @PreAuthorize("hasAuthority('PASSWORD_RESET')")
    public ResponseEntity<ApiResponse<Void>> resetPassword(
            @Parameter(description = "User ID", required = true)
            @PathVariable Long id,
            @Parameter(description = "New password", required = true)
            @RequestParam String newPassword) {
        
        log.info("Password reset request for user ID: {}", id);
        
        userService.resetPassword(id, newPassword);
        
        log.info("Password reset successfully for user ID: {}", id);
        
        return ResponseEntity.ok(
            ApiResponse.success(null, "Password reset successfully")
        );
    }
}
</file>

<file path="src/main/java/com/example/demo/security/dto/LoginRequest.java">
package com.example.demo.security.dto;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class LoginRequest {
    
    @NotBlank(message = "Username is required")
    @Size(min = 3, max = 50, message = "Username must be between 3 and 50 characters")
    private String username;
    
    @NotBlank(message = "Password is required")
    @Size(min = 6, max = 100, message = "Password must be between 6 and 100 characters")
    private String password;
    
    private boolean rememberMe = false;
}
</file>

<file path="src/main/java/com/example/demo/security/dto/LoginResponse.java">
package com.example.demo.security.dto;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;

import java.time.Instant;
import java.util.Set;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class LoginResponse {

    private String token;

    @Builder.Default
    private String tokenType = "Bearer";

    private Long expiresIn; // seconds

    private UserDto user;

    private Set<String> permissions;

    private Instant loginTime;
}
</file>

<file path="src/main/java/com/example/demo/security/dto/UserCreateRequest.java">
package com.example.demo.security.dto;

import lombok.Data;
import jakarta.validation.constraints.*;
import java.util.Set;

@Data
public class UserCreateRequest {
    @NotBlank
    @Size(min = 3, max = 50)
    private String username;
    
    @NotBlank
    @Email
    private String email;
    
    @NotBlank
    @Size(min = 8, max = 100)
    private String password;
    
    @NotBlank
    @Size(max = 50)
    private String firstName;
    
    @NotBlank
    @Size(max = 50)
    private String lastName;
    
    private Set<Long> roleIds;
}
</file>

<file path="src/main/java/com/example/demo/security/dto/UserDto.java">
package com.example.demo.security.dto;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import java.time.Instant;
import java.util.Set;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserDto {
    
    private Long id;
    
    @NotBlank(message = "Username is required")
    @Size(min = 3, max = 50, message = "Username must be between 3 and 50 characters")
    private String username;
    
    @NotBlank(message = "Email is required")
    @Email(message = "Email should be valid")
    private String email;
    
    @NotBlank(message = "First name is required")
    @Size(max = 50, message = "First name must not exceed 50 characters")
    private String firstName;
    
    @NotBlank(message = "Last name is required")
    @Size(max = 50, message = "Last name must not exceed 50 characters")
    private String lastName;
    
    private boolean enabled;
    
    private Instant createdAt;
    
    private Instant updatedAt;
    
    private Instant lastLogin;
    
    private Set<RoleDto> roles;
}
</file>

<file path="src/main/java/com/example/demo/security/dto/UserUpdateRequest.java">
package com.example.demo.security.dto;

import lombok.Data;
import jakarta.validation.constraints.*;
import java.util.Set;

@Data
public class UserUpdateRequest {
    @NotBlank
    @Email
    private String email;
    
    @NotBlank
    @Size(max = 50)
    private String firstName;
    
    @NotBlank
    @Size(max = 50)
    private String lastName;
    
    private Boolean enabled;
    
    private Set<Long> roleIds;
}
</file>

<file path="src/main/java/com/example/demo/security/entity/Resource.java">
package com.example.demo.security.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.Instant;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "resources", indexes = {
    @Index(name = "idx_resource_url", columnList = "url"),
    @Index(name = "idx_resource_method", columnList = "method"),
    @Index(name = "idx_resource_category", columnList = "category"),
    @Index(name = "idx_resource_active", columnList = "active")
})
@EntityListeners(AuditingEntityListener.class)
@Getter
@Setter
public class Resource {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "name", nullable = false, length = 100)
    private String name;
    
    @Column(name = "url", nullable = false, length = 255)
    private String url;
    
    @Column(name = "method", nullable = false, length = 10)
    private String method;
    
    @Column(name = "description", length = 255)
    private String description;
    
    @Column(name = "category", nullable = false, length = 50)
    private String category;
    
    @Column(name = "active", nullable = false)
    private Boolean active = true;
    
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;
    
    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;
    
    @Column(name = "created_by")
    private Long createdBy;
    
    @Column(name = "updated_by")
    private Long updatedBy;
    
    @ManyToMany(mappedBy = "resources", fetch = FetchType.LAZY)
    private Set<Role> roles = new HashSet<>();
}
</file>

<file path="src/main/java/com/example/demo/security/entity/User.java">
package com.example.demo.security.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.Duration;
import java.time.Instant;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "users",
    indexes = {
        @Index(name = "idx_user_username", columnList = "username"),
        @Index(name = "idx_user_email", columnList = "email"),
        @Index(name = "idx_user_enabled", columnList = "enabled"),
        @Index(name = "idx_user_account_locked", columnList = "account_locked")
    },
    uniqueConstraints = {
        @UniqueConstraint(name = "uk_user_username", columnNames = "username"),
        @UniqueConstraint(name = "uk_user_email", columnNames = "email")
    }
)
@EntityListeners(AuditingEntityListener.class)
@Getter
@Setter
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "username", nullable = false, length = 50)
    @NotBlank(message = "Username is required")
    @Size(min = 3, max = 50, message = "Username must be between 3 and 50 characters")
    private String username;

    @Column(name = "password", nullable = false)
    @NotBlank(message = "Password is required")
    private String password;
    
    @Column(name = "email", nullable = false, length = 100)
    @NotBlank(message = "Email is required")
    @Email(message = "Email must be valid")
    private String email;
    
    @Column(name = "first_name", length = 50)
    private String firstName;
    
    @Column(name = "last_name", length = 50)
    private String lastName;
    
    @Column(name = "enabled", nullable = false)
    private Boolean enabled = true;
    
    @Column(name = "last_login")
    private Instant lastLogin;
    
    @Column(name = "login_attempts", nullable = false)
    private Integer loginAttempts = 0;
    
    @Column(name = "account_locked", nullable = false)
    private Boolean accountLocked = false;
    
    @Column(name = "account_locked_until")
    private Instant accountLockedUntil;
    
    @Column(name = "password_expired", nullable = false)
    private Boolean passwordExpired = false;
    
    @Column(name = "password_change_required", nullable = false)
    private Boolean passwordChangeRequired = false;
    
    @Column(name = "password_changed_at")
    private Instant passwordChangedAt;
    
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;
    
    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;
    
    @Column(name = "created_by")
    private Long createdBy;
    
    @Column(name = "updated_by")
    private Long updatedBy;
    
    @ManyToMany(fetch = FetchType.LAZY)
    @JoinTable(
        name = "user_roles",
        joinColumns = @JoinColumn(name = "user_id"),
        inverseJoinColumns = @JoinColumn(name = "role_id"),
        foreignKey = @ForeignKey(name = "fk_user_roles_user"),
        inverseForeignKey = @ForeignKey(name = "fk_user_roles_role")
    )
    private Set<Role> roles = new HashSet<>();
    
    public boolean isAccountNonLocked() {
        if (!accountLocked) return true;
        if (accountLockedUntil != null && Instant.now().isAfter(accountLockedUntil)) {
            accountLocked = false;
            accountLockedUntil = null;
            return true;
        }
        return false;
    }
    
    public void incrementLoginAttempts() {
        this.loginAttempts++;
        if (this.loginAttempts >= 5) {
            this.accountLocked = true;
            this.accountLockedUntil = Instant.now().plus(Duration.ofMinutes(30));
        }
    }
    
    public void resetLoginAttempts() {
        this.loginAttempts = 0;
        this.accountLocked = false;
        this.accountLockedUntil = null;
        this.lastLogin = Instant.now();
    }
}
</file>

<file path="src/main/java/com/example/demo/security/exception/AuthenticationException.java">
package com.example.demo.security.exception;

public class AuthenticationException extends RuntimeException {
    
    public AuthenticationException(String message) {
        super(message);
    }
    
    public AuthenticationException(String message, Throwable cause) {
        super(message, cause);
    }
}
</file>

<file path="src/main/java/com/example/demo/security/exception/AuthorizationException.java">
package com.example.demo.security.exception;

public class AuthorizationException extends RuntimeException {
    
    public AuthorizationException(String message) {
        super(message);
    }
    
    public AuthorizationException(String message, Throwable cause) {
        super(message, cause);
    }
}
</file>

<file path="src/main/java/com/example/demo/security/exception/InvalidPasswordException.java">
package com.example.demo.security.exception;

public class InvalidPasswordException extends RuntimeException {
    
    public InvalidPasswordException(String message) {
        super(message);
    }
    
    public InvalidPasswordException(String message, Throwable cause) {
        super(message, cause);
    }
}
</file>

<file path="src/main/java/com/example/demo/security/exception/ResourceNotFoundException.java">
package com.example.demo.security.exception;

public class ResourceNotFoundException extends RuntimeException {
    
    public ResourceNotFoundException(String message) {
        super(message);
    }
    
    public ResourceNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }
    
    public ResourceNotFoundException(Long resourceId) {
        super("Resource not found with ID: " + resourceId);
    }
}
</file>

<file path="src/main/java/com/example/demo/security/exception/RoleInUseException.java">
package com.example.demo.security.exception;

public class RoleInUseException extends RuntimeException {
    
    public RoleInUseException(String message) {
        super(message);
    }
    
    public RoleInUseException(String message, Throwable cause) {
        super(message, cause);
    }
}
</file>

<file path="src/main/java/com/example/demo/security/exception/UserAlreadyExistsException.java">
package com.example.demo.security.exception;

public class UserAlreadyExistsException extends RuntimeException {
    
    public UserAlreadyExistsException(String message) {
        super(message);
    }
    
    public UserAlreadyExistsException(String message, Throwable cause) {
        super(message, cause);
    }
}
</file>

<file path="src/main/java/com/example/demo/security/exception/UserNotFoundException.java">
package com.example.demo.security.exception;

public class UserNotFoundException extends RuntimeException {
    
    public UserNotFoundException(String message) {
        super(message);
    }
    
    public UserNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }
    
    public UserNotFoundException(Long userId) {
        super("User not found with ID: " + userId);
    }
    
    public UserNotFoundException(String username, boolean byUsername) {
        super("User not found with username: " + username);
    }
}
</file>

<file path="src/main/java/com/example/demo/security/repository/ResourceRepository.java">
package com.example.demo.security.repository;

import com.example.demo.security.entity.Resource;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface ResourceRepository extends JpaRepository<Resource, Long> {
    
    /**
     * Find resource by URL and HTTP method
     * @param url Resource URL
     * @param method HTTP method
     * @return Optional Resource
     */
    Optional<Resource> findByUrlAndMethod(String url, String method);
    
    /**
     * Find all active resources
     * @return List of active resources
     */
    List<Resource> findByActiveTrue();
    
    /**
     * Find resources by category
     * @param category Resource category
     * @return List of resources in the category
     */
    List<Resource> findByCategory(String category);
    
    /**
     * Find resources by URL containing search term (case insensitive)
     * @param url URL search term
     * @return List of matching resources
     */
    List<Resource> findByUrlContainingIgnoreCase(String url);
    
    /**
     * Check if resource exists by URL and method
     * @param url Resource URL
     * @param method HTTP method
     * @return true if resource exists
     */
    boolean existsByUrlAndMethod(String url, String method);
    
    /**
     * Find resources by role ID
     * @param roleId Role ID
     * @return List of resources assigned to the role
     */
    @Query("SELECT res FROM Resource res JOIN res.roles r WHERE r.id = :roleId")
    List<Resource> findByRoleId(@Param("roleId") Long roleId);
    
    /**
     * Find resources by user ID (through roles)
     * @param userId User ID
     * @return List of resources accessible to the user
     */
    @Query("SELECT DISTINCT res FROM Resource res " +
           "JOIN res.roles r " +
           "JOIN r.users u " +
           "WHERE u.id = :userId AND res.active = true AND r.active = true")
    List<Resource> findByUserId(@Param("userId") Long userId);
    
    /**
     * Find resources matching URL pattern for permission checking
     * @param urlPattern URL pattern to match
     * @param method HTTP method
     * @return List of matching resources
     */
    @Query("SELECT res FROM Resource res WHERE " +
           "res.active = true AND " +
           "res.method = :method AND " +
           "(:urlPattern LIKE CONCAT('%', res.url, '%') OR res.url LIKE CONCAT('%', :urlPattern, '%'))")
    List<Resource> findByUrlPatternAndMethod(@Param("urlPattern") String urlPattern, 
                                           @Param("method") String method);
    
    /**
     * Find all distinct categories
     * @return List of distinct resource categories
     */
    @Query("SELECT DISTINCT res.category FROM Resource res WHERE res.active = true")
    List<String> findDistinctCategories();
    
    /**
     * Find resources by name containing search term (case insensitive)
     * @param name Resource name search term
     * @return List of matching resources
     */
    List<Resource> findByNameContainingIgnoreCase(String name);
    
    /**
     * Count roles assigned to a resource
     * @param resourceId Resource ID
     * @return Number of roles assigned to the resource
     */
    @Query("SELECT COUNT(r) FROM Role r JOIN r.resources res WHERE res.id = :resourceId")
    long countRolesByResourceId(@Param("resourceId") Long resourceId);
}
</file>

<file path="src/main/java/com/example/demo/security/repository/RoleRepository.java">
package com.example.demo.security.repository;

import com.example.demo.security.entity.Role;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.Optional;
import java.util.List;

@Repository
public interface RoleRepository extends JpaRepository<Role, Long> {
    
    /**
     * Find role by name
     * @param name Role name to search for
     * @return Optional Role
     */
    Optional<Role> findByName(String name);
    
    /**
     * Check if role name exists
     * @param name Role name to check
     * @return true if role name exists
     */
    boolean existsByName(String name);
    
    /**
     * Find all active roles
     * @return List of active roles
     */
    List<Role> findByActiveTrue();
    
    /**
     * Find roles by name containing search term (case insensitive)
     * @param name Role name search term
     * @return List of matching roles
     */
    List<Role> findByNameContainingIgnoreCase(String name);
    
    /**
     * Find roles with their resources loaded (using JOIN FETCH for performance)
     * @return List of roles with resources
     */
    @Query("SELECT DISTINCT r FROM Role r LEFT JOIN FETCH r.resources")
    List<Role> findRolesWithResources();
    
    /**
     * Find role by name with resources loaded
     * @param name Role name to search for
     * @return Optional Role with resources
     */
    @Query("SELECT r FROM Role r LEFT JOIN FETCH r.resources WHERE r.name = :name")
    Optional<Role> findByNameWithResources(@Param("name") String name);
    
    /**
     * Find role by ID with resources loaded
     * @param id Role ID to search for
     * @return Optional Role with resources
     */
    @Query("SELECT r FROM Role r LEFT JOIN FETCH r.resources WHERE r.id = :id")
    Optional<Role> findByIdWithResources(@Param("id") Long id);
    
    /**
     * Find roles assigned to a specific user
     * @param userId User ID to search for
     * @return List of roles assigned to the user
     */
    @Query("SELECT r FROM Role r JOIN r.users u WHERE u.id = :userId")
    List<Role> findByUserId(@Param("userId") Long userId);
    
    /**
     * Find active roles with resources for permission checking
     * @return List of active roles with resources
     */
    @Query("SELECT DISTINCT r FROM Role r LEFT JOIN FETCH r.resources res " +
           "WHERE r.active = true AND res.active = true")
    List<Role> findActiveRolesWithActiveResources();
    
    /**
     * Count users assigned to a role
     * @param roleId Role ID
     * @return Number of users assigned to the role
     */
    @Query("SELECT COUNT(u) FROM User u JOIN u.roles r WHERE r.id = :roleId")
    long countUsersByRoleId(@Param("roleId") Long roleId);
}
</file>

<file path="src/main/java/com/example/demo/security/repository/UserRepository.java">
package com.example.demo.security.repository;

import com.example.demo.security.entity.User;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.Optional;
import java.util.List;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    
    /**
     * Find user by username
     * @param username Username to search for
     * @return Optional User
     */
    Optional<User> findByUsername(String username);
    
    /**
     * Find user by email
     * @param email Email to search for
     * @return Optional User
     */
    Optional<User> findByEmail(String email);
    
    /**
     * Check if username exists
     * @param username Username to check
     * @return true if username exists
     */
    boolean existsByUsername(String username);
    
    /**
     * Check if email exists
     * @param email Email to check
     * @return true if email exists
     */
    boolean existsByEmail(String email);
    
    /**
     * Find all enabled users
     * @return List of enabled users
     */
    List<User> findByEnabledTrue();
    
    /**
     * Find enabled users with pagination
     * @param pageable Pagination parameters
     * @return Page of enabled users
     */
    Page<User> findByEnabledTrue(Pageable pageable);
    
    /**
     * Find users by username containing search term (case insensitive)
     * @param username Username search term
     * @return List of matching users
     */
    List<User> findByUsernameContainingIgnoreCase(String username);
    
    /**
     * Find users by first name or last name containing search term (case insensitive)
     * @param firstName First name search term
     * @param lastName Last name search term
     * @return List of matching users
     */
    List<User> findByFirstNameContainingIgnoreCaseOrLastNameContainingIgnoreCase(
        String firstName, String lastName);
    
    /**
     * Find users with their roles loaded (using JOIN FETCH for performance)
     * @return List of users with roles
     */
    @Query("SELECT DISTINCT u FROM User u LEFT JOIN FETCH u.roles")
    List<User> findUsersWithRoles();
    
    /**
     * Find user by username with roles loaded
     * @param username Username to search for
     * @return Optional User with roles
     */
    @Query("SELECT u FROM User u LEFT JOIN FETCH u.roles WHERE u.username = :username")
    Optional<User> findByUsernameWithRoles(@Param("username") String username);
    
    /**
     * Find users by role name
     * @param roleName Role name to filter by
     * @return List of users with the specified role
     */
    @Query("SELECT u FROM User u JOIN u.roles r WHERE r.name = :roleName")
    List<User> findByRoleName(@Param("roleName") String roleName);
    
    /**
     * Search users by multiple criteria
     * @param searchTerm Search term for username, first name, or last name
     * @param pageable Pagination parameters
     * @return Page of matching users
     */
    @Query("SELECT u FROM User u WHERE " +
           "LOWER(u.username) LIKE LOWER(CONCAT('%', :searchTerm, '%')) OR " +
           "LOWER(u.firstName) LIKE LOWER(CONCAT('%', :searchTerm, '%')) OR " +
           "LOWER(u.lastName) LIKE LOWER(CONCAT('%', :searchTerm, '%')) OR " +
           "LOWER(u.email) LIKE LOWER(CONCAT('%', :searchTerm, '%'))")
    Page<User> searchUsers(@Param("searchTerm") String searchTerm, Pageable pageable);
}
</file>

<file path="src/main/java/com/example/demo/security/security/AESUtil.java">
package com.example.demo.security.security;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.security.SecureRandom;
import java.util.Base64;

@Component
@Slf4j
public class AESUtil {
    
    private static final String ALGORITHM = "AES";
    private static final String TRANSFORMATION = "AES/GCM/NoPadding";
    private static final int GCM_IV_LENGTH = 12;
    private static final int GCM_TAG_LENGTH = 16;
    
    private final SecretKey secretKey;
    private final SecureRandom secureRandom;
    
    public AESUtil(@Value("${encryption.key:myEncryptionKey}") String encryptionKey) {
        // Ensure key is 32 bytes for AES-256
        byte[] keyBytes = encryptionKey.getBytes(StandardCharsets.UTF_8);
        if (keyBytes.length < 32) {
            byte[] paddedKey = new byte[32];
            System.arraycopy(keyBytes, 0, paddedKey, 0, keyBytes.length);
            keyBytes = paddedKey;
        } else if (keyBytes.length > 32) {
            byte[] truncatedKey = new byte[32];
            System.arraycopy(keyBytes, 0, truncatedKey, 0, 32);
            keyBytes = truncatedKey;
        }
        
        this.secretKey = new SecretKeySpec(keyBytes, ALGORITHM);
        this.secureRandom = new SecureRandom();
        
        log.info("AES encryption utility initialized");
    }
    
    /**
     * Encrypt plaintext using AES-GCM
     * @param plaintext Text to encrypt
     * @return Base64 encoded encrypted text with IV prepended
     */
    public String encrypt(String plaintext) {
        if (plaintext == null || plaintext.isEmpty()) {
            return plaintext;
        }
        
        try {
            // Generate random IV
            byte[] iv = new byte[GCM_IV_LENGTH];
            secureRandom.nextBytes(iv);
            
            // Initialize cipher
            Cipher cipher = Cipher.getInstance(TRANSFORMATION);
            GCMParameterSpec parameterSpec = new GCMParameterSpec(GCM_TAG_LENGTH * 8, iv);
            cipher.init(Cipher.ENCRYPT_MODE, secretKey, parameterSpec);
            
            // Encrypt
            byte[] encryptedData = cipher.doFinal(plaintext.getBytes(StandardCharsets.UTF_8));
            
            // Combine IV and encrypted data
            byte[] encryptedWithIv = new byte[GCM_IV_LENGTH + encryptedData.length];
            System.arraycopy(iv, 0, encryptedWithIv, 0, GCM_IV_LENGTH);
            System.arraycopy(encryptedData, 0, encryptedWithIv, GCM_IV_LENGTH, encryptedData.length);
            
            // Return Base64 encoded result
            return Base64.getEncoder().encodeToString(encryptedWithIv);
            
        } catch (Exception e) {
            log.error("Error encrypting data", e);
            throw new RuntimeException("Encryption failed", e);
        }
    }
    
    /**
     * Decrypt ciphertext using AES-GCM
     * @param ciphertext Base64 encoded encrypted text with IV prepended
     * @return Decrypted plaintext
     */
    public String decrypt(String ciphertext) {
        if (ciphertext == null || ciphertext.isEmpty()) {
            return ciphertext;
        }
        
        try {
            // Decode Base64
            byte[] encryptedWithIv = Base64.getDecoder().decode(ciphertext);
            
            // Extract IV
            byte[] iv = new byte[GCM_IV_LENGTH];
            System.arraycopy(encryptedWithIv, 0, iv, 0, GCM_IV_LENGTH);
            
            // Extract encrypted data
            byte[] encryptedData = new byte[encryptedWithIv.length - GCM_IV_LENGTH];
            System.arraycopy(encryptedWithIv, GCM_IV_LENGTH, encryptedData, 0, encryptedData.length);
            
            // Initialize cipher
            Cipher cipher = Cipher.getInstance(TRANSFORMATION);
            GCMParameterSpec parameterSpec = new GCMParameterSpec(GCM_TAG_LENGTH * 8, iv);
            cipher.init(Cipher.DECRYPT_MODE, secretKey, parameterSpec);
            
            // Decrypt
            byte[] decryptedData = cipher.doFinal(encryptedData);
            
            return new String(decryptedData, StandardCharsets.UTF_8);
            
        } catch (Exception e) {
            log.error("Error decrypting data", e);
            throw new RuntimeException("Decryption failed", e);
        }
    }
    
    /**
     * Generate a new AES key for testing purposes
     * @return Base64 encoded AES key
     */
    public static String generateKey() {
        try {
            KeyGenerator keyGenerator = KeyGenerator.getInstance(ALGORITHM);
            keyGenerator.init(256);
            SecretKey key = keyGenerator.generateKey();
            return Base64.getEncoder().encodeToString(key.getEncoded());
        } catch (Exception e) {
            throw new RuntimeException("Key generation failed", e);
        }
    }
}
</file>

<file path="src/main/java/com/example/demo/security/security/CustomUserDetailsService.java">
package com.example.demo.security.security;

import com.example.demo.security.entity.User;
import com.example.demo.security.entity.Role;
import com.example.demo.security.entity.Resource;
import com.example.demo.security.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Collection;
import java.util.HashSet;
import java.util.Set;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class CustomUserDetailsService implements UserDetailsService {
    
    private final UserRepository userRepository;
    
    @Override
    @Transactional(readOnly = true)
    @Cacheable(value = "userDetails", key = "#username")
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        log.debug("Loading user details for username: {}", username);
        
        User user = userRepository.findByUsernameWithRoles(username)
                .orElseThrow(() -> {
                    log.warn("User not found with username: {}", username);
                    return new UsernameNotFoundException("User not found with username: " + username);
                });
        
        if (!user.getEnabled()) {
            log.warn("User account is disabled: {}", username);
            throw new UsernameNotFoundException("User account is disabled: " + username);
        }
        
        Collection<GrantedAuthority> authorities = getAuthorities(user);
        
        log.debug("User {} loaded with {} authorities", username, authorities.size());
        
        return CustomUserPrincipal.builder()
                .id(user.getId())
                .username(user.getUsername())
                .password(user.getPassword())
                .email(user.getEmail())
                .firstName(user.getFirstName())
                .lastName(user.getLastName())
                .enabled(user.getEnabled())
                .accountNonLocked(user.isAccountNonLocked())
                .passwordExpired(user.getPasswordExpired())
                .passwordChangeRequired(user.getPasswordChangeRequired())
                .authorities(authorities)
                .build();
    }
    
    private Collection<GrantedAuthority> getAuthorities(User user) {
        Set<GrantedAuthority> authorities = new HashSet<>();
        
        // Add role-based authorities
        for (Role role : user.getRoles()) {
            if (role.getActive()) {
                authorities.add(new SimpleGrantedAuthority("ROLE_" + role.getName()));
                
                // Add resource-based authorities (permissions)
                for (Resource resource : role.getResources()) {
                    if (resource.getActive()) {
                        String permission = resource.getMethod() + ":" + resource.getUrl();
                        authorities.add(new SimpleGrantedAuthority(permission));
                    }
                }
            }
        }
        
        return authorities;
    }
    
    /**
     * Load user by ID for internal use
     */
    @Transactional(readOnly = true)
    @Cacheable(value = "userDetailsById", key = "#userId")
    public UserDetails loadUserById(Long userId) {
        log.debug("Loading user details for user ID: {}", userId);
        
        User user = userRepository.findById(userId)
                .orElseThrow(() -> {
                    log.warn("User not found with ID: {}", userId);
                    return new UsernameNotFoundException("User not found with ID: " + userId);
                });
        
        if (!user.getEnabled()) {
            log.warn("User account is disabled for ID: {}", userId);
            throw new UsernameNotFoundException("User account is disabled for ID: " + userId);
        }
        
        Collection<GrantedAuthority> authorities = getAuthorities(user);
        
        return CustomUserPrincipal.builder()
                .id(user.getId())
                .username(user.getUsername())
                .password(user.getPassword())
                .email(user.getEmail())
                .firstName(user.getFirstName())
                .lastName(user.getLastName())
                .enabled(user.getEnabled())
                .accountNonLocked(user.isAccountNonLocked())
                .passwordExpired(user.getPasswordExpired())
                .passwordChangeRequired(user.getPasswordChangeRequired())
                .authorities(authorities)
                .build();
    }
}
</file>

<file path="src/main/java/com/example/demo/security/security/CustomUserPrincipal.java">
package com.example.demo.security.security;

import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.Collection;

public class CustomUserPrincipal implements UserDetails {
    
    private Long id;
    private String username;
    private String password;
    private String email;
    private String firstName;
    private String lastName;
    private boolean enabled;
    private boolean accountNonLocked;
    private boolean passwordExpired;
    private boolean passwordChangeRequired;
    private Collection<? extends GrantedAuthority> authorities;
    
    // Default constructor (required for builder pattern)
    public CustomUserPrincipal() {
    }
    
    // Constructor with all fields
    public CustomUserPrincipal(Long id, String username, String password, String email, 
                              String firstName, String lastName, boolean enabled, 
                              boolean accountNonLocked, boolean passwordExpired, 
                              boolean passwordChangeRequired, 
                              Collection<? extends GrantedAuthority> authorities) {
        this.id = id;
        this.username = username;
        this.password = password;
        this.email = email;
        this.firstName = firstName;
        this.lastName = lastName;
        this.enabled = enabled;
        this.accountNonLocked = accountNonLocked;
        this.passwordExpired = passwordExpired;
        this.passwordChangeRequired = passwordChangeRequired;
        this.authorities = authorities;
    }
    
    // Getters and Setters (replacing Lombok @Data)
    public Long getId() {
        return id;
    }
    
    public void setId(Long id) {
        this.id = id;
    }
    
    public String getEmail() {
        return email;
    }
    
    public void setEmail(String email) {
        this.email = email;
    }
    
    public String getFirstName() {
        return firstName;
    }
    
    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }
    
    public String getLastName() {
        return lastName;
    }
    
    public void setLastName(String lastName) {
        this.lastName = lastName;
    }
    
    public void setUsername(String username) {
        this.username = username;
    }
    
    public void setPassword(String password) {
        this.password = password;
    }
    
    public void setEnabled(boolean enabled) {
        this.enabled = enabled;
    }
    
    public void setAccountNonLocked(boolean accountNonLocked) {
        this.accountNonLocked = accountNonLocked;
    }
    
    public void setPasswordExpired(boolean passwordExpired) {
        this.passwordExpired = passwordExpired;
    }
    
    public void setPasswordChangeRequired(boolean passwordChangeRequired) {
        this.passwordChangeRequired = passwordChangeRequired;
    }
    
    public void setAuthorities(Collection<? extends GrantedAuthority> authorities) {
        this.authorities = authorities;
    }
    
    // Builder method (in case Lombok fails)
    public static CustomUserPrincipalBuilder builder() {
        return new CustomUserPrincipalBuilder();
    }
    
    public static class CustomUserPrincipalBuilder {
        private Long id;
        private String username;
        private String password;
        private String email;
        private String firstName;
        private String lastName;
        private boolean enabled;
        private boolean accountNonLocked;
        private boolean passwordExpired;
        private boolean passwordChangeRequired;
        private Collection<? extends GrantedAuthority> authorities;
        
        public CustomUserPrincipalBuilder id(Long id) {
            this.id = id;
            return this;
        }
        
        public CustomUserPrincipalBuilder username(String username) {
            this.username = username;
            return this;
        }
        
        public CustomUserPrincipalBuilder password(String password) {
            this.password = password;
            return this;
        }
        
        public CustomUserPrincipalBuilder email(String email) {
            this.email = email;
            return this;
        }
        
        public CustomUserPrincipalBuilder firstName(String firstName) {
            this.firstName = firstName;
            return this;
        }
        
        public CustomUserPrincipalBuilder lastName(String lastName) {
            this.lastName = lastName;
            return this;
        }
        
        public CustomUserPrincipalBuilder enabled(boolean enabled) {
            this.enabled = enabled;
            return this;
        }
        
        public CustomUserPrincipalBuilder accountNonLocked(boolean accountNonLocked) {
            this.accountNonLocked = accountNonLocked;
            return this;
        }
        
        public CustomUserPrincipalBuilder passwordExpired(boolean passwordExpired) {
            this.passwordExpired = passwordExpired;
            return this;
        }
        
        public CustomUserPrincipalBuilder passwordChangeRequired(boolean passwordChangeRequired) {
            this.passwordChangeRequired = passwordChangeRequired;
            return this;
        }
        
        public CustomUserPrincipalBuilder authorities(Collection<? extends GrantedAuthority> authorities) {
            this.authorities = authorities;
            return this;
        }
        
        public CustomUserPrincipal build() {
            CustomUserPrincipal principal = new CustomUserPrincipal();
            principal.id = this.id;
            principal.username = this.username;
            principal.password = this.password;
            principal.email = this.email;
            principal.firstName = this.firstName;
            principal.lastName = this.lastName;
            principal.enabled = this.enabled;
            principal.accountNonLocked = this.accountNonLocked;
            principal.passwordExpired = this.passwordExpired;
            principal.passwordChangeRequired = this.passwordChangeRequired;
            principal.authorities = this.authorities;
            return principal;
        }
    }
    
    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return authorities;
    }
    
    @Override
    public String getPassword() {
        return password;
    }
    
    @Override
    public String getUsername() {
        return username;
    }
    
    @Override
    public boolean isAccountNonExpired() {
        return true; // We don't track account expiration separately
    }
    
    @Override
    public boolean isAccountNonLocked() {
        return accountNonLocked;
    }
    
    @Override
    public boolean isCredentialsNonExpired() {
        return !passwordExpired;
    }
    
    @Override
    public boolean isEnabled() {
        return enabled;
    }
    
    public String getFullName() {
        return firstName + " " + lastName;
    }
}
</file>

<file path="src/main/java/com/example/demo/security/security/EncryptedStringConverter.java">
package com.example.demo.security.security;

import jakarta.persistence.AttributeConverter;
import jakarta.persistence.Converter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

@Converter
@Component
@RequiredArgsConstructor
@Slf4j
public class EncryptedStringConverter implements AttributeConverter<String, String> {
    
    private final AESUtil aesUtil;
    
    @Override
    public String convertToDatabaseColumn(String attribute) {
        if (attribute == null) {
            return null;
        }
        
        try {
            String encrypted = aesUtil.encrypt(attribute);
            log.debug("Successfully encrypted field for database storage");
            return encrypted;
        } catch (Exception e) {
            log.error("Error encrypting field for database storage", e);
            throw new RuntimeException("Failed to encrypt sensitive data", e);
        }
    }
    
    @Override
    public String convertToEntityAttribute(String dbData) {
        if (dbData == null) {
            return null;
        }
        
        try {
            String decrypted = aesUtil.decrypt(dbData);
            log.debug("Successfully decrypted field from database");
            return decrypted;
        } catch (Exception e) {
            log.error("Error decrypting field from database", e);
            throw new RuntimeException("Failed to decrypt sensitive data", e);
        }
    }
}
</file>

<file path="src/main/java/com/example/demo/security/security/JwtTokenProvider.java">
package com.example.demo.security.security;

import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.stream.Collectors;

@Component
@Slf4j
public class JwtTokenProvider {
    
    private final SecretKey secretKey;
    private final long jwtExpirationInMs;
    private final long refreshTokenExpirationInMs;
    
    public JwtTokenProvider(
            @Value("${jwt.secret:mySecretKey}") String jwtSecret,
            @Value("${jwt.expiration:86400000}") long jwtExpirationInMs,
            @Value("${jwt.refresh-expiration:604800000}") long refreshTokenExpirationInMs) {
        
        // Ensure the secret key is at least 256 bits (32 bytes) for HS512
        byte[] keyBytes = jwtSecret.getBytes(StandardCharsets.UTF_8);
        if (keyBytes.length < 64) { // HS512 requires at least 512 bits (64 bytes)
            byte[] paddedKey = new byte[64];
            System.arraycopy(keyBytes, 0, paddedKey, 0, keyBytes.length);
            keyBytes = paddedKey;
        }
        
        this.secretKey = Keys.hmacShaKeyFor(keyBytes);
        this.jwtExpirationInMs = jwtExpirationInMs;
        this.refreshTokenExpirationInMs = refreshTokenExpirationInMs;
        
        log.info("JWT Token Provider initialized with expiration: {} ms", jwtExpirationInMs);
    }
    
    /**
     * Generate JWT token from authentication
     */
    public String generateToken(Authentication authentication) {
        CustomUserPrincipal userPrincipal = (CustomUserPrincipal) authentication.getPrincipal();
        
        Date expiryDate = new Date(System.currentTimeMillis() + jwtExpirationInMs);
        
        Map<String, Object> claims = new HashMap<>();
        claims.put("userId", userPrincipal.getId());
        claims.put("email", userPrincipal.getEmail());
        claims.put("firstName", userPrincipal.getFirstName());
        claims.put("lastName", userPrincipal.getLastName());
        claims.put("authorities", userPrincipal.getAuthorities().stream()
                .map(GrantedAuthority::getAuthority)
                .collect(Collectors.toList()));
        
        return Jwts.builder()
                .subject(userPrincipal.getUsername())
                .claims(claims)
                .issuedAt(new Date())
                .expiration(expiryDate)
                .signWith(secretKey, Jwts.SIG.HS512)
                .compact();
    }
    
    /**
     * Generate refresh token
     */
    public String generateRefreshToken(Authentication authentication) {
        CustomUserPrincipal userPrincipal = (CustomUserPrincipal) authentication.getPrincipal();
        
        Date expiryDate = new Date(System.currentTimeMillis() + refreshTokenExpirationInMs);
        
        return Jwts.builder()
                .subject(userPrincipal.getUsername())
                .claim("userId", userPrincipal.getId())
                .claim("tokenType", "refresh")
                .issuedAt(new Date())
                .expiration(expiryDate)
                .signWith(secretKey, Jwts.SIG.HS512)
                .compact();
    }
    
    /**
     * Get username from JWT token
     */
    public String getUsernameFromToken(String token) {
        Claims claims = Jwts.parser()
                .verifyWith(secretKey)
                .build()
                .parseSignedClaims(token)
                .getPayload();
        
        return claims.getSubject();
    }
    
    /**
     * Get user ID from JWT token
     */
    public Long getUserIdFromToken(String token) {
        Claims claims = Jwts.parser()
                .verifyWith(secretKey)
                .build()
                .parseSignedClaims(token)
                .getPayload();
        
        return claims.get("userId", Long.class);
    }
    
    /**
     * Get expiration date from JWT token
     */
    public Date getExpirationDateFromToken(String token) {
        Claims claims = Jwts.parser()
                .verifyWith(secretKey)
                .build()
                .parseSignedClaims(token)
                .getPayload();
        
        return claims.getExpiration();
    }
    
    /**
     * Get expiration time in seconds from JWT token
     */
    public Long getExpirationTimeFromToken(String token) {
        Date expirationDate = getExpirationDateFromToken(token);
        return expirationDate.getTime() / 1000;
    }
    
    /**
     * Get token expiration time in seconds
     */
    public Long getExpirationTime() {
        return jwtExpirationInMs / 1000;
    }
    
    /**
     * Validate JWT token
     */
    public boolean validateToken(String token) {
        try {
            Jwts.parser()
                    .verifyWith(secretKey)
                    .build()
                    .parseSignedClaims(token);
            return true;
        } catch (SecurityException ex) {
            log.error("Invalid JWT signature: {}", ex.getMessage());
        } catch (MalformedJwtException ex) {
            log.error("Invalid JWT token: {}", ex.getMessage());
        } catch (ExpiredJwtException ex) {
            log.error("Expired JWT token: {}", ex.getMessage());
        } catch (UnsupportedJwtException ex) {
            log.error("Unsupported JWT token: {}", ex.getMessage());
        } catch (IllegalArgumentException ex) {
            log.error("JWT claims string is empty: {}", ex.getMessage());
        }
        return false;
    }
    
    /**
     * Validate refresh token
     */
    public boolean validateRefreshToken(String token) {
        try {
            Claims claims = Jwts.parser()
                    .verifyWith(secretKey)
                    .build()
                    .parseSignedClaims(token)
                    .getPayload();
            
            String tokenType = claims.get("tokenType", String.class);
            return "refresh".equals(tokenType);
        } catch (Exception ex) {
            log.error("Invalid refresh token: {}", ex.getMessage());
            return false;
        }
    }
    
    /**
     * Check if token is expired
     */
    public boolean isTokenExpired(String token) {
        try {
            Date expirationDate = getExpirationDateFromToken(token);
            return expirationDate.before(new Date());
        } catch (Exception ex) {
            return true;
        }
    }
    
    /**
     * Get all claims from token
     */
    public Claims getAllClaimsFromToken(String token) {
        return Jwts.parser()
                .verifyWith(secretKey)
                .build()
                .parseSignedClaims(token)
                .getPayload();
    }
}
</file>

<file path="src/main/java/com/example/demo/security/security/SecurityUtils.java">
package com.example.demo.security.security;

import lombok.extern.slf4j.Slf4j;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.Optional;

@Slf4j
public class SecurityUtils {
    
    private SecurityUtils() {
        // Utility class
    }
    
    /**
     * Get current authenticated user
     * @return Optional CustomUserPrincipal
     */
    public static Optional<CustomUserPrincipal> getCurrentUser() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        
        if (authentication != null && authentication.getPrincipal() instanceof CustomUserPrincipal) {
            return Optional.of((CustomUserPrincipal) authentication.getPrincipal());
        }
        
        return Optional.empty();
    }
    
    /**
     * Get current user ID
     * @return Optional user ID
     */
    public static Optional<Long> getCurrentUserId() {
        return getCurrentUser().map(CustomUserPrincipal::getId);
    }
    
    /**
     * Get current username
     * @return Optional username
     */
    public static Optional<String> getCurrentUsername() {
        return getCurrentUser().map(CustomUserPrincipal::getUsername);
    }
    
    /**
     * Check if current user is authenticated
     * @return true if authenticated
     */
    public static boolean isAuthenticated() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        return authentication != null && 
               authentication.isAuthenticated() && 
               !(authentication.getPrincipal() instanceof String);
    }
    
    /**
     * Check if current user has specific role
     * @param role Role name (without ROLE_ prefix)
     * @return true if user has role
     */
    public static boolean hasRole(String role) {
        return getCurrentUser()
                .map(user -> user.getAuthorities().stream()
                        .anyMatch(auth -> auth.getAuthority().equals("ROLE_" + role)))
                .orElse(false);
    }
    
    /**
     * Check if current user has specific permission
     * @param permission Permission string (e.g., "GET:/api/users")
     * @return true if user has permission
     */
    public static boolean hasPermission(String permission) {
        return getCurrentUser()
                .map(user -> user.getAuthorities().stream()
                        .anyMatch(auth -> auth.getAuthority().equals(permission)))
                .orElse(false);
    }
    
    /**
     * Check if current user has any of the specified roles
     * @param roles Role names (without ROLE_ prefix)
     * @return true if user has any of the roles
     */
    public static boolean hasAnyRole(String... roles) {
        Optional<CustomUserPrincipal> currentUser = getCurrentUser();
        if (currentUser.isEmpty()) {
            return false;
        }
        
        for (String role : roles) {
            if (hasRole(role)) {
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * Check if current user has all of the specified roles
     * @param roles Role names (without ROLE_ prefix)
     * @return true if user has all roles
     */
    public static boolean hasAllRoles(String... roles) {
        Optional<CustomUserPrincipal> currentUser = getCurrentUser();
        if (currentUser.isEmpty()) {
            return false;
        }
        
        for (String role : roles) {
            if (!hasRole(role)) {
                return false;
            }
        }
        
        return true;
    }
    
    /**
     * Get current user's full name
     * @return Optional full name
     */
    public static Optional<String> getCurrentUserFullName() {
        return getCurrentUser().map(CustomUserPrincipal::getFullName);
    }
    
    /**
     * Get current user's email
     * @return Optional email
     */
    public static Optional<String> getCurrentUserEmail() {
        return getCurrentUser().map(CustomUserPrincipal::getEmail);
    }
    
    /**
     * Check if current user is the owner of a resource
     * @param resourceOwnerId ID of the resource owner
     * @return true if current user is the owner
     */
    public static boolean isResourceOwner(Long resourceOwnerId) {
        return getCurrentUserId()
                .map(userId -> userId.equals(resourceOwnerId))
                .orElse(false);
    }
    
    /**
     * Check if current user can access resource (owner or has admin role)
     * @param resourceOwnerId ID of the resource owner
     * @return true if user can access resource
     */
    public static boolean canAccessResource(Long resourceOwnerId) {
        return isResourceOwner(resourceOwnerId) || hasRole("ADMIN");
    }
}
</file>

<file path="src/main/java/com/example/demo/security/service/AuthenticationService.java">
package com.example.demo.security.service;

import com.example.demo.security.dto.LoginRequest;
import com.example.demo.security.dto.LoginResponse;

public interface AuthenticationService {
    
    /**
     * Authenticate user with username and password
     * @param loginRequest Login credentials
     * @return Login response with JWT token and user details
     */
    LoginResponse authenticate(LoginRequest loginRequest);
    
    /**
     * Logout user by invalidating JWT token
     * @param token JWT token to invalidate
     */
    void logout(String token);
    
    /**
     * Refresh JWT token
     * @param refreshToken Refresh token
     * @return New login response with refreshed token
     */
    LoginResponse refreshToken(String refreshToken);
    
    /**
     * Validate JWT token
     * @param token JWT token to validate
     * @return true if token is valid
     */
    boolean validateToken(String token);
    
    /**
     * Get username from JWT token
     * @param token JWT token
     * @return Username
     */
    String getUsernameFromToken(String token);
}
</file>

<file path="src/main/java/com/example/demo/security/service/impl/AuthenticationServiceImpl.java">
package com.example.demo.security.service.impl;

import com.example.demo.security.dto.LoginRequest;
import com.example.demo.security.dto.LoginResponse;
import com.example.demo.security.dto.UserDto;
import com.example.demo.security.entity.User;
import com.example.demo.security.exception.AuthenticationException;
import com.example.demo.security.repository.UserRepository;
import com.example.demo.security.security.JwtTokenProvider;
import com.example.demo.security.security.CustomUserPrincipal;
import com.example.demo.security.service.AuthenticationService;
import com.example.demo.security.service.UserService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.DisabledException;
import org.springframework.security.authentication.LockedException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;

import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.Duration;
import java.time.Instant;
import java.util.Set;
import java.util.concurrent.TimeUnit;

@Service
@RequiredArgsConstructor
@Slf4j
public class AuthenticationServiceImpl implements AuthenticationService {
    
    private final AuthenticationManager authenticationManager;
    private final JwtTokenProvider jwtTokenProvider;
    private final UserRepository userRepository;
    private final UserService userService;
    private final PasswordEncoder passwordEncoder;
    private final RedisTemplate<String, Object> redisTemplate;
    
    private static final String BLACKLIST_KEY_PREFIX = "jwt:blacklist:";
    private static final String REFRESH_TOKEN_PREFIX = "jwt:refresh:";
    
    @Override
    @Transactional
    public LoginResponse authenticate(LoginRequest loginRequest) {
        log.debug("Attempting authentication for user: {}", loginRequest.getUsername());
        
        try {
            // Find user first to handle account locking
            User user = userRepository.findByUsername(loginRequest.getUsername())
                    .orElseThrow(() -> new AuthenticationException("Invalid username or password"));
            
            // Check if account is locked
            if (!user.isAccountNonLocked()) {
                log.warn("Authentication failed - account locked: {}", loginRequest.getUsername());
                throw new AuthenticationException("Account is temporarily locked due to multiple failed login attempts");
            }
            
            // Attempt authentication
            Authentication authentication = authenticationManager.authenticate(
                    new UsernamePasswordAuthenticationToken(
                            loginRequest.getUsername(),
                            loginRequest.getPassword()
                    )
            );
            
            // Reset login attempts on successful authentication
            user.resetLoginAttempts();
            userRepository.save(user);
            
            // Generate JWT token
            String token = jwtTokenProvider.generateToken(authentication);
            Long expirationTime = jwtTokenProvider.getExpirationTime();
            
            // Generate refresh token if remember me is enabled
            String refreshToken = null;
            if (loginRequest.isRememberMe()) {
                refreshToken = jwtTokenProvider.generateRefreshToken(authentication);
                // Store refresh token in Redis
                redisTemplate.opsForValue().set(
                        REFRESH_TOKEN_PREFIX + user.getUsername(),
                        refreshToken,
                        Duration.ofDays(30)
                );
            }
            
            // Get user details and permissions
            UserDto userDto = userService.getUserByUsername(loginRequest.getUsername());
            Set<String> permissions = userService.getUserPermissions(user.getId());
            
            log.info("User {} authenticated successfully", loginRequest.getUsername());
            
            return LoginResponse.builder()
                    .token(token)
                    .tokenType("Bearer")
                    .expiresIn(expirationTime)
                    .user(userDto)
                    .permissions(permissions)
                    .loginTime(Instant.now())
                    .build();
                    
        } catch (BadCredentialsException e) {
            // Handle failed authentication
            handleFailedAuthentication(loginRequest.getUsername());
            throw new AuthenticationException("Invalid username or password");
        } catch (DisabledException e) {
            log.warn("Authentication failed - account disabled: {}", loginRequest.getUsername());
            throw new AuthenticationException("Account is disabled");
        } catch (LockedException e) {
            log.warn("Authentication failed - account locked: {}", loginRequest.getUsername());
            throw new AuthenticationException("Account is locked");
        } catch (org.springframework.security.core.AuthenticationException e) {
            log.error("Authentication failed for user: {}", loginRequest.getUsername(), e);
            throw new AuthenticationException("Authentication failed: " + e.getMessage());
        }
    }
    
    private void handleFailedAuthentication(String username) {
        userRepository.findByUsername(username).ifPresent(user -> {
            user.incrementLoginAttempts();
            userRepository.save(user);
            log.warn("Failed login attempt {} for user: {}", user.getLoginAttempts(), username);
        });
    }
    
    @Override
    public void logout(String token) {
        log.debug("Logging out user with token");
        
        if (jwtTokenProvider.validateToken(token)) {
            // Add token to blacklist
            Long expirationTime = jwtTokenProvider.getExpirationTimeFromToken(token);
            long ttl = expirationTime - System.currentTimeMillis() / 1000;
            
            if (ttl > 0) {
                redisTemplate.opsForValue().set(
                        BLACKLIST_KEY_PREFIX + token,
                        "blacklisted",
                        Duration.ofSeconds(ttl)
                );
            }
            
            // Remove refresh token if exists
            String username = jwtTokenProvider.getUsernameFromToken(token);
            redisTemplate.delete(REFRESH_TOKEN_PREFIX + username);
            
            log.info("User {} logged out successfully", username);
        }
    }
    
    @Override
    public LoginResponse refreshToken(String refreshToken) {
        log.debug("Attempting to refresh token");
        
        if (!jwtTokenProvider.validateRefreshToken(refreshToken)) {
            throw new AuthenticationException("Invalid refresh token");
        }
        
        String username = jwtTokenProvider.getUsernameFromToken(refreshToken);
        
        // Check if refresh token exists in Redis
        String storedRefreshToken = (String) redisTemplate.opsForValue()
                .get(REFRESH_TOKEN_PREFIX + username);
        
        if (storedRefreshToken == null || !storedRefreshToken.equals(refreshToken)) {
            throw new AuthenticationException("Refresh token not found or expired");
        }
        
        // Generate new access token
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new AuthenticationException("User not found"));
        
        // Load user details to create proper authentication
        CustomUserPrincipal userPrincipal = CustomUserPrincipal.builder()
                .id(user.getId())
                .username(user.getUsername())
                .email(user.getEmail())
                .firstName(user.getFirstName())
                .lastName(user.getLastName())
                .enabled(user.getEnabled())
                .accountNonLocked(user.isAccountNonLocked())
                .passwordExpired(user.getPasswordExpired())
                .passwordChangeRequired(user.getPasswordChangeRequired())
                .authorities(java.util.Collections.emptyList()) // Will be loaded by UserDetailsService
                .build();
        
        Authentication authentication = new UsernamePasswordAuthenticationToken(
                userPrincipal, null, userPrincipal.getAuthorities());
        
        String newToken = jwtTokenProvider.generateToken(authentication);
        Long expirationTime = jwtTokenProvider.getExpirationTime();
        
        UserDto userDto = userService.getUserByUsername(username);
        Set<String> permissions = userService.getUserPermissions(user.getId());
        
        log.info("Token refreshed successfully for user: {}", username);
        
        return LoginResponse.builder()
                .token(newToken)
                .tokenType("Bearer")
                .expiresIn(expirationTime)
                .user(userDto)
                .permissions(permissions)
                .loginTime(Instant.now())
                .build();
    }
    
    @Override
    public boolean validateToken(String token) {
        // Check if token is blacklisted
        if (redisTemplate.hasKey(BLACKLIST_KEY_PREFIX + token)) {
            return false;
        }
        
        return jwtTokenProvider.validateToken(token);
    }
    
    @Override
    public String getUsernameFromToken(String token) {
        return jwtTokenProvider.getUsernameFromToken(token);
    }
}
</file>

<file path="src/main/java/com/example/demo/security/service/impl/PermissionServiceImpl.java">
package com.example.demo.security.service.impl;

import com.example.demo.security.entity.User;
import com.example.demo.security.entity.Role;
import com.example.demo.security.entity.Resource;
import com.example.demo.security.exception.UserNotFoundException;
import com.example.demo.security.repository.UserRepository;
import com.example.demo.security.repository.ResourceRepository;
import com.example.demo.security.service.PermissionService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class PermissionServiceImpl implements PermissionService {
    
    private final UserRepository userRepository;
    private final ResourceRepository resourceRepository;
    
    @Override
    @Transactional(readOnly = true)
    @Cacheable(value = "userResourcePermissions", key = "#userId + ':' + #url + ':' + #method")
    public boolean hasPermission(Long userId, String url, String method) {
        log.debug("Checking permission for user ID: {}, URL: {}, Method: {}", userId, url, method);
        
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException(userId));
        
        if (!user.getEnabled()) {
            log.debug("User ID: {} is disabled", userId);
            return false;
        }
        
        // Check direct resource permission
        for (Role role : user.getRoles()) {
            if (role.getActive()) {
                for (Resource resource : role.getResources()) {
                    if (resource.getActive() && 
                        resource.getUrl().equals(url) && 
                        resource.getMethod().equals(method)) {
                        log.debug("User ID: {} has direct permission for {}:{}", userId, method, url);
                        return true;
                    }
                }
            }
        }
        
        log.debug("User ID: {} does not have permission for {}:{}", userId, method, url);
        return false;
    }
    
    @Override
    @Transactional(readOnly = true)
    @Cacheable(value = "userRoleCheck", key = "#userId + ':' + #roles.toString()")
    public boolean hasAnyRole(Long userId, Set<String> roles) {
        log.debug("Checking if user ID: {} has any of roles: {}", userId, roles);
        
        Set<String> userRoles = getUserRoles(userId);
        boolean hasAnyRole = userRoles.stream().anyMatch(roles::contains);
        
        log.debug("User ID: {} {} any of the required roles", userId, 
                hasAnyRole ? "has" : "does not have");
        
        return hasAnyRole;
    }
    
    @Override
    @Transactional(readOnly = true)
    @Cacheable(value = "userAllRolesCheck", key = "#userId + ':' + #roles.toString()")
    public boolean hasAllRoles(Long userId, Set<String> roles) {
        log.debug("Checking if user ID: {} has all roles: {}", userId, roles);
        
        Set<String> userRoles = getUserRoles(userId);
        boolean hasAllRoles = userRoles.containsAll(roles);
        
        log.debug("User ID: {} {} all required roles", userId, 
                hasAllRoles ? "has" : "does not have");
        
        return hasAllRoles;
    }
    
    @Override
    @Transactional(readOnly = true)
    @Cacheable(value = "allUserPermissions", key = "#userId")
    public Set<String> getUserPermissions(Long userId) {
        log.debug("Getting all permissions for user ID: {}", userId);
        
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException(userId));
        
        Set<String> permissions = new HashSet<>();
        
        for (Role role : user.getRoles()) {
            if (role.getActive()) {
                for (Resource resource : role.getResources()) {
                    if (resource.getActive()) {
                        String permission = resource.getMethod() + ":" + resource.getUrl();
                        permissions.add(permission);
                    }
                }
            }
        }
        
        log.debug("Found {} permissions for user ID: {}", permissions.size(), userId);
        return permissions;
    }
    
    @Override
    @Transactional(readOnly = true)
    @Cacheable(value = "allUserRoles", key = "#userId")
    public Set<String> getUserRoles(Long userId) {
        log.debug("Getting all roles for user ID: {}", userId);
        
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException(userId));
        
        Set<String> roleNames = user.getRoles().stream()
                .filter(Role::getActive)
                .map(Role::getName)
                .collect(Collectors.toSet());
        
        log.debug("Found {} roles for user ID: {}", roleNames.size(), userId);
        return roleNames;
    }
    
    @Override
    @Transactional(readOnly = true)
    public boolean hasPermissionByPattern(Long userId, String urlPattern, String method) {
        log.debug("Checking pattern permission for user ID: {}, URL pattern: {}, Method: {}", 
                userId, urlPattern, method);
        
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException(userId));
        
        if (!user.getEnabled()) {
            log.debug("User ID: {} is disabled", userId);
            return false;
        }
        
        // Get matching resources by pattern
        List<Resource> matchingResources = resourceRepository
                .findByUrlPatternAndMethod(urlPattern, method);
        
        // Check if user has access to any matching resource
        Set<String> userPermissions = getUserPermissions(userId);
        
        for (Resource resource : matchingResources) {
            String permission = resource.getMethod() + ":" + resource.getUrl();
            if (userPermissions.contains(permission)) {
                log.debug("User ID: {} has pattern permission for {}:{}", userId, method, urlPattern);
                return true;
            }
        }
        
        log.debug("User ID: {} does not have pattern permission for {}:{}", userId, method, urlPattern);
        return false;
    }
    
    @Override
    @Transactional(readOnly = true)
    public Set<String> validatePermissions(Long userId, Set<String> permissions) {
        log.debug("Validating permissions {} for user ID: {}", permissions, userId);
        
        Set<String> userPermissions = getUserPermissions(userId);
        Set<String> validPermissions = permissions.stream()
                .filter(userPermissions::contains)
                .collect(Collectors.toSet());
        
        log.debug("User ID: {} has {} out of {} requested permissions", 
                userId, validPermissions.size(), permissions.size());
        
        return validPermissions;
    }
}
</file>

<file path="src/main/java/com/example/demo/security/service/impl/RoleServiceImpl.java">
package com.example.demo.security.service.impl;

import com.example.demo.security.dto.ResourceDto;
import com.example.demo.security.dto.RoleDto;
import com.example.demo.security.entity.Role;
import com.example.demo.security.entity.Resource;
import com.example.demo.security.repository.RoleRepository;
import com.example.demo.security.repository.ResourceRepository;
import com.example.demo.security.service.RoleService;
import com.example.demo.security.exception.RoleNotFoundException;
import com.example.demo.security.exception.RoleAlreadyExistsException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * Role Service Implementation
 * 
 * Implements role management operations including CRUD operations,
 * resource assignments, and permission management.
 */
@Service
@RequiredArgsConstructor
@Slf4j
@Transactional
public class RoleServiceImpl implements RoleService {

    private final RoleRepository roleRepository;
    private final ResourceRepository resourceRepository;

    @Override
    @Transactional(readOnly = true)
    public List<RoleDto> getAllRoles() {
        log.debug("Fetching all roles");

        List<Role> roles = roleRepository.findAll();

        return roles.stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public Page<RoleDto> getAllRoles(Pageable pageable) {
        log.debug("Fetching all roles with pagination: {}", pageable);

        Page<Role> roles = roleRepository.findAll(pageable);

        return roles.map(this::convertToDto);
    }

    @Override
    @Transactional(readOnly = true)
    public RoleDto getRoleById(Long id) {
        log.debug("Fetching role with ID: {}", id);

        Role role = roleRepository.findById(id)
                .orElseThrow(() -> new RoleNotFoundException("Role not found with ID: " + id));

        return convertToDto(role);
    }

    @Override
    @Transactional(readOnly = true)
    public List<RoleDto> searchRoles(String searchTerm) {
        log.debug("Searching roles with term: '{}'", searchTerm);

        List<Role> roles = roleRepository.findByNameContainingIgnoreCase(searchTerm);

        return roles.stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    @Override
    public RoleDto createRole(RoleDto roleDto) {
        log.debug("Creating new role with name: {}", roleDto.getName());

        // Check if role name already exists
        if (roleRepository.existsByName(roleDto.getName())) {
            throw new RoleAlreadyExistsException("Role already exists with name: " + roleDto.getName());
        }

        Role role = convertToEntity(roleDto);
        role.setActive(true); // New roles are active by default

        Role savedRole = roleRepository.save(role);

        log.info("Role created successfully with ID: {}", savedRole.getId());

        return convertToDto(savedRole);
    }

    @Override
    public RoleDto updateRole(Long id, RoleDto roleDto) {
        log.debug("Updating role with ID: {}", id);

        Role existingRole = roleRepository.findById(id)
                .orElseThrow(() -> new RoleNotFoundException("Role not found with ID: " + id));

        // Check if new name conflicts with existing role (excluding current role)
        if (!existingRole.getName().equals(roleDto.getName()) &&
                roleRepository.existsByName(roleDto.getName())) {
            throw new RoleAlreadyExistsException("Role already exists with name: " + roleDto.getName());
        }

        existingRole.setName(roleDto.getName());
        existingRole.setDescription(roleDto.getDescription());

        Role updatedRole = roleRepository.save(existingRole);

        log.info("Role updated successfully: {}", updatedRole.getName());

        return convertToDto(updatedRole);
    }

    @Override
    public void deleteRole(Long id) {
        log.debug("Deleting role with ID: {}", id);

        Role role = roleRepository.findById(id)
                .orElseThrow(() -> new RoleNotFoundException("Role not found with ID: " + id));

        // Clear all resource associations first
        role.getResources().clear();
        roleRepository.save(role);

        // Delete the role
        roleRepository.delete(role);

        log.info("Role deleted successfully with ID: {}", id);
    }

    @Override
    public void setRoleEnabled(Long id, boolean enabled) {
        log.debug("Setting role {} enabled status to: {}", id, enabled);

        Role role = roleRepository.findById(id)
                .orElseThrow(() -> new RoleNotFoundException("Role not found with ID: " + id));

        role.setActive(enabled);
        roleRepository.save(role);

        String action = enabled ? "enabled" : "disabled";
        log.info("Role {} successfully {}", id, action);
    }

    @Override
    public void assignResourcesToRole(Long roleId, Set<Long> resourceIds) {
        log.debug("Assigning resources {} to role ID: {}", resourceIds, roleId);

        Role role = roleRepository.findById(roleId)
                .orElseThrow(() -> new RoleNotFoundException("Role not found with ID: " + roleId));

        for (Long resourceId : resourceIds) {
            Resource resource = resourceRepository.findById(resourceId)
                    .orElseThrow(() -> new RuntimeException("Resource not found with ID: " + resourceId));

            // Add resource to role if not already present
            role.getResources().add(resource);
        }

        roleRepository.save(role);

        log.info("Resources assigned successfully to role ID: {}", roleId);
    }

    @Override
    public void removeResourcesFromRole(Long roleId, Set<Long> resourceIds) {
        log.debug("Removing resources {} from role ID: {}", resourceIds, roleId);

        Role role = roleRepository.findById(roleId)
                .orElseThrow(() -> new RoleNotFoundException("Role not found with ID: " + roleId));

        for (Long resourceId : resourceIds) {
            Resource resource = resourceRepository.findById(resourceId).orElse(null);
            if (resource != null) {
                role.getResources().remove(resource);
            }
        }

        roleRepository.save(role);

        log.info("Resources removed successfully from role ID: {}", roleId);
    }

    @Override
    @Transactional(readOnly = true)
    public Set<String> getRolePermissions(Long roleId) {
        log.debug("Fetching permissions for role ID: {}", roleId);

        Role role = roleRepository.findById(roleId)
                .orElseThrow(() -> new RoleNotFoundException("Role not found with ID: " + roleId));

        Set<String> permissions = role.getResources().stream()
                .map(Resource::getName)
                .collect(Collectors.toSet());

        log.debug("Retrieved {} permissions for role ID: {}", permissions.size(), roleId);

        return permissions;
    }

    /**
     * Convert Role entity to RoleDto
     */
/**
 * Convert Role entity to RoleDto
 */
private RoleDto convertToDto(Role role) {
    RoleDto dto = new RoleDto();
    dto.setId(role.getId());
    dto.setName(role.getName());
    dto.setDescription(role.getDescription());
    dto.setActive(role.getActive());
    dto.setCreatedAt(role.getCreatedAt());
    dto.setUpdatedAt(role.getUpdatedAt());

    // Load resources
    Set<ResourceDto> resourceDtos = role.getResources().stream()
            .map(this::convertToResourceDto)
            .collect(Collectors.toSet());
    dto.setResources(resourceDtos);

    return dto;
}

    /**
     * Convert Resource entity to ResourceDto
     */
    private ResourceDto convertToResourceDto(Resource resource) {
        ResourceDto resourceDto = new ResourceDto();
        resourceDto.setId(resource.getId());
        resourceDto.setName(resource.getName());
        resourceDto.setDescription(resource.getDescription());
        resourceDto.setActive(resource.getActive());
        resourceDto.setCreatedAt(resource.getCreatedAt());
        resourceDto.setUpdatedAt(resource.getUpdatedAt());

        return resourceDto;
    }


    /**
     * Convert RoleDto to Role entity
     */
    private Role convertToEntity(RoleDto dto) {
        Role role = new Role();
        role.setName(dto.getName());
        role.setDescription(dto.getDescription());
        role.setActive(dto.getActive() != null ? dto.getActive() : true);

        return role;
    }
}
</file>

<file path="src/main/java/com/example/demo/security/service/impl/UserServiceImpl.java">
package com.example.demo.security.service.impl;

import com.example.demo.security.dto.UserDto;
import com.example.demo.security.dto.UserCreateRequest;
import com.example.demo.security.dto.UserUpdateRequest;
import com.example.demo.security.dto.RoleDto;
import com.example.demo.security.entity.User;
import com.example.demo.security.entity.Role;
import com.example.demo.security.entity.Resource;
import com.example.demo.security.exception.UserNotFoundException;
import com.example.demo.security.exception.UserAlreadyExistsException;
import com.example.demo.security.exception.RoleNotFoundException;
import com.example.demo.security.exception.InvalidPasswordException;
import com.example.demo.security.repository.UserRepository;
import com.example.demo.security.repository.RoleRepository;
import com.example.demo.security.service.UserService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.Instant;
import java.util.HashSet;
import java.util.Set;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class UserServiceImpl implements UserService {
    
    private final UserRepository userRepository;
    private final RoleRepository roleRepository;
    private final PasswordEncoder passwordEncoder;
    
    @Override
    @Transactional
    public UserDto createUser(UserCreateRequest createRequest) {
        log.debug("Creating new user with username: {}", createRequest.getUsername());
        
        // Check if username already exists
        if (userRepository.existsByUsername(createRequest.getUsername())) {
            throw new UserAlreadyExistsException("Username already exists: " + createRequest.getUsername());
        }
        
        // Check if email already exists
        if (userRepository.existsByEmail(createRequest.getEmail())) {
            throw new UserAlreadyExistsException("Email already exists: " + createRequest.getEmail());
        }
        
        User user = new User();
        user.setUsername(createRequest.getUsername());
        user.setEmail(createRequest.getEmail());
        user.setPassword(passwordEncoder.encode(createRequest.getPassword()));
        user.setFirstName(createRequest.getFirstName());
        user.setLastName(createRequest.getLastName());
        user.setEnabled(true);
        user.setPasswordChangedAt(Instant.now());
        
        // Assign roles if provided
        if (createRequest.getRoleIds() != null && !createRequest.getRoleIds().isEmpty()) {
            Set<Role> roles = new HashSet<>();
            for (Long roleId : createRequest.getRoleIds()) {
                Role role = roleRepository.findById(roleId)
                        .orElseThrow(() -> new RoleNotFoundException(roleId));
                roles.add(role);
            }
            user.setRoles(roles);
        }
        
        User savedUser = userRepository.save(user);
        log.info("User created successfully with ID: {}", savedUser.getId());
        
        return convertToDto(savedUser);
    }    
@Override
    @Transactional
    @CacheEvict(value = {"userDetails", "userDetailsById"}, key = "#id")
    public UserDto updateUser(Long id, UserUpdateRequest updateRequest) {
        log.debug("Updating user with ID: {}", id);
        
        User user = userRepository.findById(id)
                .orElseThrow(() -> new UserNotFoundException(id));
        
        // Check if email is being changed and if it already exists
        if (!user.getEmail().equals(updateRequest.getEmail()) && 
            userRepository.existsByEmail(updateRequest.getEmail())) {
            throw new UserAlreadyExistsException("Email already exists: " + updateRequest.getEmail());
        }
        
        user.setEmail(updateRequest.getEmail());
        user.setFirstName(updateRequest.getFirstName());
        user.setLastName(updateRequest.getLastName());
        
        if (updateRequest.getEnabled() != null) {
            user.setEnabled(updateRequest.getEnabled());
        }
        
        // Update roles if provided
        if (updateRequest.getRoleIds() != null) {
            Set<Role> roles = new HashSet<>();
            for (Long roleId : updateRequest.getRoleIds()) {
                Role role = roleRepository.findById(roleId)
                        .orElseThrow(() -> new RoleNotFoundException(roleId));
                roles.add(role);
            }
            user.setRoles(roles);
        }
        
        User savedUser = userRepository.save(user);
        log.info("User updated successfully with ID: {}", savedUser.getId());
        
        return convertToDto(savedUser);
    }
    
    @Override
    @Transactional(readOnly = true)
    @Cacheable(value = "users", key = "#id")
    public UserDto getUserById(Long id) {
        log.debug("Getting user by ID: {}", id);
        
        User user = userRepository.findById(id)
                .orElseThrow(() -> new UserNotFoundException(id));
        
        return convertToDto(user);
    }
    
    @Override
    @Transactional(readOnly = true)
    @Cacheable(value = "usersByUsername", key = "#username")
    public UserDto getUserByUsername(String username) {
        log.debug("Getting user by username: {}", username);
        
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new UserNotFoundException(username, true));
        
        return convertToDto(user);
    }
    
    @Override
    @Transactional(readOnly = true)
    public Page<UserDto> getAllUsers(Pageable pageable) {
        log.debug("Getting all users with pagination: {}", pageable);
        
        Page<User> users = userRepository.findAll(pageable);
        return users.map(this::convertToDto);
    }
    
    @Override
    @Transactional(readOnly = true)
    public Page<UserDto> searchUsers(String searchTerm, Pageable pageable) {
        log.debug("Searching users with term: {} and pagination: {}", searchTerm, pageable);
        
        Page<User> users = userRepository.searchUsers(searchTerm, pageable);
        return users.map(this::convertToDto);
    }  
  @Override
    @Transactional
    @CacheEvict(value = {"users", "userDetails", "userDetailsById"}, key = "#id")
    public void deleteUser(Long id) {
        log.debug("Deleting user with ID: {}", id);
        
        User user = userRepository.findById(id)
                .orElseThrow(() -> new UserNotFoundException(id));
        
        userRepository.delete(user);
        log.info("User deleted successfully with ID: {}", id);
    }
    
    @Override
    @Transactional
    @CacheEvict(value = {"users", "userDetails", "userDetailsById"}, key = "#id")
    public void setUserEnabled(Long id, boolean enabled) {
        log.debug("Setting user enabled status to {} for ID: {}", enabled, id);
        
        User user = userRepository.findById(id)
                .orElseThrow(() -> new UserNotFoundException(id));
        
        user.setEnabled(enabled);
        userRepository.save(user);
        
        log.info("User enabled status updated to {} for ID: {}", enabled, id);
    }
    
    @Override
    @Transactional
    @CacheEvict(value = {"users", "userDetails", "userDetailsById"}, key = "#userId")
    public void assignRolesToUser(Long userId, Set<Long> roleIds) {
        log.debug("Assigning roles {} to user ID: {}", roleIds, userId);
        
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException(userId));
        
        Set<Role> rolesToAdd = new HashSet<>();
        for (Long roleId : roleIds) {
            Role role = roleRepository.findById(roleId)
                    .orElseThrow(() -> new RoleNotFoundException(roleId));
            rolesToAdd.add(role);
        }
        
        user.getRoles().addAll(rolesToAdd);
        userRepository.save(user);
        
        log.info("Roles assigned successfully to user ID: {}", userId);
    }
    
    @Override
    @Transactional
    @CacheEvict(value = {"users", "userDetails", "userDetailsById"}, key = "#userId")
    public void removeRolesFromUser(Long userId, Set<Long> roleIds) {
        log.debug("Removing roles {} from user ID: {}", roleIds, userId);
        
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException(userId));
        
        Set<Role> rolesToRemove = user.getRoles().stream()
                .filter(role -> roleIds.contains(role.getId()))
                .collect(Collectors.toSet());
        
        user.getRoles().removeAll(rolesToRemove);
        userRepository.save(user);
        
        log.info("Roles removed successfully from user ID: {}", userId);
    }   
 @Override
    @Transactional(readOnly = true)
    @Cacheable(value = "userPermissions", key = "#userId")
    public Set<String> getUserPermissions(Long userId) {
        log.debug("Getting permissions for user ID: {}", userId);
        
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException(userId));
        
        Set<String> permissions = new HashSet<>();
        
        for (Role role : user.getRoles()) {
            if (role.getActive()) {
                for (Resource resource : role.getResources()) {
                    if (resource.getActive()) {
                        String permission = resource.getMethod() + ":" + resource.getUrl();
                        permissions.add(permission);
                    }
                }
            }
        }
        
        log.debug("Found {} permissions for user ID: {}", permissions.size(), userId);
        return permissions;
    }
    
    @Override
    @Transactional(readOnly = true)
    public boolean hasPermission(Long userId, String permission) {
        log.debug("Checking permission '{}' for user ID: {}", permission, userId);
        
        Set<String> userPermissions = getUserPermissions(userId);
        boolean hasPermission = userPermissions.contains(permission);
        
        log.debug("User ID: {} {} permission '{}'", userId, 
                hasPermission ? "has" : "does not have", permission);
        
        return hasPermission;
    }
    
    @Override
    @Transactional
    public void updateLastLoginTime(Long userId) {
        log.debug("Updating last login time for user ID: {}", userId);
        
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException(userId));
        
        user.setLastLogin(Instant.now());
        userRepository.save(user);
        
        log.debug("Last login time updated for user ID: {}", userId);
    }
    
    @Override
    @Transactional
    @CacheEvict(value = {"userDetails", "userDetailsById"}, key = "#userId")
    public void changePassword(Long userId, String oldPassword, String newPassword) {
        log.debug("Changing password for user ID: {}", userId);
        
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException(userId));
        
        // Verify old password
        if (!passwordEncoder.matches(oldPassword, user.getPassword())) {
            throw new InvalidPasswordException("Current password is incorrect");
        }
        
        // Update password
        user.setPassword(passwordEncoder.encode(newPassword));
        user.setPasswordChangedAt(Instant.now());
        user.setPasswordChangeRequired(false);
        userRepository.save(user);
        
        log.info("Password changed successfully for user ID: {}", userId);
    }
    
    @Override
    @Transactional
    @CacheEvict(value = {"userDetails", "userDetailsById"}, key = "#userId")
    public void resetPassword(Long userId, String newPassword) {
        log.debug("Resetting password for user ID: {}", userId);
        
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException(userId));
        
        user.setPassword(passwordEncoder.encode(newPassword));
        user.setPasswordChangedAt(Instant.now());
        user.setPasswordChangeRequired(true); // Force password change on next login
        userRepository.save(user);
        
        log.info("Password reset successfully for user ID: {}", userId);
    }  
  private UserDto convertToDto(User user) {
        Set<RoleDto> roleDtos = user.getRoles().stream()
                .map(this::convertRoleToDto)
                .collect(Collectors.toSet());
        
        return UserDto.builder()
                .id(user.getId())
                .username(user.getUsername())
                .email(user.getEmail())
                .firstName(user.getFirstName())
                .lastName(user.getLastName())
                .enabled(user.getEnabled())
                .createdAt(user.getCreatedAt())
                .updatedAt(user.getUpdatedAt())
                .lastLogin(user.getLastLogin())
                .roles(roleDtos)
                .build();
    }
    
    private RoleDto convertRoleToDto(Role role) {
        return RoleDto.builder()
                .id(role.getId())
                .name(role.getName())
                .description(role.getDescription())
                .active(role.getActive())
                .createdAt(role.getCreatedAt())
                .updatedAt(role.getUpdatedAt())
                .build();
    }
}
</file>

<file path="src/main/java/com/example/demo/security/service/PermissionService.java">
package com.example.demo.security.service;

import java.util.Set;

public interface PermissionService {
    
    /**
     * Check if user has permission to access a resource
     * @param userId User ID
     * @param url Resource URL
     * @param method HTTP method
     * @return true if user has permission
     */
    boolean hasPermission(Long userId, String url, String method);
    
    /**
     * Check if user has any of the specified roles
     * @param userId User ID
     * @param roles Set of role names
     * @return true if user has any of the roles
     */
    boolean hasAnyRole(Long userId, Set<String> roles);
    
    /**
     * Check if user has all of the specified roles
     * @param userId User ID
     * @param roles Set of role names
     * @return true if user has all roles
     */
    boolean hasAllRoles(Long userId, Set<String> roles);
    
    /**
     * Get all permissions for a user
     * @param userId User ID
     * @return Set of permission strings in format "METHOD:URL"
     */
    Set<String> getUserPermissions(Long userId);
    
    /**
     * Get all role names for a user
     * @param userId User ID
     * @return Set of role names
     */
    Set<String> getUserRoles(Long userId);
    
    /**
     * Check if user can access resource based on URL pattern matching
     * @param userId User ID
     * @param urlPattern URL pattern to match
     * @param method HTTP method
     * @return true if user has permission
     */
    boolean hasPermissionByPattern(Long userId, String urlPattern, String method);
    
    /**
     * Validate user permissions for multiple resources
     * @param userId User ID
     * @param permissions Set of permissions to check
     * @return Set of permissions the user actually has
     */
    Set<String> validatePermissions(Long userId, Set<String> permissions);
}
</file>

<file path="src/main/java/com/example/demo/security/service/RoleService.java">
package com.example.demo.security.service;

import com.example.demo.security.dto.RoleDto;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import java.util.List;
import java.util.Set;

/**
 * Role Service Interface
 * 
 * Defines operations for role management including CRUD operations,
 * resource assignments, and permission management.
 */
public interface RoleService {
    
    /**
     * Get all roles
     * 
     * @return List of all roles
     */
    List<RoleDto> getAllRoles();
    
    /**
     * Get all roles with pagination
     * 
     * @param pageable Pagination parameters
     * @return Paginated list of roles
     */
    Page<RoleDto> getAllRoles(Pageable pageable);
    
    /**
     * Get role by ID
     * 
     * @param id Role ID
     * @return Role details
     */
    RoleDto getRoleById(Long id);
    
    /**
     * Search roles by name
     * 
     * @param searchTerm Search term for role name
     * @return List of matching roles
     */
    List<RoleDto> searchRoles(String searchTerm);
    
    /**
     * Create new role
     * 
     * @param roleDto Role creation data
     * @return Created role details
     */
    RoleDto createRole(RoleDto roleDto);
    
    /**
     * Update existing role
     * 
     * @param id Role ID
     * @param roleDto Updated role data
     * @return Updated role details
     */
    RoleDto updateRole(Long id, RoleDto roleDto);
    
    /**
     * Delete role
     * 
     * @param id Role ID
     */
    void deleteRole(Long id);
    
    /**
     * Enable or disable role
     * 
     * @param id Role ID
     * @param enabled Enable/disable flag
     */
    void setRoleEnabled(Long id, boolean enabled);
    
    /**
     * Assign resources to role
     * 
     * @param roleId Role ID
     * @param resourceIds Set of resource IDs to assign
     */
    void assignResourcesToRole(Long roleId, Set<Long> resourceIds);
    
    /**
     * Remove resources from role
     * 
     * @param roleId Role ID
     * @param resourceIds Set of resource IDs to remove
     */
    void removeResourcesFromRole(Long roleId, Set<Long> resourceIds);
    
    /**
     * Get role permissions
     * 
     * @param roleId Role ID
     * @return Set of role permissions
     */
    Set<String> getRolePermissions(Long roleId);
}
</file>

<file path="src/main/java/com/example/demo/security/service/UserService.java">
package com.example.demo.security.service;

import com.example.demo.security.dto.UserDto;
import com.example.demo.security.dto.UserCreateRequest;
import com.example.demo.security.dto.UserUpdateRequest;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import java.util.Set;

public interface UserService {
    
    /**
     * Create a new user
     * @param createRequest User creation data
     * @return Created user DTO
     */
    UserDto createUser(UserCreateRequest createRequest);
    
    /**
     * Update an existing user
     * @param id User ID
     * @param updateRequest Updated user data
     * @return Updated user DTO
     */
    UserDto updateUser(Long id, UserUpdateRequest updateRequest);
    
    /**
     * Get user by ID
     * @param id User ID
     * @return User DTO
     */
    UserDto getUserById(Long id);
    
    /**
     * Get user by username
     * @param username Username
     * @return User DTO
     */
    UserDto getUserByUsername(String username);
    
    /**
     * Get all users with pagination
     * @param pageable Pagination parameters
     * @return Page of user DTOs
     */
    Page<UserDto> getAllUsers(Pageable pageable);
    
    /**
     * Search users by criteria
     * @param searchTerm Search term for username, first name, or last name
     * @param pageable Pagination parameters
     * @return Page of matching user DTOs
     */
    Page<UserDto> searchUsers(String searchTerm, Pageable pageable);
    
    /**
     * Delete user by ID
     * @param id User ID
     */
    void deleteUser(Long id);
    
    /**
     * Enable or disable user
     * @param id User ID
     * @param enabled Enable/disable flag
     */
    void setUserEnabled(Long id, boolean enabled);
    
    /**
     * Assign roles to user
     * @param userId User ID
     * @param roleIds Set of role IDs to assign
     */
    void assignRolesToUser(Long userId, Set<Long> roleIds);
    
    /**
     * Remove roles from user
     * @param userId User ID
     * @param roleIds Set of role IDs to remove
     */
    void removeRolesFromUser(Long userId, Set<Long> roleIds);
    
    /**
     * Get user permissions
     * @param userId User ID
     * @return Set of permission strings
     */
    Set<String> getUserPermissions(Long userId);
    
    /**
     * Check if user has specific permission
     * @param userId User ID
     * @param permission Permission string
     * @return true if user has permission
     */
    boolean hasPermission(Long userId, String permission);
    
    /**
     * Update user last login time
     * @param userId User ID
     */
    void updateLastLoginTime(Long userId);
    
    /**
     * Change user password
     * @param userId User ID
     * @param oldPassword Current password
     * @param newPassword New password
     */
    void changePassword(Long userId, String oldPassword, String newPassword);
    
    /**
     * Reset user password (admin function)
     * @param userId User ID
     * @param newPassword New password
     */
    void resetPassword(Long userId, String newPassword);
}
</file>

<file path="src/main/java/com/example/demo/ServletInitializer.java">
package com.example.demo;

import org.springframework.boot.builder.SpringApplicationBuilder;
import org.springframework.boot.web.servlet.support.SpringBootServletInitializer;

/**
 * ServletInitializer for WAR deployment configuration.
 * 
 * This class extends SpringBootServletInitializer to support traditional
 * WAR deployment to external servlet containers if needed, while maintaining
 * the primary executable JAR deployment strategy.
 */
public class ServletInitializer extends SpringBootServletInitializer {

    @Override
    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
        return application.sources(DemoApplication.class);
    }
}
</file>

<file path="src/main/resources/application-dev.properties">
# Development Environment Configuration
# Employee Management System - Development Profile

# Development Server Configuration
server.error.include-stacktrace=on_param
server.error.include-exception=true

# Development Database Configuration
spring.datasource.url=jdbc:postgresql://localhost:5432/employee_management_dev
spring.datasource.username=employee_admin
spring.datasource.password=dev_password

# Development JPA Configuration
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.use_sql_comments=true

# Development Redis Configuration
spring.data.redis.host=localhost
spring.data.redis.port=6379
spring.data.redis.database=1

# Development Security Configuration
jwt.secret=developmentSecretKeyNotForProduction
encryption.key=developmentEncryptionKeyNotForProduction

# Development Email Configuration (Console output)
spring.mail.host=localhost
spring.mail.port=1025
spring.mail.username=
spring.mail.password=
spring.mail.properties.mail.smtp.auth=false
spring.mail.properties.mail.smtp.starttls.enable=false

# Development Logging Configuration
logging.level.com.example.demo=DEBUG
logging.level.org.springframework.web=DEBUG
logging.level.org.springframework.security=DEBUG
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE
logging.level.org.springframework.cache=DEBUG

# Development Actuator Configuration
management.endpoints.web.exposure.include=*
management.endpoint.health.show-details=always

# Development CORS Configuration (Allow all origins for development)
cors.allowed-origins=http://localhost:3000,http://localhost:5173
cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS
cors.allowed-headers=*
cors.allow-credentials=true

# Development File Storage
file.upload.directory=./uploads/dev
file.temp.directory=./temp/dev
</file>

<file path="src/main/resources/application-prod.properties">
# Production Environment Configuration
# Employee Management System - Production Profile

# Production Server Configuration
server.error.include-message=never
server.error.include-binding-errors=never
server.error.include-stacktrace=never
server.error.include-exception=false

# Production Database Configuration
spring.datasource.url=${DATABASE_URL:jdbc:postgresql://localhost:5432/employee_management}
spring.datasource.username=${DATABASE_USERNAME:employee_admin}
spring.datasource.password=${DATABASE_PASSWORD}

# Production Connection Pool Configuration
spring.datasource.hikari.maximum-pool-size=30
spring.datasource.hikari.minimum-idle=10
spring.datasource.hikari.idle-timeout=600000
spring.datasource.hikari.connection-timeout=30000
spring.datasource.hikari.max-lifetime=1800000

# Production JPA Configuration
spring.jpa.show-sql=false
spring.jpa.properties.hibernate.format_sql=false
spring.jpa.properties.hibernate.use_sql_comments=false

# Production Redis Configuration
spring.data.redis.host=${REDIS_HOST:localhost}
spring.data.redis.port=${REDIS_PORT:6379}
spring.data.redis.password=${REDIS_PASSWORD:}
spring.data.redis.database=0
spring.data.redis.ssl.enabled=${REDIS_SSL_ENABLED:false}

# Production Security Configuration
jwt.secret=${JWT_SECRET}
jwt.expiration=3600000
jwt.refresh-expiration=86400000
encryption.key=${ENCRYPTION_KEY}

# Production Email Configuration
spring.mail.host=${EMAIL_HOST}
spring.mail.port=${EMAIL_PORT:587}
spring.mail.username=${EMAIL_USERNAME}
spring.mail.password=${EMAIL_PASSWORD}
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true
spring.mail.properties.mail.smtp.starttls.required=true

# Production Logging Configuration
logging.level.com.example.demo=INFO
logging.level.org.springframework.security=WARN
logging.level.org.hibernate.SQL=WARN
logging.level.org.springframework.web=WARN
logging.file.name=logs/employee-management.log
logging.file.max-size=10MB
logging.file.max-history=30

# Production Actuator Configuration
management.endpoints.web.exposure.include=health,info,metrics
management.endpoint.health.show-details=never
management.security.enabled=true

# Production CORS Configuration
cors.allowed-origins=${CORS_ALLOWED_ORIGINS:https://yourdomain.com}
cors.allowed-methods=GET,POST,PUT,DELETE
cors.allowed-headers=Authorization,Content-Type,X-Requested-With
cors.allow-credentials=true

# Production File Storage
file.upload.directory=${FILE_UPLOAD_DIR:/var/app/uploads}
file.temp.directory=${FILE_TEMP_DIR:/var/app/temp}

# Production SSL Configuration (if applicable)
server.ssl.enabled=${SSL_ENABLED:false}
server.ssl.key-store=${SSL_KEYSTORE:}
server.ssl.key-store-password=${SSL_KEYSTORE_PASSWORD:}
server.ssl.key-store-type=PKCS12
</file>

<file path="src/main/resources/application.properties">
# Employee Management System - Main Configuration
# Spring Boot 3.5.4 with Java 24

# Server Configuration
server.port=8080
server.servlet.context-path=/api
server.error.include-message=on_param
server.error.include-binding-errors=on_param

# Application Information
spring.application.name=Employee Management System
info.app.name=Employee Management System
info.app.description=Spring Boot Employee Management System with PostgreSQL and Redis
info.app.version=1.0.0

# Profile Configuration
spring.profiles.active=dev

# PostgreSQL Database Configuration
spring.datasource.url=jdbc:postgresql://localhost:5432/employee_management
spring.datasource.username=employee_admin
spring.datasource.password=dev_password
spring.datasource.driver-class-name=org.postgresql.Driver

# HikariCP Connection Pool Configuration
spring.datasource.hikari.maximum-pool-size=20
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.idle-timeout=300000
spring.datasource.hikari.connection-timeout=20000
spring.datasource.hikari.max-lifetime=1200000
spring.datasource.hikari.pool-name=EmployeeManagementPool

# JPA/Hibernate Configuration
spring.jpa.hibernate.ddl-auto=validate
spring.jpa.show-sql=false
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.use_sql_comments=true
spring.jpa.properties.hibernate.jdbc.batch_size=20
spring.jpa.properties.hibernate.order_inserts=true
spring.jpa.properties.hibernate.order_updates=true
spring.jpa.properties.hibernate.jdbc.batch_versioned_data=true

# Flyway Configuration
spring.flyway.enabled=true
spring.flyway.locations=classpath:db/migration
spring.flyway.baseline-on-migrate=true
spring.flyway.validate-on-migrate=true
spring.flyway.out-of-order=false

# Redis Configuration
spring.data.redis.host=localhost
spring.data.redis.port=6379
spring.data.redis.database=0
spring.data.redis.timeout=2000ms
spring.data.redis.lettuce.pool.max-active=8
spring.data.redis.lettuce.pool.max-idle=8
spring.data.redis.lettuce.pool.min-idle=0
spring.data.redis.lettuce.pool.max-wait=-1ms

# Cache Configuration
spring.cache.type=redis
spring.cache.redis.time-to-live=600000
spring.cache.redis.cache-null-values=false

# Security Configuration
# JWT Configuration (use environment variables in production)
jwt.secret=${JWT_SECRET:mySecretKeyForDevelopmentOnlyChangeInProduction}
jwt.expiration=86400000
jwt.refresh-expiration=604800000

# Encryption Configuration (use environment variables in production)
encryption.key=${ENCRYPTION_KEY:myEncryptionKeyForDevelopmentOnly}

# Email Configuration
spring.mail.host=localhost
spring.mail.port=587
spring.mail.username=${EMAIL_USERNAME:}
spring.mail.password=${EMAIL_PASSWORD:}
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true
spring.mail.properties.mail.smtp.starttls.required=true

# File Upload Configuration
spring.servlet.multipart.enabled=true
spring.servlet.multipart.max-file-size=10MB
spring.servlet.multipart.max-request-size=10MB

# Async Configuration
spring.task.execution.pool.core-size=5
spring.task.execution.pool.max-size=20
spring.task.execution.pool.queue-capacity=100
spring.task.execution.thread-name-prefix=async-

# Actuator Configuration
management.endpoints.web.exposure.include=health,info,metrics,prometheus
management.endpoint.health.show-details=when_authorized
management.metrics.export.prometheus.enabled=true

# Logging Configuration
logging.level.com.example.demo=INFO
logging.level.org.springframework.security=DEBUG
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} - %msg%n
logging.pattern.file=%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n

# Jackson Configuration
spring.jackson.serialization.write-dates-as-timestamps=false
spring.jackson.time-zone=UTC
spring.jackson.date-format=yyyy-MM-dd HH:mm:ss

# WebSocket Configuration
app.websocket.allowed-origins=http://localhost:3000,http://localhost:5173,http://localhost:8080
app.websocket.heartbeat.client=10000
app.websocket.heartbeat.server=10000

# CSRF Configuration
app.csrf.enabled=true
app.csrf.cookie.name=XSRF-TOKEN
app.csrf.header.name=X-XSRF-TOKEN
app.csrf.parameter.name=_csrf
app.csrf.cookie.http-only=false
app.csrf.cookie.secure=false
app.csrf.cookie.same-site=Lax
</file>

<file path="src/main/resources/db/migration/.gitkeep">
# This file ensures the db/migration directory is tracked by Git
# Flyway migration scripts will be placed in this directory
</file>

<file path="src/main/resources/db/migration/V0__Initial_baseline.sql">
-- Initial baseline migration for Employee Management System
-- This migration establishes the baseline for the database schema
-- Version: V0__Initial_baseline.sql
-- Description: Creates the initial database structure baseline

-- Enable UUID extension for PostgreSQL
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Create schema for application tables (optional, using public schema by default)
-- CREATE SCHEMA IF NOT EXISTS employee_management;

-- Create audit trigger function for automatic timestamp updates
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Create function for generating employee numbers
CREATE OR REPLACE FUNCTION generate_employee_number()
RETURNS TEXT AS $$
DECLARE
    next_number INTEGER;
    employee_number TEXT;
BEGIN
    -- Get the next sequence number
    SELECT COALESCE(MAX(CAST(SUBSTRING(employee_number FROM 4) AS INTEGER)), 0) + 1
    INTO next_number
    FROM employees
    WHERE employee_number ~ '^EMP[0-9]{6}$';
    
    -- Format as EMP followed by 6 digits
    employee_number := 'EMP' || LPAD(next_number::TEXT, 6, '0');
    
    RETURN employee_number;
END;
$$ LANGUAGE plpgsql;

-- Create function for generating department codes
CREATE OR REPLACE FUNCTION generate_department_code()
RETURNS TEXT AS $$
DECLARE
    next_number INTEGER;
    department_code TEXT;
BEGIN
    -- Get the next sequence number
    SELECT COALESCE(MAX(CAST(SUBSTRING(code FROM 5) AS INTEGER)), 0) + 1
    INTO next_number
    FROM departments
    WHERE code ~ '^DEPT[0-9]{4}$';
    
    -- Format as DEPT followed by 4 digits
    department_code := 'DEPT' || LPAD(next_number::TEXT, 4, '0');
    
    RETURN department_code;
END;
$$ LANGUAGE plpgsql;

-- Create function for generating position codes
CREATE OR REPLACE FUNCTION generate_position_code()
RETURNS TEXT AS $$
DECLARE
    next_number INTEGER;
    position_code TEXT;
BEGIN
    -- Get the next sequence number
    SELECT COALESCE(MAX(CAST(SUBSTRING(code FROM 4) AS INTEGER)), 0) + 1
    INTO next_number
    FROM positions
    WHERE code ~ '^POS[0-9]{4}$';
    
    -- Format as POS followed by 4 digits
    position_code := 'POS' || LPAD(next_number::TEXT, 4, '0');
    
    RETURN position_code;
END;
$$ LANGUAGE plpgsql;

-- Create indexes for common query patterns (will be used by future migrations)
-- These are placeholder comments for the actual table creation in subsequent migrations

-- Baseline migration completed
-- Next migrations will create the actual table structures:
-- V1__Create_security_tables.sql - User, Role, Resource tables
-- V2__Create_departments_table.sql - Department hierarchy
-- V3__Create_positions_table.sql - Position management
-- V4__Create_employees_table.sql - Employee data
-- V5__Create_email_tables.sql - Email templates and logs
-- V6__Create_notification_tables.sql - Notification system
-- V7__Create_payroll_tables.sql - Payroll management

COMMENT ON EXTENSION "uuid-ossp" IS 'UUID generation functions for primary keys';
COMMENT ON FUNCTION update_updated_at_column() IS 'Trigger function to automatically update updated_at timestamps';
COMMENT ON FUNCTION generate_employee_number() IS 'Generates sequential employee numbers in format EMP######';
COMMENT ON FUNCTION generate_department_code() IS 'Generates sequential department codes in format DEPT####';
COMMENT ON FUNCTION generate_position_code() IS 'Generates sequential position codes in format POS####';
</file>

<file path="src/main/resources/db/migration/V1__Create_security_tables.sql">
-- Create users table
CREATE TABLE users (
    id BIGSERIAL PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    password VARCHAR(255) NOT NULL,
    email VARCHAR(100) NOT NULL,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    enabled BOOLEAN NOT NULL DEFAULT true,
    last_login TIMESTAMP,
    login_attempts INTEGER NOT NULL DEFAULT 0,
    account_locked BOOLEAN NOT NULL DEFAULT false,
    account_locked_until TIMESTAMP,
    password_expired BOOLEAN NOT NULL DEFAULT false,
    password_change_required BOOLEAN NOT NULL DEFAULT false,
    password_changed_at TIMESTAMP,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP,
    created_by BIGINT,
    updated_by BIGINT,
    
    CONSTRAINT uk_user_username UNIQUE (username),
    CONSTRAINT uk_user_email UNIQUE (email)
);

-- Create indexes for users table
CREATE INDEX idx_user_username ON users (username);
CREATE INDEX idx_user_email ON users (email);
CREATE INDEX idx_user_enabled ON users (enabled);
CREATE INDEX idx_user_account_locked ON users (account_locked);

-- Create roles table
CREATE TABLE roles (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(50) NOT NULL UNIQUE,
    description VARCHAR(255),
    active BOOLEAN NOT NULL DEFAULT true,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP,
    created_by BIGINT,
    updated_by BIGINT
);

-- Create indexes for roles table
CREATE INDEX idx_role_name ON roles (name);
CREATE INDEX idx_role_active ON roles (active);

-- Create resources table
CREATE TABLE resources (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    url VARCHAR(255) NOT NULL,
    method VARCHAR(10) NOT NULL,
    description VARCHAR(255),
    category VARCHAR(50) NOT NULL,
    active BOOLEAN NOT NULL DEFAULT true,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP,
    created_by BIGINT,
    updated_by BIGINT,
    
    CONSTRAINT uk_resource_url_method UNIQUE (url, method)
);

-- Create indexes for resources table
CREATE INDEX idx_resource_url ON resources (url);
CREATE INDEX idx_resource_method ON resources (method);
CREATE INDEX idx_resource_category ON resources (category);
CREATE INDEX idx_resource_active ON resources (active);

-- Create user_roles junction table
CREATE TABLE user_roles (
    user_id BIGINT NOT NULL,
    role_id BIGINT NOT NULL,
    
    PRIMARY KEY (user_id, role_id),
    CONSTRAINT fk_user_roles_user FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
    CONSTRAINT fk_user_roles_role FOREIGN KEY (role_id) REFERENCES roles (id) ON DELETE CASCADE
);

-- Create role_resources junction table
CREATE TABLE role_resources (
    role_id BIGINT NOT NULL,
    resource_id BIGINT NOT NULL,
    
    PRIMARY KEY (role_id, resource_id),
    CONSTRAINT fk_role_resources_role FOREIGN KEY (role_id) REFERENCES roles (id) ON DELETE CASCADE,
    CONSTRAINT fk_role_resources_resource FOREIGN KEY (resource_id) REFERENCES resources (id) ON DELETE CASCADE
);

-- Insert default system roles
INSERT INTO roles (name, description, active, created_at) VALUES
('ADMIN', 'System Administrator with full access', true, CURRENT_TIMESTAMP),
('HR_MANAGER', 'HR Manager with employee management access', true, CURRENT_TIMESTAMP),
('EMPLOYEE', 'Regular employee with limited access', true, CURRENT_TIMESTAMP),
('DEPARTMENT_MANAGER', 'Department Manager with team management access', true, CURRENT_TIMESTAMP);

-- Insert default system resources
INSERT INTO resources (name, url, method, description, category, active, created_at) VALUES
-- User Management
('User List', '/api/users', 'GET', 'View user list', 'USER_MANAGEMENT', true, CURRENT_TIMESTAMP),
('User Create', '/api/users', 'POST', 'Create new user', 'USER_MANAGEMENT', true, CURRENT_TIMESTAMP),
('User Update', '/api/users/*', 'PUT', 'Update user information', 'USER_MANAGEMENT', true, CURRENT_TIMESTAMP),
('User Delete', '/api/users/*', 'DELETE', 'Delete user', 'USER_MANAGEMENT', true, CURRENT_TIMESTAMP),

-- Role Management
('Role List', '/api/roles', 'GET', 'View role list', 'ROLE_MANAGEMENT', true, CURRENT_TIMESTAMP),
('Role Create', '/api/roles', 'POST', 'Create new role', 'ROLE_MANAGEMENT', true, CURRENT_TIMESTAMP),
('Role Update', '/api/roles/*', 'PUT', 'Update role information', 'ROLE_MANAGEMENT', true, CURRENT_TIMESTAMP),
('Role Delete', '/api/roles/*', 'DELETE', 'Delete role', 'ROLE_MANAGEMENT', true, CURRENT_TIMESTAMP),

-- Employee Management
('Employee List', '/api/employees', 'GET', 'View employee list', 'EMPLOYEE_MANAGEMENT', true, CURRENT_TIMESTAMP),
('Employee Create', '/api/employees', 'POST', 'Create new employee', 'EMPLOYEE_MANAGEMENT', true, CURRENT_TIMESTAMP),
('Employee Update', '/api/employees/*', 'PUT', 'Update employee information', 'EMPLOYEE_MANAGEMENT', true, CURRENT_TIMESTAMP),
('Employee Delete', '/api/employees/*', 'DELETE', 'Delete employee', 'EMPLOYEE_MANAGEMENT', true, CURRENT_TIMESTAMP),
('Employee Import', '/api/employees/import', 'POST', 'Import employees from Excel', 'EMPLOYEE_MANAGEMENT', true, CURRENT_TIMESTAMP),
('Employee Export', '/api/employees/export', 'GET', 'Export employees to Excel', 'EMPLOYEE_MANAGEMENT', true, CURRENT_TIMESTAMP),

-- Department Management
('Department List', '/api/departments', 'GET', 'View department list', 'DEPARTMENT_MANAGEMENT', true, CURRENT_TIMESTAMP),
('Department Create', '/api/departments', 'POST', 'Create new department', 'DEPARTMENT_MANAGEMENT', true, CURRENT_TIMESTAMP),
('Department Update', '/api/departments/*', 'PUT', 'Update department information', 'DEPARTMENT_MANAGEMENT', true, CURRENT_TIMESTAMP),
('Department Delete', '/api/departments/*', 'DELETE', 'Delete department', 'DEPARTMENT_MANAGEMENT', true, CURRENT_TIMESTAMP),

-- Position Management
('Position List', '/api/positions', 'GET', 'View position list', 'POSITION_MANAGEMENT', true, CURRENT_TIMESTAMP),
('Position Create', '/api/positions', 'POST', 'Create new position', 'POSITION_MANAGEMENT', true, CURRENT_TIMESTAMP),
('Position Update', '/api/positions/*', 'PUT', 'Update position information', 'POSITION_MANAGEMENT', true, CURRENT_TIMESTAMP),
('Position Delete', '/api/positions/*', 'DELETE', 'Delete position', 'POSITION_MANAGEMENT', true, CURRENT_TIMESTAMP);

-- Assign resources to ADMIN role (full access)
INSERT INTO role_resources (role_id, resource_id)
SELECT r.id, res.id
FROM roles r
CROSS JOIN resources res
WHERE r.name = 'ADMIN';

-- Assign employee management resources to HR_MANAGER role
INSERT INTO role_resources (role_id, resource_id)
SELECT r.id, res.id
FROM roles r
CROSS JOIN resources res
WHERE r.name = 'HR_MANAGER'
AND res.category IN ('EMPLOYEE_MANAGEMENT', 'DEPARTMENT_MANAGEMENT', 'POSITION_MANAGEMENT');

-- Assign limited resources to EMPLOYEE role
INSERT INTO role_resources (role_id, resource_id)
SELECT r.id, res.id
FROM roles r
CROSS JOIN resources res
WHERE r.name = 'EMPLOYEE'
AND res.method = 'GET'
AND res.category IN ('EMPLOYEE_MANAGEMENT', 'DEPARTMENT_MANAGEMENT');

-- Assign department and employee management to DEPARTMENT_MANAGER role
INSERT INTO role_resources (role_id, resource_id)
SELECT r.id, res.id
FROM roles r
CROSS JOIN resources res
WHERE r.name = 'DEPARTMENT_MANAGER'
AND res.category IN ('EMPLOYEE_MANAGEMENT', 'DEPARTMENT_MANAGEMENT');

-- Create default admin user (password: admin123 - should be changed in production)
-- Note: This is a BCrypt hash of 'admin123'
INSERT INTO users (username, password, email, first_name, last_name, enabled, created_at)
VALUES ('admin', '$2a$10$N.zmdr9k7uOCQb376NoUnuTJ8iAt6Z5EHsM8lE9lBOsl7iKTVMFvK', 'admin@company.com', 'System', 'Administrator', true, CURRENT_TIMESTAMP);

-- Assign ADMIN role to default admin user
INSERT INTO user_roles (user_id, role_id)
SELECT u.id, r.id
FROM users u
CROSS JOIN roles r
WHERE u.username = 'admin' AND r.name = 'ADMIN';
</file>

<file path="src/main/resources/db/migration/V2__Create_departments_table.sql">
-- Create departments table with hierarchical structure
CREATE TABLE departments (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    code VARCHAR(20) NOT NULL UNIQUE,
    description VARCHAR(500),
    location VARCHAR(255),
    parent_id BIGINT,
    dep_path VARCHAR(500),
    is_parent BOOLEAN NOT NULL DEFAULT FALSE,
    enabled BOOLEAN NOT NULL DEFAULT TRUE,
    level INTEGER DEFAULT 0,
    sort_order INTEGER DEFAULT 0,
    manager_id BIGINT,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    created_by BIGINT,
    updated_by BIGINT,
    
    -- Self-referencing foreign key for hierarchy
    CONSTRAINT fk_department_parent FOREIGN KEY (parent_id) REFERENCES departments(id) ON DELETE RESTRICT,
    
    -- Check constraints
    CONSTRAINT chk_department_level CHECK (level >= 0),
    CONSTRAINT chk_department_sort_order CHECK (sort_order >= 0),
    CONSTRAINT chk_department_name_not_empty CHECK (LENGTH(TRIM(name)) > 0),
    CONSTRAINT chk_department_code_not_empty CHECK (LENGTH(TRIM(code)) > 0)
);

-- Create indexes for performance optimization
CREATE INDEX idx_department_name ON departments(name);
CREATE INDEX idx_department_code ON departments(code);
CREATE INDEX idx_department_parent_id ON departments(parent_id);
CREATE INDEX idx_department_dep_path ON departments(dep_path);
CREATE INDEX idx_department_enabled ON departments(enabled);
CREATE INDEX idx_department_manager_id ON departments(manager_id);
CREATE INDEX idx_department_level ON departments(level);
CREATE INDEX idx_department_sort_order ON departments(sort_order);

-- Composite indexes for common queries
CREATE INDEX idx_department_parent_sort ON departments(parent_id, sort_order);
CREATE INDEX idx_department_enabled_path ON departments(enabled, dep_path);

-- Insert default root departments
INSERT INTO departments (name, code, description, dep_path, is_parent, level, sort_order) VALUES
('Company', 'COMP', 'Root company department', '/COMP', TRUE, 0, 1),
('Human Resources', 'HR', 'Human Resources Department', '/COMP/HR', FALSE, 1, 1),
('Information Technology', 'IT', 'Information Technology Department', '/COMP/IT', FALSE, 1, 2),
('Finance', 'FIN', 'Finance Department', '/COMP/FIN', FALSE, 1, 3),
('Operations', 'OPS', 'Operations Department', '/COMP/OPS', FALSE, 1, 4);

-- Update parent relationships
UPDATE departments SET parent_id = (SELECT id FROM departments WHERE code = 'COMP') 
WHERE code IN ('HR', 'IT', 'FIN', 'OPS');

-- Update is_parent flag for company
UPDATE departments SET is_parent = TRUE WHERE code = 'COMP';

-- Create trigger to automatically update dep_path and level
CREATE OR REPLACE FUNCTION update_department_path()
RETURNS TRIGGER AS $$
DECLARE
    parent_path VARCHAR(500);
    parent_level INTEGER;
BEGIN
    IF NEW.parent_id IS NULL THEN
        -- Root department
        NEW.dep_path := '/' || NEW.code;
        NEW.level := 0;
        NEW.is_parent := CASE WHEN EXISTS(SELECT 1 FROM departments WHERE parent_id = NEW.id) THEN TRUE ELSE FALSE END;
    ELSE
        -- Child department
        SELECT dep_path, level INTO parent_path, parent_level
        FROM departments WHERE id = NEW.parent_id;
        
        IF parent_path IS NULL THEN
            RAISE EXCEPTION 'Parent department not found';
        END IF;
        
        NEW.dep_path := parent_path || '/' || NEW.code;
        NEW.level := parent_level + 1;
        
        -- Update parent's is_parent flag
        UPDATE departments SET is_parent = TRUE WHERE id = NEW.parent_id;
    END IF;
    
    NEW.updated_at := CURRENT_TIMESTAMP;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger
CREATE TRIGGER trigger_update_department_path
    BEFORE INSERT OR UPDATE ON departments
    FOR EACH ROW
    EXECUTE FUNCTION update_department_path();

-- Create function to update is_parent flag when departments are deleted
CREATE OR REPLACE FUNCTION update_parent_flag_on_delete()
RETURNS TRIGGER AS $$
BEGIN
    -- Update parent's is_parent flag if no more children exist
    IF OLD.parent_id IS NOT NULL THEN
        UPDATE departments 
        SET is_parent = CASE WHEN EXISTS(SELECT 1 FROM departments WHERE parent_id = OLD.parent_id AND id != OLD.id) THEN TRUE ELSE FALSE END
        WHERE id = OLD.parent_id;
    END IF;
    
    RETURN OLD;
END;
$$ LANGUAGE plpgsql;

-- Create delete trigger
CREATE TRIGGER trigger_update_parent_flag_on_delete
    AFTER DELETE ON departments
    FOR EACH ROW
    EXECUTE FUNCTION update_parent_flag_on_delete();

-- Add comments for documentation
COMMENT ON TABLE departments IS 'Hierarchical department structure with path-based organization';
COMMENT ON COLUMN departments.dep_path IS 'Full path from root to this department (e.g., /COMP/IT/DEV)';
COMMENT ON COLUMN departments.is_parent IS 'Flag indicating if this department has child departments';
COMMENT ON COLUMN departments.level IS 'Hierarchy level (0 for root departments)';
COMMENT ON COLUMN departments.sort_order IS 'Sort order within the same parent level';
COMMENT ON COLUMN departments.manager_id IS 'Employee ID of the department manager';
</file>

<file path="src/main/resources/db/migration/V3__Create_positions_table.sql">
-- Create positions table for job position management
CREATE TABLE positions (
    id BIGSERIAL PRIMARY KEY,
    job_title VARCHAR(100) NOT NULL,
    professional_title VARCHAR(100),
    code VARCHAR(20) NOT NULL UNIQUE,
    description TEXT,
    requirements TEXT,
    responsibilities TEXT,
    category VARCHAR(20) NOT NULL DEFAULT 'TECHNICAL',
    salary_grade VARCHAR(10),
    department_id BIGINT NOT NULL,
    level VARCHAR(20) NOT NULL DEFAULT 'JUNIOR',
    enabled BOOLEAN NOT NULL DEFAULT true,
    min_salary DECIMAL(12,2),
    max_salary DECIMAL(12,2),
    required_skills TEXT,
    required_education VARCHAR(500),
    required_experience INTEGER,
    benefits TEXT,
    work_location VARCHAR(255),
    employment_type VARCHAR(20) NOT NULL DEFAULT 'FULL_TIME',
    is_managerial BOOLEAN NOT NULL DEFAULT false,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_by BIGINT,
    updated_by BIGINT,
    
    -- Foreign key constraint to departments table
    CONSTRAINT fk_position_department FOREIGN KEY (department_id) REFERENCES departments(id) ON DELETE RESTRICT
);

-- Create indexes for performance optimization
CREATE INDEX idx_position_job_title ON positions(job_title);
CREATE INDEX idx_position_code ON positions(code);
CREATE INDEX idx_position_department_id ON positions(department_id);
CREATE INDEX idx_position_level ON positions(level);
CREATE INDEX idx_position_enabled ON positions(enabled);
CREATE INDEX idx_position_category ON positions(category);

-- Add check constraints for enum values
ALTER TABLE positions ADD CONSTRAINT chk_position_category 
    CHECK (category IN ('TECHNICAL', 'MANAGEMENT', 'ADMINISTRATIVE', 'SALES', 'HR', 'FINANCE', 'MARKETING', 'OPERATIONS', 'SUPPORT', 'OTHER'));

ALTER TABLE positions ADD CONSTRAINT chk_position_level 
    CHECK (level IN ('JUNIOR', 'MID', 'SENIOR', 'LEAD', 'MANAGER', 'DIRECTOR', 'VP', 'EXECUTIVE'));

ALTER TABLE positions ADD CONSTRAINT chk_employment_type 
    CHECK (employment_type IN ('FULL_TIME', 'PART_TIME', 'CONTRACT', 'INTERNSHIP', 'TEMPORARY'));

-- Add check constraint for salary range
ALTER TABLE positions ADD CONSTRAINT chk_salary_range 
    CHECK (min_salary IS NULL OR max_salary IS NULL OR min_salary <= max_salary);

-- Add comments for documentation
COMMENT ON TABLE positions IS 'Job positions and titles within the organization';
COMMENT ON COLUMN positions.job_title IS 'The official job title for the position';
COMMENT ON COLUMN positions.professional_title IS 'Professional or industry-standard title';
COMMENT ON COLUMN positions.code IS 'Unique position code for identification';
COMMENT ON COLUMN positions.department_id IS 'Department where this position belongs';
COMMENT ON COLUMN positions.level IS 'Hierarchical level of the position';
COMMENT ON COLUMN positions.category IS 'Functional category of the position';
COMMENT ON COLUMN positions.employment_type IS 'Type of employment (full-time, part-time, etc.)';
COMMENT ON COLUMN positions.is_managerial IS 'Whether this position has management responsibilities';
</file>

<file path="src/main/resources/db/migration/V4__Create_employees_table.sql">
-- Create employees table
CREATE TABLE employees (
    id BIGSERIAL PRIMARY KEY,
    employee_number VARCHAR(20) NOT NULL UNIQUE,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL UNIQUE,
    phone VARCHAR(20),
    mobile_phone VARCHAR(20),
    address VARCHAR(255),
    city VARCHAR(100),
    state VARCHAR(100),
    zip_code VARCHAR(20),
    country VARCHAR(100),
    date_of_birth_encrypted TEXT, -- Encrypted field
    gender VARCHAR(20),
    marital_status VARCHAR(20),
    nationality VARCHAR(50),
    department_id BIGINT NOT NULL,
    position_id BIGINT,
    manager_id BIGINT,
    hire_date DATE NOT NULL,
    termination_date DATE,
    status VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',
    employment_type VARCHAR(20) NOT NULL DEFAULT 'FULL_TIME',
    pay_type VARCHAR(10) NOT NULL DEFAULT 'SALARY',
    salary DECIMAL(12,2),
    hourly_rate DECIMAL(8,2),
    bank_account_encrypted TEXT, -- Encrypted field
    tax_id_encrypted TEXT, -- Encrypted field
    enabled BOOLEAN NOT NULL DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    created_by BIGINT,
    updated_by BIGINT,
    
    -- Foreign key constraints
    CONSTRAINT fk_employee_department FOREIGN KEY (department_id) REFERENCES departments(id),
    CONSTRAINT fk_employee_manager FOREIGN KEY (manager_id) REFERENCES employees(id),
    
    -- Check constraints
    CONSTRAINT chk_employee_status CHECK (status IN ('ACTIVE', 'INACTIVE', 'TERMINATED', 'ON_LEAVE', 'PROBATION', 'SUSPENDED')),
    CONSTRAINT chk_employment_type CHECK (employment_type IN ('FULL_TIME', 'PART_TIME', 'CONTRACT', 'TEMPORARY', 'INTERN', 'CONSULTANT')),
    CONSTRAINT chk_pay_type CHECK (pay_type IN ('SALARY', 'HOURLY')),
    CONSTRAINT chk_gender CHECK (gender IN ('MALE', 'FEMALE', 'OTHER', 'PREFER_NOT_TO_SAY')),
    CONSTRAINT chk_marital_status CHECK (marital_status IN ('SINGLE', 'MARRIED', 'DIVORCED', 'WIDOWED', 'SEPARATED', 'DOMESTIC_PARTNERSHIP')),
    CONSTRAINT chk_salary_positive CHECK (salary IS NULL OR salary >= 0),
    CONSTRAINT chk_hourly_rate_positive CHECK (hourly_rate IS NULL OR hourly_rate >= 0),
    CONSTRAINT chk_hire_date_not_future CHECK (hire_date <= CURRENT_DATE),
    CONSTRAINT chk_termination_after_hire CHECK (termination_date IS NULL OR termination_date >= hire_date)
);

-- Create indexes for performance
CREATE INDEX idx_employee_number ON employees(employee_number);
CREATE INDEX idx_employee_email ON employees(email);
CREATE INDEX idx_employee_department_id ON employees(department_id);
CREATE INDEX idx_employee_position_id ON employees(position_id);
CREATE INDEX idx_employee_status ON employees(status);
CREATE INDEX idx_employee_last_name ON employees(last_name);
CREATE INDEX idx_employee_hire_date ON employees(hire_date);
CREATE INDEX idx_employee_manager_id ON employees(manager_id);

-- Add comments
COMMENT ON TABLE employees IS 'Employee information with comprehensive fields and audit trail';
COMMENT ON COLUMN employees.employee_number IS 'Unique employee identifier';
COMMENT ON COLUMN employees.date_of_birth_encrypted IS 'Encrypted date of birth for privacy';
COMMENT ON COLUMN employees.bank_account_encrypted IS 'Encrypted bank account information';
COMMENT ON COLUMN employees.tax_id_encrypted IS 'Encrypted tax identification number';
COMMENT ON COLUMN employees.enabled IS 'Soft delete flag - false means employee is disabled';
</file>

<file path="src/main/resources/db/migration/V5__Create_email_tables.sql">
-- Create email templates table
CREATE TABLE email_templates (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    code VARCHAR(50) NOT NULL UNIQUE,
    subject VARCHAR(255) NOT NULL,
    content TEXT NOT NULL,
    template_type VARCHAR(20) NOT NULL CHECK (template_type IN ('HTML', 'TEXT', 'MIXED')),
    category VARCHAR(50) CHECK (category IN ('WELCOME', 'NOTIFICATION', 'REMINDER', 'MARKETING', 'PASSWORD_RESET')),
    description VARCHAR(500),
    variables TEXT, -- JSON string of available template variables
    is_default BOOLEAN NOT NULL DEFAULT FALSE,
    enabled BOOLEAN NOT NULL DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE,
    created_by BIGINT,
    updated_by BIGINT
);

-- Create indexes for email_templates
CREATE UNIQUE INDEX idx_emailtemplate_code ON email_templates(code);
CREATE INDEX idx_emailtemplate_category ON email_templates(category);
CREATE INDEX idx_emailtemplate_enabled ON email_templates(enabled);
CREATE INDEX idx_emailtemplate_created_by ON email_templates(created_by);

-- Create email logs table
CREATE TABLE email_logs (
    id BIGSERIAL PRIMARY KEY,
    to_email VARCHAR(255) NOT NULL,
    cc_emails VARCHAR(1000), -- Comma-separated CC emails
    bcc_emails VARCHAR(1000), -- Comma-separated BCC emails
    subject VARCHAR(255) NOT NULL,
    content TEXT NOT NULL,
    template_code VARCHAR(50), -- Template used (if any)
    status VARCHAR(20) NOT NULL CHECK (status IN ('PENDING', 'SENT', 'FAILED', 'BOUNCED', 'DELIVERED', 'OPENED', 'CLICKED')),
    error_message VARCHAR(2000), -- Error details if failed
    retry_count INTEGER NOT NULL DEFAULT 0,
    sent_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    sent_by BIGINT, -- User who sent the email
    message_id VARCHAR(255), -- Email provider message ID
    priority VARCHAR(20) CHECK (priority IN ('HIGH', 'NORMAL', 'LOW')) DEFAULT 'NORMAL'
);

-- Create indexes for email_logs
CREATE INDEX idx_emaillog_to_email ON email_logs(to_email);
CREATE INDEX idx_emaillog_status ON email_logs(status);
CREATE INDEX idx_emaillog_template_code ON email_logs(template_code);
CREATE INDEX idx_emaillog_sent_by ON email_logs(sent_by);
CREATE INDEX idx_emaillog_created_at ON email_logs(created_at);
CREATE INDEX idx_emaillog_sent_at ON email_logs(sent_at);
CREATE INDEX idx_emaillog_priority ON email_logs(priority);

-- Add foreign key constraint for template_code (optional, as template might be deleted)
ALTER TABLE email_logs 
ADD CONSTRAINT fk_emaillog_template 
FOREIGN KEY (template_code) REFERENCES email_templates(code) 
ON DELETE SET NULL;

-- Add foreign key constraints for user references (assuming users table exists)
-- These will be added when the users table is available
-- ALTER TABLE email_templates ADD CONSTRAINT fk_emailtemplate_created_by FOREIGN KEY (created_by) REFERENCES users(id);
-- ALTER TABLE email_templates ADD CONSTRAINT fk_emailtemplate_updated_by FOREIGN KEY (updated_by) REFERENCES users(id);
-- ALTER TABLE email_logs ADD CONSTRAINT fk_emaillog_sent_by FOREIGN KEY (sent_by) REFERENCES users(id);

-- Insert some default email templates
INSERT INTO email_templates (name, code, subject, content, template_type, category, description, variables, is_default, enabled, created_at) VALUES
('Welcome Email', 'WELCOME_USER', 'Welcome to {{companyName}}!', 
'<html><body><h1>Welcome {{firstName}}!</h1><p>We are excited to have you join {{companyName}}. Your account has been created successfully.</p><p>Best regards,<br>The {{companyName}} Team</p></body></html>', 
'HTML', 'WELCOME', 'Default welcome email template for new users', 
'["firstName", "companyName"]', TRUE, TRUE, CURRENT_TIMESTAMP),

('Password Reset', 'PASSWORD_RESET', 'Reset Your Password', 
'<html><body><h2>Password Reset Request</h2><p>Hello {{firstName}},</p><p>You have requested to reset your password. Please click the link below to reset your password:</p><p><a href="{{resetLink}}">Reset Password</a></p><p>This link will expire in {{expirationHours}} hours.</p><p>If you did not request this, please ignore this email.</p><p>Best regards,<br>The {{companyName}} Team</p></body></html>', 
'HTML', 'PASSWORD_RESET', 'Password reset email template', 
'["firstName", "resetLink", "expirationHours", "companyName"]', TRUE, TRUE, CURRENT_TIMESTAMP),

('General Notification', 'GENERAL_NOTIFICATION', '{{subject}}', 
'<html><body><h2>{{title}}</h2><p>Hello {{firstName}},</p><p>{{message}}</p><p>Best regards,<br>The {{companyName}} Team</p></body></html>', 
'HTML', 'NOTIFICATION', 'General notification email template', 
'["firstName", "title", "subject", "message", "companyName"]', TRUE, TRUE, CURRENT_TIMESTAMP);

-- Add comments to tables
COMMENT ON TABLE email_templates IS 'Email templates for system-generated emails';
COMMENT ON TABLE email_logs IS 'Log of all emails sent by the system';

COMMENT ON COLUMN email_templates.variables IS 'JSON array of available template variables';
COMMENT ON COLUMN email_templates.is_default IS 'Whether this is the default template for its category';
COMMENT ON COLUMN email_logs.retry_count IS 'Number of times email sending was retried';
COMMENT ON COLUMN email_logs.message_id IS 'Unique message ID from email provider';
</file>

<file path="src/main/resources/db/migration/V6__Create_chat_tables.sql">
-- Create chat_rooms table
CREATE TABLE chat_rooms (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(100),
    type VARCHAR(20) NOT NULL CHECK (type IN ('DIRECT', 'GROUP', 'CHANNEL')),
    description VARCHAR(500),
    avatar_url VARCHAR(255),
    created_by BIGINT NOT NULL,
    is_private BOOLEAN NOT NULL DEFAULT FALSE,
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    last_message_at TIMESTAMP WITH TIME ZONE,
    last_message_id BIGINT
);

-- Create indexes for chat_rooms
CREATE INDEX idx_chatroom_type ON chat_rooms(type);
CREATE INDEX idx_chatroom_created_by ON chat_rooms(created_by);
CREATE INDEX idx_chatroom_active ON chat_rooms(is_active);
CREATE INDEX idx_chatroom_last_message_at ON chat_rooms(last_message_at);

-- Create chat_participants table
CREATE TABLE chat_participants (
    id BIGSERIAL PRIMARY KEY,
    room_id BIGINT NOT NULL,
    user_id BIGINT NOT NULL,
    role VARCHAR(20) NOT NULL CHECK (role IN ('OWNER', 'ADMIN', 'MEMBER')),
    joined_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    last_read_at TIMESTAMP WITH TIME ZONE,
    last_read_message_id BIGINT,
    is_muted BOOLEAN NOT NULL DEFAULT FALSE,
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    left_at TIMESTAMP WITH TIME ZONE,
    
    CONSTRAINT fk_participant_room FOREIGN KEY (room_id) REFERENCES chat_rooms(id) ON DELETE CASCADE,
    CONSTRAINT uk_participant_room_user UNIQUE (room_id, user_id)
);

-- Create indexes for chat_participants
CREATE INDEX idx_participant_room_id ON chat_participants(room_id);
CREATE INDEX idx_participant_user_id ON chat_participants(user_id);
CREATE INDEX idx_participant_active ON chat_participants(is_active);
CREATE INDEX idx_participant_role ON chat_participants(role);

-- Create chat_messages table
CREATE TABLE chat_messages (
    id BIGSERIAL PRIMARY KEY,
    room_id BIGINT NOT NULL,
    sender_id BIGINT NOT NULL,
    content TEXT,
    message_type VARCHAR(20) DEFAULT 'TEXT' CHECK (message_type IN ('TEXT', 'IMAGE', 'FILE', 'SYSTEM')),
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    is_edited BOOLEAN NOT NULL DEFAULT FALSE,
    edited_at TIMESTAMP WITH TIME ZONE,
    is_deleted BOOLEAN NOT NULL DEFAULT FALSE,
    deleted_at TIMESTAMP WITH TIME ZONE,
    
    CONSTRAINT fk_message_room FOREIGN KEY (room_id) REFERENCES chat_rooms(id) ON DELETE CASCADE
);

-- Create indexes for chat_messages
CREATE INDEX idx_chatmessage_room_id ON chat_messages(room_id);
CREATE INDEX idx_chatmessage_sender_id ON chat_messages(sender_id);
CREATE INDEX idx_chatmessage_created_at ON chat_messages(created_at);
CREATE INDEX idx_chatmessage_deleted ON chat_messages(is_deleted);
CREATE INDEX idx_chatmessage_room_created ON chat_messages(room_id, created_at);

-- Create composite index for efficient message queries
CREATE INDEX idx_chatmessage_room_active ON chat_messages(room_id, is_deleted, created_at);

-- Add foreign key constraint for last_message_id in chat_rooms
ALTER TABLE chat_rooms 
ADD CONSTRAINT fk_room_last_message 
FOREIGN KEY (last_message_id) REFERENCES chat_messages(id) ON DELETE SET NULL;

-- Create function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Create trigger to automatically update updated_at for chat_rooms
CREATE TRIGGER update_chat_rooms_updated_at 
    BEFORE UPDATE ON chat_rooms 
    FOR EACH ROW 
    EXECUTE FUNCTION update_updated_at_column();
</file>

<file path="src/main/resources/db/migration/V7__Create_notification_tables.sql">
-- Create notifications table (single-table model as per database-design.md)
CREATE TABLE notifications (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL,
    title VARCHAR(255) NOT NULL,
    content TEXT NOT NULL,
    type VARCHAR(50) NOT NULL CHECK (type IN ('SYSTEM', 'ANNOUNCEMENT', 'CHAT_MESSAGE', 'EMAIL', 'TASK_ASSIGNMENT', 'PAYROLL', 'EMPLOYEE_UPDATE', 'DEPARTMENT_UPDATE')),
    priority VARCHAR(20) NOT NULL DEFAULT 'NORMAL' CHECK (priority IN ('LOW', 'NORMAL', 'HIGH', 'URGENT')),
    is_read BOOLEAN NOT NULL DEFAULT FALSE,
    read_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    sender_id BIGINT,
    reference_id BIGINT,
    reference_type VARCHAR(50),
    action_url VARCHAR(500),
    metadata TEXT,
    expires_at TIMESTAMP WITH TIME ZONE
);

-- Create indexes for notifications
CREATE INDEX idx_notification_user_id ON notifications(user_id);
CREATE INDEX idx_notification_type ON notifications(type);
CREATE INDEX idx_notification_is_read ON notifications(is_read);
CREATE INDEX idx_notification_created_at ON notifications(created_at);
CREATE INDEX idx_notification_user_read ON notifications(user_id, is_read);
CREATE INDEX idx_notification_sender_id ON notifications(sender_id);
CREATE INDEX idx_notification_reference ON notifications(reference_type, reference_id);
CREATE INDEX idx_notification_expires_at ON notifications(expires_at);

-- Create announcements table
CREATE TABLE announcements (
    id BIGSERIAL PRIMARY KEY,
    title VARCHAR(200) NOT NULL,
    content TEXT NOT NULL,
    author_id BIGINT NOT NULL,
    target_audience VARCHAR(50) CHECK (target_audience IN ('ALL', 'DEPARTMENT', 'ROLE')),
    department_id BIGINT,
    role_name VARCHAR(100),
    publish_date DATE,
    expiry_date DATE,
    published BOOLEAN NOT NULL DEFAULT FALSE,
    priority VARCHAR(20) NOT NULL DEFAULT 'NORMAL' CHECK (priority IN ('LOW', 'NORMAL', 'HIGH', 'URGENT')),
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    created_by BIGINT,
    updated_by BIGINT
);

-- Create indexes for announcements
CREATE INDEX idx_announcement_author_id ON announcements(author_id);
CREATE INDEX idx_announcement_target_audience ON announcements(target_audience);
CREATE INDEX idx_announcement_department_id ON announcements(department_id);
CREATE INDEX idx_announcement_published ON announcements(published);
CREATE INDEX idx_announcement_publish_date ON announcements(publish_date);
CREATE INDEX idx_announcement_expiry_date ON announcements(expiry_date);
CREATE INDEX idx_announcement_priority ON announcements(priority);

-- Create function to automatically create notifications for published announcements
CREATE OR REPLACE FUNCTION create_announcement_notifications()
RETURNS TRIGGER AS $$
DECLARE
    target_user_id BIGINT;
BEGIN
    -- Only create notifications when announcement is published
    IF NEW.published = TRUE AND (OLD IS NULL OR OLD.published = FALSE) THEN
        -- Create notifications based on target audience
        IF NEW.target_audience = 'ALL' THEN
            -- Create notifications for all active employees
            INSERT INTO notifications (user_id, title, content, type, priority, sender_id, reference_id, reference_type, action_url)
            SELECT 
                e.id,
                'New Announcement: ' || NEW.title,
                NEW.content,
                'ANNOUNCEMENT',
                NEW.priority::VARCHAR,
                NEW.author_id,
                NEW.id,
                'ANNOUNCEMENT',
                '/announcements/' || NEW.id
            FROM employees e 
            WHERE e.status = 'ACTIVE';
            
        ELSIF NEW.target_audience = 'DEPARTMENT' AND NEW.department_id IS NOT NULL THEN
            -- Create notifications for employees in specific department
            INSERT INTO notifications (user_id, title, content, type, priority, sender_id, reference_id, reference_type, action_url)
            SELECT 
                e.id,
                'New Announcement: ' || NEW.title,
                NEW.content,
                'ANNOUNCEMENT',
                NEW.priority::VARCHAR,
                NEW.author_id,
                NEW.id,
                'ANNOUNCEMENT',
                '/announcements/' || NEW.id
            FROM employees e 
            WHERE e.department_id = NEW.department_id AND e.status = 'ACTIVE';
            
        ELSIF NEW.target_audience = 'ROLE' AND NEW.role_name IS NOT NULL THEN
            -- Create notifications for users with specific role
            INSERT INTO notifications (user_id, title, content, type, priority, sender_id, reference_id, reference_type, action_url)
            SELECT 
                u.id,
                'New Announcement: ' || NEW.title,
                NEW.content,
                'ANNOUNCEMENT',
                NEW.priority::VARCHAR,
                NEW.author_id,
                NEW.id,
                'ANNOUNCEMENT',
                '/announcements/' || NEW.id
            FROM users u 
            JOIN user_roles ur ON u.id = ur.user_id
            JOIN roles r ON ur.role_id = r.id
            WHERE r.name = NEW.role_name AND u.enabled = TRUE;
        END IF;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger for announcement notifications
CREATE TRIGGER trigger_announcement_notifications
    AFTER INSERT OR UPDATE ON announcements
    FOR EACH ROW
    EXECUTE FUNCTION create_announcement_notifications();

-- Create trigger to automatically update updated_at for announcements
CREATE TRIGGER update_announcements_updated_at 
    BEFORE UPDATE ON announcements 
    FOR EACH ROW 
    EXECUTE FUNCTION update_updated_at_column();

-- Create function to clean up expired notifications
CREATE OR REPLACE FUNCTION cleanup_expired_notifications()
RETURNS INTEGER AS $$
DECLARE
    deleted_count INTEGER;
BEGIN
    DELETE FROM notifications 
    WHERE expires_at IS NOT NULL AND expires_at < CURRENT_TIMESTAMP;
    
    GET DIAGNOSTICS deleted_count = ROW_COUNT;
    RETURN deleted_count;
END;
$$ LANGUAGE plpgsql;

-- Create function to mark notification as read
CREATE OR REPLACE FUNCTION mark_notification_read(notification_id BIGINT, user_id BIGINT)
RETURNS BOOLEAN AS $$
DECLARE
    updated_count INTEGER;
BEGIN
    UPDATE notifications 
    SET is_read = TRUE, read_at = CURRENT_TIMESTAMP
    WHERE id = notification_id AND user_id = user_id AND is_read = FALSE;
    
    GET DIAGNOSTICS updated_count = ROW_COUNT;
    RETURN updated_count > 0;
END;
$$ LANGUAGE plpgsql;
</file>

<file path="src/main/resources/db/migration/V8__Create_payroll_tables.sql">
-- Create payroll management tables
-- This migration creates tables for payroll ledgers, periods, salary components, and audit trails

-- Create payroll_periods table
CREATE TABLE payroll_periods (
    id BIGSERIAL PRIMARY KEY,
    period_name VARCHAR(100) NOT NULL,
    start_date DATE NOT NULL,
    end_date DATE NOT NULL,
    period_type VARCHAR(20) NOT NULL CHECK (period_type IN ('MONTHLY', 'BI_WEEKLY', 'WEEKLY', 'CUSTOM')),
    status VARCHAR(20) NOT NULL DEFAULT 'OPEN' CHECK (status IN ('OPEN', 'PROCESSING', 'CLOSED', 'CANCELLED')),
    pay_date DATE,
    description VARCHAR(500),
    is_active BOOLEAN NOT NULL DEFAULT true,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- Constraints
    CONSTRAINT chk_payroll_period_dates CHECK (end_date >= start_date),
    CONSTRAINT chk_payroll_period_pay_date CHECK (pay_date IS NULL OR pay_date >= end_date)
);

-- Create salary_components table
CREATE TABLE salary_components (
    id BIGSERIAL PRIMARY KEY,
    component_name VARCHAR(100) NOT NULL,
    component_type VARCHAR(50) NOT NULL CHECK (component_type IN ('EARNING', 'DEDUCTION', 'TAX')),
    amount DECIMAL(15,2) NOT NULL DEFAULT 0.00 CHECK (amount >= 0),
    percentage DECIMAL(5,2) CHECK (percentage >= 0 AND percentage <= 100),
    is_taxable BOOLEAN NOT NULL DEFAULT false,
    is_mandatory BOOLEAN NOT NULL DEFAULT false,
    calculation_order INTEGER NOT NULL DEFAULT 0,
    description VARCHAR(500),
    is_active BOOLEAN NOT NULL DEFAULT true,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- Constraints
    CONSTRAINT uk_salary_component_name UNIQUE (component_name),
    CONSTRAINT chk_salary_component_amount_or_percentage CHECK (
        (amount > 0 AND percentage IS NULL) OR 
        (amount = 0 AND percentage IS NOT NULL AND percentage > 0)
    )
);

-- Create payroll_ledgers table
CREATE TABLE payroll_ledgers (
    id BIGSERIAL PRIMARY KEY,
    employee_id BIGINT NOT NULL,
    payroll_period_id BIGINT NOT NULL,
    base_salary DECIMAL(15,2) NOT NULL CHECK (base_salary >= 0),
    gross_pay DECIMAL(15,2) DEFAULT 0.00 CHECK (gross_pay >= 0),
    total_deductions DECIMAL(15,2) DEFAULT 0.00 CHECK (total_deductions >= 0),
    total_taxes DECIMAL(15,2) DEFAULT 0.00 CHECK (total_taxes >= 0),
    net_pay DECIMAL(15,2) DEFAULT 0.00 CHECK (net_pay >= 0),
    overtime_hours DECIMAL(8,2) DEFAULT 0.00 CHECK (overtime_hours >= 0),
    overtime_pay DECIMAL(15,2) DEFAULT 0.00 CHECK (overtime_pay >= 0),
    bonus_amount DECIMAL(15,2) DEFAULT 0.00 CHECK (bonus_amount >= 0),
    status VARCHAR(20) NOT NULL DEFAULT 'PENDING' CHECK (status IN ('PENDING', 'CALCULATED', 'APPROVED', 'PAID', 'REJECTED', 'CANCELLED')),
    payment_method VARCHAR(20) CHECK (payment_method IN ('BANK_TRANSFER', 'CHECK', 'CASH', 'OTHER')),
    pay_date DATE,
    payment_reference VARCHAR(100),
    notes VARCHAR(1000),
    approved_by BIGINT,
    approved_at TIMESTAMP,
    paid_by BIGINT,
    paid_at TIMESTAMP,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_by BIGINT,
    updated_by BIGINT,
    
    -- Foreign key constraints
    CONSTRAINT fk_payroll_ledger_employee FOREIGN KEY (employee_id) REFERENCES employees(id) ON DELETE CASCADE,
    CONSTRAINT fk_payroll_ledger_period FOREIGN KEY (payroll_period_id) REFERENCES payroll_periods(id) ON DELETE CASCADE,
    CONSTRAINT fk_payroll_ledger_approved_by FOREIGN KEY (approved_by) REFERENCES users(id),
    CONSTRAINT fk_payroll_ledger_paid_by FOREIGN KEY (paid_by) REFERENCES users(id),
    CONSTRAINT fk_payroll_ledger_created_by FOREIGN KEY (created_by) REFERENCES users(id),
    CONSTRAINT fk_payroll_ledger_updated_by FOREIGN KEY (updated_by) REFERENCES users(id),
    
    -- Business constraints
    CONSTRAINT uk_payroll_ledger_employee_period UNIQUE (employee_id, payroll_period_id),
    CONSTRAINT chk_payroll_ledger_net_pay CHECK (net_pay = gross_pay - total_deductions - total_taxes),
    CONSTRAINT chk_payroll_ledger_approval CHECK (
        (status != 'APPROVED' AND approved_by IS NULL AND approved_at IS NULL) OR
        (status = 'APPROVED' AND approved_by IS NOT NULL AND approved_at IS NOT NULL)
    ),
    CONSTRAINT chk_payroll_ledger_payment CHECK (
        (status != 'PAID' AND paid_by IS NULL AND paid_at IS NULL AND payment_reference IS NULL) OR
        (status = 'PAID' AND paid_by IS NOT NULL AND paid_at IS NOT NULL)
    )
);

-- Create payroll_ledger_components table for detailed salary breakdowns
CREATE TABLE payroll_ledger_components (
    id BIGSERIAL PRIMARY KEY,
    payroll_ledger_id BIGINT NOT NULL,
    salary_component_id BIGINT NOT NULL,
    amount DECIMAL(15,2) NOT NULL CHECK (amount >= 0),
    calculated_amount DECIMAL(15,2) NOT NULL CHECK (calculated_amount >= 0),
    percentage_applied DECIMAL(5,2) CHECK (percentage_applied >= 0 AND percentage_applied <= 100),
    is_override BOOLEAN NOT NULL DEFAULT false,
    override_reason VARCHAR(500),
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    -- Foreign key constraints
    CONSTRAINT fk_payroll_component_ledger FOREIGN KEY (payroll_ledger_id) REFERENCES payroll_ledgers(id) ON DELETE CASCADE,
    CONSTRAINT fk_payroll_component_salary FOREIGN KEY (salary_component_id) REFERENCES salary_components(id) ON DELETE CASCADE,
    
    -- Unique constraint
    CONSTRAINT uk_payroll_component_ledger_salary UNIQUE (payroll_ledger_id, salary_component_id)
);

-- Create payroll_audits table for change tracking
CREATE TABLE payroll_audits (
    id BIGSERIAL PRIMARY KEY,
    payroll_ledger_id BIGINT NOT NULL,
    action VARCHAR(50) NOT NULL CHECK (action IN ('CREATED', 'CALCULATED', 'APPROVED', 'PAID', 'REJECTED', 'CANCELLED', 'UPDATED')),
    old_status VARCHAR(20),
    new_status VARCHAR(20),
    changes TEXT, -- JSON string of changes
    reason VARCHAR(500),
    performed_by BIGINT NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    
    -- Foreign key constraints
    CONSTRAINT fk_payroll_audit_ledger FOREIGN KEY (payroll_ledger_id) REFERENCES payroll_ledgers(id) ON DELETE CASCADE,
    CONSTRAINT fk_payroll_audit_performed_by FOREIGN KEY (performed_by) REFERENCES users(id)
);

-- Create indexes for performance optimization
CREATE INDEX idx_payroll_periods_status ON payroll_periods(status);
CREATE INDEX idx_payroll_periods_dates ON payroll_periods(start_date, end_date);
CREATE INDEX idx_payroll_periods_active ON payroll_periods(is_active);

CREATE INDEX idx_salary_components_type ON salary_components(component_type);
CREATE INDEX idx_salary_components_active ON salary_components(is_active);
CREATE INDEX idx_salary_components_order ON salary_components(calculation_order);

CREATE INDEX idx_payroll_ledger_employee_id ON payroll_ledgers(employee_id);
CREATE INDEX idx_payroll_ledger_period_id ON payroll_ledgers(payroll_period_id);
CREATE INDEX idx_payroll_ledger_status ON payroll_ledgers(status);
CREATE INDEX idx_payroll_ledger_pay_date ON payroll_ledgers(pay_date);
CREATE INDEX idx_payroll_ledger_created_at ON payroll_ledgers(created_at);

CREATE INDEX idx_payroll_component_ledger_id ON payroll_ledger_components(payroll_ledger_id);
CREATE INDEX idx_payroll_component_salary_id ON payroll_ledger_components(salary_component_id);

CREATE INDEX idx_payroll_audit_ledger_id ON payroll_audits(payroll_ledger_id);
CREATE INDEX idx_payroll_audit_action ON payroll_audits(action);
CREATE INDEX idx_payroll_audit_created_at ON payroll_audits(created_at);
CREATE INDEX idx_payroll_audit_performed_by ON payroll_audits(performed_by);

-- Insert default salary components
INSERT INTO salary_components (component_name, component_type, amount, is_taxable, is_mandatory, calculation_order, description) VALUES
('Basic Salary', 'EARNING', 0.00, true, true, 1, 'Base salary component'),
('House Rent Allowance', 'EARNING', 0.00, true, false, 2, 'Housing allowance'),
('Transport Allowance', 'EARNING', 0.00, false, false, 3, 'Transportation allowance'),
('Medical Allowance', 'EARNING', 0.00, false, false, 4, 'Medical benefits allowance'),
('Performance Bonus', 'EARNING', 0.00, true, false, 5, 'Performance-based bonus'),
('Overtime Pay', 'EARNING', 0.00, true, false, 6, 'Overtime compensation'),

('Income Tax', 'TAX', 0.00, false, true, 10, 'Federal income tax'),
('Social Security Tax', 'TAX', 0.00, false, true, 11, 'Social security contribution'),
('Medicare Tax', 'TAX', 0.00, false, true, 12, 'Medicare contribution'),
('State Tax', 'TAX', 0.00, false, false, 13, 'State income tax'),

('Health Insurance', 'DEDUCTION', 0.00, false, false, 20, 'Health insurance premium'),
('Life Insurance', 'DEDUCTION', 0.00, false, false, 21, 'Life insurance premium'),
('Retirement Fund', 'DEDUCTION', 0.00, false, false, 22, 'Retirement savings contribution'),
('Union Dues', 'DEDUCTION', 0.00, false, false, 23, 'Union membership dues'),
('Loan Repayment', 'DEDUCTION', 0.00, false, false, 24, 'Employee loan repayment');

-- Add comments for documentation
COMMENT ON TABLE payroll_periods IS 'Payroll periods for organizing payroll processing cycles';
COMMENT ON TABLE salary_components IS 'Configurable salary components for earnings, deductions, and taxes';
COMMENT ON TABLE payroll_ledgers IS 'Individual employee payroll records for each pay period';
COMMENT ON TABLE payroll_ledger_components IS 'Detailed breakdown of salary components for each payroll ledger';
COMMENT ON TABLE payroll_audits IS 'Audit trail for all payroll-related changes and actions';

COMMENT ON COLUMN payroll_ledgers.net_pay IS 'Calculated as gross_pay - total_deductions - total_taxes';
COMMENT ON COLUMN payroll_audits.changes IS 'JSON string containing detailed change information';
COMMENT ON COLUMN salary_components.calculation_order IS 'Order in which components are calculated (lower numbers first)';
</file>

<file path="src/main/resources/static/.gitkeep">
# This file ensures the static directory is tracked by Git
# Static web assets (for React build) will be placed in this directory
</file>

<file path="src/main/resources/templates/.gitkeep">
# This file ensures the templates directory is tracked by Git
# Email templates (Freemarker .ftl files) will be placed in this directory
</file>

<file path="src/test/java/com/example/demo/communication/announcement/service/AnnouncementScheduledServiceTest.java">
package com.example.demo.communication.announcement.service;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
public class AnnouncementScheduledServiceTest {

    @Mock
    private AnnouncementService announcementService;

    @InjectMocks
    private AnnouncementScheduledService announcementScheduledService;

    @Test
    void cleanupExpiredAnnouncements_shouldCallService() {
        when(announcementService.cleanupExpiredAnnouncements()).thenReturn(5);

        announcementScheduledService.cleanupExpiredAnnouncements();

        verify(announcementService, times(1)).cleanupExpiredAnnouncements();
    }
}
</file>

<file path="src/test/java/com/example/demo/communication/announcement/service/AnnouncementServiceTest.java">
package com.example.demo.communication.announcement.service;

import com.example.demo.communication.announcement.dto.AnnouncementCreateRequest;
import com.example.demo.communication.announcement.dto.AnnouncementDto;
import com.example.demo.communication.announcement.entity.Announcement;
import com.example.demo.communication.announcement.entity.AnnouncementTarget;
import com.example.demo.communication.announcement.repository.AnnouncementRepository;
import com.example.demo.communication.announcement.service.impl.AnnouncementServiceImpl;
import com.example.demo.communication.notification.service.NotificationService;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.time.LocalDate;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class AnnouncementServiceTest {

    @Mock
    private AnnouncementRepository announcementRepository;

    @Mock
    private NotificationService notificationService;

    @InjectMocks
    private AnnouncementServiceImpl announcementService;

    private AnnouncementCreateRequest createRequest;
    private Announcement announcement;

    @BeforeEach
    void setUp() {
        createRequest = new AnnouncementCreateRequest();
        createRequest.setTitle("Test Announcement");
        createRequest.setContent("This is a test announcement");
        createRequest.setTargetAudience(AnnouncementTarget.ALL);
        createRequest.setPublished(false);
        createRequest.setPriority(Announcement.AnnouncementPriority.NORMAL);

        announcement = Announcement.builder()
                .id(1L)
                .title("Test Announcement")
                .content("This is a test announcement")
                .authorId(1L)
                .targetAudience(AnnouncementTarget.ALL)
                .published(false)
                .priority(Announcement.AnnouncementPriority.NORMAL)
                .build();
    }

    @Test
    void createAnnouncement_ShouldCreateSuccessfully() {
        // Given
        when(announcementRepository.save(any(Announcement.class))).thenReturn(announcement);

        // When
        AnnouncementDto result = announcementService.createAnnouncement(createRequest, 1L);

        // Then
        assertNotNull(result);
        assertEquals("Test Announcement", result.getTitle());
        assertEquals("This is a test announcement", result.getContent());
        assertEquals(AnnouncementTarget.ALL, result.getTargetAudience());
        assertFalse(result.isPublished());

        verify(announcementRepository).save(any(Announcement.class));
    }

    @Test
    void createAnnouncement_WithDepartmentTarget_ShouldRequireDepartmentId() {
        // Given
        createRequest.setTargetAudience(AnnouncementTarget.DEPARTMENT);
        createRequest.setDepartmentId(null);

        // When & Then
        assertThrows(IllegalArgumentException.class, 
                () -> announcementService.createAnnouncement(createRequest, 1L));
    }

    @Test
    void createAnnouncement_WithRoleTarget_ShouldRequireRoleName() {
        // Given
        createRequest.setTargetAudience(AnnouncementTarget.ROLE);
        createRequest.setRoleName(null);

        // When & Then
        assertThrows(IllegalArgumentException.class, 
                () -> announcementService.createAnnouncement(createRequest, 1L));
    }

    @Test
    void getAnnouncement_ShouldReturnAnnouncement() {
        // Given
        when(announcementRepository.findById(1L)).thenReturn(Optional.of(announcement));

        // When
        AnnouncementDto result = announcementService.getAnnouncement(1L);

        // Then
        assertNotNull(result);
        assertEquals(1L, result.getId());
        assertEquals("Test Announcement", result.getTitle());
    }

    @Test
    void publishAnnouncement_ShouldPublishSuccessfully() {
        // Given
        announcement.setPublished(false);
        when(announcementRepository.findById(1L)).thenReturn(Optional.of(announcement));
        when(announcementRepository.save(any(Announcement.class))).thenReturn(announcement);

        // When
        AnnouncementDto result = announcementService.publishAnnouncement(1L, 1L);

        // Then
        assertTrue(result.isPublished());
        verify(announcementRepository).save(any(Announcement.class));
    }

    @Test
    void publishAnnouncement_AlreadyPublished_ShouldThrowException() {
        // Given
        announcement.setPublished(true);
        when(announcementRepository.findById(1L)).thenReturn(Optional.of(announcement));

        // When & Then
        assertThrows(IllegalStateException.class, 
                () -> announcementService.publishAnnouncement(1L, 1L));
    }
}
</file>

<file path="src/test/java/com/example/demo/communication/announcement/service/AnnouncementValidationServiceTest.java">
package com.example.demo.communication.announcement.service;

import com.example.demo.common.exception.ValidationException;
import com.example.demo.communication.announcement.dto.AnnouncementCreateRequest;
import com.example.demo.communication.announcement.entity.AnnouncementTarget;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertThrows;

@ExtendWith(MockitoExtension.class)
public class AnnouncementValidationServiceTest {

    @InjectMocks
    private AnnouncementValidationService announcementValidationService;

    @Test
    void validateCreateRequest_withValidRequest_shouldNotThrowException() {
        AnnouncementCreateRequest request = new AnnouncementCreateRequest();
        request.setTitle("Valid Title");
        request.setContent("Valid Content");
        request.setTargetAudience(AnnouncementTarget.ALL);

        assertDoesNotThrow(() -> announcementValidationService.validateCreateRequest(request));
    }

    @Test
    void validateCreateRequest_withDepartmentTargetAndNullDepartmentId_shouldThrowException() {
        AnnouncementCreateRequest request = new AnnouncementCreateRequest();
        request.setTitle("Test Title");
        request.setContent("Test Content");
        request.setTargetAudience(AnnouncementTarget.DEPARTMENT);
        request.setDepartmentId(null);

        assertThrows(ValidationException.class, () -> announcementValidationService.validateCreateRequest(request));
    }

    @Test
    void validateCreateRequest_withRoleTargetAndNullRoleName_shouldThrowException() {
        AnnouncementCreateRequest request = new AnnouncementCreateRequest();
        request.setTitle("Test Title");
        request.setContent("Test Content");
        request.setTargetAudience(AnnouncementTarget.ROLE);
        request.setRoleName(null);

        assertThrows(ValidationException.class, () -> announcementValidationService.validateCreateRequest(request));
    }
}
</file>

<file path="src/test/java/com/example/demo/communication/announcement/service/impl/AnnouncementServiceImplTest.java">
package com.example.demo.communication.announcement.service.impl;

import com.example.demo.communication.announcement.dto.AnnouncementCreateRequest;
import com.example.demo.communication.announcement.dto.AnnouncementDto;
import com.example.demo.communication.announcement.dto.AnnouncementUpdateRequest;
import com.example.demo.communication.announcement.entity.Announcement;
import com.example.demo.communication.announcement.repository.AnnouncementRepository;
import com.example.demo.communication.announcement.service.AnnouncementValidationService;
import com.example.demo.communication.notification.service.NotificationService;
import com.example.demo.employee.repository.EmployeeRepository;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.modelmapper.ModelMapper;

import java.util.Optional;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
public class AnnouncementServiceImplTest {

    @Mock
    private AnnouncementRepository announcementRepository;

    @Mock
    private NotificationService notificationService;

    @Mock
    private EmployeeRepository employeeRepository;

    @Mock
    private ModelMapper modelMapper;

    @Mock
    private AnnouncementValidationService announcementValidationService;

    @InjectMocks
    private AnnouncementServiceImpl announcementService;

    @Test
    void createAnnouncement_shouldReturnAnnouncementDto() {
        Long userId = 1L;
        AnnouncementCreateRequest createRequest = new AnnouncementCreateRequest();
        createRequest.setTitle("Test Title");
        createRequest.setContent("Test Content");

        Announcement announcement = new Announcement();
        announcement.setId(1L);
        announcement.setTitle("Test Title");

        AnnouncementDto expectedDto = new AnnouncementDto();
        expectedDto.setId(1L);
        expectedDto.setTitle("Test Title");

        when(modelMapper.map(createRequest, Announcement.class)).thenReturn(announcement);
        when(announcementRepository.save(any(Announcement.class))).thenReturn(announcement);
        when(modelMapper.map(announcement, AnnouncementDto.class)).thenReturn(expectedDto);

        AnnouncementDto result = announcementService.createAnnouncement(createRequest, userId);

        assertNotNull(result);
        assertEquals(expectedDto.getId(), result.getId());
        assertEquals(expectedDto.getTitle(), result.getTitle());

        verify(announcementValidationService, times(1)).validateCreateRequest(any(AnnouncementCreateRequest.class));
        verify(announcementRepository, times(1)).save(any(Announcement.class));
    }

    @Test
    void updateAnnouncement_shouldReturnUpdatedDto() {
        Long announcementId = 1L;
        Long userId = 1L;
        AnnouncementUpdateRequest updateRequest = new AnnouncementUpdateRequest();
        updateRequest.setTitle("Updated Title");

        Announcement existingAnnouncement = new Announcement();
        existingAnnouncement.setId(announcementId);
        existingAnnouncement.setTitle("Old Title");

        AnnouncementDto expectedDto = new AnnouncementDto();
        expectedDto.setId(announcementId);
        expectedDto.setTitle("Updated Title");

        when(announcementRepository.findById(announcementId)).thenReturn(Optional.of(existingAnnouncement));
        when(announcementRepository.save(any(Announcement.class))).thenReturn(existingAnnouncement);
        when(modelMapper.map(existingAnnouncement, AnnouncementDto.class)).thenReturn(expectedDto);

        AnnouncementDto result = announcementService.updateAnnouncement(announcementId, updateRequest, userId);

        assertNotNull(result);
        assertEquals(expectedDto.getTitle(), result.getTitle());

        verify(announcementRepository, times(1)).findById(announcementId);
        verify(announcementRepository, times(1)).save(any(Announcement.class));
        verify(modelMapper, times(1)).map(any(AnnouncementUpdateRequest.class), eq(existingAnnouncement));
    }
}
</file>

<file path="src/test/java/com/example/demo/communication/chat/service/impl/ChatServiceImplTest.java">
package com.example.demo.communication.chat.service.impl;

import com.example.demo.communication.chat.dto.ChatRoomDto;
import com.example.demo.communication.chat.entity.ChatRoom;
import com.example.demo.communication.chat.entity.ChatRoomType;
import com.example.demo.communication.chat.repository.ChatMessageRepository;
import com.example.demo.communication.chat.repository.ChatParticipantRepository;
import com.example.demo.communication.chat.repository.ChatRoomRepository;
import com.example.demo.employee.repository.EmployeeRepository;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.modelmapper.ModelMapper;

import java.util.Collections;
import java.util.List;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
public class ChatServiceImplTest {

    @Mock
    private ChatRoomRepository chatRoomRepository;

    @Mock
    private ChatParticipantRepository chatParticipantRepository;

    @Mock
    private ChatMessageRepository chatMessageRepository;

    @Mock
    private EmployeeRepository employeeRepository;

    @Mock
    private ModelMapper modelMapper;

    @InjectMocks
    private ChatServiceImpl chatService;

    @Test
    void createChatRoom_shouldReturnChatRoomDto() {
        Long creatorId = 1L;
        List<Long> participantIds = Collections.singletonList(2L);
        String roomName = "Test Room";
        ChatRoomType roomType = ChatRoomType.GROUP;

        ChatRoom chatRoom = new ChatRoom();
        chatRoom.setId(1L);
        chatRoom.setName(roomName);

        ChatRoomDto expectedDto = new ChatRoomDto();
        expectedDto.setId(1L);
        expectedDto.setName(roomName);

        when(chatRoomRepository.save(any(ChatRoom.class))).thenReturn(chatRoom);
        when(modelMapper.map(chatRoom, ChatRoomDto.class)).thenReturn(expectedDto);

        ChatRoomDto result = chatService.createChatRoom(roomName, roomType, "description", creatorId, participantIds);

        assertNotNull(result);
        assertEquals(expectedDto.getId(), result.getId());
    }
}
</file>

<file path="src/test/java/com/example/demo/communication/email/util/EmailTemplateProcessorTest.java">
package com.example.demo.communication.email.util;

import org.junit.jupiter.api.Test;
import java.util.HashMap;
import java.util.Map;
import static org.junit.jupiter.api.Assertions.assertEquals;

public class EmailTemplateProcessorTest {

    @Test
    void processTemplate_shouldReplaceVariables() {
        EmailTemplateProcessor processor = new EmailTemplateProcessor();
        String template = "Hello, {{name}}! Welcome to {{company}}.";
        Map<String, Object> variables = new HashMap<>();
        variables.put("name", "John Doe");
        variables.put("company", "ACME Corp");

        String result = processor.processTemplate(template, variables);

        assertEquals("Hello, John Doe! Welcome to ACME Corp.", result);
    }

    @Test
    void processTemplate_withMissingVariables_shouldLeaveThemAsIs() {
        EmailTemplateProcessor processor = new EmailTemplateProcessor();
        String template = "Hello, {{name}}! Your code is {{code}}.";
        Map<String, Object> variables = new HashMap<>();
        variables.put("name", "Jane Doe");

        String result = processor.processTemplate(template, variables);

        assertEquals("Hello, Jane Doe! Your code is {{code}}.", result);
    }
}
</file>

<file path="src/test/java/com/example/demo/communication/notification/service/impl/NotificationServiceImplTest.java">
package com.example.demo.communication.notification.service.impl;

import com.example.demo.communication.notification.dto.NotificationCreateRequest;
import com.example.demo.communication.notification.dto.NotificationDto;
import com.example.demo.communication.notification.entity.Notification;
import com.example.demo.communication.notification.repository.NotificationRepository;
import com.example.demo.employee.repository.EmployeeRepository;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.modelmapper.ModelMapper;
import org.springframework.messaging.simp.SimpMessagingTemplate;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
public class NotificationServiceImplTest {

    @Mock
    private NotificationRepository notificationRepository;

    @Mock
    private EmployeeRepository employeeRepository;

    @Mock
    private SimpMessagingTemplate messagingTemplate;

    @Mock
    private ModelMapper modelMapper;

    @InjectMocks
    private NotificationServiceImpl notificationService;

    @Test
    void createNotification_shouldReturnNotificationDto() {
        NotificationCreateRequest request = new NotificationCreateRequest();
        request.setTitle("Test Title");
        request.setContent("Test Content");
        request.setUserId(1L);

        Notification notification = new Notification();
        notification.setId(1L);
        notification.setTitle("Test Title");

        NotificationDto expectedDto = new NotificationDto();
        expectedDto.setId(1L);
        expectedDto.setTitle("Test Title");

        when(modelMapper.map(request, Notification.class)).thenReturn(notification);
        when(notificationRepository.save(any(Notification.class))).thenReturn(notification);
        when(modelMapper.map(notification, NotificationDto.class)).thenReturn(expectedDto);

        NotificationDto result = notificationService.createNotification(request, 2L);

        assertNotNull(result);
        assertEquals(expectedDto.getId(), result.getId());
    }
}
</file>

<file path="src/test/java/com/example/demo/DemoApplicationTests.java">
package com.example.demo;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;

/**
 * Basic integration test for the Spring Boot application.
 * 
 * Verifies that the application context loads successfully
 * with all configurations and dependencies.
 */
@SpringBootTest
@ActiveProfiles("test")
class DemoApplicationTests {

    @Test
    void contextLoads() {
        // This test verifies that the Spring Boot application context
        // can be loaded successfully with all configurations
    }
}
</file>

<file path="src/test/java/com/example/demo/department/service/DepartmentServiceTest.java">
package com.example.demo.department.service;

import com.example.demo.department.dto.DepartmentCreateRequest;
import com.example.demo.department.dto.DepartmentDto;
import com.example.demo.department.dto.DepartmentTreeDto;
import com.example.demo.department.entity.Department;
import com.example.demo.department.exception.DepartmentAlreadyExistsException;
import com.example.demo.department.exception.DepartmentNotFoundException;
import com.example.demo.department.repository.DepartmentRepository;
import com.example.demo.department.service.impl.DepartmentServiceImpl;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.time.Instant;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class DepartmentServiceTest {
    
    @Mock
    private DepartmentRepository departmentRepository;
    
    @InjectMocks
    private DepartmentServiceImpl departmentService;
    
    private Department testDepartment;
    private DepartmentCreateRequest createRequest;
    
    @BeforeEach
    void setUp() {
        testDepartment = new Department();
        testDepartment.setId(1L);
        testDepartment.setName("Test Department");
        testDepartment.setCode("TEST");
        testDepartment.setDescription("Test Description");
        testDepartment.setEnabled(true);
        testDepartment.setLevel(0);
        testDepartment.setSortOrder(1);
        testDepartment.setDepPath("/TEST");
        testDepartment.setIsParent(false);
        testDepartment.setCreatedAt(Instant.now());
        testDepartment.setUpdatedAt(Instant.now());
        
        createRequest = new DepartmentCreateRequest();
        createRequest.setName("New Department");
        createRequest.setCode("NEW");
        createRequest.setDescription("New Description");
        createRequest.setEnabled(true);
        createRequest.setSortOrder(1);
    }
    
    @Test
    void createDepartment_Success() {
        // Given
        when(departmentRepository.existsByName(anyString())).thenReturn(false);
        when(departmentRepository.existsByCode(anyString())).thenReturn(false);
        when(departmentRepository.save(any(Department.class))).thenReturn(testDepartment);
        
        // When
        DepartmentDto result = departmentService.createDepartment(createRequest);
        
        // Then
        assertNotNull(result);
        assertEquals(testDepartment.getId(), result.getId());
        assertEquals(testDepartment.getName(), result.getName());
        assertEquals(testDepartment.getCode(), result.getCode());
        
        verify(departmentRepository).existsByName(createRequest.getName());
        verify(departmentRepository).existsByCode(createRequest.getCode());
        verify(departmentRepository).save(any(Department.class));
    }
    
    @Test
    void createDepartment_NameAlreadyExists_ThrowsException() {
        // Given
        when(departmentRepository.existsByName(anyString())).thenReturn(true);
        
        // When & Then
        assertThrows(DepartmentAlreadyExistsException.class, 
            () -> departmentService.createDepartment(createRequest));
        
        verify(departmentRepository).existsByName(createRequest.getName());
        verify(departmentRepository, never()).save(any(Department.class));
    }
    
    @Test
    void createDepartment_CodeAlreadyExists_ThrowsException() {
        // Given
        when(departmentRepository.existsByName(anyString())).thenReturn(false);
        when(departmentRepository.existsByCode(anyString())).thenReturn(true);
        
        // When & Then
        assertThrows(DepartmentAlreadyExistsException.class, 
            () -> departmentService.createDepartment(createRequest));
        
        verify(departmentRepository).existsByName(createRequest.getName());
        verify(departmentRepository).existsByCode(createRequest.getCode());
        verify(departmentRepository, never()).save(any(Department.class));
    }
    
    @Test
    void getDepartmentById_Success() {
        // Given
        when(departmentRepository.findById(1L)).thenReturn(Optional.of(testDepartment));
        
        // When
        DepartmentDto result = departmentService.getDepartmentById(1L);
        
        // Then
        assertNotNull(result);
        assertEquals(testDepartment.getId(), result.getId());
        assertEquals(testDepartment.getName(), result.getName());
        
        verify(departmentRepository).findById(1L);
    }
    
    @Test
    void getDepartmentById_NotFound_ThrowsException() {
        // Given
        when(departmentRepository.findById(1L)).thenReturn(Optional.empty());
        
        // When & Then
        assertThrows(DepartmentNotFoundException.class, 
            () -> departmentService.getDepartmentById(1L));
        
        verify(departmentRepository).findById(1L);
    }
    
    @Test
    void getDepartmentTree_Success() {
        // Given
        Department rootDept = new Department();
        rootDept.setId(1L);
        rootDept.setName("Root");
        rootDept.setCode("ROOT");
        rootDept.setLevel(0);
        rootDept.setSortOrder(1);
        
        Department childDept = new Department();
        childDept.setId(2L);
        childDept.setName("Child");
        childDept.setCode("CHILD");
        childDept.setLevel(1);
        childDept.setSortOrder(1);
        childDept.setParentId(1L);
        
        when(departmentRepository.findByParentIdIsNullOrderBySortOrder())
            .thenReturn(Arrays.asList(rootDept));
        when(departmentRepository.findByParentIdOrderBySortOrder(1L))
            .thenReturn(Arrays.asList(childDept));
        when(departmentRepository.findByParentIdOrderBySortOrder(2L))
            .thenReturn(Arrays.asList());
        
        // When
        List<DepartmentTreeDto> result = departmentService.getDepartmentTree();
        
        // Then
        assertNotNull(result);
        assertEquals(1, result.size());
        
        DepartmentTreeDto rootDto = result.get(0);
        assertEquals("Root", rootDto.getName());
        assertEquals(1, rootDto.getChildren().size());
        
        DepartmentTreeDto childDto = rootDto.getChildren().get(0);
        assertEquals("Child", childDto.getName());
        assertEquals(0, childDto.getChildren().size());
        
        verify(departmentRepository).findByParentIdIsNullOrderBySortOrder();
        verify(departmentRepository, times(2)).findByParentIdOrderBySortOrder(any());
    }
    
    @Test
    void searchDepartments_Success() {
        // Given
        when(departmentRepository.findByNameContainingIgnoreCaseOrderByName("test"))
            .thenReturn(Arrays.asList(testDepartment));
        
        // When
        List<DepartmentDto> result = departmentService.searchDepartments("test");
        
        // Then
        assertNotNull(result);
        assertEquals(1, result.size());
        assertEquals(testDepartment.getName(), result.get(0).getName());
        
        verify(departmentRepository).findByNameContainingIgnoreCaseOrderByName("test");
    }
    
    @Test
    void deleteDepartment_Success() {
        // Given
        when(departmentRepository.findById(1L)).thenReturn(Optional.of(testDepartment));
        when(departmentRepository.existsByParentId(1L)).thenReturn(false);
        
        // When
        departmentService.deleteDepartment(1L);
        
        // Then
        verify(departmentRepository).findById(1L);
        verify(departmentRepository).existsByParentId(1L);
        verify(departmentRepository).delete(testDepartment);
    }
    
    @Test
    void deleteDepartment_NotFound_ThrowsException() {
        // Given
        when(departmentRepository.findById(1L)).thenReturn(Optional.empty());
        
        // When & Then
        assertThrows(DepartmentNotFoundException.class, 
            () -> departmentService.deleteDepartment(1L));
        
        verify(departmentRepository).findById(1L);
        verify(departmentRepository, never()).delete(any());
    }
}
</file>

<file path="src/test/resources/application-test.properties">
# Test Environment Configuration
# Employee Management System - Test Profile

# Test Database Configuration (H2 in-memory for unit tests)
spring.datasource.url=jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
spring.datasource.driver-class-name=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=

# Test JPA Configuration
spring.jpa.hibernate.ddl-auto=create-drop
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.H2Dialect

# Disable Flyway for unit tests
spring.flyway.enabled=false

# Test Redis Configuration (use embedded Redis or disable)
spring.cache.type=none
spring.data.redis.host=localhost
spring.data.redis.port=6370

# Test Security Configuration
jwt.secret=testSecretKeyForUnitTestsOnly
jwt.expiration=3600000
encryption.key=testEncryptionKeyForUnitTestsOnly

# Test Email Configuration (disable actual sending)
spring.mail.host=localhost
spring.mail.port=3025
spring.mail.username=test
spring.mail.password=test

# Test Logging Configuration
logging.level.com.example.demo=DEBUG
logging.level.org.springframework.web=DEBUG
logging.level.org.springframework.security=DEBUG
logging.level.org.hibernate.SQL=DEBUG

# Test Actuator Configuration
management.endpoints.web.exposure.include=*
management.endpoint.health.show-details=always

# Test File Configuration
file.upload.directory=./target/test-uploads
file.temp.directory=./target/test-temp
</file>

<file path=".kiro/specs/spring-backend/position-implementation.md">
# Position and Title Management Implementation

## Overview
This document provides detailed implementation specifications for the Position and Title Management module. This module handles job positions, professional titles, position hierarchies, and position-related CRUD operations.

## Package Structure
```
com.example.demo.position/
├── entity/
│   └── Position.java
├── repository/
│   └── PositionRepository.java
├── service/
│   ├── PositionService.java
│   └── impl/
│       └── PositionServiceImpl.java
├── controller/
│   └── PositionController.java
├── dto/
│   ├── PositionDto.java
│   ├── PositionCreateRequest.java
│   ├── PositionUpdateRequest.java
│   └── PositionSearchCriteria.java
└── exception/
    ├── PositionNotFoundException.java
    ├── PositionAlreadyExistsException.java
    └── PositionInUseException.java
```

## Entity Class

### Enums

#### PositionCategory Enum
```java
package com.example.demo.position.enums;

public enum PositionCategory {
    TECHNICAL,
    MANAGEMENT,
    ADMINISTRATIVE,
    SALES,
    HR,
    FINANCE,
    MARKETING,
    OPERATIONS,
    SUPPORT,
    OTHER
}
```

#### PositionLevel Enum
```java
package com.example.demo.position.enums;

public enum PositionLevel {
    JUNIOR,
    MID,
    SENIOR,
    LEAD,
    MANAGER,
    DIRECTOR,
    VP,
    EXECUTIVE
}
```

#### EmploymentType Enum
```java
package com.example.demo.position.enums;

public enum EmploymentType {
    FULL_TIME,
    PART_TIME,
    CONTRACT,
    INTERNSHIP,
    TEMPORARY
}
```
### Position Entity
```java
package com.example.demo.position.entity;

import com.example.demo.department.entity.Department;
import com.example.demo.employee.entity.Employee;
import com.example.demo.position.enums.EmploymentType;
import com.example.demo.position.enums.PositionCategory;
import com.example.demo.position.enums.PositionLevel;
import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.Data;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "positions", indexes = {
    @Index(name = "idx_position_job_title", columnList = "job_title"),
    @Index(name = "idx_position_code", columnList = "code"),
    @Index(name = "idx_position_department_id", columnList = "department_id"),
    @Index(name = "idx_position_level", columnList = "level"),
    @Index(name = "idx_position_enabled", columnList = "enabled"),
    @Index(name = "idx_position_category", columnList = "category")
})
@EntityListeners(AuditingEntityListener.class)
@Data
public class Position {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotBlank(message = "Job title is required")
    @Column(name = "job_title", nullable = false, length = 100)
    private String jobTitle;

    @Column(name = "professional_title", length = 100)
    private String professionalTitle;

    @NotBlank(message = "Position code is required")
    @Column(name = "code", unique = true, nullable = false, length = 20)
    private String code;

    @Column(name = "description", length = 1000)
    private String description;

    @Column(name = "requirements", length = 2000)
    private String requirements;

    @Column(name = "responsibilities", length = 2000)
    private String responsibilities;

    @NotNull(message = "Position category is required")
    @Enumerated(EnumType.STRING)
    @Column(name = "category", nullable = false, length = 20)
    private PositionCategory category = PositionCategory.TECHNICAL;

    @Column(name = "salary_grade", length = 10)
    private String salaryGrade;

    @NotNull(message = "Department is required")
    @Column(name = "department_id", nullable = false)
    private Long departmentId;

    @NotNull(message = "Position level is required")
    @Enumerated(EnumType.STRING)
    @Column(name = "level", nullable = false, length = 20)
    private PositionLevel level = PositionLevel.JUNIOR;

    @Column(name = "enabled", nullable = false)
    private Boolean enabled = true;

    @Column(name = "min_salary", precision = 12, scale = 2)
    private BigDecimal minSalary;

    @Column(name = "max_salary", precision = 12, scale = 2)
    private BigDecimal maxSalary;

    @Column(name = "required_skills", length = 1000)
    private String requiredSkills;

    @Column(name = "required_education", length = 500)
    private String requiredEducation;

    @Column(name = "required_experience")
    private Integer requiredExperience;

    @Column(name = "benefits", length = 1000)
    private String benefits;

    @Column(name = "work_location", length = 255)
    private String workLocation;

    @NotNull(message = "Employment type is required")
    @Enumerated(EnumType.STRING)
    @Column(name = "employment_type", nullable = false, length = 20)
    private EmploymentType employmentType = EmploymentType.FULL_TIME;

    @Column(name = "is_managerial", nullable = false)
    private Boolean isManagerial = false;

    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;

    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;

    @Column(name = "created_by")
    private Long createdBy;

    @Column(name = "updated_by")
    private Long updatedBy;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "department_id", insertable = false, updatable = false,
            foreignKey = @ForeignKey(name = "fk_position_department"))
    private Department department;

    @OneToMany(mappedBy = "position", fetch = FetchType.LAZY)
    private Set<Employee> employees = new HashSet<>();
}
```

## Repository Interface

### PositionRepository
```java
package com.example.demo.position.repository;

import com.example.demo.position.entity.Position;
import com.example.demo.position.enums.PositionCategory;
import com.example.demo.position.enums.PositionLevel;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface PositionRepository extends JpaRepository<Position, Long>, JpaSpecificationExecutor<Position> {

    /**
     * Find a position by its unique code.
     *
     * @param code The position code.
     * @return An Optional containing the found position or empty if not found.
     */
    Optional<Position> findByCode(String code);

    /**
     * Check if a position with the given code exists.
     *
     * @param code The position code.
     * @return true if a position with the code exists, false otherwise.
     */
    boolean existsByCode(String code);

    /**
     * Find all positions within a specific department.
     *
     * @param departmentId The ID of the department.
     * @return A list of positions in the specified department.
     */
    List<Position> findByDepartmentId(Long departmentId);

    /**
     * Find all positions matching a specific level.
     *
     * @param level The position level.
     * @return A list of positions with the specified level.
     */
    List<Position> findByLevel(PositionLevel level);

    /**
     * Find all positions belonging to a specific category.
     *
     * @param category The position category.
     * @return A list of positions in the specified category.
     */
    List<Position> findByCategory(PositionCategory category);

    /**
     * Find all enabled positions with pagination.
     *
     * @param pageable Pagination information.
     * @return A Page of enabled positions.
     */
    Page<Position> findByEnabledTrue(Pageable pageable);

    /**
     * Search for positions by job title.
     *
     * @param jobTitle The job title to search for (case-insensitive).
     * @param pageable Pagination information.
     * @return A Page of positions matching the job title.
     */
    Page<Position> findByJobTitleContainingIgnoreCase(String jobTitle, Pageable pageable);

    /**
     * Custom query to find positions by department and filter by job title.
     *
     * @param departmentId The ID of the department.
     * @param jobTitle     A part of the job title to search for.
     * @return A list of matching positions.
     */
    @Query("SELECT p FROM Position p WHERE p.departmentId = :departmentId AND lower(p.jobTitle) LIKE lower(concat('%', :jobTitle, '%'))")
    List<Position> findByDepartmentAndJobTitle(@Param("departmentId") Long departmentId, @Param("jobTitle") String jobTitle);
}
```
</file>

<file path="design.md">
The following is a summary of project requirements, architectural design, and design specifications based on the contents of the folder:

### Project Requirements
#### Functional Requirements
1. **Permission Management**
- Design a permission database containing resource tables, role tables, user tables, resource role tables, and user role tables.
- Dynamically handle the relationship between roles and resources, and dynamically load modules based on the user's role after login.
    - Manage user-role relationships.
2. **Server Environment**
- Develop the server using SpringBoot + SpringSecurity.
- Implement a unified exception handling mechanism for server-side exceptions.
3. **Frontend Interaction**
- Wrap Axios requests and uniformly handle request exceptions.
    - Save login status and dynamically load components after successful login.
4. **Department Management**
- Design the department database and write stored procedures.
- Implement recursive queries for department data.
- Use a Tree component to display department information.
5. **Position and Title Management**
    - Manage job title and professional title information, display via tables, and support basic CRUD operations.
6. **Employee Management**
    - Manage employee basic information, implement CRUD operations, pagination, batch deletion, basic search, and advanced search functionality.
    - Support Excel import/export of employee information.
7. **Email Functionality**
    - Use Freemarker email templates to generate emails.
    - Implement Java email sending functionality, supporting the use of new threads to send emails in SpringBoot.
8. **Payroll Ledger Management**
- Manage payroll ledgers, supporting the addition of new payroll ledgers.
9. **Employee Ledger Settings**
- Set up employee ledgers, supporting the viewing of ledger details and ledger modifications.
10. **Chat and Notification Functionality**
    - Implement online chat functionality.
- Implement system notification functionality, including notification saving, pushing, and viewing.

#### Non-Functional Requirements
- Provide detailed documentation to help newcomers quickly understand the project.

### Architecture Design
#### Server-Side Architecture
- **Framework**: Developed using SpringBoot + SpringSecurity.
- **Dependencies**: Uses MyBatis for database operations, Druid as the database connection pool, and MySQL as the database.
- **Exception Handling**: Uniformly handles server-side exceptions.

#### Frontend Architecture
- **Framework**: Developed using Vue for the frontend.
- **Request Encapsulation**: Encapsulate axios requests and uniformly handle request exceptions.
- **Component Reusability**: Support component reusability.

### Design Specifications
#### Database Design
- **Permissions Database**: Includes resource tables, role tables, user tables, resource-role tables, and user-role tables.
- **Department Database**: Includes standard fields, uses depPath for convenient querying, and isParent indicates whether it is a parent department.
- **System Notification Database**: A modern and robust single-table model named `notifications` is used. This entity handles all aspects of notifications, including content, recipients, status, and type, ensuring a centralized and efficient notification system.

#### Code Implementation
- **Recursive Query**: Uses the collection feature in MyBatis' ResultMap to implement recursive queries for department data.
- **Tree Control**: Uses ElementUI's tree control to display department information, adopting a one-time loading approach for all data.
- **Email Templates**: Uses Freemarker to create email templates, with template files stored in the ftl directory under the resources directory.

#### Interface Design
- **Role Display**: Uses ElementUI's Collapse panel to display roles, and a tree control to display role resources.
- **Position and Title Management**: Use a table to display position and title information.
- **Employee Management**: Provide an employee basic information management interface, supporting CRUD operations, pagination, batch deletion, and search functionality.
- **Chat and Notifications**: Provide an online chat and system notification interface, supporting message sending and viewing.
</file>

<file path="src/main/java/com/example/demo/common/exception/BusinessException.java">
package com.example.demo.common.exception;

import lombok.Getter;

/**
 * Base exception for business logic errors.
 * 
 * Used for domain-specific errors that occur during business
 * operations and should be handled gracefully by the application.
 */
@Getter
public class BusinessException extends RuntimeException {
    
    /**
     * Application-specific error code
     */
    private final String errorCode;
    
    /**
     * Additional context information
     */
    private final Object context;
    
    /**
     * Creates a business exception with message
     */
    public BusinessException(String message) {
        super(message);
        this.errorCode = "BUSINESS_ERROR";
        this.context = null;
    }
    
    /**
     * Creates a business exception with message and cause
     */
    public BusinessException(String message, Throwable cause) {
        super(message, cause);
        this.errorCode = "BUSINESS_ERROR";
        this.context = null;
    }
    
    /**
     * Creates a business exception with error code and message
     */
    public BusinessException(String errorCode, String message) {
        super(message);
        this.errorCode = errorCode;
        this.context = null;
    }
    
    /**
     * Creates a business exception with error code, message, and context
     */
    public BusinessException(String errorCode, String message, Object context) {
        super(message);
        this.errorCode = errorCode;
        this.context = context;
    }
    
    /**
     * Creates a business exception with error code, message, and cause
     */
    public BusinessException(String errorCode, String message, Throwable cause) {
        super(message, cause);
        this.errorCode = errorCode;
        this.context = null;
    }
    
    /**
     * Creates a business exception with all parameters
     */
    public BusinessException(String errorCode, String message, Object context, Throwable cause) {
        super(message, cause);
        this.errorCode = errorCode;
        this.context = context;
    }
}
</file>

<file path="src/main/java/com/example/demo/common/exception/ValidationException.java">
package com.example.demo.common.exception;

import lombok.Getter;

import java.util.Map;

/**
 * Exception for data validation errors.
 * 
 * Used when input data fails validation rules and contains
 * detailed information about validation failures.
 */
@Getter
public class ValidationException extends BusinessException {
    
    /**
     * Map of field names to validation error messages
     */
    private final Map<String, String> validationErrors;
    
    /**
     * Creates a validation exception with a general message
     */
    public ValidationException(String message) {
        super("VALIDATION_ERROR", message);
        this.validationErrors = null;
    }
    
    /**
     * Creates a validation exception with message and cause
     */
    public ValidationException(String message, Throwable cause) {
        super("VALIDATION_ERROR", message, cause);
        this.validationErrors = null;
    }
    
    /**
     * Creates a validation exception with field-specific errors
     */
    public ValidationException(String message, Map<String, String> validationErrors) {
        super("VALIDATION_ERROR", message, validationErrors);
        this.validationErrors = validationErrors;
    }
    
    /**
     * Creates a validation exception with error code and field errors
     */
    public ValidationException(String errorCode, String message, Map<String, String> validationErrors) {
        super(errorCode, message, validationErrors);
        this.validationErrors = validationErrors;
    }
    
    /**
     * Checks if this exception has field-specific validation errors
     */
    public boolean hasFieldErrors() {
        return validationErrors != null && !validationErrors.isEmpty();
    }
    
    /**
     * Gets the number of validation errors
     */
    public int getErrorCount() {
        return validationErrors != null ? validationErrors.size() : 0;
    }
}
</file>

<file path="src/main/java/com/example/demo/communication/announcement/entity/Announcement.java">
package com.example.demo.communication.announcement.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.Instant;
import java.time.LocalDate;

@Entity
@Table(name = "announcements", indexes = {
    @Index(name = "idx_announcement_author_id", columnList = "author_id"),
    @Index(name = "idx_announcement_target_audience", columnList = "target_audience"),
    @Index(name = "idx_announcement_department_id", columnList = "department_id"),
    @Index(name = "idx_announcement_published", columnList = "published"),
    @Index(name = "idx_announcement_publish_date", columnList = "publish_date")
})
@EntityListeners(AuditingEntityListener.class)
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Announcement {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 200)
    private String title;

    @Lob
    @Column(nullable = false, columnDefinition = "TEXT")
    private String content;

    @Column(name = "author_id", nullable = false)
    private Long authorId; // User who created the announcement

    @Enumerated(EnumType.STRING)
    @Column(name = "target_audience", length = 50)
    private AnnouncementTarget targetAudience; // ALL, DEPARTMENT, ROLE

    @Column(name = "department_id") // if target is a specific department
    private Long departmentId;

    @Column(name = "role_name", length = 100) // if target is a specific role
    private String roleName;

    @Column(name = "publish_date")
    private LocalDate publishDate;

    @Column(name = "expiry_date")
    private LocalDate expiryDate;

    @Column(nullable = false)
    @Builder.Default
    private boolean published = false;

    @Column(name = "priority", length = 20)
    @Enumerated(EnumType.STRING)
    @Builder.Default
    private AnnouncementPriority priority = AnnouncementPriority.NORMAL;

    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;

    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;

    @Column(name = "created_by")
    private Long createdBy;

    @Column(name = "updated_by")
    private Long updatedBy;
    
    public enum AnnouncementPriority {
        LOW,
        NORMAL,
        HIGH,
        URGENT
    }
}
</file>

<file path="src/main/java/com/example/demo/communication/chat/entity/ChatParticipant.java">
package com.example.demo.communication.chat.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import java.time.Instant;

@Entity
@Table(name = "chat_participants", uniqueConstraints = {
    @UniqueConstraint(columnNames = {"room_id", "user_id"}, name = "uk_participant_room_user")
})
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ChatParticipant {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "room_id", nullable = false)
    private ChatRoom room;
    
    @Column(name = "user_id", nullable = false)
    private Long userId;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "role", nullable = false, length = 20)
    private ChatParticipantRole role; // OWNER, ADMIN, MEMBER
    
    @Column(name = "joined_at", nullable = false)
    private Instant joinedAt;
    
    @Column(name = "last_read_at")
    private Instant lastReadAt;
    
    @Column(name = "last_read_message_id")
    private Long lastReadMessageId; // Stored in Redis, synced periodically
    
    @Column(name = "is_muted", nullable = false)
    @Builder.Default
    private boolean isMuted = false;
    
    @Column(name = "is_active", nullable = false)
    @Builder.Default
    private boolean isActive = true;
    
    @Column(name = "left_at")
    private Instant leftAt;
    
    // Transient fields for DTO mapping
    @Transient
    private String userName;
    @Transient
    private String userAvatar;
    @Transient
    private boolean isOnline;
}
</file>

<file path="src/main/java/com/example/demo/communication/chat/entity/ChatRoom.java">
package com.example.demo.communication.chat.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.Instant;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "chat_rooms", indexes = {
    @Index(name = "idx_chatroom_type", columnList = "type"),
    @Index(name = "idx_chatroom_created_by", columnList = "created_by")
})
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@EntityListeners(AuditingEntityListener.class)
public class ChatRoom {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "name", length = 100)
    private String name; // Room name (for group chats)
    
    @Enumerated(EnumType.STRING)
    @Column(name = "type", nullable = false, length = 20)
    private ChatRoomType type; // DIRECT, GROUP, CHANNEL
    
    @Column(name = "description", length = 500)
    private String description;
    
    @Column(name = "avatar_url", length = 255)
    private String avatarUrl;
    
    @Column(name = "created_by", nullable = false)
    private Long createdBy; // User who created the room
    
    @Column(name = "is_private", nullable = false)
    @Builder.Default
    private boolean isPrivate = false;
    
    @Column(name = "is_active", nullable = false)
    @Builder.Default
    private boolean isActive = true;
    
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;
    
    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;
    
    @Column(name = "last_message_at")
    private Instant lastMessageAt;
    
    @Column(name = "last_message_id")
    private Long lastMessageId; // Stored in Redis, synced periodically
    
    @OneToMany(mappedBy = "room", cascade = CascadeType.ALL, orphanRemoval = true)
    @Builder.Default
    private Set<ChatParticipant> participants = new HashSet<>();

    // Transient fields for DTO mapping
    @Transient
    private Long unreadCount;
    @Transient
    private String lastMessageContent;
    @Transient
    private String lastMessageSender;
}
</file>

<file path="src/main/java/com/example/demo/communication/chat/websocket/WebSocketConfig.java">
package com.example.demo.communication.chat.websocket;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.lang.NonNull;
import org.springframework.messaging.Message;
import org.springframework.messaging.MessageChannel;
import org.springframework.messaging.simp.config.ChannelRegistration;
import org.springframework.messaging.simp.config.MessageBrokerRegistry;
import org.springframework.messaging.simp.stomp.StompCommand;
import org.springframework.messaging.simp.stomp.StompHeaderAccessor;
import org.springframework.messaging.support.ChannelInterceptor;
import org.springframework.messaging.support.MessageHeaderAccessor;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;
import org.springframework.web.socket.config.annotation.StompEndpointRegistry;
import org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;
import org.springframework.web.socket.server.HandshakeInterceptor;
import org.springframework.web.socket.WebSocketSession;
import org.springframework.web.socket.server.support.HttpSessionHandshakeInterceptor;

import java.util.List;
import java.util.Map;

/**
 * WebSocket Configuration with Security and Monitoring.
 * 
 * Configures STOMP messaging with security interceptors,
 * connection monitoring, and proper authentication handling.
 */
@Slf4j
@Configuration
@EnableWebSocketMessageBroker
@RequiredArgsConstructor
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Value("${app.websocket.allowed-origins:http://localhost:3000,http://localhost:5173}")
    private List<String> allowedOrigins;

    @Value("${app.websocket.heartbeat.client:10000}")
    private long clientHeartbeat;

    @Value("${app.websocket.heartbeat.server:10000}")
    private long serverHeartbeat;

    @Override
    public void configureMessageBroker(@NonNull MessageBrokerRegistry config) {
        // Enable a simple memory-based message broker to carry the messages
        // back to the client on destinations prefixed with "/topic" and "/queue"
        config.enableSimpleBroker("/topic", "/queue")
                .setHeartbeatValue(new long[]{serverHeartbeat, clientHeartbeat});
        
        // Designate the "/app" prefix for messages that are bound for methods
        // annotated with @MessageMapping
        config.setApplicationDestinationPrefixes("/app");
        
        // Set user destination prefix for private messages
        config.setUserDestinationPrefix("/user");
    }

    @Override
    public void registerStompEndpoints(@NonNull StompEndpointRegistry registry) {
        // Register the "/ws" endpoint with security and monitoring
        registry.addEndpoint("/ws")
                .setAllowedOriginPatterns(allowedOrigins.toArray(new String[0]))
                .addInterceptors(webSocketHandshakeInterceptor())
                .withSockJS()
                .setHeartbeatTime(25000); // 25 seconds
    }

    @Override
    public void configureClientInboundChannel(ChannelRegistration registration) {
        registration.interceptors(webSocketChannelInterceptor());
    }

    @Override
    public void configureClientOutboundChannel(ChannelRegistration registration) {
        registration.interceptors(webSocketChannelInterceptor());
    }

    /**
     * WebSocket handshake interceptor for connection security
     */
    @Bean
    public HandshakeInterceptor webSocketHandshakeInterceptor() {
        return new HttpSessionHandshakeInterceptor() {
            @Override
            public boolean beforeHandshake(
                    org.springframework.http.server.ServerHttpRequest request,
                    org.springframework.http.server.ServerHttpResponse response,
                    org.springframework.web.socket.WebSocketHandler wsHandler,
                    Map<String, Object> attributes) throws Exception {
                
                log.info("WebSocket handshake attempt from: {}", request.getRemoteAddress());
                
                // Add session attributes to WebSocket session
                boolean result = super.beforeHandshake(request, response, wsHandler, attributes);
                
                if (result) {
                    // Add connection timestamp
                    attributes.put("connectionTime", System.currentTimeMillis());
                    
                    // Add remote address for monitoring
                    attributes.put("remoteAddress", request.getRemoteAddress());
                    
                    log.info("WebSocket handshake successful for: {}", request.getRemoteAddress());
                } else {
                    log.warn("WebSocket handshake failed for: {}", request.getRemoteAddress());
                }
                
                return result;
            }

            @Override
            public void afterHandshake(
                    org.springframework.http.server.ServerHttpRequest request,
                    org.springframework.http.server.ServerHttpResponse response,
                    org.springframework.web.socket.WebSocketHandler wsHandler,
                    Exception exception) {
                
                if (exception != null) {
                    log.error("WebSocket handshake error for: {}", request.getRemoteAddress(), exception);
                } else {
                    log.info("WebSocket connection established for: {}", request.getRemoteAddress());
                }
                
                super.afterHandshake(request, response, wsHandler, exception);
            }
        };
    }

    /**
     * WebSocket channel interceptor for message security and monitoring
     */
    @Bean
    public ChannelInterceptor webSocketChannelInterceptor() {
        return new ChannelInterceptor() {
            @Override
            public Message<?> preSend(@NonNull Message<?> message, @NonNull MessageChannel channel) {
                StompHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class);
                
                if (accessor != null) {
                    StompCommand command = accessor.getCommand();
                    
                    if (StompCommand.CONNECT.equals(command)) {
                        handleConnect(accessor);
                    } else if (StompCommand.DISCONNECT.equals(command)) {
                        handleDisconnect(accessor);
                    } else if (StompCommand.SUBSCRIBE.equals(command)) {
                        handleSubscribe(accessor);
                    } else if (StompCommand.SEND.equals(command)) {
                        handleSend(accessor);
                    }
                    
                    // Log message for monitoring
                    log.debug("WebSocket message: command={}, destination={}, sessionId={}", 
                            command, accessor.getDestination(), accessor.getSessionId());
                }
                
                return message;
            }

            @Override
            public void postSend(@NonNull Message<?> message, @NonNull MessageChannel channel, boolean sent) {
                StompHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class);
                
                if (accessor != null && StompCommand.CONNECT.equals(accessor.getCommand())) {
                    // Connection established
                    String sessionId = accessor.getSessionId();
                    log.info("WebSocket STOMP connection established: sessionId={}", sessionId);
                }
            }

            private void handleConnect(StompHeaderAccessor accessor) {
                String sessionId = accessor.getSessionId();
                log.info("WebSocket CONNECT: sessionId={}", sessionId);
                
                // Extract authentication from headers if available
                String authToken = accessor.getFirstNativeHeader("Authorization");
                if (authToken != null && authToken.startsWith("Bearer ")) {
                    // Here you would validate the JWT token and set authentication
                    // For now, we'll create a simple authentication
                    Authentication auth = new UsernamePasswordAuthenticationToken("user", null, List.of());
                    accessor.setUser(auth);
                    SecurityContextHolder.getContext().setAuthentication(auth);
                }
            }

            private void handleDisconnect(StompHeaderAccessor accessor) {
                String sessionId = accessor.getSessionId();
                log.info("WebSocket DISCONNECT: sessionId={}", sessionId);
                
                // Clean up any session-specific resources
                SecurityContextHolder.clearContext();
            }

            private void handleSubscribe(StompHeaderAccessor accessor) {
                String destination = accessor.getDestination();
                String sessionId = accessor.getSessionId();
                
                log.info("WebSocket SUBSCRIBE: destination={}, sessionId={}", destination, sessionId);
                
                // Validate subscription permissions
                if (destination != null && destination.startsWith("/user/") && accessor.getUser() == null) {
                    log.warn("Unauthorized subscription attempt to private destination: {}", destination);
                    throw new SecurityException("Authentication required for private destinations");
                }
            }

            private void handleSend(StompHeaderAccessor accessor) {
                String destination = accessor.getDestination();
                String sessionId = accessor.getSessionId();
                
                log.debug("WebSocket SEND: destination={}, sessionId={}", destination, sessionId);
                
                // Validate send permissions
                if (destination != null && destination.startsWith("/app/admin/") && 
                    (accessor.getUser() == null || !hasAdminRole(accessor.getUser()))) {
                    log.warn("Unauthorized send attempt to admin destination: {}", destination);
                    throw new SecurityException("Admin privileges required");
                }
            }

            private boolean hasAdminRole(java.security.Principal user) {
                // Implement admin role check based on your authentication system
                return user != null && user.getName().contains("admin");
            }
        };
    }
}
</file>

<file path="src/main/java/com/example/demo/communication/email/dto/BulkEmailRequest.java">
package com.example.demo.communication.email.dto;

import com.example.demo.communication.email.entity.EmailPriority;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.Size;
import lombok.Data;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import java.util.List;
import java.util.Map;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class BulkEmailRequest {
    
    @NotEmpty(message = "Recipient list cannot be empty")
    private List<@Email String> recipients;
    
    private List<@Email String> ccEmails;
    
    private List<@Email String> bccEmails;
    
    @NotBlank(message = "Subject is required")
    @Size(max = 255, message = "Subject must not exceed 255 characters")
    private String subject;
    
    @NotBlank(message = "Content is required")
    private String content;
    
    private String templateCode; // Optional: use template instead of direct content
    
    private Map<String, Object> templateVariables; // Variables for template processing
    
    @Builder.Default
    private EmailPriority priority = EmailPriority.NORMAL;
    
    private Long sentBy; // User ID of sender
    
    @Builder.Default
    private boolean isHtml = true; // Whether content is HTML
    
    @Builder.Default
    private int batchSize = 50; // Number of emails to send in each batch
    
    @Builder.Default
    private long delayBetweenBatches = 1000; // Delay in milliseconds between batches
}
</file>

<file path="src/main/java/com/example/demo/communication/email/dto/EmailRequest.java">
package com.example.demo.communication.email.dto;

import com.example.demo.communication.email.entity.EmailPriority;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Data;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import java.util.List;
import java.util.Map;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class EmailRequest {
    
    @NotBlank(message = "Recipient email is required")
    @Email(message = "Invalid email format")
    private String toEmail;
    
    private List<@Email String> ccEmails;
    
    private List<@Email String> bccEmails;
    
    @NotBlank(message = "Subject is required")
    @Size(max = 255, message = "Subject must not exceed 255 characters")
    private String subject;
    
    @NotBlank(message = "Content is required")
    private String content;
    
    private String templateCode; // Optional: use template instead of direct content
    
    private Map<String, Object> templateVariables; // Variables for template processing
    
    @Builder.Default
    private EmailPriority priority = EmailPriority.NORMAL;
    
    private Long sentBy; // User ID of sender
    
    @Builder.Default
    private boolean isHtml = true; // Whether content is HTML
}
</file>

<file path="src/main/java/com/example/demo/communication/email/entity/EmailLog.java">
package com.example.demo.communication.email.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.Instant;

@Entity
@Table(name = "email_logs", indexes = {
    @Index(name = "idx_emaillog_to_email", columnList = "to_email"),
    @Index(name = "idx_emaillog_status", columnList = "status"),
    @Index(name = "idx_emaillog_template_code", columnList = "template_code"),
    @Index(name = "idx_emaillog_sent_by", columnList = "sent_by")
})
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@EntityListeners(AuditingEntityListener.class)
public class EmailLog {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "to_email", nullable = false)
    private String toEmail;
    
    @Column(name = "cc_emails", length = 1000)
    private String ccEmails; // Comma-separated CC emails
    
    @Column(name = "bcc_emails", length = 1000)
    private String bccEmails; // Comma-separated BCC emails
    
    @Column(name = "subject", nullable = false)
    private String subject;
    
    @Lob
    @Column(name = "content", nullable = false, columnDefinition = "TEXT")
    private String content;
    
    @Column(name = "template_code", length = 50)
    private String templateCode; // Template used (if any)
    
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 20)
    private EmailStatus status; // PENDING, SENT, FAILED, BOUNCED
    
    @Column(name = "error_message", length = 2000)
    private String errorMessage; // Error details if failed
    
    @Builder.Default
    @Column(name = "retry_count", nullable = false)
    private Integer retryCount = 0;
    
    @Column(name = "sent_at")
    private Instant sentAt;
    
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;
    
    @Column(name = "sent_by")
    private Long sentBy; // User who sent the email
    
    @Column(name = "message_id", length = 255)
    private String messageId; // Email provider message ID
    
    @Enumerated(EnumType.STRING)
    @Column(name = "priority", length = 20)
    private EmailPriority priority; // HIGH, NORMAL, LOW
}
</file>

<file path="src/main/java/com/example/demo/communication/email/entity/EmailTemplate.java">
package com.example.demo.communication.email.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.Instant;

@Entity
@Table(name = "email_templates", indexes = {
    @Index(name = "idx_emailtemplate_code", columnList = "code", unique = true),
    @Index(name = "idx_emailtemplate_category", columnList = "category")
})
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@EntityListeners(AuditingEntityListener.class)
public class EmailTemplate {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "name", nullable = false, length = 100)
    private String name; // Template name for identification
    
    @Column(name = "code", nullable = false, unique = true, length = 50)
    private String code; // Unique template code
    
    @Column(name = "subject", nullable = false, length = 255)
    private String subject; // Email subject template
    
    @Lob
    @Column(name = "content", nullable = false, columnDefinition = "TEXT")
    private String content; // Email content template (HTML/Text)
    
    @Enumerated(EnumType.STRING)
    @Column(name = "template_type", nullable = false, length = 20)
    private TemplateType templateType; // Template type (e.g., HTML, TEXT, MIXED)
    
    @Enumerated(EnumType.STRING)
    @Column(name = "category", length = 50)
    private TemplateCategory category; // WELCOME, NOTIFICATION, REMINDER, etc.
    
    @Column(name = "description", length = 500)
    private String description;
    
    @Lob
    @Column(name = "variables", columnDefinition = "TEXT")
    private String variables; // JSON string of available template variables
    
    @Builder.Default
    @Column(name = "is_default", nullable = false)
    private boolean isDefault = false;
    
    @Builder.Default
    @Column(name = "enabled", nullable = false)
    private boolean enabled = true;
    
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;
    
    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;
    
    @Column(name = "created_by")
    private Long createdBy;
    
    @Column(name = "updated_by")
    private Long updatedBy;
}
</file>

<file path="src/main/java/com/example/demo/communication/email/repository/EmailTemplateRepository.java">
package com.example.demo.communication.email.repository;

import com.example.demo.communication.email.entity.EmailTemplate;
import com.example.demo.communication.email.entity.TemplateCategory;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface EmailTemplateRepository extends JpaRepository<EmailTemplate, Long> {
    
    /**
     * Find template by unique code
     * @param code Template code
     * @return Optional EmailTemplate
     */
    Optional<EmailTemplate> findByCode(String code);
    
    /**
     * Find templates by category
     * @param category Template category
     * @return List of templates
     */
    List<EmailTemplate> findByCategory(TemplateCategory category);
    
    /**
     * Find enabled templates
     * @param enabled Whether template is enabled
     * @return List of enabled templates
     */
    List<EmailTemplate> findByEnabled(boolean enabled);
    
    /**
     * Find templates by category and enabled status
     * @param category Template category
     * @param enabled Whether template is enabled
     * @return List of templates
     */
    List<EmailTemplate> findByCategoryAndEnabled(TemplateCategory category, boolean enabled);
    
    /**
     * Find enabled templates
     * @return List of enabled templates
     */
    List<EmailTemplate> findByEnabledTrue();
    
    /**
     * Search templates by name or description
     * @param name Name search term
     * @param description Description search term
     * @param pageable Pagination parameters
     * @return Page of matching templates
     */
    Page<EmailTemplate> findByNameContainingOrDescriptionContaining(String name, String description, Pageable pageable);
    
    /**
     * Find default template for a category
     * @param category Template category
     * @return Optional default template
     */
    Optional<EmailTemplate> findByCategoryAndIsDefaultTrue(TemplateCategory category);
    
    /**
     * Search templates by name or description
     * @param searchTerm Search term
     * @param pageable Pagination parameters
     * @return Page of matching templates
     */
    @Query("SELECT t FROM EmailTemplate t WHERE " +
           "LOWER(t.name) LIKE LOWER(CONCAT('%', :searchTerm, '%')) OR " +
           "LOWER(t.description) LIKE LOWER(CONCAT('%', :searchTerm, '%'))")
    Page<EmailTemplate> searchTemplates(@Param("searchTerm") String searchTerm, Pageable pageable);
    
    /**
     * Check if template code exists
     * @param code Template code
     * @return true if exists
     */
    boolean existsByCode(String code);
    
    /**
     * Find templates created by user
     * @param createdBy User ID
     * @param pageable Pagination parameters
     * @return Page of templates
     */
    Page<EmailTemplate> findByCreatedBy(Long createdBy, Pageable pageable);
}
</file>

<file path="src/main/java/com/example/demo/communication/notification/controller/NotificationController.java">
package com.example.demo.communication.notification.controller;

import com.example.demo.communication.notification.dto.NotificationDto;
import com.example.demo.communication.notification.dto.NotificationCreateRequest;
import com.example.demo.communication.notification.dto.NotificationMarkReadRequest;
import com.example.demo.communication.notification.entity.NotificationType;
import com.example.demo.communication.notification.service.NotificationService;
import com.example.demo.common.dto.ApiResponse;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/v1/notifications")
@RequiredArgsConstructor
public class NotificationController {

    private final NotificationService notificationService;

    @PostMapping
    @PreAuthorize("hasAuthority('NOTIFICATION_SEND')")
    public ResponseEntity<ApiResponse<NotificationDto>> createNotification(
            @Valid @RequestBody NotificationCreateRequest request,
            Authentication authentication) {
        
        Long senderId = getCurrentUserId(authentication);
        NotificationDto notification = notificationService.createNotification(request, senderId);
        
        return ResponseEntity.status(HttpStatus.CREATED)
                .body(ApiResponse.success(notification, "Notification created successfully"));
    }

    @PostMapping("/bulk")
    @PreAuthorize("hasAuthority('NOTIFICATION_SEND')")
    public ResponseEntity<ApiResponse<List<NotificationDto>>> createBulkNotifications(
            @Valid @RequestBody NotificationCreateRequest request,
            Authentication authentication) {
        
        Long senderId = getCurrentUserId(authentication);
        List<NotificationDto> notifications = notificationService.createBulkNotifications(request, senderId);
        
        return ResponseEntity.status(HttpStatus.CREATED)
                .body(ApiResponse.success(notifications, "Bulk notifications created successfully"));
    }

    @GetMapping
    @PreAuthorize("hasAuthority('NOTIFICATION_READ')")
    public ResponseEntity<ApiResponse<Page<NotificationDto>>> getUserNotifications(
            Pageable pageable,
            Authentication authentication) {
        
        Long userId = getCurrentUserId(authentication);
        Page<NotificationDto> notifications = notificationService.getUserNotifications(userId, pageable);
        
        return ResponseEntity.ok(ApiResponse.success(notifications));
    }
    
    @GetMapping("/unread")
    @PreAuthorize("hasAuthority('NOTIFICATION_READ')")
    public ResponseEntity<ApiResponse<Page<NotificationDto>>> getUnreadNotifications(
            Pageable pageable,
            Authentication authentication) {
        
        Long userId = getCurrentUserId(authentication);
        Page<NotificationDto> notifications = notificationService.getUnreadNotifications(userId, pageable);
        
        return ResponseEntity.ok(ApiResponse.success(notifications));
    }

    @GetMapping("/type/{type}")
    @PreAuthorize("hasAuthority('NOTIFICATION_READ')")
    public ResponseEntity<ApiResponse<Page<NotificationDto>>> getNotificationsByType(
            @PathVariable NotificationType type,
            Pageable pageable,
            Authentication authentication) {
        
        Long userId = getCurrentUserId(authentication);
        Page<NotificationDto> notifications = notificationService.getNotificationsByType(userId, type, pageable);
        
        return ResponseEntity.ok(ApiResponse.success(notifications));
    }

    @PutMapping("/{id}/read")
    @PreAuthorize("hasAuthority('NOTIFICATION_READ')")
    public ResponseEntity<ApiResponse<Void>> markAsRead(
            @PathVariable Long id,
            Authentication authentication) {
        
        Long userId = getCurrentUserId(authentication);
        boolean success = notificationService.markAsRead(id, userId);
        
        if (success) {
            return ResponseEntity.ok(ApiResponse.success(null, "Notification marked as read"));
        } else {
            return ResponseEntity.badRequest()
                    .body(ApiResponse.error("Failed to mark notification as read"));
        }
    }

    @PutMapping("/read")
    @PreAuthorize("hasAuthority('NOTIFICATION_READ')")
    public ResponseEntity<ApiResponse<Integer>> markMultipleAsRead(
            @Valid @RequestBody NotificationMarkReadRequest request,
            Authentication authentication) {
        
        Long userId = getCurrentUserId(authentication);
        
        if (request.isMarkAll()) {
            int count = notificationService.markAllAsRead(userId);
            return ResponseEntity.ok(ApiResponse.success(count, "All notifications marked as read"));
        } else if (request.getNotificationIds() != null && !request.getNotificationIds().isEmpty()) {
            int count = notificationService.markMultipleAsRead(request.getNotificationIds(), userId);
            return ResponseEntity.ok(ApiResponse.success(count, "Notifications marked as read"));
        } else {
            return ResponseEntity.badRequest()
                    .body(ApiResponse.error("Invalid request: no notifications specified"));
        }
    }

    @GetMapping("/unread-count")
    @PreAuthorize("hasAuthority('NOTIFICATION_READ')")
    public ResponseEntity<ApiResponse<Long>> getUnreadCount(Authentication authentication) {
        Long userId = getCurrentUserId(authentication);
        long count = notificationService.getUnreadCount(userId);
        
        return ResponseEntity.ok(ApiResponse.success(count));
    }

    @GetMapping("/unread-count/{type}")
    @PreAuthorize("hasAuthority('NOTIFICATION_READ')")
    public ResponseEntity<ApiResponse<Long>> getUnreadCountByType(
            @PathVariable NotificationType type,
            Authentication authentication) {
        
        Long userId = getCurrentUserId(authentication);
        long count = notificationService.getUnreadCountByType(userId, type);
        
        return ResponseEntity.ok(ApiResponse.success(count));
    }

    @DeleteMapping("/{id}")
    @PreAuthorize("hasAuthority('NOTIFICATION_DELETE')")
    public ResponseEntity<ApiResponse<Void>> deleteNotification(
            @PathVariable Long id,
            Authentication authentication) {
        
        Long userId = getCurrentUserId(authentication);
        boolean success = notificationService.deleteNotification(id, userId);
        
        if (success) {
            return ResponseEntity.ok(ApiResponse.success(null, "Notification deleted successfully"));
        } else {
            return ResponseEntity.badRequest()
                    .body(ApiResponse.error("Failed to delete notification"));
        }
    }

    @GetMapping("/recent")
    @PreAuthorize("hasAuthority('NOTIFICATION_READ')")
    public ResponseEntity<ApiResponse<List<NotificationDto>>> getRecentNotifications(
            Authentication authentication) {
        
        Long userId = getCurrentUserId(authentication);
        List<NotificationDto> notifications = notificationService.getRecentNotifications(userId);
        
        return ResponseEntity.ok(ApiResponse.success(notifications));
    }

    private Long getCurrentUserId(Authentication authentication) {
        // This should extract user ID from the authentication object
        // Implementation depends on your security setup
        return Long.parseLong(authentication.getName());
    }
}
</file>

<file path="src/main/java/com/example/demo/communication/notification/entity/Notification.java">
package com.example.demo.communication.notification.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.Instant;

@Entity
@Table(name = "notifications", indexes = {
    @Index(name = "idx_notification_user_id", columnList = "user_id"),
    @Index(name = "idx_notification_type", columnList = "type"),
    @Index(name = "idx_notification_is_read", columnList = "is_read"),
    @Index(name = "idx_notification_created_at", columnList = "created_at"),
    @Index(name = "idx_notification_user_read", columnList = "user_id, is_read")
})
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@EntityListeners(AuditingEntityListener.class)
public class Notification {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "user_id", nullable = false)
    private Long userId; // Recipient user ID
    
    @Column(name = "title", nullable = false, length = 255)
    private String title;
    
    @Column(name = "content", nullable = false, columnDefinition = "TEXT")
    private String content;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "type", nullable = false, length = 50)
    private NotificationType type;
    
    @Builder.Default
    @Enumerated(EnumType.STRING)
    @Column(name = "priority", nullable = false, length = 20)
    private NotificationPriority priority = NotificationPriority.NORMAL;
    
    @Builder.Default
    @Column(name = "is_read", nullable = false)
    private Boolean isRead = false;
    
    @Column(name = "read_at")
    private Instant readAt;
    
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;
    
    @Column(name = "sender_id")
    private Long senderId; // User who sent the notification (optional)
    
    @Column(name = "reference_id")
    private Long referenceId; // Reference to related entity (e.g., chat message ID, announcement ID)
    
    @Column(name = "reference_type", length = 50)
    private String referenceType; // Type of referenced entity (e.g., "CHAT_MESSAGE", "ANNOUNCEMENT")
    
    @Column(name = "action_url", length = 500)
    private String actionUrl; // URL to navigate when notification is clicked
    
    @Column(name = "metadata", columnDefinition = "TEXT")
    private String metadata; // JSON string for additional data
    
    @Column(name = "expires_at")
    private Instant expiresAt; // Optional expiration time for the notification
}
</file>

<file path="src/main/java/com/example/demo/config/JpaConfig.java">
package com.example.demo.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;

@Configuration
@EnableJpaRepositories(basePackages = "com.example.demo")
public class JpaConfig {
}
</file>

<file path="src/main/java/com/example/demo/department/controller/DepartmentController.java">
package com.example.demo.department.controller;

import com.example.demo.common.dto.ApiResponse;
import com.example.demo.department.dto.*;
import com.example.demo.department.service.DepartmentService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/departments")
@RequiredArgsConstructor
@Slf4j
@Tag(name = "Department Management", description = "APIs for managing department hierarchy")
public class DepartmentController {
    
    private final DepartmentService departmentService;
    private final com.example.demo.employee.service.EmployeeService employeeService;
    
    @PostMapping
    @PreAuthorize("hasAuthority('DEPARTMENT_CREATE')")
    @Operation(summary = "Create a new department", description = "Creates a new department in the hierarchy")
    public ResponseEntity<ApiResponse<DepartmentDto>> createDepartment(
            @Valid @RequestBody DepartmentCreateRequest request) {
        log.info("Creating department: {}", request.getName());
        
        DepartmentDto created = departmentService.createDepartment(request);
        
        return ResponseEntity.status(HttpStatus.CREATED)
            .body(ApiResponse.success(created, "Department created successfully"));
    }
    
    @PutMapping("/{id}")
    @PreAuthorize("hasAuthority('DEPARTMENT_UPDATE')")
    @Operation(summary = "Update department", description = "Updates an existing department")
    public ResponseEntity<ApiResponse<DepartmentDto>> updateDepartment(
            @Parameter(description = "Department ID") @PathVariable Long id,
            @Valid @RequestBody DepartmentUpdateRequest request) {
        log.info("Updating department: {}", id);
        
        DepartmentDto updated = departmentService.updateDepartment(id, request);
        
        return ResponseEntity.ok(ApiResponse.success(updated, "Department updated successfully"));
    }
    
    @GetMapping("/{id}")
    @PreAuthorize("hasAuthority('DEPARTMENT_READ')")
    @Operation(summary = "Get department by ID", description = "Retrieves a department by its ID")
    public ResponseEntity<ApiResponse<DepartmentDto>> getDepartmentById(
            @Parameter(description = "Department ID") @PathVariable Long id) {
        log.info("Getting department: {}", id);
        
        DepartmentDto department = departmentService.getDepartmentById(id);
        
        return ResponseEntity.ok(ApiResponse.success(department));
    }
    
    @GetMapping("/code/{code}")
    @PreAuthorize("hasAuthority('DEPARTMENT_READ')")
    @Operation(summary = "Get department by code", description = "Retrieves a department by its code")
    public ResponseEntity<ApiResponse<DepartmentDto>> getDepartmentByCode(
            @Parameter(description = "Department code") @PathVariable String code) {
        log.info("Getting department by code: {}", code);
        
        DepartmentDto department = departmentService.getDepartmentByCode(code);
        
        return ResponseEntity.ok(ApiResponse.success(department));
    }
    
    @GetMapping
    @PreAuthorize("hasAuthority('DEPARTMENT_READ')")
    @Operation(summary = "Get all departments", description = "Retrieves all departments as a flat list")
    public ResponseEntity<ApiResponse<List<DepartmentDto>>> getAllDepartments() {
        log.info("Getting all departments");
        
        List<DepartmentDto> departments = departmentService.getAllDepartments();
        
        return ResponseEntity.ok(ApiResponse.success(departments));
    }
    
    @GetMapping("/tree")
    @PreAuthorize("hasAuthority('DEPARTMENT_READ')")
    @Operation(summary = "Get department tree", description = "Retrieves the complete department hierarchy as a tree")
    public ResponseEntity<ApiResponse<List<DepartmentTreeDto>>> getDepartmentTree() {
        log.info("Getting department tree");
        
        List<DepartmentTreeDto> tree = departmentService.getDepartmentTree();
        
        return ResponseEntity.ok(ApiResponse.success(tree));
    }
    
    @GetMapping("/{id}/subtree")
    @PreAuthorize("hasAuthority('DEPARTMENT_READ')")
    @Operation(summary = "Get department subtree", description = "Retrieves a department subtree starting from the specified department")
    public ResponseEntity<ApiResponse<DepartmentTreeDto>> getDepartmentSubtree(
            @Parameter(description = "Root department ID for subtree") @PathVariable Long id) {
        log.info("Getting department subtree for: {}", id);
        
        DepartmentTreeDto subtree = departmentService.getDepartmentSubtree(id);
        
        return ResponseEntity.ok(ApiResponse.success(subtree));
    }
    
    @GetMapping("/{id}/children")
    @PreAuthorize("hasAuthority('DEPARTMENT_READ')")
    @Operation(summary = "Get child departments", description = "Retrieves direct child departments of the specified parent")
    public ResponseEntity<ApiResponse<List<DepartmentDto>>> getChildDepartments(
            @Parameter(description = "Parent department ID") @PathVariable Long id) {
        log.info("Getting child departments for: {}", id);
        
        List<DepartmentDto> children = departmentService.getChildDepartments(id);
        
        return ResponseEntity.ok(ApiResponse.success(children));
    }
    
    @GetMapping("/root")
    @PreAuthorize("hasAuthority('DEPARTMENT_READ')")
    @Operation(summary = "Get root departments", description = "Retrieves all root-level departments")
    public ResponseEntity<ApiResponse<List<DepartmentDto>>> getRootDepartments() {
        log.info("Getting root departments");
        
        List<DepartmentDto> rootDepartments = departmentService.getChildDepartments(null);
        
        return ResponseEntity.ok(ApiResponse.success(rootDepartments));
    }
    
    @GetMapping("/level/{level}")
    @PreAuthorize("hasAuthority('DEPARTMENT_READ')")
    @Operation(summary = "Get departments by level", description = "Retrieves all departments at the specified hierarchy level")
    public ResponseEntity<ApiResponse<List<DepartmentDto>>> getDepartmentsByLevel(
            @Parameter(description = "Hierarchy level (0 for root)") @PathVariable Integer level) {
        log.info("Getting departments at level: {}", level);
        
        List<DepartmentDto> departments = departmentService.getDepartmentsByLevel(level);
        
        return ResponseEntity.ok(ApiResponse.success(departments));
    }
    
    @GetMapping("/search")
    @PreAuthorize("hasAuthority('DEPARTMENT_READ')")
    @Operation(summary = "Search departments", description = "Searches departments by name")
    public ResponseEntity<ApiResponse<List<DepartmentDto>>> searchDepartments(
            @Parameter(description = "Search term") @RequestParam String q) {
        log.info("Searching departments with term: {}", q);
        
        List<DepartmentDto> departments = departmentService.searchDepartments(q);
        
        return ResponseEntity.ok(ApiResponse.success(departments));
    }
    
    @DeleteMapping("/{id}")
    @PreAuthorize("hasAuthority('DEPARTMENT_DELETE')")
    @Operation(summary = "Delete department", description = "Deletes a department if it has no children or employees")
    public ResponseEntity<ApiResponse<Void>> deleteDepartment(
            @Parameter(description = "Department ID") @PathVariable Long id) {
        log.info("Deleting department: {}", id);
        
        departmentService.deleteDepartment(id);
        
        return ResponseEntity.ok(ApiResponse.success(null, "Department deleted successfully"));
    }
    
    @PutMapping("/{id}/move")
    @PreAuthorize("hasAuthority('DEPARTMENT_UPDATE')")
    @Operation(summary = "Move department", description = "Moves a department to a new parent")
    public ResponseEntity<ApiResponse<Void>> moveDepartment(
            @Parameter(description = "Department ID to move") @PathVariable Long id,
            @Parameter(description = "New parent department ID (null for root)") @RequestParam(required = false) Long parentId) {
        log.info("Moving department {} to parent {}", id, parentId);
        
        departmentService.moveDepartment(id, parentId);
        
        return ResponseEntity.ok(ApiResponse.success(null, "Department moved successfully"));
    }
    
    @PutMapping("/{id}/enabled")
    @PreAuthorize("hasAuthority('DEPARTMENT_UPDATE')")
    @Operation(summary = "Enable/disable department", description = "Enables or disables a department")
    public ResponseEntity<ApiResponse<Void>> setDepartmentEnabled(
            @Parameter(description = "Department ID") @PathVariable Long id,
            @Parameter(description = "Enable/disable flag") @RequestParam boolean enabled) {
        log.info("Setting department {} enabled status to: {}", id, enabled);
        
        departmentService.setDepartmentEnabled(id, enabled);
        
        return ResponseEntity.ok(ApiResponse.success(null, 
            "Department " + (enabled ? "enabled" : "disabled") + " successfully"));
    }
    
    @PutMapping("/{id}/sort-order")
    @PreAuthorize("hasAuthority('DEPARTMENT_UPDATE')")
    @Operation(summary = "Update sort order", description = "Updates the sort order of a department")
    public ResponseEntity<ApiResponse<Void>> updateSortOrder(
            @Parameter(description = "Department ID") @PathVariable Long id,
            @Parameter(description = "New sort order") @RequestParam Integer sortOrder) {
        log.info("Updating sort order for department {} to: {}", id, sortOrder);
        
        departmentService.updateSortOrder(id, sortOrder);
        
        return ResponseEntity.ok(ApiResponse.success(null, "Sort order updated successfully"));
    }
    
    @GetMapping("/{id}/path")
    @PreAuthorize("hasAuthority('DEPARTMENT_READ')")
    @Operation(summary = "Get department path", description = "Gets the path from root to the specified department")
    public ResponseEntity<ApiResponse<List<DepartmentDto>>> getDepartmentPath(
            @Parameter(description = "Department ID") @PathVariable Long id) {
        log.info("Getting path for department: {}", id);
        
        List<DepartmentDto> path = departmentService.getDepartmentPath(id);
        
        return ResponseEntity.ok(ApiResponse.success(path));
    }
    
    @GetMapping("/{id}/ancestors")
    @PreAuthorize("hasAuthority('DEPARTMENT_READ')")
    @Operation(summary = "Get ancestor departments", description = "Gets all ancestor departments of the specified department")
    public ResponseEntity<ApiResponse<List<DepartmentDto>>> getAncestorDepartments(
            @Parameter(description = "Department ID") @PathVariable Long id) {
        log.info("Getting ancestors for department: {}", id);
        
        List<DepartmentDto> ancestors = departmentService.getAncestorDepartments(id);
        
        return ResponseEntity.ok(ApiResponse.success(ancestors));
    }
    
    @GetMapping("/{id}/descendants")
    @PreAuthorize("hasAuthority('DEPARTMENT_READ')")
    @Operation(summary = "Get descendant departments", description = "Gets all descendant departments of the specified department")
    public ResponseEntity<ApiResponse<List<DepartmentDto>>> getDescendantDepartments(
            @Parameter(description = "Department ID") @PathVariable Long id) {
        log.info("Getting descendants for department: {}", id);
        
        List<DepartmentDto> descendants = departmentService.getDescendantDepartments(id);
        
        return ResponseEntity.ok(ApiResponse.success(descendants));
    }
    
    @GetMapping("/{id}/can-delete")
    @PreAuthorize("hasAuthority('DEPARTMENT_DELETE')")
    @Operation(summary = "Check if department can be deleted", description = "Checks if a department can be safely deleted")
    public ResponseEntity<ApiResponse<Boolean>> canDeleteDepartment(
            @Parameter(description = "Department ID") @PathVariable Long id) {
        log.info("Checking if department can be deleted: {}", id);
        
        boolean canDelete = departmentService.canDeleteDepartment(id);
        
        return ResponseEntity.ok(ApiResponse.success(canDelete));
    }
    
    @GetMapping("/{id}/statistics")
    @PreAuthorize("hasAuthority('DEPARTMENT_READ')")
    @Operation(summary = "Get department statistics", description = "Gets statistics for the specified department")
    public ResponseEntity<ApiResponse<DepartmentStatisticsDto>> getDepartmentStatistics(
            @Parameter(description = "Department ID") @PathVariable Long id) {
        log.info("Getting statistics for department: {}", id);
        
        DepartmentStatisticsDto statistics = departmentService.getDepartmentStatistics(id);
        
        return ResponseEntity.ok(ApiResponse.success(statistics));
    }
    
    @GetMapping("/{id}/employees")
    @PreAuthorize("hasAuthority('DEPARTMENT_READ')")
    @Operation(summary = "Get department employees", description = "Retrieves all employees in the specified department")
    public ResponseEntity<ApiResponse<List<com.example.demo.employee.dto.EmployeeDto>>> getDepartmentEmployees(
            @Parameter(description = "Department ID") @PathVariable Long id) {
        log.info("Getting employees for department: {}", id);
        
        List<com.example.demo.employee.dto.EmployeeDto> employees = employeeService.getEmployeesByDepartmentId(id);
        
        return ResponseEntity.ok(ApiResponse.success(employees));
    }
    
    @PostMapping("/rebuild-paths")
    @PreAuthorize("hasAuthority('DEPARTMENT_ADMIN')")
    @Operation(summary = "Rebuild department paths", description = "Maintenance operation to rebuild all department paths and levels")
    public ResponseEntity<ApiResponse<Void>> rebuildDepartmentPaths() {
        log.info("Rebuilding department paths");
        
        departmentService.rebuildDepartmentPaths();
        
        return ResponseEntity.ok(ApiResponse.success(null, "Department paths rebuilt successfully"));
    }
}
</file>

<file path="src/main/java/com/example/demo/employee/controller/EmployeeController.java">
package com.example.demo.employee.controller;

import com.example.demo.common.dto.ApiResponse;
import com.example.demo.employee.dto.*;
import com.example.demo.employee.entity.EmployeeStatus;
import com.example.demo.employee.service.EmployeeService;
import com.example.demo.employee.service.EmployeeImportService;
import com.example.demo.employee.service.EmployeeExportService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.http.MediaType;
import org.springframework.http.HttpHeaders;

import java.util.List;
import java.util.Map;
import java.util.HashMap;

@RestController
@RequestMapping("/api/employees")
@RequiredArgsConstructor
@Slf4j
@Tag(name = "Employee Management", description = "APIs for managing employees")
public class EmployeeController {

    private final EmployeeService employeeService;
    private final EmployeeImportService employeeImportService;
    private final EmployeeExportService employeeExportService;

    @PostMapping
    @PreAuthorize("hasAuthority('EMPLOYEE_CREATE')")
    @Operation(summary = "Create a new employee", description = "Creates a new employee with comprehensive information")
    public ResponseEntity<ApiResponse<EmployeeDto>> createEmployee(
            @Valid @RequestBody EmployeeCreateRequest createRequest) {
        log.info("Creating employee with email: {}", createRequest.getEmail());
        
        EmployeeDto createdEmployee = employeeService.createEmployee(createRequest);
        
        return ResponseEntity.status(HttpStatus.CREATED)
            .body(ApiResponse.success(createdEmployee, "Employee created successfully"));
    }

    @PutMapping("/{id}")
    @PreAuthorize("hasAuthority('EMPLOYEE_UPDATE')")
    @Operation(summary = "Update employee", description = "Updates an existing employee")
    public ResponseEntity<ApiResponse<EmployeeDto>> updateEmployee(
            @Parameter(description = "Employee ID") @PathVariable Long id,
            @Valid @RequestBody EmployeeUpdateRequest updateRequest) {
        log.info("Updating employee with ID: {}", id);
        
        EmployeeDto updatedEmployee = employeeService.updateEmployee(id, updateRequest);
        
        return ResponseEntity.ok(ApiResponse.success(updatedEmployee, "Employee updated successfully"));
    }

    @GetMapping("/{id}")
    @PreAuthorize("hasAuthority('EMPLOYEE_READ')")
    @Operation(summary = "Get employee by ID", description = "Retrieves an employee by their ID")
    public ResponseEntity<ApiResponse<EmployeeDto>> getEmployeeById(
            @Parameter(description = "Employee ID") @PathVariable Long id) {
        log.info("Getting employee with ID: {}", id);
        
        EmployeeDto employee = employeeService.getEmployeeById(id);
        
        return ResponseEntity.ok(ApiResponse.success(employee));
    }

    @GetMapping("/employee-number/{employeeNumber}")
    @PreAuthorize("hasAuthority('EMPLOYEE_READ')")
    @Operation(summary = "Get employee by employee number", description = "Retrieves an employee by their employee number")
    public ResponseEntity<ApiResponse<EmployeeDto>> getEmployeeByEmployeeNumber(
            @Parameter(description = "Employee number") @PathVariable String employeeNumber) {
        log.info("Getting employee with employee number: {}", employeeNumber);
        
        EmployeeDto employee = employeeService.getEmployeeByEmployeeNumber(employeeNumber);
        
        return ResponseEntity.ok(ApiResponse.success(employee));
    }

    @GetMapping
    @PreAuthorize("hasAuthority('EMPLOYEE_READ')")
    @Operation(summary = "Get all employees", description = "Retrieves all employees with pagination")
    public ResponseEntity<ApiResponse<Page<EmployeeDto>>> getAllEmployees(Pageable pageable) {
        log.info("Getting all employees with pagination");
        
        Page<EmployeeDto> employees = employeeService.getAllEmployees(pageable);
        
        return ResponseEntity.ok(ApiResponse.success(employees));
    }

    @GetMapping("/department/{departmentId}")
    @PreAuthorize("hasAuthority('EMPLOYEE_READ')")
    @Operation(summary = "Get employees by department", description = "Retrieves employees in a specific department")
    public ResponseEntity<ApiResponse<Page<EmployeeDto>>> getEmployeesByDepartment(
            @Parameter(description = "Department ID") @PathVariable Long departmentId,
            Pageable pageable) {
        log.info("Getting employees for department: {}", departmentId);
        
        Page<EmployeeDto> employees = employeeService.getEmployeesByDepartmentId(departmentId, pageable);
        
        return ResponseEntity.ok(ApiResponse.success(employees));
    }

    @GetMapping("/status/{status}")
    @PreAuthorize("hasAuthority('EMPLOYEE_READ')")
    @Operation(summary = "Get employees by status", description = "Retrieves employees with a specific status")
    public ResponseEntity<ApiResponse<Page<EmployeeDto>>> getEmployeesByStatus(
            @Parameter(description = "Employee status") @PathVariable EmployeeStatus status,
            Pageable pageable) {
        log.info("Getting employees with status: {}", status);
        
        Page<EmployeeDto> employees = employeeService.getEmployeesByStatus(status, pageable);
        
        return ResponseEntity.ok(ApiResponse.success(employees));
    }

    @GetMapping("/search")
    @PreAuthorize("hasAuthority('EMPLOYEE_READ')")
    @Operation(summary = "Search employees", description = "Searches employees by name, email, or employee number")
    public ResponseEntity<ApiResponse<Page<EmployeeDto>>> searchEmployees(
            @Parameter(description = "Search term") @RequestParam String q,
            Pageable pageable) {
        log.info("Searching employees with term: {}", q);
        
        Page<EmployeeDto> employees = employeeService.searchEmployees(q, pageable);
        
        return ResponseEntity.ok(ApiResponse.success(employees));
    }

    @DeleteMapping("/{id}")
    @PreAuthorize("hasAuthority('EMPLOYEE_DELETE')")
    @Operation(summary = "Delete employee", description = "Deletes an employee")
    public ResponseEntity<ApiResponse<Void>> deleteEmployee(
            @Parameter(description = "Employee ID") @PathVariable Long id) {
        log.info("Deleting employee with ID: {}", id);
        
        employeeService.deleteEmployee(id);
        
        return ResponseEntity.ok(ApiResponse.success(null, "Employee deleted successfully"));
    }

    @GetMapping("/exists/employee-number/{employeeNumber}")
    @PreAuthorize("hasAuthority('EMPLOYEE_READ')")
    @Operation(summary = "Check if employee number exists", description = "Checks if an employee number is already in use")
    public ResponseEntity<ApiResponse<Boolean>> existsByEmployeeNumber(
            @Parameter(description = "Employee number") @PathVariable String employeeNumber) {
        boolean exists = employeeService.existsByEmployeeNumber(employeeNumber);
        return ResponseEntity.ok(ApiResponse.success(exists));
    }

    @GetMapping("/exists/email/{email}")
    @PreAuthorize("hasAuthority('EMPLOYEE_READ')")
    @Operation(summary = "Check if email exists", description = "Checks if an email is already in use")
    public ResponseEntity<ApiResponse<Boolean>> existsByEmail(
            @Parameter(description = "Email address") @PathVariable String email) {
        boolean exists = employeeService.existsByEmail(email);
        return ResponseEntity.ok(ApiResponse.success(exists));
    }

    @PostMapping("/search/advanced")
    @PreAuthorize("hasAuthority('EMPLOYEE_READ')")
    @Operation(summary = "Advanced search employees", description = "Searches employees with multiple criteria")
    public ResponseEntity<ApiResponse<Page<EmployeeDto>>> advancedSearchEmployees(
            @Valid @RequestBody EmployeeSearchCriteria criteria,
            Pageable pageable) {
        log.info("Advanced search employees with criteria");
        
        Page<EmployeeDto> employees = employeeService.searchEmployees(criteria, pageable);
        
        return ResponseEntity.ok(ApiResponse.success(employees));
    }

    // Import/Export endpoints
    @PostMapping(value = "/import", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    @PreAuthorize("hasAuthority('EMPLOYEE_IMPORT')")
    @Operation(summary = "Import employees from Excel", description = "Imports employees from Excel file")
    public ResponseEntity<ApiResponse<EmployeeImportResult>> importEmployees(
            @Parameter(description = "Excel file containing employee data") @RequestParam("file") MultipartFile file,
            @Parameter(description = "Import options") @RequestParam(required = false) Map<String, Object> options) {
        log.info("Importing employees from file: {}", file.getOriginalFilename());
        
        if (options == null) {
            options = new HashMap<>();
        }
        
        EmployeeImportResult result = employeeImportService.importFromExcel(file, options);
        
        return ResponseEntity.ok(ApiResponse.success(result, "Import completed"));
    }

    @PostMapping(value = "/import/csv", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    @PreAuthorize("hasAuthority('EMPLOYEE_IMPORT')")
    @Operation(summary = "Import employees from CSV", description = "Imports employees from CSV file")
    public ResponseEntity<ApiResponse<EmployeeImportResult>> importEmployeesFromCsv(
            @Parameter(description = "CSV file containing employee data") @RequestParam("file") MultipartFile file,
            @Parameter(description = "Import options") @RequestParam(required = false) Map<String, Object> options) {
        log.info("Importing employees from CSV file: {}", file.getOriginalFilename());
        
        if (options == null) {
            options = new HashMap<>();
        }
        
        EmployeeImportResult result = employeeImportService.importFromCsv(file, options);
        
        return ResponseEntity.ok(ApiResponse.success(result, "CSV import completed"));
    }

    @PostMapping(value = "/import/validate", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    @PreAuthorize("hasAuthority('EMPLOYEE_READ')")
    @Operation(summary = "Validate import file", description = "Validates import file format and structure")
    public ResponseEntity<ApiResponse<EmployeeImportResult>> validateImportFile(
            @Parameter(description = "File to validate") @RequestParam("file") MultipartFile file) {
        log.info("Validating import file: {}", file.getOriginalFilename());
        
        EmployeeImportResult result = employeeImportService.validateImportFile(file);
        
        return ResponseEntity.ok(ApiResponse.success(result, "File validation completed"));
    }

    @PostMapping(value = "/import/preview", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    @PreAuthorize("hasAuthority('EMPLOYEE_READ')")
    @Operation(summary = "Preview import data", description = "Previews import data without actually importing")
    public ResponseEntity<ApiResponse<EmployeeImportResult>> previewImport(
            @Parameter(description = "File to preview") @RequestParam("file") MultipartFile file,
            @Parameter(description = "Maximum rows to preview") @RequestParam(defaultValue = "10") int maxRows) {
        log.info("Previewing import file: {}", file.getOriginalFilename());
        
        EmployeeImportResult result = employeeImportService.previewImport(file, maxRows);
        
        return ResponseEntity.ok(ApiResponse.success(result, "Import preview completed"));
    }

    @GetMapping("/import/template")
    @PreAuthorize("hasAuthority('EMPLOYEE_READ')")
    @Operation(summary = "Download import template", description = "Downloads Excel template for employee import")
    public ResponseEntity<byte[]> downloadImportTemplate(
            @Parameter(description = "Include example data") @RequestParam(defaultValue = "false") boolean includeExamples) {
        log.info("Downloading import template with examples: {}", includeExamples);
        
        byte[] template = employeeImportService.getImportTemplate(includeExamples);
        
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_OCTET_STREAM);
        headers.setContentDispositionFormData("attachment", "employee-import-template.xlsx");
        
        return ResponseEntity.ok()
                .headers(headers)
                .body(template);
    }

    @PostMapping("/export")
    @PreAuthorize("hasAuthority('EMPLOYEE_EXPORT')")
    @Operation(summary = "Export employees", description = "Exports employees based on criteria")
    public ResponseEntity<byte[]> exportEmployees(
            @Valid @RequestBody EmployeeExportRequest exportRequest) {
        log.info("Exporting employees to format: {}", exportRequest.getFormat());
        
        byte[] exportData;
        String contentType;
        String fileExtension;
        
        switch (exportRequest.getFormat()) {
            case EXCEL:
                exportData = employeeExportService.exportToExcel(exportRequest);
                contentType = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
                fileExtension = "xlsx";
                break;
            case CSV:
                exportData = employeeExportService.exportToCsv(exportRequest);
                contentType = "text/csv";
                fileExtension = "csv";
                break;
            case PDF:
                exportData = employeeExportService.exportToPdf(exportRequest);
                contentType = "application/pdf";
                fileExtension = "pdf";
                break;
            default:
                throw new IllegalArgumentException("Unsupported export format: " + exportRequest.getFormat());
        }
        
        String filename = employeeExportService.generateExportFilename(exportRequest);
        if (!filename.endsWith("." + fileExtension)) {
            filename += "." + fileExtension;
        }
        
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.parseMediaType(contentType));
        headers.setContentDispositionFormData("attachment", filename);
        
        return ResponseEntity.ok()
                .headers(headers)
                .body(exportData);
    }

    @PostMapping("/export/by-ids")
    @PreAuthorize("hasAuthority('EMPLOYEE_EXPORT')")
    @Operation(summary = "Export specific employees", description = "Exports specific employees by their IDs")
    public ResponseEntity<byte[]> exportEmployeesByIds(
            @Parameter(description = "Employee IDs to export") @RequestBody List<Long> employeeIds,
            @Valid @RequestBody EmployeeExportRequest exportRequest) {
        log.info("Exporting {} employees by IDs", employeeIds.size());
        
        byte[] exportData = employeeExportService.exportEmployeesByIds(employeeIds, exportRequest);
        
        String filename = employeeExportService.generateExportFilename(exportRequest);
        String contentType = getContentTypeForFormat(exportRequest.getFormat());
        
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.parseMediaType(contentType));
        headers.setContentDispositionFormData("attachment", filename);
        
        return ResponseEntity.ok()
                .headers(headers)
                .body(exportData);
    }

    @GetMapping("/import/info")
    @PreAuthorize("hasAuthority('EMPLOYEE_READ')")
    @Operation(summary = "Get import information", description = "Gets information about import capabilities")
    public ResponseEntity<ApiResponse<Map<String, Object>>> getImportInfo() {
        Map<String, Object> info = new HashMap<>();
        info.put("supportedFormats", employeeImportService.getSupportedFormats());
        info.put("maxFileSize", employeeImportService.getMaxFileSize());
        info.put("maxRecordCount", employeeImportService.getMaxRecordCount());
        info.put("fieldMapping", employeeImportService.getFieldMapping());
        info.put("requiredFields", employeeImportService.getRequiredFields());
        info.put("optionalFields", employeeImportService.getOptionalFields());
        
        return ResponseEntity.ok(ApiResponse.success(info));
    }

    @GetMapping("/export/info")
    @PreAuthorize("hasAuthority('EMPLOYEE_READ')")
    @Operation(summary = "Get export information", description = "Gets information about export capabilities")
    public ResponseEntity<ApiResponse<Map<String, Object>>> getExportInfo() {
        Map<String, Object> info = new HashMap<>();
        info.put("supportedFormats", employeeExportService.getSupportedFormats());
        info.put("maxExportRecords", employeeExportService.getMaxExportRecords());
        
        return ResponseEntity.ok(ApiResponse.success(info));
    }

    private String getContentTypeForFormat(EmployeeExportRequest.ExportFormat format) {
        switch (format) {
            case EXCEL:
                return "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
            case CSV:
                return "text/csv";
            case PDF:
                return "application/pdf";
            default:
                return "application/octet-stream";
        }
    }
}
</file>

<file path="src/main/java/com/example/demo/employee/dto/EmployeeExportRequest.java">
package com.example.demo.employee.dto;

import com.example.demo.employee.entity.EmployeeStatus;
import com.example.demo.employee.entity.EmploymentType;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;

import java.time.LocalDate;
import java.util.List;
import java.util.Set;

/**
 * DTO for employee export request parameters
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class EmployeeExportRequest {
    
    // Export format
    @Builder.Default
    private ExportFormat format = ExportFormat.EXCEL;
    
    // File name (without extension)
    private String fileName;
    
    // Fields to include in export
    private Set<String> includeFields;
    
    // Fields to exclude from export
    private Set<String> excludeFields;
    
    // Filter criteria
    private List<Long> departmentIds;
    private List<Long> positionIds;
    private List<EmployeeStatus> statuses;
    private List<EmploymentType> employmentTypes;
    
    // Date range filters
    private LocalDate hireDateFrom;
    private LocalDate hireDateTo;
    
    // Include sensitive data (requires special permission)
    @Builder.Default
    private boolean includeSensitiveData = false;
    
    // Include terminated employees
    @Builder.Default
    private boolean includeTerminated = false;
    
    // Include disabled employees
    @Builder.Default
    private boolean includeDisabled = false;
    
    // Sort options
    @Builder.Default
    private String sortBy = "lastName";
    @Builder.Default
    private String sortDirection = "ASC";
    
    // Template options
    @Builder.Default
    private boolean includeHeaders = true;
    @Builder.Default
    private boolean includeMetadata = true;
    
    // Localization
    @Builder.Default
    private String locale = "en_US";
    
    public enum ExportFormat {
        EXCEL("xlsx"),
        CSV("csv"),
        PDF("pdf");
        
        private final String extension;
        
        ExportFormat(String extension) {
            this.extension = extension;
        }
        
        public String getExtension() {
            return extension;
        }
    }
    
    /**
     * Get default field set for export
     */
    public static Set<String> getDefaultFields() {
        return Set.of(
            "employeeNumber", "firstName", "lastName", "email", 
            "phone", "departmentName", "positionName", "managerName",
            "hireDate", "status", "employmentType", "salary"
        );
    }
    
    /**
     * Get sensitive fields that require special permission
     */
    public static Set<String> getSensitiveFields() {
        return Set.of(
            "dateOfBirth", "bankAccount", "taxId", "address", 
            "city", "state", "zipCode", "country"
        );
    }
    
    /**
     * Check if request includes sensitive data
     */
    public boolean requestsIncludeSensitiveData() {
        if (!includeSensitiveData) return false;
        
        if (includeFields != null) {
            return includeFields.stream().anyMatch(getSensitiveFields()::contains);
        }
        
        if (excludeFields != null) {
            return getSensitiveFields().stream().anyMatch(field -> !excludeFields.contains(field));
        }
        
        return true; // Default includes sensitive data if flag is set
    }
    
    /**
     * Get effective fields to export
     */
    public Set<String> getEffectiveFields() {
        Set<String> fields = includeFields != null ? includeFields : getDefaultFields();
        
        if (excludeFields != null) {
            fields.removeAll(excludeFields);
        }
        
        if (!includeSensitiveData) {
            fields.removeAll(getSensitiveFields());
        }
        
        return fields;
    }
}
</file>

<file path="src/main/java/com/example/demo/employee/service/EmployeeService.java">
package com.example.demo.employee.service;

import com.example.demo.employee.dto.EmployeeCreateRequest;
import com.example.demo.employee.dto.EmployeeDto;
import com.example.demo.employee.dto.EmployeeSearchCriteria;
import com.example.demo.employee.dto.EmployeeUpdateRequest;
import com.example.demo.employee.entity.EmployeeStatus;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import java.util.List;

public interface EmployeeService {
    
    /**
     * Create a new employee
     */
    EmployeeDto createEmployee(EmployeeCreateRequest createRequest);
    
    /**
     * Update an existing employee
     */
    EmployeeDto updateEmployee(Long id, EmployeeUpdateRequest updateRequest);
    
    /**
     * Get employee by ID
     */
    EmployeeDto getEmployeeById(Long id);
    
    /**
     * Get employee by employee number
     */
    EmployeeDto getEmployeeByEmployeeNumber(String employeeNumber);
    
    /**
     * Get all employees with pagination
     */
    Page<EmployeeDto> getAllEmployees(Pageable pageable);
    
    /**
     * Get employees by department ID
     */
    Page<EmployeeDto> getEmployeesByDepartmentId(Long departmentId, Pageable pageable);
    
    /**
     * Get employees by department ID (list version for department service)
     */
    List<EmployeeDto> getEmployeesByDepartmentId(Long departmentId);
    
    /**
     * Get employees by status
     */
    Page<EmployeeDto> getEmployeesByStatus(EmployeeStatus status, Pageable pageable);
    
    /**
     * Search employees by term
     */
    Page<EmployeeDto> searchEmployees(String searchTerm, Pageable pageable);
    
    /**
     * Advanced search employees with multiple criteria
     */
    Page<EmployeeDto> searchEmployees(EmployeeSearchCriteria criteria, Pageable pageable);
    
    /**
     * Delete employee by ID
     */
    void deleteEmployee(Long id);
    
    /**
     * Check if employee exists by employee number
     */
    boolean existsByEmployeeNumber(String employeeNumber);
    
    /**
     * Check if employee exists by email
     */
    boolean existsByEmail(String email);
    
    /**
     * Count employees by department ID
     */
    long countEmployeesByDepartmentId(Long departmentId);
}
</file>

<file path="src/main/java/com/example/demo/employee/service/impl/EmployeeServiceImpl.java">
package com.example.demo.employee.service.impl;

import com.example.demo.employee.dto.EmployeeCreateRequest;
import com.example.demo.employee.dto.EmployeeDto;
import com.example.demo.employee.dto.EmployeeSearchCriteria;
import com.example.demo.employee.dto.EmployeeUpdateRequest;
import com.example.demo.employee.entity.Employee;
import com.example.demo.employee.entity.EmployeeStatus;
import com.example.demo.employee.exception.EmployeeAlreadyExistsException;
import com.example.demo.employee.exception.EmployeeNotFoundException;
import com.example.demo.employee.repository.EmployeeRepository;
import com.example.demo.employee.service.EmployeeService;
import com.example.demo.department.entity.Department;
import com.example.demo.department.repository.DepartmentRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class EmployeeServiceImpl implements EmployeeService {

    private final EmployeeRepository employeeRepository;
    private final DepartmentRepository departmentRepository;

    @Override
    @Transactional
    public EmployeeDto createEmployee(EmployeeCreateRequest createRequest) {
        log.info("Creating employee with email: {}", createRequest.getEmail());

        // Validate unique constraints
        if (employeeRepository.existsByEmail(createRequest.getEmail())) {
            throw EmployeeAlreadyExistsException.byEmail(createRequest.getEmail());
        }

        // Validate department exists
        if (!departmentRepository.existsById(createRequest.getDepartmentId())) {
            throw new RuntimeException("Department not found with id: " + createRequest.getDepartmentId());
        }

        // Create employee entity
        Employee employee = new Employee();
        employee.setEmployeeNumber(generateEmployeeNumber());
        employee.setFirstName(createRequest.getFirstName());
        employee.setLastName(createRequest.getLastName());
        employee.setEmail(createRequest.getEmail());
        employee.setPhone(createRequest.getPhone());
        employee.setMobilePhone(createRequest.getMobilePhone());
        employee.setAddress(createRequest.getAddress());
        employee.setCity(createRequest.getCity());
        employee.setState(createRequest.getState());
        employee.setZipCode(createRequest.getZipCode());
        employee.setCountry(createRequest.getCountry());
        employee.setDateOfBirth(createRequest.getDateOfBirth());
        employee.setGender(createRequest.getGender());
        employee.setMaritalStatus(createRequest.getMaritalStatus());
        employee.setNationality(createRequest.getNationality());
        employee.setDepartmentId(createRequest.getDepartmentId());
        employee.setPositionId(createRequest.getPositionId());
        employee.setManagerId(createRequest.getManagerId());
        employee.setHireDate(createRequest.getHireDate());
        employee.setStatus(createRequest.getStatus());
        employee.setEmploymentType(createRequest.getEmploymentType());
        employee.setPayType(createRequest.getPayType());
        employee.setSalary(createRequest.getSalary());
        employee.setHourlyRate(createRequest.getHourlyRate());
        employee.setBankAccount(createRequest.getBankAccount());
        employee.setTaxId(createRequest.getTaxId());
        employee.setEnabled(createRequest.getEnabled());

        Employee savedEmployee = employeeRepository.save(employee);
        log.info("Employee created successfully with ID: {}", savedEmployee.getId());

        return convertToDto(savedEmployee);
    }

    @Override
    @Transactional
    public EmployeeDto updateEmployee(Long id, EmployeeUpdateRequest updateRequest) {
        log.info("Updating employee with ID: {}", id);

        Employee existingEmployee = employeeRepository.findById(id)
                .orElseThrow(() -> new EmployeeNotFoundException(id));

        // Check email uniqueness (excluding current employee)
        employeeRepository.findByEmail(updateRequest.getEmail())
                .ifPresent(employee -> {
                    if (!employee.getId().equals(id)) {
                        throw EmployeeAlreadyExistsException.byEmail(updateRequest.getEmail());
                    }
                });

        // Validate department exists
        if (!departmentRepository.existsById(updateRequest.getDepartmentId())) {
            throw new RuntimeException("Department not found with id: " + updateRequest.getDepartmentId());
        }

        // Update fields
        existingEmployee.setFirstName(updateRequest.getFirstName());
        existingEmployee.setLastName(updateRequest.getLastName());
        existingEmployee.setEmail(updateRequest.getEmail());
        existingEmployee.setPhone(updateRequest.getPhone());
        existingEmployee.setMobilePhone(updateRequest.getMobilePhone());
        existingEmployee.setAddress(updateRequest.getAddress());
        existingEmployee.setCity(updateRequest.getCity());
        existingEmployee.setState(updateRequest.getState());
        existingEmployee.setZipCode(updateRequest.getZipCode());
        existingEmployee.setCountry(updateRequest.getCountry());
        existingEmployee.setDateOfBirth(updateRequest.getDateOfBirth());
        existingEmployee.setGender(updateRequest.getGender());
        existingEmployee.setMaritalStatus(updateRequest.getMaritalStatus());
        existingEmployee.setNationality(updateRequest.getNationality());
        existingEmployee.setDepartmentId(updateRequest.getDepartmentId());
        existingEmployee.setPositionId(updateRequest.getPositionId());
        existingEmployee.setManagerId(updateRequest.getManagerId());
        existingEmployee.setHireDate(updateRequest.getHireDate());
        existingEmployee.setTerminationDate(updateRequest.getTerminationDate());
        existingEmployee.setStatus(updateRequest.getStatus());
        existingEmployee.setEmploymentType(updateRequest.getEmploymentType());
        existingEmployee.setPayType(updateRequest.getPayType());
        existingEmployee.setSalary(updateRequest.getSalary());
        existingEmployee.setHourlyRate(updateRequest.getHourlyRate());
        existingEmployee.setBankAccount(updateRequest.getBankAccount());
        existingEmployee.setTaxId(updateRequest.getTaxId());
        existingEmployee.setEnabled(updateRequest.getEnabled());

        Employee updatedEmployee = employeeRepository.save(existingEmployee);
        log.info("Employee updated successfully with ID: {}", updatedEmployee.getId());

        return convertToDto(updatedEmployee);
    }

    @Override
    @Transactional(readOnly = true)
    public EmployeeDto getEmployeeById(Long id) {
        Employee employee = employeeRepository.findById(id)
                .orElseThrow(() -> new EmployeeNotFoundException(id));
        return convertToDto(employee);
    }

    @Override
    @Transactional(readOnly = true)
    public EmployeeDto getEmployeeByEmployeeNumber(String employeeNumber) {
        Employee employee = employeeRepository.findByEmployeeNumber(employeeNumber)
                .orElseThrow(() -> EmployeeNotFoundException.byEmployeeNumber(employeeNumber));
        return convertToDto(employee);
    }

    @Override
    @Transactional(readOnly = true)
    public Page<EmployeeDto> getAllEmployees(Pageable pageable) {
        return employeeRepository.findAll(pageable).map(this::convertToDto);
    }

    @Override
    @Transactional(readOnly = true)
    public Page<EmployeeDto> getEmployeesByDepartmentId(Long departmentId, Pageable pageable) {
        return employeeRepository.findByDepartmentId(departmentId, pageable).map(this::convertToDto);
    }

    @Override
    @Transactional(readOnly = true)
    public List<EmployeeDto> getEmployeesByDepartmentId(Long departmentId) {
        List<Employee> employees = employeeRepository.findByDepartmentId(departmentId);
        return employees.stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
    }

    @Override
    @Transactional(readOnly = true)
    public Page<EmployeeDto> getEmployeesByStatus(EmployeeStatus status, Pageable pageable) {
        return employeeRepository.findByStatus(status, pageable).map(this::convertToDto);
    }

    @Override
    @Transactional(readOnly = true)
    public Page<EmployeeDto> searchEmployees(String searchTerm, Pageable pageable) {
        return employeeRepository.searchEmployees(searchTerm, pageable).map(this::convertToDto);
    }

    @Override
    @Transactional(readOnly = true)
    public Page<EmployeeDto> searchEmployees(EmployeeSearchCriteria criteria, Pageable pageable) {
        log.info("Searching employees with advanced criteria");

        // If no criteria specified, return all employees
        if (criteria == null || !criteria.hasAnyCriteria()) {
            return employeeRepository.findAll(pageable).map(this::convertToDto);
        }

        // If only basic search term is provided, use simple search
        if (criteria.hasSearchTerm() && !hasAdvancedCriteria(criteria)) {
            return searchEmployees(criteria.getSearchTerm(), pageable);
        }

        // Use advanced search with criteria
        return searchWithCriteria(criteria, pageable);
    }

    private boolean hasAdvancedCriteria(EmployeeSearchCriteria criteria) {
        return criteria.getDepartmentIds() != null && !criteria.getDepartmentIds().isEmpty() ||
                criteria.getPositionIds() != null && !criteria.getPositionIds().isEmpty() ||
                criteria.getManagerIds() != null && !criteria.getManagerIds().isEmpty() ||
                criteria.getStatuses() != null && !criteria.getStatuses().isEmpty() ||
                criteria.getEmploymentTypes() != null && !criteria.getEmploymentTypes().isEmpty() ||
                criteria.getPayTypes() != null && !criteria.getPayTypes().isEmpty() ||
                criteria.getHireDateFrom() != null || criteria.getHireDateTo() != null ||
                criteria.getTerminationDateFrom() != null || criteria.getTerminationDateTo() != null ||
                criteria.getSalaryFrom() != null || criteria.getSalaryTo() != null ||
                criteria.getHourlyRateFrom() != null || criteria.getHourlyRateTo() != null ||
                criteria.getEnabled() != null || criteria.getHasManager() != null ||
                criteria.getHasDirectReports() != null;
    }

    private Page<EmployeeDto> searchWithCriteria(EmployeeSearchCriteria criteria, Pageable pageable) {
        // For now, implement basic filtering. In a real application, you would use
        // JPA Criteria API or custom repository methods for complex queries

        Page<Employee> employees = employeeRepository.findAll(pageable);

        // Apply basic filters that can be handled by existing repository methods
        if (criteria.getDepartmentIds() != null && criteria.getDepartmentIds().size() == 1) {
            employees = employeeRepository.findByDepartmentId(criteria.getDepartmentIds().get(0), pageable);
        } else if (criteria.getStatuses() != null && criteria.getStatuses().size() == 1) {
            employees = employeeRepository.findByStatus(criteria.getStatuses().get(0), pageable);
        } else if (criteria.getHireDateFrom() != null && criteria.getHireDateTo() != null) {
            employees = employeeRepository.findByHireDateBetween(criteria.getHireDateFrom(), criteria.getHireDateTo(),
                    pageable);
        } else if (criteria.hasSearchTerm()) {
            // Use the existing search method for basic text search
            return searchEmployees(criteria.getSearchTerm(), pageable);
        }

        return employees.map(this::convertToDto);
    }

    @Override
    @Transactional
    public void deleteEmployee(Long id) {
        if (!employeeRepository.existsById(id)) {
            throw new EmployeeNotFoundException(id);
        }
        employeeRepository.deleteById(id);
        log.info("Employee deleted successfully with ID: {}", id);
    }

    @Override
    @Transactional(readOnly = true)
    public boolean existsByEmployeeNumber(String employeeNumber) {
        return employeeRepository.existsByEmployeeNumber(employeeNumber);
    }

    @Override
    @Transactional(readOnly = true)
    public boolean existsByEmail(String email) {
        return employeeRepository.existsByEmail(email);
    }

    @Override
    @Transactional(readOnly = true)
    public long countEmployeesByDepartmentId(Long departmentId) {
        return employeeRepository.countByDepartmentId(departmentId);
    }

    private String generateEmployeeNumber() {
        String prefix = "EMP";
        String suffix;
        String employeeNumber;

        do {
            suffix = UUID.randomUUID().toString().substring(0, 8).toUpperCase();
            employeeNumber = prefix + "-" + suffix;
        } while (employeeRepository.existsByEmployeeNumber(employeeNumber));

        return employeeNumber;
    }

    private EmployeeDto convertToDto(Employee employee) {
        EmployeeDto dto = EmployeeDto.builder()
                .id(employee.getId())
                .employeeNumber(employee.getEmployeeNumber())
                .firstName(employee.getFirstName())
                .lastName(employee.getLastName())
                .email(employee.getEmail())
                .phone(employee.getPhone())
                .mobilePhone(employee.getMobilePhone())
                .address(employee.getAddress())
                .city(employee.getCity())
                .state(employee.getState())
                .zipCode(employee.getZipCode())
                .country(employee.getCountry())
                .dateOfBirth(employee.getDateOfBirth()) // Already decrypted by converter
                .gender(employee.getGender())
                .maritalStatus(employee.getMaritalStatus())
                .nationality(employee.getNationality())
                .departmentId(employee.getDepartmentId())
                .positionId(employee.getPositionId())
                .managerId(employee.getManagerId())
                .hireDate(employee.getHireDate())
                .terminationDate(employee.getTerminationDate())
                .status(employee.getStatus())
                .employmentType(employee.getEmploymentType())
                .payType(employee.getPayType())
                .salary(employee.getSalary())
                .hourlyRate(employee.getHourlyRate())
                .enabled(employee.isEnabled())
                .createdAt(employee.getCreatedAt())
                .updatedAt(employee.getUpdatedAt())
                .fullName(employee.getFullName())
                .build();

        // Mask sensitive data
        if (employee.getBankAccount() != null && employee.getBankAccount().length() > 4) {
            dto.setBankAccount("****" + employee.getBankAccount().substring(employee.getBankAccount().length() - 4));
        }
        if (employee.getTaxId() != null && employee.getTaxId().length() > 4) {
            dto.setTaxId("****" + employee.getTaxId().substring(employee.getTaxId().length() - 4));
        }

        // Set department name if available
        if (employee.getDepartment() != null) {
            dto.setDepartmentName(employee.getDepartment().getName());
        }

        // Set manager name if available
        if (employee.getManager() != null) {
            dto.setManagerName(employee.getManager().getFullName());
        }

        return dto;
    }
}
</file>

<file path="src/main/java/com/example/demo/employee/util/EmployeeExcelUtil.java">
package com.example.demo.employee.util;

import com.example.demo.employee.dto.EmployeeDto;
import com.example.demo.employee.dto.EmployeeImportResult;
import com.example.demo.employee.entity.EmployeeStatus;
import com.example.demo.employee.entity.EmploymentType;
import com.example.demo.employee.entity.Gender;
import com.example.demo.employee.entity.MaritalStatus;
import com.example.demo.employee.entity.PayType;
import com.example.demo.employee.exception.EmployeeImportException;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.ss.util.CellRangeAddressList;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.*;

/**
 * Utility class for Excel operations related to employee data
 */
public class EmployeeExcelUtil {
    
    // Excel column headers
    public static final String[] IMPORT_HEADERS = {
        "Employee Number", "First Name", "Last Name", "Email", "Phone", 
        "Mobile Phone", "Address", "City", "State", "Zip Code", "Country",
        "Date of Birth", "Gender", "Marital Status", "Nationality",
        "Department ID", "Position ID", "Manager ID", "Hire Date",
        "Status", "Employment Type", "Pay Type", "Salary", "Hourly Rate",
        "Bank Account", "Tax ID"
    };
    
    public static final String[] EXPORT_HEADERS = {
        "Employee Number", "First Name", "Last Name", "Full Name", "Email", 
        "Phone", "Mobile Phone", "Address", "City", "State", "Zip Code", "Country",
        "Date of Birth", "Gender", "Marital Status", "Nationality",
        "Department", "Position", "Manager", "Hire Date", "Termination Date",
        "Status", "Employment Type", "Pay Type", "Salary", "Hourly Rate",
        "Enabled", "Created At", "Updated At"
    };
    
    // Field mapping for import
    private static final Map<String, String> FIELD_MAPPING = new HashMap<>();
    static {
        FIELD_MAPPING.put("Employee Number", "employeeNumber");
        FIELD_MAPPING.put("First Name", "firstName");
        FIELD_MAPPING.put("Last Name", "lastName");
        FIELD_MAPPING.put("Email", "email");
        FIELD_MAPPING.put("Phone", "phone");
        FIELD_MAPPING.put("Mobile Phone", "mobilePhone");
        FIELD_MAPPING.put("Address", "address");
        FIELD_MAPPING.put("City", "city");
        FIELD_MAPPING.put("State", "state");
        FIELD_MAPPING.put("Zip Code", "zipCode");
        FIELD_MAPPING.put("Country", "country");
        FIELD_MAPPING.put("Date of Birth", "dateOfBirth");
        FIELD_MAPPING.put("Gender", "gender");
        FIELD_MAPPING.put("Marital Status", "maritalStatus");
        FIELD_MAPPING.put("Nationality", "nationality");
        FIELD_MAPPING.put("Department ID", "departmentId");
        FIELD_MAPPING.put("Position ID", "positionId");
        FIELD_MAPPING.put("Manager ID", "managerId");
        FIELD_MAPPING.put("Hire Date", "hireDate");
        FIELD_MAPPING.put("Status", "status");
        FIELD_MAPPING.put("Employment Type", "employmentType");
        FIELD_MAPPING.put("Pay Type", "payType");
        FIELD_MAPPING.put("Salary", "salary");
        FIELD_MAPPING.put("Hourly Rate", "hourlyRate");
        FIELD_MAPPING.put("Bank Account", "bankAccount");
        FIELD_MAPPING.put("Tax ID", "taxId");
    }
    
    // Date formatters
    private static final DateTimeFormatter[] DATE_FORMATTERS = {
        DateTimeFormatter.ofPattern("yyyy-MM-dd"),
        DateTimeFormatter.ofPattern("MM/dd/yyyy"),
        DateTimeFormatter.ofPattern("dd/MM/yyyy"),
        DateTimeFormatter.ofPattern("yyyy/MM/dd"),
        DateTimeFormatter.ofPattern("dd-MM-yyyy"),
        DateTimeFormatter.ofPattern("MM-dd-yyyy")
    }; 
   /**
     * Create Excel template for employee import
     */
    public static byte[] createImportTemplate(boolean includeExamples) {
        try (XSSFWorkbook workbook = new XSSFWorkbook()) {
            Sheet sheet = workbook.createSheet("Employee Import Template");
            
            // Create header row
            Row headerRow = sheet.createRow(0);
            CellStyle headerStyle = createHeaderStyle(workbook);
            
            for (int i = 0; i < IMPORT_HEADERS.length; i++) {
                Cell cell = headerRow.createCell(i);
                cell.setCellValue(IMPORT_HEADERS[i]);
                cell.setCellStyle(headerStyle);
                sheet.autoSizeColumn(i);
            }
            
            // Add example data if requested
            if (includeExamples) {
                addExampleData(sheet, workbook);
            }
            
            // Add data validation
            addDataValidation(sheet);
            
            // Auto-size columns
            for (int i = 0; i < IMPORT_HEADERS.length; i++) {
                sheet.autoSizeColumn(i);
            }
            
            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
            workbook.write(outputStream);
            return outputStream.toByteArray();
            
        } catch (IOException e) {
            throw new EmployeeImportException("Failed to create import template", e);
        }
    }
    
    /**
     * Export employees to Excel
     */
    public static byte[] exportToExcel(List<EmployeeDto> employees, Set<String> includeFields) {
        try (XSSFWorkbook workbook = new XSSFWorkbook()) {
            Sheet sheet = workbook.createSheet("Employee Export");
            
            // Determine which headers to include
            List<String> headers = getExportHeaders(includeFields);
            
            // Create header row
            Row headerRow = sheet.createRow(0);
            CellStyle headerStyle = createHeaderStyle(workbook);
            
            for (int i = 0; i < headers.size(); i++) {
                Cell cell = headerRow.createCell(i);
                cell.setCellValue(headers.get(i));
                cell.setCellStyle(headerStyle);
            }
            
            // Create data rows
            CellStyle dateStyle = createDateStyle(workbook);
            CellStyle currencyStyle = createCurrencyStyle(workbook);
            
            for (int i = 0; i < employees.size(); i++) {
                Row row = sheet.createRow(i + 1);
                EmployeeDto employee = employees.get(i);
                
                for (int j = 0; j < headers.size(); j++) {
                    Cell cell = row.createCell(j);
                    setEmployeeCellValue(cell, employee, headers.get(j), dateStyle, currencyStyle);
                }
            }
            
            // Auto-size columns
            for (int i = 0; i < headers.size(); i++) {
                sheet.autoSizeColumn(i);
            }
            
            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
            workbook.write(outputStream);
            return outputStream.toByteArray();
            
        } catch (IOException e) {
            throw new EmployeeImportException("Failed to export employees to Excel", e);
        }
    } 
   /**
     * Parse Excel file and extract employee data
     */
    public static EmployeeImportResult parseExcelFile(InputStream inputStream, String fileName) {
        EmployeeImportResult result = EmployeeImportResult.builder()
                .build();
        
        try (Workbook workbook = WorkbookFactory.create(inputStream)) {
            Sheet sheet = workbook.getSheetAt(0);
            
            // Validate headers
            Row headerRow = sheet.getRow(0);
            if (headerRow == null) {
                result.addError(1, "Header", "", "Header row is missing");
                return result;
            }
            
            Map<String, Integer> headerMap = validateAndMapHeaders(headerRow, result);
            if (!result.getErrors().isEmpty()) {
                return result;
            }
            
            // Process data rows
            int totalRows = sheet.getLastRowNum();
            result.setTotalRecords(totalRows);
            for (int i = 1; i <= totalRows; i++) {
                Row row = sheet.getRow(i);
                if (row == null || isEmptyRow(row)) {
                    result.setSkippedRecords(result.getSkippedRecords() + 1);
                    continue;
                }
                
                final int currentRowNumber = i + 1;
                try {
                    Map<String, Object> employeeData = parseEmployeeRow(row, headerMap, currentRowNumber, result);
                    if (employeeData != null && result.getErrors().stream()
                            .noneMatch(error -> error.getRowNumber() == currentRowNumber)) {
                        // Convert to EmployeeDto and add to result
                        // This would be handled by the service layer
                        result.setSuccessfulImports(result.getSuccessfulImports() + 1);
                    } else {
                        result.setFailedImports(result.getFailedImports() + 1);
                    }
                } catch (Exception e) {
                    result.addError(currentRowNumber, "Row", "", "Error processing row: " + e.getMessage());
                    result.setFailedImports(result.getFailedImports() + 1);
                }
            }
            
        } catch (IOException e) {
            throw new EmployeeImportException("Failed to parse Excel file: " + fileName, e);
        }
        
        result.generateSummary();
        return result;
    }
    
    /**
     * Validate and map Excel headers
     */
    private static Map<String, Integer> validateAndMapHeaders(Row headerRow, EmployeeImportResult result) {
        Map<String, Integer> headerMap = new HashMap<>();
        Set<String> requiredHeaders = Set.of("First Name", "Last Name", "Email", "Department ID", 
                                           "Position ID", "Hire Date", "Status");
        Set<String> foundHeaders = new HashSet<>();
        
        for (int i = 0; i < headerRow.getLastCellNum(); i++) {
            Cell cell = headerRow.getCell(i);
            if (cell != null) {
                String headerValue = getCellValueAsString(cell).trim();
                if (FIELD_MAPPING.containsKey(headerValue)) {
                    headerMap.put(headerValue, i);
                    foundHeaders.add(headerValue);
                }
            }
        }
        
        // Check for missing required headers
        for (String requiredHeader : requiredHeaders) {
            if (!foundHeaders.contains(requiredHeader)) {
                result.addError(1, "Header", requiredHeader, "Required header is missing");
            }
        }
        
        return headerMap;
    }  
  /**
     * Parse employee data from Excel row
     */
    private static Map<String, Object> parseEmployeeRow(Row row, Map<String, Integer> headerMap, 
                                                       int rowNumber, EmployeeImportResult result) {
        Map<String, Object> employeeData = new HashMap<>();
        
        for (Map.Entry<String, Integer> entry : headerMap.entrySet()) {
            String header = entry.getKey();
            int columnIndex = entry.getValue();
            Cell cell = row.getCell(columnIndex);
            
            try {
                Object value = parseCellValue(cell, header, rowNumber, result);
                if (value != null) {
                    employeeData.put(FIELD_MAPPING.get(header), value);
                }
            } catch (Exception e) {
                result.addError(rowNumber, header, getCellValueAsString(cell), 
                              "Error parsing value: " + e.getMessage());
            }
        }
        
        return employeeData;
    }
    
    /**
     * Parse cell value based on field type
     */
    private static Object parseCellValue(Cell cell, String header, int rowNumber, EmployeeImportResult result) {
        if (cell == null) {
            return null;
        }
        
        String cellValue = getCellValueAsString(cell).trim();
        if (cellValue.isEmpty()) {
            return null;
        }
        
        try {
            switch (header) {
                case "Department ID":
                case "Position ID":
                case "Manager ID":
                    return parseLongValue(cellValue);
                    
                case "Hire Date":
                case "Date of Birth":
                    return parseDate(cellValue);
                    
                case "Salary":
                case "Hourly Rate":
                    return parseBigDecimal(cellValue);
                    
                case "Status":
                    return parseEmployeeStatus(cellValue);
                    
                case "Employment Type":
                    return parseEmploymentType(cellValue);
                    
                case "Pay Type":
                    return parsePayType(cellValue);
                    
                case "Gender":
                    return parseGender(cellValue);
                    
                case "Marital Status":
                    return parseMaritalStatus(cellValue);
                    
                default:
                    return cellValue;
            }
        } catch (Exception e) {
            result.addError(rowNumber, header, cellValue, "Invalid value format: " + e.getMessage());
            return null;
        }
    }
    
    /**
     * Get cell value as string
     */
    private static String getCellValueAsString(Cell cell) {
        if (cell == null) {
            return "";
        }
        
        switch (cell.getCellType()) {
            case STRING:
                return cell.getStringCellValue();
            case NUMERIC:
                if (DateUtil.isCellDateFormatted(cell)) {
                    return cell.getLocalDateTimeCellValue().toLocalDate().toString();
                } else {
                    double numericValue = cell.getNumericCellValue();
                    if (numericValue == Math.floor(numericValue)) {
                        return String.valueOf((long) numericValue);
                    } else {
                        return String.valueOf(numericValue);
                    }
                }
            case BOOLEAN:
                return String.valueOf(cell.getBooleanCellValue());
            case FORMULA:
                return cell.getCellFormula();
            default:
                return "";
        }
    }    
/**
     * Parse date from string with multiple format support
     */
    private static LocalDate parseDate(String dateString) {
        for (DateTimeFormatter formatter : DATE_FORMATTERS) {
            try {
                return LocalDate.parse(dateString, formatter);
            } catch (DateTimeParseException ignored) {
                // Try next formatter
            }
        }
        throw new IllegalArgumentException("Unable to parse date: " + dateString);
    }
    
    /**
     * Parse Long value
     */
    private static Long parseLongValue(String value) {
        try {
            return Long.valueOf(value);
        } catch (NumberFormatException e) {
            throw new IllegalArgumentException("Invalid number format: " + value);
        }
    }
    
    /**
     * Parse BigDecimal value
     */
    private static BigDecimal parseBigDecimal(String value) {
        try {
            // Remove currency symbols and commas
            String cleanValue = value.replaceAll("[,$]", "");
            return new BigDecimal(cleanValue);
        } catch (NumberFormatException e) {
            throw new IllegalArgumentException("Invalid decimal format: " + value);
        }
    }
    
    /**
     * Parse EmployeeStatus enum
     */
    private static EmployeeStatus parseEmployeeStatus(String value) {
        try {
            return EmployeeStatus.valueOf(value.toUpperCase().replace(" ", "_"));
        } catch (IllegalArgumentException e) {
            throw new IllegalArgumentException("Invalid employee status: " + value);
        }
    }
    
    /**
     * Parse EmploymentType enum
     */
    private static EmploymentType parseEmploymentType(String value) {
        try {
            return EmploymentType.valueOf(value.toUpperCase().replace(" ", "_"));
        } catch (IllegalArgumentException e) {
            throw new IllegalArgumentException("Invalid employment type: " + value);
        }
    }
    
    /**
     * Parse PayType enum
     */
    private static PayType parsePayType(String value) {
        try {
            return PayType.valueOf(value.toUpperCase());
        } catch (IllegalArgumentException e) {
            throw new IllegalArgumentException("Invalid pay type: " + value);
        }
    }
    
    /**
     * Parse Gender enum
     */
    private static Gender parseGender(String value) {
        try {
            return Gender.valueOf(value.toUpperCase());
        } catch (IllegalArgumentException e) {
            throw new IllegalArgumentException("Invalid gender: " + value);
        }
    }
    
    /**
     * Parse MaritalStatus enum
     */
    private static MaritalStatus parseMaritalStatus(String value) {
        try {
            return MaritalStatus.valueOf(value.toUpperCase().replace(" ", "_"));
        } catch (IllegalArgumentException e) {
            throw new IllegalArgumentException("Invalid marital status: " + value);
        }
    }  
  /**
     * Check if row is empty
     */
    private static boolean isEmptyRow(Row row) {
        for (int i = 0; i < row.getLastCellNum(); i++) {
            Cell cell = row.getCell(i);
            if (cell != null && !getCellValueAsString(cell).trim().isEmpty()) {
                return false;
            }
        }
        return true;
    }
    
    /**
     * Create header cell style
     */
    private static CellStyle createHeaderStyle(Workbook workbook) {
        CellStyle style = workbook.createCellStyle();
        Font font = workbook.createFont();
        font.setBold(true);
        font.setColor(IndexedColors.WHITE.getIndex());
        style.setFont(font);
        style.setFillForegroundColor(IndexedColors.DARK_BLUE.getIndex());
        style.setFillPattern(FillPatternType.SOLID_FOREGROUND);
        style.setBorderBottom(BorderStyle.THIN);
        style.setBorderTop(BorderStyle.THIN);
        style.setBorderRight(BorderStyle.THIN);
        style.setBorderLeft(BorderStyle.THIN);
        return style;
    }
    
    /**
     * Create date cell style
     */
    private static CellStyle createDateStyle(Workbook workbook) {
        CellStyle style = workbook.createCellStyle();
        style.setDataFormat(workbook.getCreationHelper().createDataFormat().getFormat("yyyy-mm-dd"));
        return style;
    }
    
    /**
     * Create currency cell style
     */
    private static CellStyle createCurrencyStyle(Workbook workbook) {
        CellStyle style = workbook.createCellStyle();
        style.setDataFormat(workbook.getCreationHelper().createDataFormat().getFormat("$#,##0.00"));
        return style;
    }
    
    /**
     * Add example data to template
     */
    private static void addExampleData(Sheet sheet, Workbook workbook) {
        Row exampleRow = sheet.createRow(1);
        
        // Add example employee data
        String[] exampleData = {
            "EMP-001", "John", "Doe", "john.doe@company.com", "555-1234",
            "555-5678", "123 Main St", "New York", "NY", "10001", "USA",
            "1990-01-15", "MALE", "SINGLE", "American",
            "1", "1", "", "2023-01-15",
            "ACTIVE", "FULL_TIME", "SALARY", "75000", "",
            "", ""
        };
        
        for (int i = 0; i < exampleData.length && i < IMPORT_HEADERS.length; i++) {
            Cell cell = exampleRow.createCell(i);
            cell.setCellValue(exampleData[i]);
        }
    }
    
    /**
     * Add data validation to template
     */
    private static void addDataValidation(Sheet sheet) {
        DataValidationHelper validationHelper = sheet.getDataValidationHelper();
        
        // Add validation for Status column
        int statusColumnIndex = Arrays.asList(IMPORT_HEADERS).indexOf("Status");
        if (statusColumnIndex >= 0) {
            String[] statusValues = Arrays.stream(EmployeeStatus.values())
                    .map(Enum::name)
                    .toArray(String[]::new);
            addDropdownValidation(sheet, validationHelper, statusColumnIndex, statusValues);
        }
        
        // Add validation for Gender column
        int genderColumnIndex = Arrays.asList(IMPORT_HEADERS).indexOf("Gender");
        if (genderColumnIndex >= 0) {
            String[] genderValues = Arrays.stream(Gender.values())
                    .map(Enum::name)
                    .toArray(String[]::new);
            addDropdownValidation(sheet, validationHelper, genderColumnIndex, genderValues);
        }
        
        // Add validation for Employment Type column
        int employmentTypeColumnIndex = Arrays.asList(IMPORT_HEADERS).indexOf("Employment Type");
        if (employmentTypeColumnIndex >= 0) {
            String[] employmentTypeValues = Arrays.stream(EmploymentType.values())
                    .map(Enum::name)
                    .toArray(String[]::new);
            addDropdownValidation(sheet, validationHelper, employmentTypeColumnIndex, employmentTypeValues);
        }
        
        // Add validation for Pay Type column
        int payTypeColumnIndex = Arrays.asList(IMPORT_HEADERS).indexOf("Pay Type");
        if (payTypeColumnIndex >= 0) {
            String[] payTypeValues = Arrays.stream(PayType.values())
                    .map(Enum::name)
                    .toArray(String[]::new);
            addDropdownValidation(sheet, validationHelper, payTypeColumnIndex, payTypeValues);
        }
    }  
  /**
     * Add dropdown validation to column
     */
    private static void addDropdownValidation(Sheet sheet, DataValidationHelper validationHelper, 
                                            int columnIndex, String[] values) {
        DataValidationConstraint constraint = validationHelper.createExplicitListConstraint(values);
        CellRangeAddressList addressList = new CellRangeAddressList(1, 1000, columnIndex, columnIndex);
        DataValidation validation = validationHelper.createValidation(constraint, addressList);
        validation.setSuppressDropDownArrow(true);
        validation.setShowErrorBox(true);
        sheet.addValidationData(validation);
    }
    
    /**
     * Get export headers based on included fields
     */
    private static List<String> getExportHeaders(Set<String> includeFields) {
        if (includeFields == null || includeFields.isEmpty()) {
            return Arrays.asList(EXPORT_HEADERS);
        }
        
        List<String> headers = new ArrayList<>();
        for (String header : EXPORT_HEADERS) {
            String fieldName = getFieldNameFromHeader(header);
            if (includeFields.contains(fieldName)) {
                headers.add(header);
            }
        }
        return headers;
    }
    
    /**
     * Get field name from export header
     */
    private static String getFieldNameFromHeader(String header) {
        switch (header) {
            case "Employee Number": return "employeeNumber";
            case "First Name": return "firstName";
            case "Last Name": return "lastName";
            case "Full Name": return "fullName";
            case "Email": return "email";
            case "Phone": return "phone";
            case "Mobile Phone": return "mobilePhone";
            case "Address": return "address";
            case "City": return "city";
            case "State": return "state";
            case "Zip Code": return "zipCode";
            case "Country": return "country";
            case "Date of Birth": return "dateOfBirth";
            case "Gender": return "gender";
            case "Marital Status": return "maritalStatus";
            case "Nationality": return "nationality";
            case "Department": return "departmentName";
            case "Position": return "positionName";
            case "Manager": return "managerName";
            case "Hire Date": return "hireDate";
            case "Termination Date": return "terminationDate";
            case "Status": return "status";
            case "Employment Type": return "employmentType";
            case "Pay Type": return "payType";
            case "Salary": return "salary";
            case "Hourly Rate": return "hourlyRate";
            case "Enabled": return "enabled";
            case "Created At": return "createdAt";
            case "Updated At": return "updatedAt";
            default: return header.toLowerCase().replace(" ", "");
        }
    }
    
    /**
     * Set cell value for employee export
     */
    private static void setEmployeeCellValue(Cell cell, EmployeeDto employee, String header, 
                                           CellStyle dateStyle, CellStyle currencyStyle) {
        switch (header) {
            case "Employee Number":
                cell.setCellValue(employee.getEmployeeNumber());
                break;
            case "First Name":
                cell.setCellValue(employee.getFirstName());
                break;
            case "Last Name":
                cell.setCellValue(employee.getLastName());
                break;
            case "Full Name":
                cell.setCellValue(employee.getFullName());
                break;
            case "Email":
                cell.setCellValue(employee.getEmail());
                break;
            case "Phone":
                cell.setCellValue(employee.getPhone());
                break;
            case "Mobile Phone":
                cell.setCellValue(employee.getMobilePhone());
                break;
            case "Address":
                cell.setCellValue(employee.getAddress());
                break;
            case "City":
                cell.setCellValue(employee.getCity());
                break;
            case "State":
                cell.setCellValue(employee.getState());
                break;
            case "Zip Code":
                cell.setCellValue(employee.getZipCode());
                break;
            case "Country":
                cell.setCellValue(employee.getCountry());
                break;
            case "Date of Birth":
                cell.setCellValue(employee.getDateOfBirth());
                break;
            case "Gender":
                if (employee.getGender() != null) {
                    cell.setCellValue(employee.getGender().name());
                }
                break;
            case "Marital Status":
                if (employee.getMaritalStatus() != null) {
                    cell.setCellValue(employee.getMaritalStatus().name());
                }
                break;
            case "Nationality":
                cell.setCellValue(employee.getNationality());
                break;
            case "Department":
                cell.setCellValue(employee.getDepartmentName());
                break;
            case "Position":
                cell.setCellValue(employee.getPositionName());
                break;
            case "Manager":
                cell.setCellValue(employee.getManagerName());
                break;
            case "Hire Date":
                if (employee.getHireDate() != null) {
                    cell.setCellValue(employee.getHireDate().toString());
                    cell.setCellStyle(dateStyle);
                }
                break;
            case "Termination Date":
                if (employee.getTerminationDate() != null) {
                    cell.setCellValue(employee.getTerminationDate().toString());
                    cell.setCellStyle(dateStyle);
                }
                break;
            case "Status":
                if (employee.getStatus() != null) {
                    cell.setCellValue(employee.getStatus().name());
                }
                break;
            case "Employment Type":
                if (employee.getEmploymentType() != null) {
                    cell.setCellValue(employee.getEmploymentType().name());
                }
                break;
            case "Pay Type":
                if (employee.getPayType() != null) {
                    cell.setCellValue(employee.getPayType().name());
                }
                break;
            case "Salary":
                if (employee.getSalary() != null) {
                    cell.setCellValue(employee.getSalary().doubleValue());
                    cell.setCellStyle(currencyStyle);
                }
                break;
            case "Hourly Rate":
                if (employee.getHourlyRate() != null) {
                    cell.setCellValue(employee.getHourlyRate().doubleValue());
                    cell.setCellStyle(currencyStyle);
                }
                break;
            case "Enabled":
                cell.setCellValue(employee.isEnabled());
                break;
            case "Created At":
                if (employee.getCreatedAt() != null) {
                    cell.setCellValue(employee.getCreatedAt().toString());
                }
                break;
            case "Updated At":
                if (employee.getUpdatedAt() != null) {
                    cell.setCellValue(employee.getUpdatedAt().toString());
                }
                break;
            default:
                cell.setCellValue("");
        }
    }
    
    /**
     * Get field mapping for import
     */
    public static Map<String, String> getFieldMapping() {
        return new HashMap<>(FIELD_MAPPING);
    }
    
    /**
     * Get required fields for import
     */
    public static List<String> getRequiredFields() {
        return Arrays.asList("First Name", "Last Name", "Email", "Department ID", 
                           "Position ID", "Hire Date", "Status");
    }
    
    /**
     * Get optional fields for import
     */
    public static List<String> getOptionalFields() {
        List<String> allFields = Arrays.asList(IMPORT_HEADERS);
        List<String> requiredFields = getRequiredFields();
        return allFields.stream()
                .filter(field -> !requiredFields.contains(field))
                .collect(ArrayList::new, ArrayList::add, ArrayList::addAll);
    }
}
</file>

<file path="src/main/java/com/example/demo/payroll/controller/PayrollController.java">
package com.example.demo.payroll.controller;

import com.example.demo.common.dto.ApiResponse;
import com.example.demo.common.dto.PageResponse;
import com.example.demo.payroll.dto.*;
import com.example.demo.payroll.entity.PayrollLedgerStatus;
import com.example.demo.payroll.service.PayrollService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDate;
import java.util.List;

/**
 * REST Controller for Payroll Management
 * Provides endpoints for payroll ledgers, periods, salary components, and reporting
 */
@RestController
@RequestMapping("/api/payroll")
@RequiredArgsConstructor
@Slf4j
@Tag(name = "Payroll Management", description = "APIs for managing payroll operations")
@SecurityRequirement(name = "bearerAuth")
public class PayrollController {

    private final PayrollService payrollService;

    // ===== PAYROLL LEDGER ENDPOINTS =====

    @Operation(summary = "Get all payroll ledgers with pagination and filtering")
    @GetMapping("/ledgers")
    @PreAuthorize("hasAuthority('PAYROLL_READ')")
    public ResponseEntity<ApiResponse<PageResponse<PayrollLedgerDto>>> getPayrollLedgers(
            @PageableDefault(size = 20) Pageable pageable,
            @RequestParam(required = false) Long employeeId,
            @RequestParam(required = false) Long payrollPeriodId,
            @RequestParam(required = false) PayrollLedgerStatus status) {
        
        log.info("Fetching payroll ledgers with filters - employeeId: {}, periodId: {}, status: {}", 
                employeeId, payrollPeriodId, status);
        
        PageResponse<PayrollLedgerDto> ledgers;
        
        if (employeeId != null) {
            ledgers = payrollService.getPayrollLedgersByEmployeeWithPaging(employeeId, pageable);
        } else {
            ledgers = payrollService.getPayrollLedgers(pageable);
        }
        
        return ResponseEntity.ok(ApiResponse.success(ledgers));
    }

    @Operation(summary = "Get payroll ledger by ID")
    @GetMapping("/ledgers/{id}")
    @PreAuthorize("hasAuthority('PAYROLL_READ')")
    public ResponseEntity<ApiResponse<PayrollLedgerDto>> getPayrollLedgerById(
            @Parameter(description = "Payroll ledger ID") @PathVariable Long id) {
        
        log.info("Fetching payroll ledger with ID: {}", id);
        PayrollLedgerDto ledger = payrollService.getPayrollLedgerById(id);
        return ResponseEntity.ok(ApiResponse.success(ledger));
    }

    @Operation(summary = "Get payroll ledgers by employee")
    @GetMapping("/ledgers/employee/{employeeId}")
    @PreAuthorize("hasAuthority('PAYROLL_READ')")
    public ResponseEntity<ApiResponse<List<PayrollLedgerDto>>> getPayrollLedgersByEmployee(
            @Parameter(description = "Employee ID") @PathVariable Long employeeId) {
        
        log.info("Fetching payroll ledgers for employee: {}", employeeId);
        List<PayrollLedgerDto> ledgers = payrollService.getPayrollLedgersByEmployee(employeeId);
        return ResponseEntity.ok(ApiResponse.success(ledgers));
    }

    @Operation(summary = "Get payroll ledgers by period")
    @GetMapping("/ledgers/period/{periodId}")
    @PreAuthorize("hasAuthority('PAYROLL_READ')")
    public ResponseEntity<ApiResponse<List<PayrollLedgerDto>>> getPayrollLedgersByPeriod(
            @Parameter(description = "Payroll period ID") @PathVariable Long periodId) {
        
        log.info("Fetching payroll ledgers for period: {}", periodId);
        List<PayrollLedgerDto> ledgers = payrollService.getPayrollLedgersByPeriod(periodId);
        return ResponseEntity.ok(ApiResponse.success(ledgers));
    }

    @Operation(summary = "Get payroll ledgers by status")
    @GetMapping("/ledgers/status/{status}")
    @PreAuthorize("hasAuthority('PAYROLL_READ')")
    public ResponseEntity<ApiResponse<List<PayrollLedgerDto>>> getPayrollLedgersByStatus(
            @Parameter(description = "Payroll status") @PathVariable PayrollLedgerStatus status) {
        
        log.info("Fetching payroll ledgers with status: {}", status);
        List<PayrollLedgerDto> ledgers = payrollService.getPayrollLedgersByStatus(status);
        return ResponseEntity.ok(ApiResponse.success(ledgers));
    }

    @Operation(summary = "Create new payroll ledger")
    @PostMapping("/ledgers")
    @PreAuthorize("hasAuthority('PAYROLL_CREATE')")
    public ResponseEntity<ApiResponse<PayrollLedgerDto>> createPayrollLedger(
            @Valid @RequestBody PayrollCalculationRequest request) {
        
        log.info("Creating payroll ledger for employee: {}, period: {}", 
                request.getEmployeeId(), request.getPayrollPeriodId());
        
        PayrollLedgerDto ledger = payrollService.createPayrollLedger(request);
        return ResponseEntity.status(HttpStatus.CREATED)
                .body(ApiResponse.success(ledger, "Payroll ledger created successfully"));
    }

    @Operation(summary = "Update payroll ledger")
    @PutMapping("/ledgers/{id}")
    @PreAuthorize("hasAuthority('PAYROLL_UPDATE')")
    public ResponseEntity<ApiResponse<PayrollLedgerDto>> updatePayrollLedger(
            @Parameter(description = "Payroll ledger ID") @PathVariable Long id,
            @Valid @RequestBody PayrollLedgerDto payrollLedgerDto) {
        
        log.info("Updating payroll ledger with ID: {}", id);
        PayrollLedgerDto updatedLedger = payrollService.updatePayrollLedger(id, payrollLedgerDto);
        return ResponseEntity.ok(ApiResponse.success(updatedLedger, "Payroll ledger updated successfully"));
    }

    @Operation(summary = "Delete payroll ledger")
    @DeleteMapping("/ledgers/{id}")
    @PreAuthorize("hasAuthority('PAYROLL_DELETE')")
    public ResponseEntity<ApiResponse<Void>> deletePayrollLedger(
            @Parameter(description = "Payroll ledger ID") @PathVariable Long id) {
        
        log.info("Deleting payroll ledger with ID: {}", id);
        payrollService.deletePayrollLedger(id);
        return ResponseEntity.ok(ApiResponse.success(null, "Payroll ledger deleted successfully"));
    }

    // ===== PAYROLL CALCULATION ENDPOINTS =====

    @Operation(summary = "Calculate payroll for single employee")
    @PostMapping("/calculate")
    @PreAuthorize("hasAuthority('PAYROLL_CALCULATE')")
    public ResponseEntity<ApiResponse<PayrollLedgerDto>> calculatePayroll(
            @Valid @RequestBody PayrollCalculationRequest request) {
        
        log.info("Calculating payroll for employee: {}, period: {}", 
                request.getEmployeeId(), request.getPayrollPeriodId());
        
        PayrollLedgerDto ledger = payrollService.createPayrollLedger(request);
        return ResponseEntity.ok(ApiResponse.success(ledger, "Payroll calculated successfully"));
    }

    @Operation(summary = "Process payroll for entire period")
    @PostMapping("/periods/{periodId}/process")
    @PreAuthorize("hasAuthority('PAYROLL_PROCESS')")
    public ResponseEntity<ApiResponse<List<PayrollLedgerDto>>> processPayrollForPeriod(
            @Parameter(description = "Payroll period ID") @PathVariable Long periodId,
            @RequestBody(required = false) List<Long> employeeIds) {
        
        log.info("Processing payroll for period: {}, employees: {}", periodId, employeeIds);
        List<PayrollLedgerDto> ledgers = payrollService.processPayrollForPeriod(periodId, employeeIds);
        return ResponseEntity.ok(ApiResponse.success(ledgers, "Payroll processed successfully"));
    }

    // ===== PAYROLL APPROVAL ENDPOINTS =====

    @Operation(summary = "Approve payroll ledger")
    @PostMapping("/ledgers/{id}/approve")
    @PreAuthorize("hasAuthority('PAYROLL_APPROVE')")
    public ResponseEntity<ApiResponse<PayrollLedgerDto>> approvePayroll(
            @Parameter(description = "Payroll ledger ID") @PathVariable Long id,
            @RequestParam(required = false) String reason) {
        
        log.info("Approving payroll ledger with ID: {}, reason: {}", id, reason);
        PayrollLedgerDto ledger = payrollService.approvePayroll(id, reason);
        return ResponseEntity.ok(ApiResponse.success(ledger, "Payroll approved successfully"));
    }

    @Operation(summary = "Reject payroll ledger")
    @PostMapping("/ledgers/{id}/reject")
    @PreAuthorize("hasAuthority('PAYROLL_APPROVE')")
    public ResponseEntity<ApiResponse<PayrollLedgerDto>> rejectPayroll(
            @Parameter(description = "Payroll ledger ID") @PathVariable Long id,
            @RequestParam String reason) {
        
        log.info("Rejecting payroll ledger with ID: {}, reason: {}", id, reason);
        PayrollLedgerDto ledger = payrollService.rejectPayroll(id, reason);
        return ResponseEntity.ok(ApiResponse.success(ledger, "Payroll rejected successfully"));
    }

    @Operation(summary = "Mark payroll as paid")
    @PostMapping("/ledgers/{id}/paid")
    @PreAuthorize("hasAuthority('PAYROLL_PAY')")
    public ResponseEntity<ApiResponse<PayrollLedgerDto>> markAsPaid(
            @Parameter(description = "Payroll ledger ID") @PathVariable Long id,
            @RequestParam String paymentReference) {
        
        log.info("Marking payroll ledger as paid with ID: {}, reference: {}", id, paymentReference);
        PayrollLedgerDto ledger = payrollService.markAsPaid(id, paymentReference);
        return ResponseEntity.ok(ApiResponse.success(ledger, "Payroll marked as paid successfully"));
    }

    // ===== PAYROLL PERIOD ENDPOINTS =====

    @Operation(summary = "Get all payroll periods")
    @GetMapping("/periods")
    @PreAuthorize("hasAuthority('PAYROLL_READ')")
    public ResponseEntity<ApiResponse<PageResponse<PayrollPeriodDto>>> getPayrollPeriods(
            @PageableDefault(size = 20) Pageable pageable) {
        
        log.info("Fetching payroll periods");
        PageResponse<PayrollPeriodDto> periods = payrollService.getPayrollPeriods(pageable);
        return ResponseEntity.ok(ApiResponse.success(periods));
    }

    @Operation(summary = "Get active payroll periods")
    @GetMapping("/periods/active")
    @PreAuthorize("hasAuthority('PAYROLL_READ')")
    public ResponseEntity<ApiResponse<List<PayrollPeriodDto>>> getActivePayrollPeriods() {
        
        log.info("Fetching active payroll periods");
        List<PayrollPeriodDto> periods = payrollService.getActivePayrollPeriods();
        return ResponseEntity.ok(ApiResponse.success(periods));
    }

    @Operation(summary = "Get current payroll period")
    @GetMapping("/periods/current")
    @PreAuthorize("hasAuthority('PAYROLL_READ')")
    public ResponseEntity<ApiResponse<PayrollPeriodDto>> getCurrentPayrollPeriod() {
        
        log.info("Fetching current payroll period");
        PayrollPeriodDto period = payrollService.getCurrentPayrollPeriod();
        return ResponseEntity.ok(ApiResponse.success(period));
    }

    @Operation(summary = "Get payroll period by ID")
    @GetMapping("/periods/{id}")
    @PreAuthorize("hasAuthority('PAYROLL_READ')")
    public ResponseEntity<ApiResponse<PayrollPeriodDto>> getPayrollPeriodById(
            @Parameter(description = "Payroll period ID") @PathVariable Long id) {
        
        log.info("Fetching payroll period with ID: {}", id);
        PayrollPeriodDto period = payrollService.getPayrollPeriodById(id);
        return ResponseEntity.ok(ApiResponse.success(period));
    }

    @Operation(summary = "Create new payroll period")
    @PostMapping("/periods")
    @PreAuthorize("hasAuthority('PAYROLL_ADMIN')")
    public ResponseEntity<ApiResponse<PayrollPeriodDto>> createPayrollPeriod(
            @Valid @RequestBody PayrollPeriodDto payrollPeriodDto) {
        
        log.info("Creating payroll period: {}", payrollPeriodDto.getPeriodName());
        PayrollPeriodDto period = payrollService.createPayrollPeriod(payrollPeriodDto);
        return ResponseEntity.status(HttpStatus.CREATED)
                .body(ApiResponse.success(period, "Payroll period created successfully"));
    }

    @Operation(summary = "Update payroll period")
    @PutMapping("/periods/{id}")
    @PreAuthorize("hasAuthority('PAYROLL_ADMIN')")
    public ResponseEntity<ApiResponse<PayrollPeriodDto>> updatePayrollPeriod(
            @Parameter(description = "Payroll period ID") @PathVariable Long id,
            @Valid @RequestBody PayrollPeriodDto payrollPeriodDto) {
        
        log.info("Updating payroll period with ID: {}", id);
        PayrollPeriodDto period = payrollService.updatePayrollPeriod(id, payrollPeriodDto);
        return ResponseEntity.ok(ApiResponse.success(period, "Payroll period updated successfully"));
    }

    @Operation(summary = "Close payroll period")
    @PostMapping("/periods/{id}/close")
    @PreAuthorize("hasAuthority('PAYROLL_ADMIN')")
    public ResponseEntity<ApiResponse<PayrollPeriodDto>> closePayrollPeriod(
            @Parameter(description = "Payroll period ID") @PathVariable Long id) {
        
        log.info("Closing payroll period with ID: {}", id);
        PayrollPeriodDto period = payrollService.closePayrollPeriod(id);
        return ResponseEntity.ok(ApiResponse.success(period, "Payroll period closed successfully"));
    }

    @Operation(summary = "Delete payroll period")
    @DeleteMapping("/periods/{id}")
    @PreAuthorize("hasAuthority('PAYROLL_ADMIN')")
    public ResponseEntity<ApiResponse<Void>> deletePayrollPeriod(
            @Parameter(description = "Payroll period ID") @PathVariable Long id) {
        
        log.info("Deleting payroll period with ID: {}", id);
        payrollService.deletePayrollPeriod(id);
        return ResponseEntity.ok(ApiResponse.success(null, "Payroll period deleted successfully"));
    }

    // ===== SALARY COMPONENT ENDPOINTS =====

    @Operation(summary = "Get all salary components")
    @GetMapping("/components")
    @PreAuthorize("hasAuthority('PAYROLL_READ')")
    public ResponseEntity<ApiResponse<PageResponse<SalaryComponentDto>>> getSalaryComponents(
            @PageableDefault(size = 50) Pageable pageable,
            @RequestParam(required = false) String componentType) {
        
        log.info("Fetching salary components with type filter: {}", componentType);
        PageResponse<SalaryComponentDto> components;
        
        if (componentType != null) {
            List<SalaryComponentDto> componentList = payrollService.getSalaryComponentsByType(componentType);
            Page<SalaryComponentDto> componentPage = new PageImpl<>(componentList, pageable, componentList.size());
            components = PageResponse.of(componentPage);
        } else {
            components = payrollService.getSalaryComponents(pageable);
        }
        
        return ResponseEntity.ok(ApiResponse.success(components));
    }

    @Operation(summary = "Get active salary components")
    @GetMapping("/components/active")
    @PreAuthorize("hasAuthority('PAYROLL_READ')")
    public ResponseEntity<ApiResponse<List<SalaryComponentDto>>> getActiveSalaryComponents() {
        
        log.info("Fetching active salary components");
        List<SalaryComponentDto> components = payrollService.getActiveSalaryComponents();
        return ResponseEntity.ok(ApiResponse.success(components));
    }

    @Operation(summary = "Get salary component by ID")
    @GetMapping("/components/{id}")
    @PreAuthorize("hasAuthority('PAYROLL_READ')")
    public ResponseEntity<ApiResponse<SalaryComponentDto>> getSalaryComponentById(
            @Parameter(description = "Salary component ID") @PathVariable Long id) {
        
        log.info("Fetching salary component with ID: {}", id);
        SalaryComponentDto component = payrollService.getSalaryComponentById(id);
        return ResponseEntity.ok(ApiResponse.success(component));
    }

    @Operation(summary = "Create new salary component")
    @PostMapping("/components")
    @PreAuthorize("hasAuthority('PAYROLL_ADMIN')")
    public ResponseEntity<ApiResponse<SalaryComponentDto>> createSalaryComponent(
            @Valid @RequestBody SalaryComponentDto salaryComponentDto) {
        
        log.info("Creating salary component: {}", salaryComponentDto.getComponentName());
        SalaryComponentDto component = payrollService.createSalaryComponent(salaryComponentDto);
        return ResponseEntity.status(HttpStatus.CREATED)
                .body(ApiResponse.success(component, "Salary component created successfully"));
    }

    @Operation(summary = "Update salary component")
    @PutMapping("/components/{id}")
    @PreAuthorize("hasAuthority('PAYROLL_ADMIN')")
    public ResponseEntity<ApiResponse<SalaryComponentDto>> updateSalaryComponent(
            @Parameter(description = "Salary component ID") @PathVariable Long id,
            @Valid @RequestBody SalaryComponentDto salaryComponentDto) {
        
        log.info("Updating salary component with ID: {}", id);
        SalaryComponentDto component = payrollService.updateSalaryComponent(id, salaryComponentDto);
        return ResponseEntity.ok(ApiResponse.success(component, "Salary component updated successfully"));
    }

    @Operation(summary = "Delete salary component")
    @DeleteMapping("/components/{id}")
    @PreAuthorize("hasAuthority('PAYROLL_ADMIN')")
    public ResponseEntity<ApiResponse<Void>> deleteSalaryComponent(
            @Parameter(description = "Salary component ID") @PathVariable Long id) {
        
        log.info("Deleting salary component with ID: {}", id);
        payrollService.deleteSalaryComponent(id);
        return ResponseEntity.ok(ApiResponse.success(null, "Salary component deleted successfully"));
    }

    // ===== REPORTING ENDPOINTS =====

    @Operation(summary = "Get payroll summary for period")
    @GetMapping("/reports/summary/period/{periodId}")
    @PreAuthorize("hasAuthority('PAYROLL_REPORT')")
    public ResponseEntity<ApiResponse<PayrollSummaryDto>> getPayrollSummary(
            @Parameter(description = "Payroll period ID") @PathVariable Long periodId) {
        
        log.info("Generating payroll summary for period: {}", periodId);
        PayrollSummaryDto summary = payrollService.getPayrollSummary(periodId);
        return ResponseEntity.ok(ApiResponse.success(summary));
    }

    @Operation(summary = "Get payroll summary by date range")
    @GetMapping("/reports/summary/daterange")
    @PreAuthorize("hasAuthority('PAYROLL_REPORT')")
    public ResponseEntity<ApiResponse<List<PayrollSummaryDto>>> getPayrollSummaryByDateRange(
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate startDate,
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate endDate) {
        
        log.info("Generating payroll summary for date range: {} to {}", startDate, endDate);
        List<PayrollSummaryDto> summaries = payrollService.getPayrollSummaryByDateRange(startDate, endDate);
        return ResponseEntity.ok(ApiResponse.success(summaries));
    }

    @Operation(summary = "Generate payroll report")
    @PostMapping("/reports/generate")
    @PreAuthorize("hasAuthority('PAYROLL_REPORT')")
    public ResponseEntity<byte[]> generatePayrollReport(
            @Valid @RequestBody PayrollReportRequest request) {
        
        log.info("Generating payroll report for request: {}", request);
        byte[] reportData = payrollService.generatePayrollReport(request);
        
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_OCTET_STREAM);
        headers.setContentDispositionFormData("attachment", "payroll_report.pdf");
        headers.setContentLength(reportData.length);
        
        return ResponseEntity.ok()
                .headers(headers)
                .body(reportData);
    }

    // ===== AUDIT ENDPOINTS =====

    @Operation(summary = "Get payroll audit history")
    @GetMapping("/ledgers/{id}/audit")
    @PreAuthorize("hasAuthority('PAYROLL_AUDIT')")
    public ResponseEntity<ApiResponse<List<Object>>> getPayrollAuditHistory(
            @Parameter(description = "Payroll ledger ID") @PathVariable Long id) {
        
        log.info("Fetching audit history for payroll ledger: {}", id);
        // This would be implemented in the service layer
        return ResponseEntity.ok(ApiResponse.success(List.of(), "Audit history retrieved successfully"));
    }
}
</file>

<file path="src/main/java/com/example/demo/payroll/dto/PayrollLedgerDto.java">
package com.example.demo.payroll.dto;

import com.example.demo.payroll.entity.PayrollLedgerStatus;
import com.example.demo.payroll.entity.PaymentMethod;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.Getter;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Getter
@Setter
public class PayrollLedgerDto {
    private Long id;
    private Long employeeId;
    private String employeeName;
    private String employeeNumber;
    private Long payrollPeriodId;
    private String payrollPeriodName;
    private BigDecimal baseSalary;
    private BigDecimal grossPay;
    private BigDecimal totalDeductions;
    private BigDecimal totalTaxes;
    private BigDecimal netPay;
    private BigDecimal overtimeHours;
    private BigDecimal overtimePay;
    private BigDecimal bonusAmount;
    private PayrollLedgerStatus status;
    private PaymentMethod paymentMethod;
    private LocalDate payDate;
    private String paymentReference;
    private String notes;
    private Long approvedBy;
    private String approvedByName;
    private LocalDateTime approvedAt;
    private Long paidBy;
    private String paidByName;
    private LocalDateTime paidAt;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    private List<PayrollLedgerComponentDto> components;
}
</file>

<file path="src/main/java/com/example/demo/payroll/dto/PayrollPeriodDto.java">
package com.example.demo.payroll.dto;

import com.example.demo.payroll.entity.PayrollPeriodStatus;
import com.example.demo.payroll.entity.PayrollPeriodType;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.Getter;

import java.time.LocalDate;
import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Getter
@Setter
public class PayrollPeriodDto {
    private Long id;
    
    @NotBlank(message = "Period name is required")
    private String periodName;
    
    @NotNull(message = "Start date is required")
    private LocalDate startDate;
    
    @NotNull(message = "End date is required")
    private LocalDate endDate;
    
    @NotNull(message = "Period type is required")
    private PayrollPeriodType periodType;
    
    private PayrollPeriodStatus status;
    private LocalDate payDate;
    private String description;
    private Boolean isActive;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    private Long employeeCount;
    private Long processedCount;
}
</file>

<file path="src/main/java/com/example/demo/payroll/service/impl/PayrollServiceImpl.java">
package com.example.demo.payroll.service.impl;

import com.example.demo.common.dto.PageResponse;
import com.example.demo.payroll.dto.*;
import com.example.demo.payroll.entity.*;
import com.example.demo.payroll.exception.*;
import com.example.demo.payroll.repository.*;
import com.example.demo.payroll.service.PayrollCalculationService;
import com.example.demo.payroll.service.PayrollService;
import com.example.demo.employee.repository.EmployeeRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

@Slf4j
@Service
@RequiredArgsConstructor
@Transactional
public class PayrollServiceImpl implements PayrollService {

    private final PayrollLedgerRepository payrollLedgerRepository;
    private final PayrollPeriodRepository payrollPeriodRepository;
    private final SalaryComponentRepository salaryComponentRepository;
    private final PayrollAuditRepository payrollAuditRepository;
    private final EmployeeRepository employeeRepository;
    private final PayrollCalculationService payrollCalculationService;

    // Payroll Ledger Operations
    @Override
    public PayrollLedgerDto createPayrollLedger(PayrollCalculationRequest request) {
        log.info("Creating payroll ledger for employee: {}", request.getEmployeeId());
        
        // Validate employee exists
        if (!employeeRepository.existsById(request.getEmployeeId())) {
            throw new PayrollNotFoundException("Employee not found with id: " + request.getEmployeeId());
        }
        
        // Calculate payroll
        PayrollLedger ledger = payrollCalculationService.calculatePayroll(request);
        PayrollLedger savedLedger = payrollLedgerRepository.save(ledger);
        
        // Create audit record
        createAuditRecord(savedLedger.getId(), "CREATED", "Payroll ledger created");
        
        return convertToDto(savedLedger);
    }

    @Override
    @CacheEvict(value = "payrollLedgers", key = "#id")
    public PayrollLedgerDto updatePayrollLedger(Long id, PayrollLedgerDto payrollLedgerDto) {
        log.info("Updating payroll ledger: {}", id);
        
        PayrollLedger existingLedger = payrollLedgerRepository.findById(id)
            .orElseThrow(() -> new PayrollNotFoundException("Payroll ledger not found with id: " + id));
        
        // Update fields
        existingLedger.setBaseSalary(payrollLedgerDto.getBaseSalary());
        existingLedger.setOvertimePay(payrollLedgerDto.getOvertimePay());
        existingLedger.setTotalDeductions(payrollLedgerDto.getTotalDeductions());
        existingLedger.setTotalTaxes(payrollLedgerDto.getTotalTaxes());
        existingLedger.setNetPay(payrollLedgerDto.getNetPay());
        existingLedger.setUpdatedAt(LocalDateTime.now());
        
        PayrollLedger savedLedger = payrollLedgerRepository.save(existingLedger);
        
        // Create audit record
        createAuditRecord(savedLedger.getId(), "UPDATED", "Payroll ledger updated");
        
        return convertToDto(savedLedger);
    }

    @Override
    @Cacheable(value = "payrollLedgers", key = "#id")
    public PayrollLedgerDto getPayrollLedgerById(Long id) {
        log.info("Fetching payroll ledger: {}", id);
        
        PayrollLedger ledger = payrollLedgerRepository.findById(id)
            .orElseThrow(() -> new PayrollNotFoundException("Payroll ledger not found with id: " + id));
        
        return convertToDto(ledger);
    }

    @Override
    @CacheEvict(value = "payrollLedgers", key = "#id")
    public void deletePayrollLedger(Long id) {
        log.info("Deleting payroll ledger: {}", id);
        
        if (!payrollLedgerRepository.existsById(id)) {
            throw new PayrollNotFoundException("Payroll ledger not found with id: " + id);
        }
        
        // Create audit record before deletion
        createAuditRecord(id, "DELETED", "Payroll ledger deleted");
        
        payrollLedgerRepository.deleteById(id);
    }

    // Payroll Ledger Queries
    @Override
    public PageResponse<PayrollLedgerDto> getPayrollLedgers(Pageable pageable) {
        log.info("Fetching payroll ledgers with pagination");
        
        Page<PayrollLedger> ledgerPage = payrollLedgerRepository.findAll(pageable);
        List<PayrollLedgerDto> ledgerDtos = ledgerPage.getContent().stream()
            .map(this::convertToDto)
            .collect(Collectors.toList());
        
        return PageResponse.of(
            ledgerDtos,
            ledgerPage.getNumber(),
            ledgerPage.getSize(),
            ledgerPage.getTotalElements(),
            ledgerPage.getTotalPages()
        );
    }

    @Override
    public List<PayrollLedgerDto> getPayrollLedgersByEmployee(Long employeeId) {
        log.info("Fetching payroll ledgers for employee: {}", employeeId);
        
        List<PayrollLedger> ledgers = payrollLedgerRepository.findByEmployeeId(employeeId);
        return ledgers.stream()
            .map(this::convertToDto)
            .collect(Collectors.toList());
    }

    @Override
    public List<PayrollLedgerDto> getPayrollLedgersByPeriod(Long payrollPeriodId) {
        log.info("Fetching payroll ledgers for period: {}", payrollPeriodId);
        
        List<PayrollLedger> ledgers = payrollLedgerRepository.findByPayrollPeriodId(payrollPeriodId);
        return ledgers.stream()
            .map(this::convertToDto)
            .collect(Collectors.toList());
    }

    @Override
    public List<PayrollLedgerDto> getPayrollLedgersByStatus(PayrollLedgerStatus status) {
        log.info("Fetching payroll ledgers with status: {}", status);
        
        List<PayrollLedger> ledgers = payrollLedgerRepository.findByStatus(status);
        return ledgers.stream()
            .map(this::convertToDto)
            .collect(Collectors.toList());
    }

    @Override
    public PageResponse<PayrollLedgerDto> getPayrollLedgersByEmployeeWithPaging(Long employeeId, Pageable pageable) {
        log.info("Fetching payroll ledgers for employee: {} with pagination", employeeId);
        
        Page<PayrollLedger> ledgerPage = payrollLedgerRepository.findByEmployeeIdOrderByCreatedAtDesc(employeeId, pageable);
        List<PayrollLedgerDto> ledgerDtos = ledgerPage.getContent().stream()
            .map(this::convertToDto)
            .collect(Collectors.toList());
        
        return PageResponse.of(
            ledgerDtos,
            ledgerPage.getNumber(),
            ledgerPage.getSize(),
            ledgerPage.getTotalElements(),
            ledgerPage.getTotalPages()
        );
    }

    // Payroll Processing
    @Override
    public List<PayrollLedgerDto> processPayrollForPeriod(Long payrollPeriodId, List<Long> employeeIds) {
        log.info("Processing payroll for period: {} and employees: {}", payrollPeriodId, employeeIds);
        
        // Validate payroll period exists
        PayrollPeriod period = payrollPeriodRepository.findById(payrollPeriodId)
            .orElseThrow(() -> new PayrollPeriodException("Payroll period not found with id: " + payrollPeriodId));
        
        List<PayrollLedger> ledgers = payrollCalculationService.calculatePayrollForPeriod(payrollPeriodId, employeeIds);
        List<PayrollLedger> savedLedgers = payrollLedgerRepository.saveAll(ledgers);
        
        // Create audit records
        savedLedgers.forEach(ledger -> 
            createAuditRecord(ledger.getId(), "PROCESSED", "Payroll processed for period: " + payrollPeriodId));
        
        return savedLedgers.stream()
            .map(this::convertToDto)
            .collect(Collectors.toList());
    }

    @Override
    @CacheEvict(value = "payrollLedgers", key = "#payrollLedgerId")
    public PayrollLedgerDto approvePayroll(Long payrollLedgerId, String reason) {
        log.info("Approving payroll ledger: {}", payrollLedgerId);
        
        PayrollLedger ledger = payrollLedgerRepository.findById(payrollLedgerId)
            .orElseThrow(() -> new PayrollNotFoundException("Payroll ledger not found with id: " + payrollLedgerId));
        
        if (ledger.getStatus() != PayrollLedgerStatus.CALCULATED) {
            throw new PayrollValidationException("Payroll can only be approved from CALCULATED status");
        }
        
        ledger.setStatus(PayrollLedgerStatus.APPROVED);
        ledger.setUpdatedAt(LocalDateTime.now());
        
        PayrollLedger savedLedger = payrollLedgerRepository.save(ledger);
        
        // Create audit record
        createAuditRecord(savedLedger.getId(), "APPROVED", reason != null ? reason : "Payroll approved");
        
        return convertToDto(savedLedger);
    }

    @Override
    @CacheEvict(value = "payrollLedgers", key = "#payrollLedgerId")
    public PayrollLedgerDto rejectPayroll(Long payrollLedgerId, String reason) {
        log.info("Rejecting payroll ledger: {}", payrollLedgerId);
        
        PayrollLedger ledger = payrollLedgerRepository.findById(payrollLedgerId)
            .orElseThrow(() -> new PayrollNotFoundException("Payroll ledger not found with id: " + payrollLedgerId));
        
        if (ledger.getStatus() != PayrollLedgerStatus.CALCULATED) {
            throw new PayrollValidationException("Payroll can only be rejected from CALCULATED status");
        }
        
        ledger.setStatus(PayrollLedgerStatus.REJECTED);
        ledger.setUpdatedAt(LocalDateTime.now());
        
        PayrollLedger savedLedger = payrollLedgerRepository.save(ledger);
        
        // Create audit record
        createAuditRecord(savedLedger.getId(), "REJECTED", reason != null ? reason : "Payroll rejected");
        
        return convertToDto(savedLedger);
    }

    @Override
    @CacheEvict(value = "payrollLedgers", key = "#payrollLedgerId")
    public PayrollLedgerDto markAsPaid(Long payrollLedgerId, String paymentReference) {
        log.info("Marking payroll ledger as paid: {}", payrollLedgerId);
        
        PayrollLedger ledger = payrollLedgerRepository.findById(payrollLedgerId)
            .orElseThrow(() -> new PayrollNotFoundException("Payroll ledger not found with id: " + payrollLedgerId));
        
        if (ledger.getStatus() != PayrollLedgerStatus.APPROVED) {
            throw new PayrollValidationException("Payroll can only be marked as paid from APPROVED status");
        }
        
        ledger.setStatus(PayrollLedgerStatus.PAID);
        ledger.setPaymentReference(paymentReference);
        ledger.setUpdatedAt(LocalDateTime.now());
        
        PayrollLedger savedLedger = payrollLedgerRepository.save(ledger);
        
        // Create audit record
        createAuditRecord(savedLedger.getId(), "PAID", "Payroll marked as paid. Reference: " + paymentReference);
        
        return convertToDto(savedLedger);
    }

    // Payroll Period Operations
    @Override
    public PayrollPeriodDto createPayrollPeriod(PayrollPeriodDto payrollPeriodDto) {
        log.info("Creating payroll period: {}", payrollPeriodDto.getPeriodName());
        
        PayrollPeriod period = convertToEntity(payrollPeriodDto);
        period.setCreatedAt(LocalDateTime.now());
        period.setUpdatedAt(LocalDateTime.now());
        
        PayrollPeriod savedPeriod = payrollPeriodRepository.save(period);
        return convertToDto(savedPeriod);
    }

    @Override
    public PayrollPeriodDto updatePayrollPeriod(Long id, PayrollPeriodDto payrollPeriodDto) {
        log.info("Updating payroll period: {}", id);
        
        PayrollPeriod existingPeriod = payrollPeriodRepository.findById(id)
            .orElseThrow(() -> new PayrollPeriodException("Payroll period not found with id: " + id));
        
        existingPeriod.setPeriodName(payrollPeriodDto.getPeriodName());
        existingPeriod.setStartDate(payrollPeriodDto.getStartDate());
        existingPeriod.setEndDate(payrollPeriodDto.getEndDate());
        existingPeriod.setStatus(payrollPeriodDto.getStatus());
        existingPeriod.setUpdatedAt(LocalDateTime.now());
        
        PayrollPeriod savedPeriod = payrollPeriodRepository.save(existingPeriod);
        return convertToDto(savedPeriod);
    }

    @Override
    public PayrollPeriodDto getPayrollPeriodById(Long id) {
        log.info("Fetching payroll period: {}", id);
        
        PayrollPeriod period = payrollPeriodRepository.findById(id)
            .orElseThrow(() -> new PayrollPeriodException("Payroll period not found with id: " + id));
        
        return convertToDto(period);
    }

    @Override
    public void deletePayrollPeriod(Long id) {
        log.info("Deleting payroll period: {}", id);
        
        if (!payrollPeriodRepository.existsById(id)) {
            throw new PayrollPeriodException("Payroll period not found with id: " + id);
        }
        
        payrollPeriodRepository.deleteById(id);
    }

    @Override
    public PageResponse<PayrollPeriodDto> getPayrollPeriods(Pageable pageable) {
        log.info("Fetching payroll periods with pagination");
        
        Page<PayrollPeriod> periodPage = payrollPeriodRepository.findAll(pageable);
        List<PayrollPeriodDto> periodDtos = periodPage.getContent().stream()
            .map(this::convertToDto)
            .collect(Collectors.toList());
        
        return PageResponse.of(
            periodDtos,
            periodPage.getNumber(),
            periodPage.getSize(),
            periodPage.getTotalElements(),
            periodPage.getTotalPages()
        );
    }

    @Override
    public List<PayrollPeriodDto> getActivePayrollPeriods() {
        log.info("Fetching active payroll periods");
        
        List<PayrollPeriod> periods = payrollPeriodRepository.findByStatus(PayrollPeriodStatus.OPEN);
        return periods.stream()
            .map(this::convertToDto)
            .collect(Collectors.toList());
    }

    @Override
    public PayrollPeriodDto getCurrentPayrollPeriod() {
        log.info("Fetching current payroll period");
        
        LocalDate today = LocalDate.now();
        PayrollPeriod period = payrollPeriodRepository.findCurrentPeriodForDate(today)
            .orElseThrow(() -> new PayrollPeriodException("No current payroll period found"));
        
        return convertToDto(period);
    }

    @Override
    public PayrollPeriodDto closePayrollPeriod(Long id) {
        log.info("Closing payroll period: {}", id);
        
        PayrollPeriod period = payrollPeriodRepository.findById(id)
            .orElseThrow(() -> new PayrollPeriodException("Payroll period not found with id: " + id));
        
        period.setStatus(PayrollPeriodStatus.CLOSED);
        period.setUpdatedAt(LocalDateTime.now());
        
        PayrollPeriod savedPeriod = payrollPeriodRepository.save(period);
        return convertToDto(savedPeriod);
    }

    // Salary Component Operations
    @Override
    public SalaryComponentDto createSalaryComponent(SalaryComponentDto salaryComponentDto) {
        log.info("Creating salary component: {}", salaryComponentDto.getComponentName());
        
        SalaryComponent component = convertToEntity(salaryComponentDto);
        component.setCreatedAt(LocalDateTime.now());
        component.setUpdatedAt(LocalDateTime.now());
        
        SalaryComponent savedComponent = salaryComponentRepository.save(component);
        return convertToDto(savedComponent);
    }

    @Override
    public SalaryComponentDto updateSalaryComponent(Long id, SalaryComponentDto salaryComponentDto) {
        log.info("Updating salary component: {}", id);
        
        SalaryComponent existingComponent = salaryComponentRepository.findById(id)
            .orElseThrow(() -> new PayrollNotFoundException("Salary component not found with id: " + id));
        
        existingComponent.setComponentName(salaryComponentDto.getComponentName());
        existingComponent.setComponentType(salaryComponentDto.getComponentType());
        existingComponent.setComponentType(salaryComponentDto.getComponentType());
        existingComponent.setAmount(salaryComponentDto.getAmount());
        existingComponent.setIsActive(salaryComponentDto.getIsActive());
        existingComponent.setUpdatedAt(LocalDateTime.now());
        
        SalaryComponent savedComponent = salaryComponentRepository.save(existingComponent);
        return convertToDto(savedComponent);
    }

    @Override
    public SalaryComponentDto getSalaryComponentById(Long id) {
        log.info("Fetching salary component: {}", id);
        
        SalaryComponent component = salaryComponentRepository.findById(id)
            .orElseThrow(() -> new PayrollNotFoundException("Salary component not found with id: " + id));
        
        return convertToDto(component);
    }

    @Override
    public void deleteSalaryComponent(Long id) {
        log.info("Deleting salary component: {}", id);
        
        if (!salaryComponentRepository.existsById(id)) {
            throw new PayrollNotFoundException("Salary component not found with id: " + id);
        }
        
        salaryComponentRepository.deleteById(id);
    }

    @Override
    public PageResponse<SalaryComponentDto> getSalaryComponents(Pageable pageable) {
        log.info("Fetching salary components with pagination");
        
        Page<SalaryComponent> componentPage = salaryComponentRepository.findAll(pageable);
        List<SalaryComponentDto> componentDtos = componentPage.getContent().stream()
            .map(this::convertToDto)
            .collect(Collectors.toList());
        
        return PageResponse.of(
            componentDtos,
            componentPage.getNumber(),
            componentPage.getSize(),
            componentPage.getTotalElements(),
            componentPage.getTotalPages()
        );
    }

    @Override
    public List<SalaryComponentDto> getActiveSalaryComponents() {
        log.info("Fetching active salary components");
        
        List<SalaryComponent> components = salaryComponentRepository.findByIsActiveTrue();
        return components.stream()
            .map(this::convertToDto)
            .collect(Collectors.toList());
    }

    @Override
    public List<SalaryComponentDto> getSalaryComponentsByType(String componentType) {
        log.info("Fetching salary components by type: {}", componentType);
        
        List<SalaryComponent> components = salaryComponentRepository.findByComponentType(componentType);
        return components.stream()
            .map(this::convertToDto)
            .collect(Collectors.toList());
    }

    // Reporting and Analytics
    @Override
    public PayrollSummaryDto getPayrollSummary(Long payrollPeriodId) {
        log.info("Generating payroll summary for period: {}", payrollPeriodId);
        
        // Implementation would aggregate payroll data for the period
        // This is a simplified version
        PayrollSummaryDto summary = new PayrollSummaryDto();
        summary.setPayrollPeriodId(payrollPeriodId);
        // Add actual summary calculations here
        
        return summary;
    }

    @Override
    public List<PayrollSummaryDto> getPayrollSummaryByDateRange(LocalDate startDate, LocalDate endDate) {
        log.info("Generating payroll summary for date range: {} to {}", startDate, endDate);
        
        // Implementation would aggregate payroll data for the date range
        // This is a simplified version
        return List.of();
    }

    @Override
    public byte[] generatePayrollReport(PayrollReportRequest request) {
        log.info("Generating payroll report for request: {}", request);
        
        // Implementation would generate actual report (PDF, Excel, etc.)
        // This is a placeholder
        return new byte[0];
    }

    // Helper methods
    private PayrollLedgerDto convertToDto(PayrollLedger ledger) {
        PayrollLedgerDto dto = new PayrollLedgerDto();
        dto.setId(ledger.getId());
        dto.setEmployeeId(ledger.getEmployeeId());
        if (ledger.getEmployee() != null) {
            dto.setEmployeeName(ledger.getEmployee().getFullName());
            dto.setEmployeeNumber(ledger.getEmployee().getEmployeeNumber());
        }
        dto.setPayrollPeriodId(ledger.getPayrollPeriodId());
        if (ledger.getPayrollPeriod() != null) {
            dto.setPayrollPeriodName(ledger.getPayrollPeriod().getPeriodName());
        }
        dto.setBaseSalary(ledger.getBaseSalary());
        dto.setGrossPay(ledger.getGrossPay());
        dto.setTotalDeductions(ledger.getTotalDeductions());
        dto.setTotalTaxes(ledger.getTotalTaxes());
        dto.setNetPay(ledger.getNetPay());
        dto.setOvertimeHours(ledger.getOvertimeHours());
        dto.setOvertimePay(ledger.getOvertimePay());
        dto.setBonusAmount(ledger.getBonusAmount());
        dto.setStatus(ledger.getStatus());
        dto.setPaymentMethod(ledger.getPaymentMethod());
        dto.setPayDate(ledger.getPayDate());
        dto.setPaymentReference(ledger.getPaymentReference());
        dto.setNotes(ledger.getNotes());
        dto.setApprovedBy(ledger.getApprovedBy());
        // approvedByName would require a separate lookup from a user service
        dto.setApprovedAt(ledger.getApprovedAt());
        dto.setPaidBy(ledger.getPaidBy());
        // paidByName would require a separate lookup from a user service
        dto.setPaidAt(ledger.getPaidAt());
        dto.setCreatedAt(ledger.getCreatedAt());
        dto.setUpdatedAt(ledger.getUpdatedAt());
        
        // Convert components if they exist
        if (ledger.getComponents() != null) {
            List<PayrollLedgerComponentDto> componentDtos = ledger.getComponents().stream()
                .map(this::convertToDto)
                .collect(Collectors.toList());
            dto.setComponents(componentDtos);
        }
        
        return dto;
    }

    private PayrollPeriodDto convertToDto(PayrollPeriod period) {
        PayrollPeriodDto dto = new PayrollPeriodDto();
        dto.setId(period.getId());
        dto.setPeriodName(period.getPeriodName());
        dto.setStartDate(period.getStartDate());
        dto.setEndDate(period.getEndDate());
        dto.setStatus(period.getStatus());
        dto.setCreatedAt(period.getCreatedAt());
        dto.setUpdatedAt(period.getUpdatedAt());
        return dto;
    }

    private PayrollPeriod convertToEntity(PayrollPeriodDto dto) {
        PayrollPeriod period = new PayrollPeriod();
        period.setPeriodName(dto.getPeriodName());
        period.setStartDate(dto.getStartDate());
        period.setEndDate(dto.getEndDate());
        period.setStatus(dto.getStatus());
        return period;
    }

    private SalaryComponentDto convertToDto(SalaryComponent component) {
        SalaryComponentDto dto = new SalaryComponentDto();
        dto.setId(component.getId());
        dto.setComponentName(component.getComponentName());
        dto.setComponentType(component.getComponentType());
        dto.setAmount(component.getAmount());
        dto.setIsActive(component.getIsActive());
        dto.setCreatedAt(component.getCreatedAt());
        dto.setUpdatedAt(component.getUpdatedAt());
        return dto;
    }

    private SalaryComponent convertToEntity(SalaryComponentDto dto) {
        SalaryComponent component = new SalaryComponent();
        component.setComponentName(dto.getComponentName());
        component.setComponentType(dto.getComponentType());
        component.setAmount(dto.getAmount());
        component.setIsActive(dto.getIsActive());
        return component;
    }

    private void createAuditRecord(Long payrollLedgerId, String action, String description) {
        PayrollAudit audit = new PayrollAudit();
        audit.setPayrollLedgerId(payrollLedgerId);
        audit.setAction(action);
        audit.setReason(description);
        audit.setCreatedAt(LocalDateTime.now());
        // audit.setUserId would be set from security context
        payrollAuditRepository.save(audit);
    }
    
    private PayrollLedgerComponentDto convertToDto(PayrollLedgerComponent component) {
        PayrollLedgerComponentDto dto = new PayrollLedgerComponentDto();
        dto.setId(component.getId());
        dto.setPayrollLedgerId(component.getPayrollLedgerId());
        dto.setSalaryComponentId(component.getSalaryComponentId());
        if (component.getSalaryComponent() != null) {
            dto.setComponentName(component.getSalaryComponent().getComponentName());
            dto.setComponentType(component.getSalaryComponent().getComponentType());
        }
        dto.setAmount(component.getAmount());
        dto.setCalculationBase(component.getCalculationBase());
        dto.setPercentageApplied(component.getPercentageApplied());
        dto.setNotes(component.getNotes());
        return dto;
    }
}
</file>

<file path="src/main/java/com/example/demo/security/config/SecurityConfig.java">
package com.example.demo.security.config;

import com.example.demo.security.security.CustomUserDetailsService;
import com.example.demo.security.security.JwtAuthenticationFilter;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.Arrays;
import java.util.List;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity(prePostEnabled = true)
@RequiredArgsConstructor
public class SecurityConfig {
    
    private final CustomUserDetailsService userDetailsService;
    private final JwtAuthenticationFilter jwtAuthenticationFilter;
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
    
    @Bean
    public AuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider(userDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder());
        return authProvider;
    }
    
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf(AbstractHttpConfigurer::disable)
            .cors(cors -> cors.configurationSource(corsConfigurationSource()))
            .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(authz -> authz
                // Public endpoints
                .requestMatchers("/api/auth/**").permitAll()
                .requestMatchers("/api/public/**").permitAll()
                .requestMatchers("/actuator/health").permitAll()
                .requestMatchers("/swagger-ui/**", "/v3/api-docs/**").permitAll()
                .requestMatchers("/favicon.ico").permitAll()
                // All other endpoints require authentication
                .anyRequest().authenticated()
            )
            .authenticationProvider(authenticationProvider())
            .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);
        
        return http.build();
    }
    
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOriginPatterns(List.of("*"));
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"));
        configuration.setAllowedHeaders(Arrays.asList("*"));
        configuration.setAllowCredentials(true);
        configuration.setMaxAge(3600L);
        
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }
}
</file>

<file path="src/main/java/com/example/demo/security/dto/ResourceDto.java">
package com.example.demo.security.dto;

import lombok.Data;
import lombok.Getter;
import lombok.Setter;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import java.time.Instant;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Getter
@Setter
public class ResourceDto {
    
    private Long id;
    
    @NotBlank(message = "Resource name is required")
    @Size(min = 2, max = 100, message = "Resource name must be between 2 and 100 characters")
    private String name;
    
    @NotBlank(message = "URL is required")
    @Size(max = 255, message = "URL must not exceed 255 characters")
    private String url;
    
    @NotBlank(message = "HTTP method is required")
    @Pattern(regexp = "GET|POST|PUT|DELETE|PATCH", message = "Method must be GET, POST, PUT, DELETE, or PATCH")
    private String method;
    
    @Size(max = 255, message = "Description must not exceed 255 characters")
    private String description;
    
    @Size(max = 50, message = "Category must not exceed 50 characters")
    private String category;
    
    private boolean active;
    
    private Instant createdAt;
    
    private Instant updatedAt;
}
</file>

<file path="src/main/java/com/example/demo/security/dto/RoleDto.java">
package com.example.demo.security.dto;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.Getter;
import lombok.AllArgsConstructor;
import lombok.Builder;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import java.time.Instant;
import java.util.Set;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Setter
@Getter
public class RoleDto {
    
    private Long id;
    
    @NotBlank(message = "Role name is required")
    @Size(min = 2, max = 50, message = "Role name must be between 2 and 50 characters")
    private String name;
    
    @Size(max = 255, message = "Description must not exceed 255 characters")
    private String description;
    
    private Boolean active;
    
    private Instant createdAt;
    
    private Instant updatedAt;
    
    private Set<ResourceDto> resources;

}
</file>

<file path="src/main/java/com/example/demo/security/entity/Role.java">
package com.example.demo.security.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.Instant;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "roles", indexes = {
    @Index(name = "idx_role_name", columnList = "name"),
    @Index(name = "idx_role_active", columnList = "active")
})
@EntityListeners(AuditingEntityListener.class)
@Getter
@Setter
public class Role {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "name", unique = true, nullable = false, length = 50)
    private String name;
    
    @Column(name = "description", length = 255)
    private String description;
    
    @Column(name = "active", nullable = false)
    private Boolean active = true;
    
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;
    
    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;
    
    @Column(name = "created_by")
    private Long createdBy;
    
    @Column(name = "updated_by")
    private Long updatedBy;
    
    @ManyToMany(mappedBy = "roles", fetch = FetchType.LAZY)
    private Set<User> users = new HashSet<>();
    
    @ManyToMany(fetch = FetchType.LAZY)
    @JoinTable(
        name = "role_resources",
        joinColumns = @JoinColumn(name = "role_id"),
        inverseJoinColumns = @JoinColumn(name = "resource_id")
    )
    private Set<Resource> resources = new HashSet<>();

}
</file>

<file path="src/main/java/com/example/demo/security/exception/RoleAlreadyExistsException.java">
package com.example.demo.security.exception;

/**
 * Exception thrown when attempting to create a role that already exists
 */
public class RoleAlreadyExistsException extends RuntimeException {
    
    public RoleAlreadyExistsException(String message) {
        super(message);
    }
    
    public RoleAlreadyExistsException(String message, Throwable cause) {
        super(message, cause);
    }
}
</file>

<file path="src/main/java/com/example/demo/security/exception/RoleNotFoundException.java">
package com.example.demo.security.exception;

/**
 * Exception thrown when a role is not found
 */
public class RoleNotFoundException extends RuntimeException {
    
    public RoleNotFoundException(String message) {
        super(message);
    }
    
    public RoleNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }

    public RoleNotFoundException(Long roleId) {
        super("Could not find role with id " + roleId);
    }
}
</file>

<file path="src/test/java/com/example/demo/communication/announcement/controller/AnnouncementControllerTest.java">
package com.example.demo.communication.announcement.controller;

import com.example.demo.communication.announcement.dto.AnnouncementCreateRequest;
import com.example.demo.communication.announcement.dto.AnnouncementDto;
import com.example.demo.communication.announcement.dto.AnnouncementUpdateRequest;
import com.example.demo.communication.announcement.service.AnnouncementService;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.http.MediaType;
import org.springframework.security.test.context.support.WithMockUser;
import org.springframework.test.context.bean.override.mockito.MockitoBean;
import org.springframework.test.web.servlet.MockMvc;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.when;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.put;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@WebMvcTest(AnnouncementController.class)
public class AnnouncementControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @MockitoBean
    private AnnouncementService announcementService;

    @Autowired
    private ObjectMapper objectMapper;

    @Test
    @WithMockUser(authorities = "ANNOUNCEMENT_MANAGE")
    void createAnnouncement_shouldReturnCreated() throws Exception {
        AnnouncementCreateRequest createRequest = new AnnouncementCreateRequest();
        createRequest.setTitle("Test Title");
        createRequest.setContent("Test Content");

        AnnouncementDto returnedDto = new AnnouncementDto();
        returnedDto.setId(1L);
        returnedDto.setTitle("Test Title");
        returnedDto.setContent("Test Content");

        when(announcementService.createAnnouncement(any(AnnouncementCreateRequest.class), any(Long.class))).thenReturn(returnedDto);

        mockMvc.perform(post("/api/v1/announcements")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(createRequest)))
                .andExpect(status().isCreated());
    }

    @Test
    @WithMockUser(authorities = "ANNOUNCEMENT_MANAGE")
    void updateAnnouncement_shouldReturnOk() throws Exception {
        Long announcementId = 1L;
        AnnouncementUpdateRequest updateRequest = new AnnouncementUpdateRequest();
        updateRequest.setTitle("Updated Title");
        updateRequest.setContent("Updated Content");

        AnnouncementDto returnedDto = new AnnouncementDto();
        returnedDto.setId(announcementId);
        returnedDto.setTitle("Updated Title");
        returnedDto.setContent("Updated Content");

        when(announcementService.updateAnnouncement(eq(announcementId), any(AnnouncementUpdateRequest.class), any(Long.class))).thenReturn(returnedDto);

        mockMvc.perform(put("/api/v1/announcements/{id}", announcementId)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(updateRequest)))
                .andExpect(status().isOk());
    }
}
</file>

<file path="src/test/java/com/example/demo/communication/chat/controller/ChatControllerTest.java">
package com.example.demo.communication.chat.controller;

import com.example.demo.communication.chat.dto.ChatRoomDto;
import com.example.demo.communication.chat.dto.CreateChatRoomRequest;
import com.example.demo.communication.chat.entity.ChatRoomType;
import com.example.demo.communication.chat.service.ChatService;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.http.MediaType;
import org.springframework.security.test.context.support.WithMockUser;
import org.springframework.test.context.bean.override.mockito.MockitoBean;
import org.springframework.test.web.servlet.MockMvc;

import java.util.Collections;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyList;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.when;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@WebMvcTest(ChatController.class)
public class ChatControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @MockitoBean
    private ChatService chatService;

    @Autowired
    private ObjectMapper objectMapper;

    @Test
    @WithMockUser(username = "1")
    void createChatRoom_shouldReturnCreated() throws Exception {
        CreateChatRoomRequest createRequest = new CreateChatRoomRequest();
        createRequest.setName("Test Room");
        createRequest.setParticipantIds(Collections.singletonList(2L));
        createRequest.setType(ChatRoomType.GROUP);

        ChatRoomDto returnedDto = new ChatRoomDto();
        returnedDto.setId(1L);
        returnedDto.setName("Test Room");

        when(chatService.createChatRoom(anyString(), any(ChatRoomType.class), anyString(), any(Long.class), anyList())).thenReturn(returnedDto);

        mockMvc.perform(post("/api/v1/chat/rooms")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(createRequest)))
                .andExpect(status().isCreated());
    }
}
</file>

<file path="src/test/java/com/example/demo/communication/email/service/impl/EmailServiceImplTest.java">
package com.example.demo.communication.email.service.impl;

import com.example.demo.communication.email.dto.EmailRequest;
import com.example.demo.communication.email.dto.EmailTemplateDto;
import com.example.demo.communication.email.entity.EmailTemplate;
import com.example.demo.communication.email.repository.EmailLogRepository;
import com.example.demo.communication.email.repository.EmailTemplateRepository;
import com.example.demo.communication.email.service.EmailTemplateService;
import com.example.demo.communication.email.util.EmailTemplateProcessor;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.mail.javamail.JavaMailSender;

import java.util.Collections;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
public class EmailServiceImplTest {

    @Mock
    private JavaMailSender mailSender;

    @Mock
    private EmailLogRepository emailLogRepository;

    @Mock
    private EmailTemplateRepository emailTemplateRepository;

    @Mock
    private EmailTemplateProcessor templateProcessor;
    
    @Mock
    private EmailTemplateService emailTemplateService;

    @InjectMocks
    private EmailServiceImpl emailService;

    @Test
    void sendEmail_shouldSendEmailAndLogIt() {
        EmailRequest emailRequest = new EmailRequest();
        emailRequest.setToEmail("test@example.com");
        emailRequest.setSubject("Test Subject");
        emailRequest.setContent("Test Content");

        emailService.sendEmail(emailRequest);

        verify(mailSender).send(any(org.springframework.mail.SimpleMailMessage.class));
        verify(emailLogRepository).save(any());
    }

    @Test
    void sendTemplatedEmail_shouldProcessAndSendEmail() {
        String to = "test@example.com";
        String templateCode = "test-template";
        
        EmailTemplateDto template = new EmailTemplateDto();
        template.setSubject("Subject: {{title}}");
        template.setContent("Hello, {{name}}");

        when(emailTemplateService.getTemplateByCode(templateCode)).thenReturn(template);
        when(templateProcessor.processTemplate(any(), any())).thenReturn("Processed Content");

        CompletableFuture<Void> future = emailService.sendTemplatedEmail(to, templateCode, Collections.emptyMap());

        future.join(); // Wait for async method to complete

        verify(mailSender).send(any(org.springframework.mail.SimpleMailMessage.class));
        verify(emailLogRepository).save(any());
    }
}
</file>

<file path="src/test/java/com/example/demo/communication/email/service/impl/EmailTemplateServiceImplTest.java">
package com.example.demo.communication.email.service.impl;

import com.example.demo.communication.email.dto.EmailTemplateDto;
import com.example.demo.communication.email.entity.EmailTemplate;
import com.example.demo.communication.email.repository.EmailTemplateRepository;
import com.example.demo.communication.email.service.impl.EmailTemplateServiceImpl;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.modelmapper.ModelMapper;

import java.util.Optional;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
public class EmailTemplateServiceImplTest {

    @Mock
    private EmailTemplateRepository emailTemplateRepository;

    @Mock
    private ModelMapper modelMapper;

    @InjectMocks
    private EmailTemplateServiceImpl emailTemplateService;

    @Test
    void createTemplate_shouldReturnEmailTemplateDto() {
        EmailTemplateDto templateDto = new EmailTemplateDto();
        templateDto.setName("Test Template");

        EmailTemplate template = new EmailTemplate();
        template.setName("Test Template");

        when(modelMapper.map(templateDto, EmailTemplate.class)).thenReturn(template);
        when(emailTemplateRepository.save(any(EmailTemplate.class))).thenReturn(template);
        when(modelMapper.map(template, EmailTemplateDto.class)).thenReturn(templateDto);

        EmailTemplateDto result = emailTemplateService.createTemplate(templateDto);

        assertNotNull(result);
        assertEquals(templateDto.getName(), result.getName());
    }

    @Test
    void getTemplateByCode_shouldReturnEmailTemplateDto() {
        String code = "test-code";
        EmailTemplate template = new EmailTemplate();
        template.setCode(code);

        EmailTemplateDto expectedDto = new EmailTemplateDto();
        expectedDto.setCode(code);

        when(emailTemplateRepository.findByCode(code)).thenReturn(Optional.of(template));
        when(modelMapper.map(template, EmailTemplateDto.class)).thenReturn(expectedDto);

        EmailTemplateDto result = emailTemplateService.getTemplateByCode(code);

        assertNotNull(result);
        assertEquals(expectedDto.getCode(), result.getCode());
    }
}
</file>

<file path="src/test/java/com/example/demo/communication/notification/controller/NotificationControllerTest.java">
package com.example.demo.communication.notification.controller;

import com.example.demo.communication.notification.dto.NotificationDto;
import com.example.demo.communication.notification.service.NotificationService;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.Pageable;
import org.springframework.http.MediaType;
import org.springframework.security.test.context.support.WithMockUser;
import org.springframework.test.context.bean.override.mockito.MockitoBean;
import org.springframework.test.web.servlet.MockMvc;

import java.util.Collections;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@WebMvcTest(NotificationController.class)
public class NotificationControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @MockitoBean
    private NotificationService notificationService;

    @Autowired
    private ObjectMapper objectMapper;

    @Test
    @WithMockUser(username = "1")
    void getMyNotifications_shouldReturnPageOfNotifications() throws Exception {
        NotificationDto notificationDto = new NotificationDto();
        notificationDto.setId(1L);
        notificationDto.setTitle("Test Title");
        Page<NotificationDto> page = new PageImpl<>(Collections.singletonList(notificationDto));

        when(notificationService.getUserNotifications(any(Long.class), any(Pageable.class))).thenReturn(page);

        mockMvc.perform(get("/api/v1/notifications/me")
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk());
    }
}
</file>

<file path=".kiro/specs/spring-backend/design.md">
# Design Document - Employee Management System

## Overview

The Employee Management System is a comprehensive enterprise-grade HR management solution built with Spring Boot 3.5.3 and Java 24. The system provides role-based access control, employee information management, department processing, payroll management, and communication features. It follows a layered architecture pattern with clear separation of concerns and leverages Spring Boot's auto-configuration capabilities.

## Architecture

### System Architecture

```mermaid
graph TB
    subgraph "Frontend Layer"
        UI[React Frontend]
        AXIOS[Axios HTTP Client]
        WS[WebSocket Client]
    end
    
    subgraph "Spring Boot Application"
        CTRL[Controllers Layer]
        SVC[Services Layer]
        REPO[Repository Layer]
        SEC[Spring Security + JWT]
        MAIL[Email Service]
        CHAT[WebSocket Chat Service]
        ENCRYPT[Encryption Service]
        AUDIT[Audit Service]
    end
    
    subgraph "Data Layer"
        PG[(PostgreSQL Database)]
        REDIS[(Redis Cache & Real-time)]
        FLYWAY[Flyway Migration]
    end
    
    UI --> AXIOS
    UI --> WS
    AXIOS --> CTRL
    WS --> CHAT
    CTRL --> SEC
    CTRL --> SVC
    SVC --> REPO
    SVC --> MAIL
    SVC --> ENCRYPT
    SVC --> AUDIT
    REPO --> PG
    CHAT --> REDIS
    SVC --> REDIS
    FLYWAY --> PG
```

### Hybrid Data Storage Strategy

The system uses a hybrid approach with PostgreSQL as the primary database and Redis for caching and real-time features:

**PostgreSQL (Primary Database):**
- All core business entities (User, Role, Resource, Employee, Department, Position, PayrollLedger)
- All transactional data with ACID compliance
- Relational integrity enforcement with foreign key constraints
- Complex queries, joins, and reporting capabilities
- Audit trails and historical data
- User authentication data and role assignments

**Redis (Cache & Real-time Only):**
- JWT token blacklisting for logout functionality
- Session data caching (not authentication state)
- Real-time chat messages and notifications
- Search result caching and frequently accessed data
- WebSocket connection management
- Department tree caching for performance

**Critical Design Principle:** Redis is used exclusively for caching and real-time features. All persistent, relational data must be stored in PostgreSQL to ensure data integrity, consistency, and proper transaction support.

### Technology Stack Integration

- **Backend**: Spring Boot 3.5.4 with Java 24
- **Security**: Spring Security with JWT authentication and role-based authorization
- **Primary Database**: PostgreSQL 15.x with JPA/Hibernate
- **Cache & Real-time**: Redis 7.x for caching and WebSocket features
- **Migration**: Flyway for database versioning and schema management
- **Email**: Spring Boot Mail with Freemarker templates
- **Encryption**: AES encryption for sensitive PII data
- **Build**: Maven with standard Spring Boot structure
- **Deployment**: Executable JAR with embedded Tomcat (modern approach)

## Components and Interfaces

### 1. Security and Permission Management

#### Permission Management Components
```java
// Core permission entities (PostgreSQL-based)
@Entity
@Table(name = "resources")
public class Resource {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private String url;
    private String method;
    private String description;
    private String category; // Resource category for organization
    private Boolean active = true;
    
    @CreatedDate
    private Instant createdAt;
    @LastModifiedDate
    private Instant updatedAt;
    private Long createdBy;
    private Long updatedBy;
}

@Entity
@Table(name = "roles")
public class Role {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private String description;
    private Boolean active = true;
    
    @CreatedDate
    private Instant createdAt;
    @LastModifiedDate
    private Instant updatedAt;
    private Long createdBy;
    private Long updatedBy;
    
    @ManyToMany
    @JoinTable(name = "role_resources")
    private Set<Resource> resources;
}

@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String username;
    private String password; // BCrypt encoded
    private String email;
    private Boolean enabled = true;
    private Integer loginAttempts = 0;
    private Boolean accountLocked = false;
    
    @CreatedDate
    private Instant createdAt;
    @LastModifiedDate
    private Instant updatedAt;
    private Long createdBy;
    private Long updatedBy;
    
    @ManyToMany
    @JoinTable(name = "user_roles")
    private Set<Role> roles;
}
```

#### Permission String Format
The system uses a standardized permission string format: `RESOURCE:ACTION`
- Examples: `EMPLOYEE:READ`, `EMPLOYEE:WRITE`, `DEPARTMENT:DELETE`, `PAYROLL:ADMIN`
- This format is used consistently across all authorization checks

#### Security Configuration
```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http);
    
    @Bean
    public PasswordEncoder passwordEncoder();
    
    @Bean
    public AuthenticationManager authenticationManager();
}
```

### 2. Department Management

#### Department Entity and Service
```java
@Entity
@Table(name = "departments")
public class Department {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private String code; // Unique department code
    private String description;
    private String depPath; // Materialized path for hierarchy
    private Long parentId;
    private Boolean isParent = false;
    private Integer level = 0;
    private Boolean enabled = true;
    private Long managerId; // Employee ID of department manager
    
    @CreatedDate
    private Instant createdAt;
    @LastModifiedDate
    private Instant updatedAt;
    private Long createdBy;
    private Long updatedBy;
    
    @ManyToOne
    @JoinColumn(name = "parent_id", insertable = false, updatable = false)
    private Department parent;
    
    @OneToMany(mappedBy = "parent")
    private Set<Department> children;
}

@Service
public class DepartmentService {
    public List<Department> getDepartmentTree();
    public Department createDepartment(DepartmentCreateRequest request);
    public void updateDepartment(Long id, DepartmentUpdateRequest request);
    public void deleteDepartment(Long id); // With dependency validation
    public void moveDepartment(Long id, Long newParentId); // Atomic path updates
}
```

### 3. Employee Management

#### Employee Entity and Related Services
```java
@Entity
@Table(name = "employees")
public class Employee {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String employeeNumber; // Unique
    private String firstName;
    private String lastName;
    private String email; // Unique
    private String phone;
    private Long departmentId;
    private Long positionId;
    private Long managerId;
    private LocalDate hireDate;
    private LocalDate terminationDate;
    
    @Enumerated(EnumType.STRING)
    private EmployeeStatus status; // ACTIVE, INACTIVE, TERMINATED, ON_LEAVE
    
    @Enumerated(EnumType.STRING)
    private EmploymentType employmentType; // FULL_TIME, PART_TIME, CONTRACT
    
    @Enumerated(EnumType.STRING)
    private PayType payType; // SALARY, HOURLY
    
    private BigDecimal salary; // For salaried employees
    private BigDecimal hourlyRate; // For hourly employees
    
    // Encrypted sensitive fields
    private String dateOfBirth; // Encrypted
    private String bankAccount; // Encrypted
    private String taxId; // Encrypted
    
    @CreatedDate
    private Instant createdAt;
    @LastModifiedDate
    private Instant updatedAt;
    private Long createdBy;
    private Long updatedBy;
    
    @ManyToOne
    @JoinColumn(name = "department_id", insertable = false, updatable = false)
    private Department department;
    
    @ManyToOne
    @JoinColumn(name = "position_id", insertable = false, updatable = false)
    private Position position;
}

@Service
public class EmployeeService {
    public Page<Employee> getEmployees(Pageable pageable, EmployeeSearchCriteria criteria);
    public Employee createEmployee(EmployeeCreateRequest request);
    public void updateEmployee(Long id, EmployeeUpdateRequest request);
    public void deleteEmployees(List<Long> ids); // Batch operation with validation
    public EmployeeImportResult importFromExcel(MultipartFile file);
    public byte[] exportToExcel(EmployeeExportRequest request);
}
```

### 4. Position and Title Management

#### Position Management Components
```java
@Entity
@Table(name = "positions")
public class Position {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String jobTitle;
    private String professionalTitle;
    private String code; // Unique position code
    private String description;
    private Long departmentId;
    
    @Enumerated(EnumType.STRING)
    private PositionLevel level; // JUNIOR, SENIOR, MANAGER, DIRECTOR
    
    @Enumerated(EnumType.STRING)
    private PositionCategory category; // TECHNICAL, MANAGEMENT, ADMINISTRATIVE
    
    private BigDecimal minSalary; // Salary range validation
    private BigDecimal maxSalary;
    private Boolean enabled = true;
    
    @CreatedDate
    private Instant createdAt;
    @LastModifiedDate
    private Instant updatedAt;
    private Long createdBy;
    private Long updatedBy;
    
    @ManyToOne
    @JoinColumn(name = "department_id", insertable = false, updatable = false)
    private Department department;
}

@Service
public class PositionService {
    public Page<Position> getPositions(Pageable pageable, PositionSearchCriteria criteria);
    public Position createPosition(PositionCreateRequest request);
    public void updatePosition(Long id, PositionUpdateRequest request);
    public void deletePosition(Long id); // With dependency validation
    public void validateSalaryRange(BigDecimal salary, Long positionId); // Business rule validation
}
```

### 5. Communication System

#### Email Service
```java
@Service
public class EmailService {
    @Async
    public void sendTemplatedEmail(String to, String template, Map<String, Object> variables);
    
    @Async
    public void sendBulkEmails(List<String> recipients, String template, Map<String, Object> variables);
}
```

#### Chat and Notification System
```java
@Entity
@Table(name = "notifications", indexes = {
    @Index(name = "idx_notification_user_id", columnList = "user_id"),
    @Index(name = "idx_notification_type", columnList = "type"),
    @Index(name = "idx_notification_read_status", columnList = "read_status")
})
@EntityListeners(AuditingEntityListener.class)
public class Notification {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
  
    @Column(name = "user_id", nullable = false)
    private Long userId;           // 目标用户
  
    @Column(name = "type", length = 50)
    private String type;           // SYSTEM, EMAIL, CHAT, TASK, etc.
  
    @Column(name = "title", length = 255)
    private String title;
  
    @Column(name = "content", columnDefinition = "TEXT")
    private String content;
  
    @Column(name = "data", columnDefinition = "TEXT")
    private String data;           // 附加的 JSON 数据
  
    @Column(name = "read_status", nullable = false)
    private Boolean read = false;
  
    @Column(name = "priority", length = 20)
    private String priority;       // LOW, MEDIUM, HIGH, URGENT
  
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;     // 时区无关的时间戳
  
    @Column(name = "read_at")
    private Instant readAt;        // 时区无关的时间戳
  
    @Column(name = "expires_at")
    private Instant expiresAt;     // 时区无关的时间戳
  
    @Column(name = "action_url", length = 500)
    private String actionUrl;
  
    @Column(name = "related_entity_id")
    private Long relatedEntityId;
  
    @Column(name = "related_entity_type", length = 50)
    private String relatedEntityType;
}


@Service
public class NotificationService {
    public void createNotification(Long userId, String content);
    public List<SystemMessage> getUserNotifications(Long userId);
    public void markAsRead(Long messageId, Long userId);
}

#### Chat and Announcement Entities
```java
@Entity
@Table(name = "chat_rooms")
public class ChatRoom {
    @Id
    private Long id;
    private String name;
    @Enumerated(EnumType.STRING)
    private ChatRoomType type; // DIRECT, GROUP, CHANNEL
    private Long createdBy;
    
    @OneToMany(mappedBy = "room", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<ChatParticipant> participants;
}

@Entity
@Table(name = "chat_participants")
public class ChatParticipant {
    @Id
    private Long id;
    
    @ManyToOne
    @JoinColumn(name = "room_id")
    private ChatRoom room;
    
    private Long userId;
    
    @Enumerated(EnumType.STRING)
    private ChatParticipantRole role; // OWNER, ADMIN, MEMBER
}

@Entity
@Table(name = "chat_messages")
public class ChatMessage {
    @Id
    private Long id;
    
    @ManyToOne
    @JoinColumn(name = "room_id")
    private ChatRoom room;
    
    private Long senderId;
    private String content;
    
    @Enumerated(EnumType.STRING)
    private ChatMessageType messageType; // TEXT, IMAGE, FILE, SYSTEM
}

@Entity
@Table(name = "announcements")
public class Announcement {
    @Id
    private Long id;
    private String title;
    private String content;
    private Long authorId;
    @Enumerated(EnumType.STRING)
    private AnnouncementTarget targetAudience; // ALL, DEPARTMENT, ROLE
    private boolean published;
}
```
```

### 6. Payroll Management

#### Payroll Components
```java
@Entity
@Table(name = "payroll_ledgers")
public class PayrollLedger {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private Long employeeId;
    private String employeeNumber; // Snapshot for historical accuracy
    
    // Employee details at time of payroll (for historical accuracy)
    private String employeeFirstName;
    private String employeeLastName;
    private String departmentName;
    private String positionTitle;
    
    @Enumerated(EnumType.STRING)
    private PayType payType; // SALARY, HOURLY
    
    private BigDecimal baseSalary;
    private BigDecimal hourlyRate;
    private Integer hoursWorked; // For hourly employees
    private BigDecimal overtimeHours;
    private BigDecimal overtimeRate;
    private BigDecimal allowances;
    private BigDecimal deductions;
    private BigDecimal grossPay;
    private BigDecimal netSalary;
    
    private LocalDate payPeriodStart;
    private LocalDate payPeriodEnd;
    
    @Enumerated(EnumType.STRING)
    private PayrollStatus status; // DRAFT, APPROVED, PAID, CANCELLED
    
    @CreatedDate
    private Instant createdAt;
    @LastModifiedDate
    private Instant updatedAt;
    private Long createdBy;
    private Long updatedBy;
    private Long approvedBy;
    private Instant approvedAt;
    
    @ManyToOne
    @JoinColumn(name = "employee_id", insertable = false, updatable = false)
    private Employee employee;
}

@Service
public class PayrollService {
    public PayrollLedger createPayrollLedger(PayrollCreateRequest request);
    public PayrollLedger getPayrollLedger(Long id);
    public void updatePayrollLedger(Long id, PayrollUpdateRequest request);
    public Page<PayrollLedger> getEmployeePayrollHistory(Long employeeId, Pageable pageable);
    public void approvePayroll(Long id, Long approverId);
    public PayrollCalculationResult calculatePayroll(Long employeeId, LocalDate periodStart, LocalDate periodEnd);
}
```

## Data Models

### Database Schema Design

#### PostgreSQL Core Tables Structure
```sql
-- User Management (PostgreSQL)
users (id, username, password, email, enabled, login_attempts, account_locked, created_at, updated_at, created_by, updated_by)
roles (id, name, description, active, created_at, updated_at, created_by, updated_by)
resources (id, name, url, method, description, category, active, created_at, updated_at, created_by, updated_by)
user_roles (user_id, role_id)
role_resources (role_id, resource_id)

-- Organization Structure (PostgreSQL)
departments (id, name, code, description, dep_path, parent_id, is_parent, level, enabled, manager_id, created_at, updated_at, created_by, updated_by)
positions (id, job_title, professional_title, code, description, department_id, level, category, min_salary, max_salary, enabled, created_at, updated_at, created_by, updated_by)

-- Employee Management (PostgreSQL)
employees (id, employee_number, first_name, last_name, email, phone, department_id, position_id, manager_id, hire_date, termination_date, status, employment_type, pay_type, salary, hourly_rate, date_of_birth_encrypted, bank_account_encrypted, tax_id_encrypted, created_at, updated_at, created_by, updated_by)

-- Communication (PostgreSQL for persistence, Redis for real-time)
email_templates (id, name, code, subject, content, template_type, category, active, variables, created_at, updated_at, created_by, updated_by)
email_logs (id, template_code, to_email, cc_emails, bcc_emails, subject, content, status, sent_at, error_message, retry_count, sent_by, created_at, updated_at)
chat_rooms (id, name, type, description, created_by, is_active, created_at, updated_at, last_message_at)
chat_participants (id, room_id, user_id, role, joined_at, last_read_at, is_muted)
chat_messages (id, room_id, sender_id, content, message_type, created_at, is_edited, is_deleted)
announcements (id, title, content, author_id, target_audience, department_id, publish_date, expiry_date, published, created_at, updated_at)
notifications (id, user_id, title, content, type, priority, is_read, read_at, created_at, updated_at)

-- Payroll (PostgreSQL)
payroll_ledgers (id, employee_id, employee_number, employee_first_name, employee_last_name, department_name, position_title, pay_type, base_salary, hourly_rate, hours_worked, overtime_hours, overtime_rate, allowances, deductions, gross_pay, net_salary, pay_period_start, pay_period_end, status, created_at, updated_at, created_by, updated_by, approved_by, approved_at)

-- Audit Trail (PostgreSQL)
audit_logs (id, table_name, record_id, action, old_values, new_values, user_id, created_at)
```

### Redis Data Structure (Caching Only)

#### Caching Strategy
```java
// JWT token blacklisting (for logout)
"jwt:blacklist:{tokenId}" -> expiration timestamp

// Permission caching
"user:permissions:{userId}" -> Set<String> permissions (TTL: 30 minutes)

// Department tree caching
"department:tree" -> Department tree structure (TTL: 1 hour)

// Employee search cache
"employee:search:{hash}" -> Page<Employee> results (TTL: 15 minutes)

// Real-time chat messages (temporary storage)
"chat:room:{roomId}:messages" -> List<ChatMessage> (TTL: 24 hours)

// WebSocket session management
"websocket:sessions:{userId}" -> Set<String> sessionIds

// Notification queue
"notifications:user:{userId}" -> List<Notification> (TTL: 7 days)
```

**Important:** Redis is used exclusively for caching and real-time features. All persistent data is stored in PostgreSQL.

## Error Handling

### Unified Exception Handling

#### Global Exception Handler
```java
@ControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(ValidationException.class)
    public ResponseEntity<ErrorResponse> handleValidation(ValidationException ex);
    
    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity<ErrorResponse> handleAccessDenied(AccessDeniedException ex);
    
    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<ErrorResponse> handleDataIntegrity(DataIntegrityViolationException ex);
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGeneral(Exception ex);
}
```

#### Custom Exception Types
```java
public class EmployeeNotFoundException extends RuntimeException;
public class DepartmentHierarchyException extends RuntimeException;
public class PayrollCalculationException extends RuntimeException;
public class EmailSendingException extends RuntimeException;
public class ImportValidationException extends RuntimeException;
```

### Frontend Error Handling

#### Axios Interceptor Configuration
```javascript
// Request interceptor for authentication
axios.interceptors.request.use(config => {
    const token = localStorage.getItem('token');
    if (token) {
        config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
});

// Response interceptor for error handling
axios.interceptors.response.use(
    response => response,
    error => {
        if (error.response.status === 401) {
            // Handle authentication errors
        } else if (error.response.status === 403) {
            // Handle authorization errors
        }
        return Promise.reject(error);
    }
);
```

## Testing Strategy

### Unit Testing Approach

#### Service Layer Testing
```java
@ExtendWith(MockitoExtension.class)
class EmployeeServiceTest {
    @Mock
    private EmployeeRepository employeeRepository;
    
    @InjectMocks
    private EmployeeService employeeService;
    
    @Test
    void shouldCreateEmployeeSuccessfully();
    
    @Test
    void shouldThrowExceptionWhenEmployeeNumberExists();
}
```

#### Repository Testing
```java
@DataRedisTest
class EmployeeRepositoryTest {
    @Autowired
    private TestEntityManager entityManager;
    
    @Autowired
    private EmployeeRepository employeeRepository;
    
    @Test
    void shouldFindEmployeesByDepartment();
    
    @Test
    void shouldSupportPaginationAndSorting();
}
```

### Integration Testing

#### Web Layer Testing
```java
@SpringBootTest
@AutoConfigureTestDatabase
class EmployeeControllerIntegrationTest {
    @Autowired
    private MockMvc mockMvc;
    
    @Test
    @WithMockUser(roles = "HR_MANAGER")
    void shouldCreateEmployeeWithValidData();
    
    @Test
    @WithMockUser(roles = "EMPLOYEE")
    void shouldDenyAccessToRestrictedEndpoints();
}
```

### Security Testing

#### Authentication and Authorization Tests
```java
@SpringBootTest
@AutoConfigureTestDatabase
class SecurityIntegrationTest {
    @Test
    void shouldAuthenticateValidUser();
    
    @Test
    void shouldDenyAccessWithoutPermission();
    
    @Test
    void shouldLoadUserPermissionsDynamically();
}
```

### Performance Testing

#### Load Testing Strategy
- Use JMeter for API endpoint load testing
- Test concurrent user scenarios for chat functionality
- Validate database performance with large datasets
- Monitor Redis cache hit rates and performance

### Email and Notification Testing

#### Async Service Testing
```java
@SpringBootTest
class EmailServiceTest {
    @MockBean
    private JavaMailSender mailSender;
    
    @Test
    void shouldSendTemplatedEmailAsynchronously();
    
    @Test
    void shouldHandleEmailSendingFailures();
}
```

## API Design Patterns

### DTO Design Strategy

#### Request/Response DTO Separation
```java
// Separate DTOs for different operations
public class EmployeeDto {
    private Long id;
    private String employeeNumber;
    private String firstName;
    private String lastName;
    private String email;
    private DepartmentDto department;
    private PositionDto position;
    private Instant createdAt;
    private Instant updatedAt;
    // Read-only fields included
}

public class EmployeeCreateRequest {
    @NotBlank
    private String firstName;
    @NotBlank
    private String lastName;
    @Email
    private String email;
    private Long departmentId;
    private Long positionId;
    // No id, createdAt, updatedAt fields
}

public class EmployeeUpdateRequest {
    @NotBlank
    private String firstName;
    @NotBlank
    private String lastName;
    @Email
    private String email;
    private Long departmentId;
    private Long positionId;
    // No id, createdAt, updatedAt fields
}
```

#### Hierarchical Data DTOs
```java
// Safe hierarchical DTOs without circular references
public class DepartmentTreeDto {
    private Long id;
    private String name;
    private String code;
    private List<DepartmentTreeDto> children; // Only children, no parent reference
}

public class DepartmentDto {
    private Long id;
    private String name;
    private String code;
    private Long parentId; // Reference by ID only
    private String parentName; // Denormalized for display
}
```

#### Batch Operation DTOs
```java
public class BatchDeleteRequest {
    @NotEmpty
    private List<Long> ids;
    private String reason; // Audit trail
}

public class BatchOperationResult {
    private int totalRequested;
    private int successful;
    private int failed;
    private List<BatchError> errors;
}
```

## Implementation Considerations

### Security Implementation
- Use Spring Security's method-level security with @PreAuthorize("hasPermission(#id, 'EMPLOYEE', 'READ')")
- Implement stateless JWT authentication (no Redis sessions for auth state)
- Use JWT token blacklisting in Redis for logout functionality
- Use BCrypt for password hashing with proper salt rounds
- Implement field-level encryption for sensitive PII data

### Data Integrity and Validation
- Use PostgreSQL foreign key constraints for referential integrity
- Implement business rule validation in service layer
- Use Instant timestamps for all temporal data (time-zone aware)
- Implement comprehensive audit trails for all critical entities
- Use enum types instead of string fields for fixed value sets

### Performance Optimization
- Implement Redis caching for frequently accessed data (department trees, user permissions)
- Use PostgreSQL connection pooling with HikariCP
- Implement proper database indexing for query performance
- Use async processing for email sending and heavy operations
- Implement pagination for all list endpoints

### API Design Best Practices
- Use dedicated CreateRequest and UpdateRequest DTOs
- Implement proper batch operation endpoints
- Avoid circular references in hierarchical DTOs
- Use consistent error response formats
- Implement proper HTTP status codes and error messages

### Scalability Considerations
- Design stateless services for horizontal scaling
- Use Redis for distributed caching only (not primary data)
- Implement proper database indexing and query optimization
- Use connection pooling for database access
- Implement async processing for non-critical operations

### Monitoring and Logging
- Use Spring Boot Actuator for health checks and metrics
- Implement structured logging with correlation IDs
- Monitor PostgreSQL and Redis performance separately
- Track business metrics (login attempts, payroll processing, etc.)
- Implement comprehensive error tracking and alerting
</file>

<file path=".kiro/steering/tech.md">
# Technology Stack

## Backend Technologies (Spring Boot)

### Core Technologies
- **Java 24** - Primary programming language
- **Spring Boot 3.5.4** - Application framework
- **Maven** - Build system and dependency management
- **PostgreSQL 15.x** - Primary database for persistent data
- **Redis 7.x** - Cache layer and real-time features
- **Tomcat** - Embedded servlet container (executable JAR deployment)

### Key Dependencies
- **Spring Boot Starter Web** - Web layer with Spring MVC
- **Spring Boot Starter WebSocket** - Real-time communication support
- **Spring Boot Starter Security** - JWT authentication and authorization
- **Spring Boot Starter Data JPA** - PostgreSQL database access layer
- **Spring Boot Starter Data Redis** - Redis caching and real-time features
- **PostgreSQL JDBC Driver** - Database connectivity
- **Flyway** - Database migration and versioning
- **Spring Boot Starter Mail** - Email functionality with templates
- **Spring Boot Starter Actuator** - Production monitoring and management
- **Spring Boot DevTools** - Development-time features (hot reload)
- **Lombok** - Code generation for boilerplate reduction
- **Spring Boot Configuration Processor** - Configuration metadata generation
- **Apache POI** - Excel import/export functionality
- **JWT Libraries** - JSON Web Token support for stateless authentication

### Backend Build Commands

#### Development
```bash
# Run the application in development mode
mvn spring-boot:run

# Run with specific profile
mvn spring-boot:run -Dspring-boot.run.profiles=dev
```

#### Build & Test
```bash
# Clean and compile
mvn clean compile

# Run tests
mvn test

# Package as executable JAR
mvn clean package

# Skip tests during build
mvn clean package -DskipTests
```

#### Useful Development Commands
```bash
# Generate sources (Lombok processing)
mvn generate-sources

# Check for dependency updates
mvn versions:display-dependency-updates
```

## Frontend Technologies (React)

### Core Technologies
- **React 18+** - Frontend framework with modern features
- **TypeScript** - Type-safe JavaScript development
- **Vite** - Fast build tool and development server
- **Node.js** - JavaScript runtime for development tools

### State Management
- **Zustand** - Lightweight global state management
- **TanStack Query (React Query)** - Server state management and caching
- **React Hook Form** - Form state management and validation

### UI and Styling
- **Mantine** - Comprehensive React component library
- **CSS Modules** - Scoped styling with Mantine theming
- **React Router v6** - Client-side routing

### Real-time and Communication
- **Socket.IO Client** - WebSocket client for real-time features
- **Axios** - HTTP client for API communication

### Development and Testing
- **Vitest** - Fast unit test runner
- **React Testing Library** - Component testing utilities
- **MSW (Mock Service Worker)** - API mocking for tests
- **Playwright** - End-to-end testing framework
- **ESLint + Prettier** - Code quality and formatting
- **TypeScript Strict Mode** - Enhanced type checking

### Validation and Forms
- **Zod** - Runtime type validation and schema definition
- **React Hook Form** - Performant form management

### Frontend Build Commands

#### Development
```bash
# Install dependencies
npm install

# Start development server
npm run dev

# Start development server with specific port
npm run dev -- --port 3000
```

#### Build & Test
```bash
# Build for production
npm run build

# Preview production build
npm run preview

# Run unit tests
npm run test

# Run tests in watch mode
npm run test:watch

# Run E2E tests
npm run test:e2e

# Type checking
npm run type-check

# Linting
npm run lint

# Format code
npm run format
```

#### Quality Assurance
```bash
# Run all tests with coverage
npm run test:coverage

# Bundle analysis
npm run analyze

# Accessibility audit
npm run a11y
```

## Database Architecture

### Hybrid Data Storage Strategy
The system uses a hybrid approach combining PostgreSQL and Redis:

**PostgreSQL (Primary Database):**
- Core business entities (Employee, Department, Position, User, Role)
- Transactional data (Payroll, Audit logs)
- Relational integrity enforcement
- Complex queries and reporting
- ACID compliance for critical operations

**Redis (Cache & Real-time):**
- Session management and JWT token blacklisting
- Real-time chat messages and notifications
- Search result caching
- Frequently accessed data caching
- WebSocket connection management

### Database Setup Requirements
```bash
# PostgreSQL setup (required)
# Install PostgreSQL 15.x
# Create database: employee_management
# Create user with appropriate permissions

# Redis setup (required)
# Install Redis 7.x
# Configure for persistence and caching
```

## Development Workflow

### Full-Stack Development
1. **Database Setup**: Ensure PostgreSQL and Redis are running
2. **Backend First**: Start Spring Boot application for API development
3. **Database Migration**: Run Flyway migrations on startup
4. **Frontend Development**: Use Vite dev server with proxy to backend
5. **Real-time Features**: Ensure WebSocket endpoints and Redis are running
6. **Testing**: Run both backend and frontend tests
7. **Integration**: Test full-stack features end-to-end

### Recommended Development Setup
```bash
# Terminal 1: Database Services
# Start PostgreSQL service
# Start Redis service

# Terminal 2: Backend
cd demo
mvn spring-boot:run

# Terminal 3: Frontend
cd frontend
npm run dev

# Terminal 4: Testing (as needed)
npm run test:watch
```

## Code Style and Best Practices

### Backend (Spring Boot)
- Use Lombok annotations to reduce boilerplate code
- Follow Spring Boot conventions for package structure
- Leverage Spring Boot's auto-configuration capabilities
- Use Maven commands directly (not wrapper scripts)
- Implement proper exception handling and validation
- Use DTOs for API responses to avoid exposing entities
- Implement comprehensive logging with SLF4J
- **Database Best Practices:**
  - Use JPA entities with proper relationships and constraints
  - Implement Flyway migrations for all schema changes
  - Use @Transactional for data consistency
  - Apply field-level encryption for sensitive PII data
  - Implement audit trails with @CreatedDate and @LastModifiedDate
- **Security Best Practices:**
  - Use JWT tokens for stateless authentication
  - Implement role-based access control with @PreAuthorize
  - Apply permission-based data filtering in repositories
  - Encrypt sensitive fields (dateOfBirth, bankAccount, taxId)
  - Maintain comprehensive audit logs
- **Caching Strategy:**
  - Use Redis for session management and frequently accessed data
  - Implement @Cacheable annotations for expensive operations
  - Cache department trees and user permissions
  - Use Redis for real-time chat and notification features

### Frontend (React)
- Use TypeScript strict mode for enhanced type safety
- Follow functional component patterns with hooks
- Implement proper error boundaries for error handling
- Use feature-based folder organization
- Write comprehensive tests for components and hooks
- Ensure accessibility compliance (WCAG 2.1)
- Implement proper loading states and user feedback
- Use semantic HTML and proper ARIA labels
- Follow React best practices for performance optimization

### Integration
- Use consistent API response formats between backend and frontend
- Implement proper error handling across the full stack
- Ensure real-time features work reliably with WebSocket connections
- Maintain type safety between backend DTOs and frontend interfaces
- Use environment variables for configuration management
- **Database Integration:**
  - Ensure PostgreSQL and Redis are properly configured
  - Use connection pooling for optimal performance
  - Implement proper transaction boundaries
  - Handle database migrations gracefully
- **Security Integration:**
  - Implement JWT token validation on frontend
  - Handle token refresh and expiration
  - Ensure encrypted data is properly handled
  - Maintain audit trail consistency
- **Real-time Integration:**
  - Use WebSocket for chat and notifications
  - Implement proper connection management
  - Handle reconnection and error scenarios
  - Ensure message delivery reliability

## Environment Configuration

### Development Environment Setup

#### PostgreSQL Configuration
```properties
# application-dev.properties
spring.datasource.url=jdbc:postgresql://localhost:5432/employee_management
spring.datasource.username=employee_admin
spring.datasource.password=dev_password
spring.datasource.driver-class-name=org.postgresql.Driver

# JPA Configuration
spring.jpa.hibernate.ddl-auto=validate
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.properties.hibernate.format_sql=true

# Flyway Configuration
spring.flyway.enabled=true
spring.flyway.locations=classpath:db/migration
spring.flyway.baseline-on-migrate=true
```

#### Redis Configuration
```properties
# Redis Configuration
spring.redis.host=localhost
spring.redis.port=6379
spring.redis.database=0
spring.redis.timeout=2000ms
spring.redis.jedis.pool.max-active=8
spring.redis.jedis.pool.max-idle=8

# Cache Configuration
spring.cache.type=redis
spring.cache.redis.time-to-live=600000
```

#### Security Configuration
```properties
# JWT Configuration
jwt.secret=${JWT_SECRET:mySecretKey}
jwt.expiration=86400000
jwt.refresh-expiration=604800000

# Encryption Configuration
encryption.key=${ENCRYPTION_KEY:myEncryptionKey}
```

### Production Environment Setup

#### Database Connection Pooling
```properties
# application-prod.properties
spring.datasource.hikari.maximum-pool-size=20
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.idle-timeout=300000
spring.datasource.hikari.connection-timeout=20000
spring.datasource.hikari.max-lifetime=1200000
```

#### Security Hardening
```properties
# Production Security
server.error.include-message=never
server.error.include-binding-errors=never
server.error.include-stacktrace=never
server.error.include-exception=false

# SSL Configuration (if applicable)
server.ssl.enabled=true
server.ssl.key-store=classpath:keystore.p12
server.ssl.key-store-password=${SSL_PASSWORD}
server.ssl.key-store-type=PKCS12
```

### Docker Configuration (Optional)

#### Docker Compose for Development
```yaml
# docker-compose.yml
version: '3.8'
services:
  postgres:
    image: postgres:15
    environment:
      POSTGRES_DB: employee_management
      POSTGRES_USER: employee_admin
      POSTGRES_PASSWORD: dev_password
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

volumes:
  postgres_data:
  redis_data:
```

### Testing Configuration

#### Test Database Setup
```properties
# application-test.properties
spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driver-class-name=org.h2.Driver
spring.jpa.hibernate.ddl-auto=create-drop

# Disable Redis for unit tests
spring.cache.type=none
spring.redis.host=localhost
spring.redis.port=6370
```

#### Integration Test Configuration
```properties
# Use TestContainers for integration tests
spring.test.database.replace=none
testcontainers.postgresql.image=postgres:15
testcontainers.redis.image=redis:7-alpine
```

## Troubleshooting

### Common Database Issues
- **Connection refused**: Ensure PostgreSQL service is running
- **Authentication failed**: Check username/password in configuration
- **Migration failed**: Verify Flyway scripts and database permissions
- **Redis connection timeout**: Check Redis service status and configuration

### Performance Optimization
- **Slow queries**: Add appropriate database indexes
- **High memory usage**: Tune JPA batch sizes and connection pool
- **Cache misses**: Review Redis cache configuration and TTL settings
- **WebSocket issues**: Check Redis pub/sub configuration for real-time features

### Security Considerations
- **JWT token security**: Use strong secret keys and proper expiration
- **Database encryption**: Ensure sensitive fields are properly encrypted
- **Audit trail**: Verify all user actions are logged with proper context
- **Permission checks**: Test role-based access control thoroughly
</file>

<file path="src/main/java/com/example/demo/config/RedisConfig.java">
package com.example.demo.config;

import com.fasterxml.jackson.annotation.JsonAutoDetect;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.annotation.PropertyAccessor;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.jsontype.impl.LaissezFaireSubTypeValidator;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.cache.CacheManager;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.cache.RedisCacheConfiguration;
import org.springframework.data.redis.cache.RedisCacheManager;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.connection.RedisStandaloneConfiguration;
import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.repository.configuration.EnableRedisRepositories;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;

import java.time.Duration;
import java.util.HashMap;
import java.util.Map;

/**
 * Redis Configuration for caching and real-time features.
 * 
 * Configures Redis connection, serialization, caching, and templates
 * for both caching and real-time messaging functionality.
 */
@Configuration
@EnableCaching
@EnableRedisRepositories(basePackages = "com.example.demo.communication.chat.repository")
public class RedisConfig {

    @Value("${spring.data.redis.host:localhost}")
    private String redisHost;

    @Value("${spring.data.redis.port:6379}")
    private int redisPort;

    @Value("${spring.data.redis.password:}")
    private String redisPassword;

    @Value("${spring.data.redis.database:0}")
    private int redisDatabase;

    /**
     * Redis Connection Factory configuration
     */
    @Bean
    public RedisConnectionFactory redisConnectionFactory() {
        RedisStandaloneConfiguration redisConfig = new RedisStandaloneConfiguration();
        redisConfig.setHostName(redisHost);
        redisConfig.setPort(redisPort);
        redisConfig.setDatabase(redisDatabase);

        if (redisPassword != null && !redisPassword.trim().isEmpty()) {
            redisConfig.setPassword(redisPassword);
        }

        LettuceConnectionFactory factory = new LettuceConnectionFactory(redisConfig);
        factory.setValidateConnection(true);

        return factory;
    }

    /**
     * Redis Template for general Redis operations
     */
    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(connectionFactory);

        // Configure JSON serialization
        ObjectMapper objectMapper = createObjectMapper();
        GenericJackson2JsonRedisSerializer jsonSerializer = new GenericJackson2JsonRedisSerializer(objectMapper);

        // Key serialization
        template.setKeySerializer(new StringRedisSerializer());
        template.setHashKeySerializer(new StringRedisSerializer());

        // Value serialization
        template.setValueSerializer(jsonSerializer);
        template.setHashValueSerializer(jsonSerializer);

        template.setDefaultSerializer(jsonSerializer);
        template.afterPropertiesSet();

        return template;
    }



    /**
     * Cache Manager configuration with different TTL for different cache types
     */
    @Bean
    public CacheManager cacheManager(RedisConnectionFactory connectionFactory) {
        ObjectMapper objectMapper = createObjectMapper();
        GenericJackson2JsonRedisSerializer jsonSerializer = new GenericJackson2JsonRedisSerializer(objectMapper);

        // Default cache configuration
        RedisCacheConfiguration defaultConfig = RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofMinutes(10))
                .serializeKeysWith(org.springframework.data.redis.serializer.RedisSerializationContext.SerializationPair
                        .fromSerializer(new StringRedisSerializer()))
                .serializeValuesWith(
                        org.springframework.data.redis.serializer.RedisSerializationContext.SerializationPair
                                .fromSerializer(jsonSerializer))
                .disableCachingNullValues();

        // Specific cache configurations
        Map<String, RedisCacheConfiguration> cacheConfigurations = new HashMap<>();

        // User cache - 30 minutes TTL
        cacheConfigurations.put("users", defaultConfig.entryTtl(Duration.ofMinutes(30)));

        // Department cache - 1 hour TTL (departments change less frequently)
        cacheConfigurations.put("departments", defaultConfig.entryTtl(Duration.ofHours(1)));

        // Position cache - 1 hour TTL
        cacheConfigurations.put("positions", defaultConfig.entryTtl(Duration.ofHours(1)));

        // Employee cache - 15 minutes TTL
        cacheConfigurations.put("employees", defaultConfig.entryTtl(Duration.ofMinutes(15)));

        // Permission cache - 1 hour TTL
        cacheConfigurations.put("permissions", defaultConfig.entryTtl(Duration.ofHours(1)));

        // Session cache - 30 minutes TTL
        cacheConfigurations.put("sessions", defaultConfig.entryTtl(Duration.ofMinutes(30)));

        // Email template cache - 2 hours TTL
        cacheConfigurations.put("email-templates", defaultConfig.entryTtl(Duration.ofHours(2)));

        return RedisCacheManager.builder(connectionFactory)
                .cacheDefaults(defaultConfig)
                .withInitialCacheConfigurations(cacheConfigurations)
                .build();
    }

    /**
     * Creates ObjectMapper for Redis JSON serialization
     */
    private ObjectMapper createObjectMapper() {
        ObjectMapper objectMapper = new ObjectMapper();

        // Register JavaTimeModule for LocalDateTime, LocalDate support
        objectMapper.registerModule(new JavaTimeModule());

        // Configure visibility
        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);

        // Enable type information for polymorphic serialization
        objectMapper.activateDefaultTyping(
                LaissezFaireSubTypeValidator.instance,
                ObjectMapper.DefaultTyping.NON_FINAL,
                JsonTypeInfo.As.PROPERTY);

        return objectMapper;
    }

    /**
     * Health check bean for Redis connectivity
     */
    @Bean
    public RedisHealthIndicator redisHealthIndicator(RedisTemplate<String, Object> redisTemplate) {
        return new RedisHealthIndicator(redisTemplate);
    }

    /**
     * Custom health indicator for Redis
     */
    public static class RedisHealthIndicator {
        private final RedisTemplate<String, Object> redisTemplate;

        public RedisHealthIndicator(RedisTemplate<String, Object> redisTemplate) {
            this.redisTemplate = redisTemplate;
        }

        public boolean isRedisAvailable() {
            try {
                RedisConnectionFactory connectionFactory = redisTemplate.getConnectionFactory();
                if (connectionFactory == null) {
                    return false;
                }
                connectionFactory.getConnection().ping();
                return true;
            } catch (Exception e) {
                return false;
            }
        }

        public String getRedisInfo() {
            try {
                RedisConnectionFactory connectionFactory = redisTemplate.getConnectionFactory();
                if (connectionFactory == null) {
                    return "Unable to retrieve Redis info";
                }
                return connectionFactory.getConnection().info().getProperty("redis_version");
            } catch (Exception e) {
                return "Unable to retrieve Redis info";
            }
        }
    }
}
</file>

<file path="src/main/java/com/example/demo/employee/entity/Employee.java">
package com.example.demo.employee.entity;

import com.example.demo.security.security.EncryptedStringConverter;
import com.example.demo.department.entity.Department;
import com.example.demo.position.entity.Position;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.math.BigDecimal;
import java.time.Instant;
import java.time.LocalDate;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "employees",
    indexes = {
        @Index(name = "idx_employee_number", columnList = "employee_number", unique = true),
        @Index(name = "idx_employee_email", columnList = "email", unique = true),
        @Index(name = "idx_employee_department_id", columnList = "department_id"),
        @Index(name = "idx_employee_position_id", columnList = "position_id"),
        @Index(name = "idx_employee_status", columnList = "status"),
        @Index(name = "idx_employee_last_name", columnList = "last_name")
    }
)
@EntityListeners(AuditingEntityListener.class)
@Getter
@Setter
public class Employee {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "employee_number", nullable = false, unique = true, length = 20)
    private String employeeNumber;

    @Column(name = "first_name", nullable = false, length = 50)
    private String firstName;

    @Column(name = "last_name", nullable = false, length = 50)
    private String lastName;

    @Column(name = "email", nullable = false, unique = true, length = 100)
    private String email;

    @Column(name = "phone", length = 20)
    private String phone;

    @Column(name = "mobile_phone", length = 20)
    private String mobilePhone;

    @Column(name = "address", length = 255)
    private String address;

    @Column(name = "city", length = 100)
    private String city;

    @Column(name = "state", length = 100)
    private String state;

    @Column(name = "zip_code", length = 20)
    private String zipCode;

    @Column(name = "country", length = 100)
    private String country;

    @Convert(converter = EncryptedStringConverter.class)
    @Column(name = "date_of_birth_encrypted")
    private String dateOfBirth; // Encrypted

    @Enumerated(EnumType.STRING)
    @Column(name = "gender", length = 20)
    private Gender gender;

    @Enumerated(EnumType.STRING)
    @Column(name = "marital_status", length = 20)
    private MaritalStatus maritalStatus;

    @Column(name = "nationality", length = 50)
    private String nationality;

    @Column(name = "department_id", nullable = false)
    private Long departmentId;

    @Column(name = "position_id")
    private Long positionId;

    @Column(name = "manager_id")
    private Long managerId;

    @Column(name = "hire_date", nullable = false)
    private LocalDate hireDate;

    @Column(name = "termination_date")
    private LocalDate terminationDate;

    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 20)
    private EmployeeStatus status = EmployeeStatus.ACTIVE;

    @Enumerated(EnumType.STRING)
    @Column(name = "employment_type", nullable = false, length = 20)
    private EmploymentType employmentType = EmploymentType.FULL_TIME;

    @Enumerated(EnumType.STRING)
    @Column(name = "pay_type", nullable = false, length = 10)
    private PayType payType = PayType.SALARY;

    @Column(name = "salary", precision = 12, scale = 2)
    private BigDecimal salary;

    @Column(name = "hourly_rate", precision = 8, scale = 2)
    private BigDecimal hourlyRate;

    @Convert(converter = EncryptedStringConverter.class)
    @Column(name = "bank_account_encrypted")
    private String bankAccount; // Encrypted

    @Convert(converter = EncryptedStringConverter.class)
    @Column(name = "tax_id_encrypted")
    private String taxId; // Encrypted

    @Column(name = "enabled", nullable = false)
    private boolean enabled = true;

    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;

    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;

    @Column(name = "created_by")
    private Long createdBy;

    @Column(name = "updated_by")
    private Long updatedBy;

    // Relationships
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "department_id", insertable = false, updatable = false)
    private Department department;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "position_id", insertable = false, updatable = false)
    private Position position;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "manager_id", insertable = false, updatable = false)
    private Employee manager;

    @OneToMany(mappedBy = "manager", fetch = FetchType.LAZY)
    private Set<Employee> directReports = new HashSet<>();

    // Helper methods
    public String getFullName() {
        return firstName + " " + lastName;
    }
}
</file>

<file path="src/main/java/com/example/demo/security/security/JwtAuthenticationFilter.java">
package com.example.demo.security.security;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.lang.NonNull;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Component
@RequiredArgsConstructor
@Slf4j
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtTokenProvider jwtTokenProvider;
    private final CustomUserDetailsService customUserDetailsService;
    private final RedisTemplate<String, Object> redisTemplate;

    private static final String AUTHORIZATION_HEADER = "Authorization";
    private static final String BEARER_PREFIX = "Bearer ";
    private static final String BLACKLIST_KEY_PREFIX = "jwt:blacklist:";

    @Override
    protected void doFilterInternal(@NonNull HttpServletRequest request,
            @NonNull HttpServletResponse response,
            @NonNull FilterChain filterChain) throws ServletException, IOException {

        try {
            String jwt = getJwtFromRequest(request);

            if (StringUtils.hasText(jwt)) {
                // Check if token is blacklisted
                if (isTokenBlacklisted(jwt)) {
                    log.debug("JWT token is blacklisted");
                    filterChain.doFilter(request, response);
                    return;
                }

                // Validate token
                if (jwtTokenProvider.validateToken(jwt)) {
                    String username = jwtTokenProvider.getUsernameFromToken(jwt);

                    // Load user details
                    UserDetails userDetails = customUserDetailsService.loadUserByUsername(username);

                    // Create authentication token
                    UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(
                            userDetails,
                            null,
                            userDetails.getAuthorities());

                    authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));

                    // Set authentication in security context
                    SecurityContextHolder.getContext().setAuthentication(authentication);

                    log.debug("JWT authentication successful for user: {}", username);
                } else {
                    log.debug("JWT token validation failed");
                }
            }
        } catch (Exception ex) {
            log.error("Could not set user authentication in security context", ex);

            // Clear security context on error
            SecurityContextHolder.clearContext();

            // Set error response
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            response.setContentType("application/json");
            response.getWriter().write("{\"error\":\"Invalid or expired token\"}");
            return;
        }

        filterChain.doFilter(request, response);
    }

    /**
     * Extract JWT token from request header
     */
    private String getJwtFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader(AUTHORIZATION_HEADER);

        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith(BEARER_PREFIX)) {
            return bearerToken.substring(BEARER_PREFIX.length());
        }

        return null;
    }

    /**
     * Check if token is blacklisted in Redis
     */
    private boolean isTokenBlacklisted(String token) {
        try {
            return Boolean.TRUE.equals(redisTemplate.hasKey(BLACKLIST_KEY_PREFIX + token));
        } catch (Exception ex) {
            log.error("Error checking token blacklist status", ex);
            // If Redis is down, allow the request to proceed
            return false;
        }
    }

    /**
     * Skip JWT authentication for certain paths
     */
    @Override
    protected boolean shouldNotFilter(@NonNull HttpServletRequest request) throws ServletException {
        String path = request.getRequestURI();

        // Skip authentication for public endpoints
        return path.startsWith("/api/auth/login") ||
                path.startsWith("/api/auth/register") ||
                path.startsWith("/api/public/") ||
                path.startsWith("/actuator/health") ||
                path.startsWith("/swagger-ui/") ||
                path.startsWith("/v3/api-docs") ||
                path.startsWith("/favicon.ico");
    }
}
</file>

<file path="src/test/java/com/example/demo/department/controller/DepartmentControllerTest.java">
package com.example.demo.department.controller;

import com.example.demo.department.dto.DepartmentCreateRequest;
import com.example.demo.department.dto.DepartmentDto;
import com.example.demo.department.service.DepartmentService;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.http.MediaType;
import org.springframework.security.test.context.support.WithMockUser;
import org.springframework.test.context.bean.override.mockito.MockitoBean;
import org.springframework.test.web.servlet.MockMvc;

import java.time.Instant;
import java.util.Arrays;
import java.util.List;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;
import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.csrf;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@WebMvcTest(DepartmentController.class)
class DepartmentControllerTest {
    
    @Autowired
    private MockMvc mockMvc;
    
    @MockitoBean
    private DepartmentService departmentService;
    
    @MockitoBean
    private com.example.demo.employee.service.EmployeeService employeeService;
    
    @Autowired
    private ObjectMapper objectMapper;
    
    private DepartmentDto testDepartmentDto;
    private DepartmentCreateRequest createRequest;
    
    @BeforeEach
    void setUp() {
        testDepartmentDto = DepartmentDto.builder()
            .id(1L)
            .name("Test Department")
            .code("TEST")
            .description("Test Description")
            .enabled(true)
            .level(0)
            .sortOrder(1)
            .depPath("/TEST")
            .isParent(false)
            .createdAt(Instant.now())
            .updatedAt(Instant.now())
            .build();
        
        createRequest = new DepartmentCreateRequest();
        createRequest.setName("New Department");
        createRequest.setCode("NEW");
        createRequest.setDescription("New Description");
        createRequest.setEnabled(true);
        createRequest.setSortOrder(1);
    }
    
    @Test
    @WithMockUser(authorities = {"DEPARTMENT_CREATE"})
    void createDepartment_Success() throws Exception {
        // Given
        when(departmentService.createDepartment(any(DepartmentCreateRequest.class)))
            .thenReturn(testDepartmentDto);
        
        // When & Then
        mockMvc.perform(post("/api/departments")
                .with(csrf())
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(createRequest)))
            .andExpect(status().isCreated())
            .andExpect(jsonPath("$.success").value(true))
            .andExpect(jsonPath("$.data.id").value(1L))
            .andExpect(jsonPath("$.data.name").value("Test Department"))
            .andExpect(jsonPath("$.data.code").value("TEST"));
    }
    
    @Test
    @WithMockUser(authorities = {"DEPARTMENT_CREATE"})
    void createDepartment_InvalidRequest_BadRequest() throws Exception {
        // Given - invalid request with empty name
        createRequest.setName("");
        
        // When & Then
        mockMvc.perform(post("/api/departments")
                .with(csrf())
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(createRequest)))
            .andExpect(status().isBadRequest());
    }
    
    @Test
    @WithMockUser(authorities = {"DEPARTMENT_READ"})
    void getDepartmentById_Success() throws Exception {
        // Given
        when(departmentService.getDepartmentById(1L)).thenReturn(testDepartmentDto);
        
        // When & Then
        mockMvc.perform(get("/api/departments/1"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.success").value(true))
            .andExpect(jsonPath("$.data.id").value(1L))
            .andExpect(jsonPath("$.data.name").value("Test Department"));
    }
    
    @Test
    @WithMockUser(authorities = {"DEPARTMENT_READ"})
    void getAllDepartments_Success() throws Exception {
        // Given
        List<DepartmentDto> departments = Arrays.asList(testDepartmentDto);
        when(departmentService.getAllDepartments()).thenReturn(departments);
        
        // When & Then
        mockMvc.perform(get("/api/departments"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.success").value(true))
            .andExpect(jsonPath("$.data").isArray())
            .andExpect(jsonPath("$.data[0].id").value(1L))
            .andExpect(jsonPath("$.data[0].name").value("Test Department"));
    }
    
    @Test
    @WithMockUser(authorities = {"DEPARTMENT_READ"})
    void searchDepartments_Success() throws Exception {
        // Given
        List<DepartmentDto> departments = Arrays.asList(testDepartmentDto);
        when(departmentService.searchDepartments("test")).thenReturn(departments);
        
        // When & Then
        mockMvc.perform(get("/api/departments/search")
                .param("q", "test"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.success").value(true))
            .andExpect(jsonPath("$.data").isArray())
            .andExpect(jsonPath("$.data[0].name").value("Test Department"));
    }
    
    @Test
    @WithMockUser(authorities = {"DEPARTMENT_DELETE"})
    void deleteDepartment_Success() throws Exception {
        // When & Then
        mockMvc.perform(delete("/api/departments/1")
                .with(csrf()))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.success").value(true))
            .andExpect(jsonPath("$.message").value("Department deleted successfully"));
    }
    
    @Test
    void createDepartment_NoAuthority_Forbidden() throws Exception {
        // When & Then
        mockMvc.perform(post("/api/departments")
                .with(csrf())
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(createRequest)))
            .andExpect(status().isForbidden());
    }
    
    @Test
    @WithMockUser(authorities = {"DEPARTMENT_UPDATE"})
    void moveDepartment_Success() throws Exception {
        // When & Then
        mockMvc.perform(put("/api/departments/1/move")
                .with(csrf())
                .param("parentId", "2"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.success").value(true))
            .andExpect(jsonPath("$.message").value("Department moved successfully"));
    }
    
    @Test
    @WithMockUser(authorities = {"DEPARTMENT_UPDATE"})
    void setDepartmentEnabled_Success() throws Exception {
        // When & Then
        mockMvc.perform(put("/api/departments/1/enabled")
                .with(csrf())
                .param("enabled", "false"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.success").value(true))
            .andExpect(jsonPath("$.message").value("Department disabled successfully"));
    }
    
    @Test
    @WithMockUser(authorities = {"DEPARTMENT_READ"})
    void getDepartmentEmployees_Success() throws Exception {
        // Given
        List<com.example.demo.employee.dto.EmployeeDto> employees = List.of();
        when(employeeService.getEmployeesByDepartmentId(1L)).thenReturn(employees);
        
        // When & Then
        mockMvc.perform(get("/api/departments/1/employees"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.success").value(true))
            .andExpect(jsonPath("$.data").isArray())
            .andExpect(jsonPath("$.data").isEmpty());
    }
}
</file>

<file path=".kiro/specs/spring-backend/department-implementation.md">
# Department Management Implementation

## Overview
This document provides detailed implementation specifications for the Department Management module. This module handles hierarchical department structure, department CRUD operations, and department tree queries with recursive support.

## Package Structure
```
com.example.demo.department/
├── entity/
│   └── Department.java
├── repository/
│   └── DepartmentRepository.java
├── service/
│   ├── DepartmentService.java
│   └── impl/
│       └── DepartmentServiceImpl.java
├── controller/
│   └── DepartmentController.java
├── dto/
│   ├── DepartmentDto.java
│   ├── DepartmentTreeDto.java
│   └── DepartmentCreateRequest.java
|   └── DepartmentUpdateRequest.java
└── exception/
    ├── DepartmentNotFoundException.java
    ├── DepartmentHierarchyException.java
    └── DepartmentInUseException.java
```

## Entity Class

### Department Entity
```java
package com.example.demo.department.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.Instant;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "departments", indexes = {
    @Index(name = "idx_department_name", columnList = "name"),
    @Index(name = "idx_department_code", columnList = "code"),
    @Index(name = "idx_department_parent_id", columnList = "parent_id"),
    @Index(name = "idx_department_dep_path", columnList = "dep_path"),
    @Index(name = "idx_department_enabled", columnList = "enabled"),
    @Index(name = "idx_department_manager_id", columnList = "manager_id")
})
@EntityListeners(AuditingEntityListener.class)
@Getter
@Setter
public class Department {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "name", nullable = false, length = 100)
    private String name;
    
    @Column(name = "code", unique = true, nullable = false, length = 20)
    private String code;
    
    @Column(name = "description", length = 500)
    private String description;
    
    @Column(name = "location", length = 255)
    private String location;
    
    @Column(name = "parent_id")
    private Long parentId;
    
    @Column(name = "dep_path", length = 500)
    private String depPath;
    
    @Column(name = "is_parent", nullable = false)
    private Boolean isParent = false;
    
    @Column(name = "enabled", nullable = false)
    private Boolean enabled = true;
    
    @Column(name = "level")
    private Integer level = 0;
    
    @Column(name = "sort_order")
    private Integer sortOrder = 0;
    
    @Column(name = "manager_id")
    private Long managerId;
    
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;
    
    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;
    
    @Column(name = "created_by")
    private Long createdBy;
    
    @Column(name = "updated_by")
    private Long updatedBy;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "parent_id", insertable = false, updatable = false)
    private Department parent;
    
    @OneToMany(mappedBy = "parent", fetch = FetchType.LAZY)
    private Set<Department> children = new HashSet<>();
    
    // Employee relationship is defined in the Employee entity
    
    @Transient
    private Long employeeCount;
}
```

## Repository Interface

### DepartmentRepository
```java
package com.example.demo.department.repository;

import com.example.demo.department.entity.Department;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface DepartmentRepository extends JpaRepository<Department, Long> {
    
    /**
     * Find department by name
     * @param name Department name
     * @return Optional department
     */
    Optional<Department> findByName(String name);
    
    /**
     * Find departments by parent ID
     * @param parentId Parent department ID
     * @return List of child departments
     */
    List<Department> findByParentIdOrderBySortOrder(Long parentId);
    
    /**
     * Find root departments (parentId is null)
     * @return List of root departments
     */
    List<Department> findByParentIdIsNullOrderBySortOrder();
    
    /**
     * Find departments by level
     * @param level Hierarchy level
     * @return List of departments at specified level
     */
    List<Department> findByLevel(Integer level);
    
    /**
     * Find departments by path prefix (for subtree queries)
     * @param pathPrefix Path prefix to match
     * @return List of departments in subtree
     */
    List<Department> findByDepPathStartingWithOrderByDepPath(String pathPrefix);
    
    /**
     * Find enabled departments
     * @return List of enabled departments
     */
    List<Department> findByEnabledTrueOrderByDepPath();
    
    /**
     * Find departments by name containing (case insensitive)
     * @param name Name search term
     * @return List of matching departments
     */
    List<Department> findByNameContainingIgnoreCaseOrderByName(String name);
    
    /**
     * Find departments by code
     * @param code Department code
     * @return Optional department
     */
    Optional<Department> findByCode(String code);
    
    /**
     * Check if department name exists
     * @param name Department name
     * @return true if exists
     */
    boolean existsByName(String name);
    
    /**
     * Check if department code exists
     * @param code Department code
     * @return true if exists
     */
    boolean existsByCode(String code);
    
    /**
     * Check if department has children
     * @param parentId Parent department ID
     * @return true if has children
     */
    boolean existsByParentId(Long parentId);
    
    /**
     * Count departments by parent ID
     * @param parentId Parent department ID
     * @return Count of child departments
     */
    long countByParentId(Long parentId);
    
    /**
     * Find departments by manager ID
     * @param managerId Manager employee ID
     * @return List of departments managed by the employee
     */
    List<Department> findByManagerId(Long managerId);
}
```## DTO 
Classes

### DepartmentDto
```java
package com.example.demo.department.dto;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import jakarta.validation.constraints.Min;
import java.time.Instant;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class DepartmentDto {
    
    private Long id;
    
    @NotBlank(message = "Department name is required")
    @Size(min = 2, max = 100, message = "Department name must be between 2 and 100 characters")
    private String name;
    
    @Size(max = 255, message = "Description must not exceed 255 characters")
    private String description;
    
    private Long parentId;
    
    private String depPath;
    
    private Boolean isParent;
    
    @Min(value = 0, message = "Level must be non-negative")
    private Integer level;
    
    @Min(value = 0, message = "Sort order must be non-negative")
    private Integer sortOrder;
    
    @Size(max = 20, message = "Department code must not exceed 20 characters")
    private String code;
    
    @Size(max = 100, message = "Location must not exceed 100 characters")
    private String location;
    
    private Long managerId;
    
    private String managerName; // Transient field for display
    
    private boolean enabled;
    
    private Instant createdAt;
    private Instant updatedAt;
    
    private Long createdBy;
    
    private Long updatedBy;
    
    private String createdByName; // Transient field for display
    
    private String updatedByName; // Transient field for display
    
    private List<DepartmentDto> children;
    
    private DepartmentDto parent;
    
    private Long employeeCount; // Number of employees in this department
}
```

### DepartmentTreeDto
```java
package com.example.demo.department.dto;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;

import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class DepartmentTreeDto {
    
    private Long id;
    
    private String name;
    
    private String code;
    
    private Long parentId;
    
    private Integer level;
    
    private Integer sortOrder;
    
    private boolean enabled;
    
    private boolean hasChildren;
    
    private Long employeeCount;
    
    private String managerName;
    
    private List<DepartmentTreeDto> children;
    
    // Additional fields for tree display
    private boolean expanded; // For UI tree expansion state
    
    private boolean selectable; // Whether this node can be selected
    
    private String icon; // Icon for tree node display
}
```

### DepartmentCreateRequest
```java
package com.example.demo.department.dto;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import jakarta.validation.constraints.Min;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class DepartmentCreateRequest {
    
    @NotBlank(message = "Department name is required")
    @Size(min = 2, max = 100, message = "Department name must be between 2 and 100 characters")
    private String name;
    
    @Size(max = 255, message = "Description must not exceed 255 characters")
    private String description;
    
    private Long parentId;
    
    @Min(value = 0, message = "Sort order must be non-negative")
    private Integer sortOrder;
    
    @Size(max = 20, message = "Department code must not exceed 20 characters")
    private String code;
    
    @Size(max = 100, message = "Location must not exceed 100 characters")
    private String location;
    
    private Long managerId;
    
    private boolean enabled = true;
}
```

### DepartmentUpdateRequest
```java
package com.example.demo.department.dto;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import jakarta.validation.constraints.Min;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class DepartmentUpdateRequest {
    
    @NotBlank(message = "Department name is required")
    @Size(min = 2, max = 100, message = "Department name must be between 2 and 100 characters")
    private String name;
    
    @Size(max = 255, message = "Description must not exceed 255 characters")
    private String description;
    
    @Min(value = 0, message = "Sort order must be non-negative")
    private Integer sortOrder;
    
    @Size(max = 20, message = "Department code must not exceed 20 characters")
    private String code;
    
    @Size(max = 100, message = "Location must not exceed 100 characters")
    private String location;
    
    private Long managerId;
    
    private boolean enabled;
}
```#
# Service Interface and Implementation

### DepartmentService Interface
```java
package com.example.demo.department.service;

import com.example.demo.department.dto.DepartmentDto;
import com.example.demo.department.dto.DepartmentTreeDto;
import com.example.demo.department.dto.DepartmentCreateRequest;
import com.example.demo.department.dto.DepartmentUpdateRequest;

import java.util.List;

public interface DepartmentService {
    
    /**
     * Create a new department
     * @param request Department creation request
     * @return Created department DTO
     * @throws DepartmentAlreadyExistsException if name or code already exists
     * @throws DepartmentNotFoundException if parent department not found
     */
    DepartmentDto createDepartment(DepartmentCreateRequest request);
    
    /**
     * Update an existing department
     * @param id Department ID
     * @param request Department update request
     * @return Updated department DTO
     * @throws DepartmentNotFoundException if department not found
     * @throws DepartmentAlreadyExistsException if name or code conflicts
     */
    DepartmentDto updateDepartment(Long id, DepartmentUpdateRequest request);
    
    /**
     * Get department by ID
     * @param id Department ID
     * @return Department DTO
     * @throws DepartmentNotFoundException if department not found
     */
    DepartmentDto getDepartmentById(Long id);
    
    /**
     * Get department by code
     * @param code Department code
     * @return Department DTO
     * @throws DepartmentNotFoundException if department not found
     */
    DepartmentDto getDepartmentByCode(String code);
    
    /**
     * Get all departments as flat list
     * @return List of department DTOs
     */
    List<DepartmentDto> getAllDepartments();
    
    /**
     * Get department tree structure
     * @return List of root department tree DTOs with children
     */
    List<DepartmentTreeDto> getDepartmentTree();
    
    /**
     * Get department subtree starting from specified department
     * @param departmentId Root department ID for subtree
     * @return Department tree DTO with children
     * @throws DepartmentNotFoundException if department not found
     */
    DepartmentTreeDto getDepartmentSubtree(Long departmentId);
    
    /**
     * Get child departments of specified parent
     * @param parentId Parent department ID (null for root departments)
     * @return List of child department DTOs
     */
    List<DepartmentDto> getChildDepartments(Long parentId);
    
    /**
     * Get departments by level in hierarchy
     * @param level Hierarchy level (0 for root)
     * @return List of department DTOs at specified level
     */
    List<DepartmentDto> getDepartmentsByLevel(Integer level);
    
    /**
     * Search departments by name
     * @param searchTerm Search term for department name
     * @return List of matching department DTOs
     */
    List<DepartmentDto> searchDepartments(String searchTerm);
    
    /**
     * Delete department by ID
     * @param id Department ID
     * @throws DepartmentNotFoundException if department not found
     * @throws DepartmentHierarchyException if department has children
     * @throws DepartmentInUseException if department has employees
     */
    void deleteDepartment(Long id);
    
    /**
     * Move department to new parent
     * @param departmentId Department ID to move
     * @param newParentId New parent department ID (null for root)
     * @throws DepartmentNotFoundException if department or parent not found
     * @throws DepartmentHierarchyException if move would create circular reference
     */
    void moveDepartment(Long departmentId, Long newParentId);
    
    /**
     * Enable or disable department
     * @param id Department ID
     * @param enabled Enable/disable flag
     * @throws DepartmentNotFoundException if department not found
     */
    void setDepartmentEnabled(Long id, boolean enabled);
    
    /**
     * Update department sort order
     * @param id Department ID
     * @param sortOrder New sort order
     * @throws DepartmentNotFoundException if department not found
     */
    void updateSortOrder(Long id, Integer sortOrder);
    
    /**
     * Get department path from root to specified department
     * @param departmentId Department ID
     * @return List of department DTOs representing path from root
     * @throws DepartmentNotFoundException if department not found
     */
    List<DepartmentDto> getDepartmentPath(Long departmentId);
    
    /**
     * Get all ancestor departments of specified department
     * @param departmentId Department ID
     * @return List of ancestor department DTOs
     * @throws DepartmentNotFoundException if department not found
     */
    List<DepartmentDto> getAncestorDepartments(Long departmentId);
    
    /**
     * Get all descendant departments of specified department
     * @param departmentId Department ID
     * @return List of descendant department DTOs
     * @throws DepartmentNotFoundException if department not found
     */
    List<DepartmentDto> getDescendantDepartments(Long departmentId);
    
    /**
     * Check if department can be deleted
     * @param id Department ID
     * @return true if department can be safely deleted
     * @throws DepartmentNotFoundException if department not found
     */
    boolean canDeleteDepartment(Long id);
    
    /**
     * Get department statistics
     * @param departmentId Department ID
     * @return Department statistics including employee count, child count, etc.
     * @throws DepartmentNotFoundException if department not found
     */
    DepartmentStatisticsDto getDepartmentStatistics(Long departmentId);
    
    /**
     * Rebuild department paths (maintenance operation)
     * This method recalculates all department paths and levels
     */
    void rebuildDepartmentPaths();
}
```

### DepartmentStatisticsDto
```java
package com.example.demo.department.dto;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class DepartmentStatisticsDto {
    
    private Long departmentId;
    
    private String departmentName;
    
    private Long directEmployeeCount; // Employees directly in this department
    
    private Long totalEmployeeCount; // Employees in this department and all subdepartments
    
    private Long directChildCount; // Direct child departments
    
    private Long totalChildCount; // All descendant departments
    
    private Integer maxDepth; // Maximum depth of subdepartments
    
    private boolean hasManager;
    
    private String managerName;
}
```
</file>

<file path=".kiro/specs/spring-backend/requirements.md">
# Requirements Document

## Introduction

This document outlines the requirements for a comprehensive Employee Management System built with Spring Boot and React. The system provides role-based access control, employee information management, department processing, payroll management, and communication features. It serves as an enterprise-grade HR management solution with robust security and user experience features.

## Requirements

### Requirement 1: Permission Management System

**User Story:** As a system administrator, I want to manage user permissions through roles and resources, so that I can control access to different parts of the system based on user responsibilities.

#### Acceptance Criteria

1. WHEN the system starts THEN it SHALL load a permission database containing resource tables, role tables, user tables, resource-role tables, and user-role tables
2. WHEN a user logs in THEN the system SHALL dynamically load modules based on the user's assigned roles
3. WHEN an administrator assigns roles to users THEN the system SHALL update user-role relationships in real-time
4. WHEN a user attempts to access a resource THEN the system SHALL verify permissions through the role-resource mapping
5. IF a user lacks permission for a resource THEN the system SHALL deny access and display an appropriate message

### Requirement 2: Authentication and Security

**User Story:** As a system user, I want secure login functionality with stateless JWT-based authentication and comprehensive security measures, so that my data and actions are protected according to industry standards.

#### Acceptance Criteria

1. WHEN the system is deployed THEN it SHALL use Spring Boot with Spring Security and stateless JWT authentication (no Redis sessions for authentication state)
2. WHEN a user logs in successfully THEN the system SHALL issue a JWT token with appropriate expiration, refresh capabilities, and secure signing using strong secret keys
3. WHEN JWT tokens are used THEN the system SHALL implement token blacklisting in Redis for logout functionality while maintaining stateless authentication
4. WHEN sensitive PII data is stored THEN the system SHALL encrypt dateOfBirth, bankAccount, and taxId fields using AES encryption with proper key management
5. WHEN server-side exceptions occur THEN the system SHALL handle them through a unified exception handling mechanism without exposing sensitive information
6. WHEN frontend requests are made THEN the system SHALL validate JWT tokens, enforce role-based access control, and implement method-level security with @PreAuthorize
7. WHEN user actions are performed THEN the system SHALL maintain comprehensive audit trails with user identification and Instant timestamps
8. WHEN password authentication fails multiple times THEN the system SHALL implement account lockout mechanisms with configurable thresholds
9. WHEN permission checks are performed THEN the system SHALL use a clearly defined permission string format (e.g., "RESOURCE:ACTION" like "EMPLOYEE:READ")
10. IF authentication fails THEN the system SHALL return appropriate error messages without exposing sensitive system information

### Requirement 3: Department Management

**User Story:** As an HR manager, I want to manage organizational departments in a hierarchical structure with proper data integrity, so that I can organize employees effectively.

#### Acceptance Criteria

1. WHEN the system initializes THEN it SHALL create department database tables in PostgreSQL with proper foreign key constraints and hierarchical query support
2. WHEN displaying departments THEN the system SHALL use a Tree component to show hierarchical relationships with proper parent-child references
3. WHEN querying department data THEN the system SHALL implement efficient hierarchical queries using depPath and PostgreSQL recursive CTEs
4. WHEN loading department information THEN the system SHALL use depPath for efficient querying and cache results in Redis for performance
5. WHEN identifying parent departments THEN the system SHALL use isParent field and maintain referential integrity through database constraints
6. WHEN department managers are assigned THEN the system SHALL validate that the manager is an employee and enforce proper authorization
7. WHEN departments are deleted THEN the system SHALL check for dependent employees and prevent deletion if dependencies exist

### Requirement 4: Position and Title Management

**User Story:** As an HR administrator, I want to manage job titles and professional titles, so that I can maintain accurate organizational structure.

#### Acceptance Criteria

1. WHEN managing positions THEN the system SHALL display job title and professional title information in tables
2. WHEN performing position operations THEN the system SHALL support Create, Read, Update, and Delete (CRUD) operations
3. WHEN viewing position data THEN the system SHALL provide clear tabular display with sorting capabilities
4. WHEN modifying position information THEN the system SHALL validate data integrity before saving
5. IF position deletion is attempted THEN the system SHALL check for dependencies before allowing removal

### Requirement 5: Employee Information Management

**User Story:** As an HR staff member, I want comprehensive employee management capabilities, so that I can efficiently handle all employee-related data operations with proper data integrity and validation.

#### Acceptance Criteria

1. WHEN managing employees THEN the system SHALL support full CRUD operations for employee basic information with proper validation and business rule enforcement
2. WHEN displaying employee lists THEN the system SHALL implement pagination for large datasets with configurable page sizes
3. WHEN selecting multiple employees THEN the system SHALL support batch deletion operations with dependency validation
4. WHEN searching for employees THEN the system SHALL provide both basic search and advanced search functionality with proper indexing
5. WHEN storing employee data THEN the system SHALL support both salaried and hourly employees with separate fields for salary and hourly rate
6. WHEN validating employee data THEN the system SHALL ensure salary falls within position's defined salary range and enforce all business rules
7. WHEN importing employee data THEN the system SHALL support Excel file import with comprehensive validation and error reporting
8. WHEN exporting employee data THEN the system SHALL generate Excel files with current employee information and proper formatting
9. WHEN handling employee payroll data THEN the system SHALL maintain referential integrity between employees and payroll records
10. IF invalid data is imported THEN the system SHALL provide detailed error messages, reject the import, and maintain data consistency

### Requirement 6: Email Communication System

**User Story:** As a system user, I want to send formatted emails to employees, so that I can communicate important information effectively.

#### Acceptance Criteria

1. WHEN sending emails THEN the system SHALL use Freemarker templates for email generation
2. WHEN processing email requests THEN the system SHALL implement Java email sending functionality
3. WHEN sending multiple emails THEN the system SHALL use new threads to prevent blocking
4. WHEN creating email templates THEN the system SHALL store template files in the ftl directory under resources
5. IF email sending fails THEN the system SHALL log errors and provide user feedback

### Requirement 7: Payroll Management

**User Story:** As a payroll administrator, I want to manage payroll ledgers and employee salary information with proper data integrity and historical accuracy, so that I can process payroll accurately and maintain compliance.

#### Acceptance Criteria

1. WHEN managing payroll THEN the system SHALL support adding new payroll ledgers with proper validation and business rule enforcement
2. WHEN setting up employee ledgers THEN the system SHALL allow viewing of ledger details with proper access control and audit trails
3. WHEN modifying ledgers THEN the system SHALL support ledger modifications with comprehensive audit trail and approval workflows
4. WHEN processing payroll THEN the system SHALL maintain data integrity, accuracy, and referential consistency with employee records
5. WHEN storing historical payroll data THEN the system SHALL maintain accurate employee and department names at the time of payroll processing without denormalization issues
6. WHEN payroll data changes THEN the system SHALL implement proper mechanisms to handle updates to historical records while preserving audit trails
7. WHEN calculating payroll THEN the system SHALL support both salaried and hourly employees with appropriate calculation methods
8. IF payroll calculations are performed THEN the system SHALL validate all financial data, enforce business rules, and maintain transaction integrity

### Requirement 8: Communication and Notification System

**User Story:** As a system user, I want online chat and notification capabilities, so that I can communicate with colleagues and receive important system updates.

#### Acceptance Criteria

1. WHEN using chat functionality THEN the system SHALL provide real-time online chat capabilities
WHEN system notifications are generated THEN the system SHALL save them to a single `notifications` table. This table is the source of truth for real-time, user-specific notifications. This is distinct from the `announcements` feature, which handles broader, system-wide communications.
3. WHEN managing user notifications THEN the system SHALL handle all aspects including content, recipients, status, and type within the `notifications` entity.
4. WHEN notifications are created THEN the system SHALL push notifications to relevant users based on the data in the `notifications` table.
5. WHEN users access notifications THEN the system SHALL provide viewing and management capabilities based on the unified `notifications` model.
6. IF chat messages are sent THEN the system SHALL ensure real-time delivery and display

### Requirement 9: User Interface and Experience

**User Story:** As a system user, I want an intuitive and responsive interface, so that I can efficiently perform my tasks.

#### Acceptance Criteria

1. WHEN displaying roles THEN the system SHALL use ElementUI Collapse panels for role information
2. WHEN showing role resources THEN the system SHALL use tree controls for hierarchical display
3. WHEN managing positions and titles THEN the system SHALL use tables for clear data presentation
4. WHEN accessing employee management THEN the system SHALL provide comprehensive CRUD interface with search capabilities
5. WHEN using chat and notifications THEN the system SHALL provide user-friendly interface for message sending and viewing

### Requirement 10: Hybrid Data Storage and Compliance

**User Story:** As a system administrator, I want a robust hybrid data storage strategy with compliance features, so that the system meets enterprise requirements and regulatory standards while maintaining optimal performance.

#### Acceptance Criteria

1. WHEN storing core business data THEN the system SHALL use PostgreSQL as the primary database with ACID compliance, referential integrity, and proper foreign key constraints for all relational entities (Users, Roles, Employees, Departments, Positions, Payroll)
2. WHEN handling caching and real-time features THEN the system SHALL use Redis exclusively for session management, frequently accessed data caching, real-time chat messages, and WebSocket connection management
3. WHEN storing sensitive PII data THEN the system SHALL implement field-level AES encryption for dateOfBirth, bankAccount, and taxId fields in compliance with GDPR and CCPA
4. WHEN handling timestamps THEN the system SHALL use Instant (UTC) or ZonedDateTime for all timestamp fields to ensure time-zone awareness and eliminate ambiguity
5. WHEN database schema changes are needed THEN the system SHALL use Flyway for versioned database migrations with proper rollback capabilities
6. WHEN data integrity is required THEN the system SHALL enforce foreign key constraints, check constraints, and proper transaction boundaries in PostgreSQL
7. WHEN audit trails are needed THEN the system SHALL automatically track created_by, updated_by, created_at, and updated_at fields using Instant timestamps for all critical entities
8. WHEN backup and recovery is required THEN the system SHALL support standard PostgreSQL backup procedures and Redis persistence configuration
9. IF data access is requested THEN the system SHALL implement permission-based filtering to ensure users only see authorized data through repository-level security

### Requirement 11: API Design and Data Consistency

**User Story:** As a frontend developer and system integrator, I want well-designed APIs with proper DTOs and consistent data handling, so that I can build reliable integrations and maintain system integrity.

#### Acceptance Criteria

1. WHEN designing API endpoints THEN the system SHALL use dedicated CreateRequest and UpdateRequest DTOs instead of reusing read DTOs for write operations
2. WHEN handling API requests THEN the system SHALL prevent clients from sending immutable fields (id, createdAt, updatedAt) in update operations
3. WHEN implementing batch operations THEN the system SHALL provide true batch endpoints (e.g., DELETE /api/employees/batch) as specified in requirements
4. WHEN returning hierarchical data THEN the system SHALL avoid infinite recursion risks by using appropriate DTO structures without circular references
5. WHEN defining entity fields THEN the system SHALL use enum types instead of string fields for fixed value sets (status, level, type fields)
6. WHEN implementing audit trails THEN the system SHALL provide comprehensive auditing for all critical entities (users, roles, employees, departments) not just payroll
7. WHEN maintaining data consistency THEN the system SHALL ensure all entity definitions are consistent across all documentation and implementation files
8. IF API responses include sensitive data THEN the system SHALL implement proper field filtering and access control at the DTO level

### Requirement 12: System Documentation and Maintainability

**User Story:** As a new developer or user, I want comprehensive documentation with a single source of truth, so that I can quickly understand and work with the system without conflicts.

#### Acceptance Criteria

1. WHEN onboarding new team members THEN the system SHALL provide detailed documentation for quick understanding with consistent entity definitions
2. WHEN maintaining the system THEN the documentation SHALL include architectural decisions and implementation details from a single source of truth
3. WHEN troubleshooting issues THEN the documentation SHALL provide clear guidance for common problems with up-to-date information
4. WHEN extending functionality THEN the documentation SHALL explain the system's extensibility patterns with consistent examples
5. WHEN defining entities and DTOs THEN the system SHALL maintain a single source of truth to prevent conflicting definitions across documents
6. IF system updates are made THEN the documentation SHALL be updated accordingly with version control and change tracking
</file>

<file path=".kiro/steering/structure.md">
# Project Structure

## Full-Stack Architecture
This project follows a full-stack architecture with separate backend (Spring Boot) and frontend (React) applications.

## Backend Structure (Spring Boot)

### Root Level
- `pom.xml` - Maven configuration and dependencies
- `mvnw`, `mvnw.cmd` - Maven wrapper scripts
- `HELP.md` - Getting started documentation

### Source Organization
```
demo/src/
├── main/
│   ├── java/
│   │   └── com/example/demo/
│   │       ├── DemoApplication.java     # Main Spring Boot application
│   │       ├── ServletInitializer.java  # WAR deployment configuration
│   │       ├── security/                # Security and Permission Management
│   │       │   ├── config/
│   │       │   │   ├── SecurityConfig.java
│   │       │   │   ├── JwtConfig.java
│   │       │   │   └── RedisConfig.java
│   │       │   ├── entity/
│   │       │   │   ├── User.java
│   │       │   │   ├── Role.java
│   │       │   │   ├── Resource.java
│   │       │   │   ├── UserRole.java
│   │       │   │   └── RoleResource.java
│   │       │   ├── repository/
│   │       │   │   ├── UserRepository.java
│   │       │   │   ├── RoleRepository.java
│   │       │   │   ├── ResourceRepository.java
│   │       │   │   ├── UserRoleRepository.java
│   │       │   │   └── RoleResourceRepository.java
│   │       │   ├── service/
│   │       │   │   ├── UserService.java
│   │       │   │   ├── RoleService.java
│   │       │   │   ├── ResourceService.java
│   │       │   │   ├── AuthenticationService.java
│   │       │   │   └── PermissionService.java
│   │       │   ├── controller/
│   │       │   │   ├── AuthController.java
│   │       │   │   ├── UserController.java
│   │       │   │   ├── RoleController.java
│   │       │   │   └── ResourceController.java
│   │       │   ├── dto/
│   │       │   │   ├── LoginRequest.java
│   │       │   │   ├── LoginResponse.java
│   │       │   │   ├── UserDto.java
│   │       │   │   ├── RoleDto.java
│   │       │   │   └── ResourceDto.java
│   │       │   ├── security/
│   │       │   │   ├── JwtAuthenticationFilter.java
│   │       │   │   ├── JwtTokenProvider.java
│   │       │   │   ├── CustomUserDetailsService.java
│   │       │   │   └── SecurityUtils.java
│   │       │   └── exception/
│   │       │       ├── AuthenticationException.java
│   │       │       ├── AuthorizationException.java
│   │       │       └── UserNotFoundException.java
│   │       ├── department/              # Department Management
│   │       │   ├── entity/
│   │       │   │   └── Department.java
│   │       │   ├── repository/
│   │       │   │   └── DepartmentRepository.java
│   │       │   ├── service/
│   │       │   │   ├── DepartmentService.java
│   │       │   │   └── impl/
│   │       │   │       └── DepartmentServiceImpl.java
│   │       │   ├── controller/
│   │       │   │   └── DepartmentController.java
│   │       │   ├── dto/
│   │       │   │   ├── DepartmentDto.java
│   │       │   │   ├── DepartmentTreeDto.java
│   │       │   │   ├── DepartmentCreateRequest.java
│   │       │   │   ├── DepartmentUpdateRequest.java
│   │       │   │   └── DepartmentStatisticsDto.java
│   │       │   └── exception/
│   │       │       ├── DepartmentNotFoundException.java
│   │       │       ├── DepartmentHierarchyException.java
│   │       │       └── DepartmentInUseException.java
│   │       ├── employee/                # Employee Management
│   │       │   ├── entity/
│   │       │   │   ├── Employee.java
│   │       │   │   └── EmployeeStatus.java
│   │       │   ├── repository/
│   │       │   │   └── EmployeeRepository.java
│   │       │   ├── service/
│   │       │   │   ├── EmployeeService.java
│   │       │   │   ├── EmployeeImportService.java
│   │       │   │   ├── EmployeeExportService.java
│   │       │   │   └── impl/
│   │       │   │       ├── EmployeeServiceImpl.java
│   │       │   │       ├── EmployeeImportServiceImpl.java
│   │       │   │       └── EmployeeExportServiceImpl.java
│   │       │   ├── controller/
│   │       │   │   └── EmployeeController.java
│   │       │   ├── dto/
│   │       │   │   ├── EmployeeDto.java
│   │       │   │   ├── EmployeeCreateRequest.java
│   │       │   │   ├── EmployeeUpdateRequest.java
│   │       │   │   ├── EmployeeSearchCriteria.java
│   │       │   │   ├── EmployeeImportResult.java
│   │       │   │   └── EmployeeExportRequest.java
│   │       │   ├── util/
│   │       │   │   ├── EmployeeExcelUtil.java
│   │       │   │   └── EmployeeValidationUtil.java
│   │       │   └── exception/
│   │       │       ├── EmployeeNotFoundException.java
│   │       │       ├── EmployeeAlreadyExistsException.java
│   │       │       ├── EmployeeImportException.java
│   │       │       └── EmployeeExportException.java
│   │       ├── position/                # Position and Title Management
│   │       │   ├── entity/
│   │       │   │   └── Position.java
│   │       │   ├── repository/
│   │       │   │   └── PositionRepository.java
│   │       │   ├── service/
│   │       │   │   ├── PositionService.java
│   │       │   │   └── impl/
│   │       │   │       └── PositionServiceImpl.java
│   │       │   ├── controller/
│   │       │   │   └── PositionController.java
│   │       │   ├── dto/
│   │       │   │   ├── PositionDto.java
│   │       │   │   ├── PositionCreateRequest.java
│   │       │   │   ├── PositionUpdateRequest.java
│   │       │   │   └── PositionSearchCriteria.java
│   │       │   └── exception/
│   │       │       ├── PositionNotFoundException.java
│   │       │       ├── PositionAlreadyExistsException.java
│   │       │       └── PositionInUseException.java
│   │       ├── communication/           # Communication System
│   │       │   ├── email/
│   │       │   │   ├── entity/
│   │       │   │   │   ├── EmailTemplate.java
│   │       │   │   │   └── EmailLog.java
│   │       │   │   ├── service/
│   │       │   │   │   ├── EmailService.java
│   │       │   │   │   ├── EmailTemplateService.java
│   │       │   │   │   └── impl/
│   │       │   │   │       ├── EmailServiceImpl.java
│   │       │   │   │       └── EmailTemplateServiceImpl.java
│   │       │   │   ├── controller/
│   │       │   │   │   └── EmailController.java
│   │       │   │   ├── dto/
│   │       │   │   │   ├── EmailRequest.java
│   │       │   │   │   ├── BulkEmailRequest.java
│   │       │   │   │   ├── EmailTemplateDto.java
│   │       │   │   │   └── EmailLogDto.java
│   │       │   │   └── util/
│   │       │   │       └── EmailTemplateProcessor.java
│   │       │   ├── chat/
│   │       │   │   ├── entity/
│   │       │   │   │   ├── ChatMessage.java
│   │       │   │   │   ├── ChatRoom.java
│   │       │   │   │   └── ChatParticipant.java
│   │       │   │   ├── service/
│   │       │   │   │   ├── ChatService.java
│   │       │   │   │   └── impl/
│   │       │   │   │       └── ChatServiceImpl.java
│   │       │   │   ├── controller/
│   │       │   │   │   └── ChatController.java
│   │       │   │   ├── dto/
│   │       │   │   │   ├── ChatMessageDto.java
│   │       │   │   │   ├── ChatRoomDto.java
│   │       │   │   │   └── ChatParticipantDto.java
│   │       │   │   └── websocket/
│   │       │   │       ├── ChatWebSocketHandler.java
│   │       │   │       └── WebSocketConfig.java
│   │       │   ├── notification/
│   │       │   │   ├── entity/
│   │       │   │   │   ├── MessageContent.java
│   │       │   │   │   └── SystemMessage.java
│   │       │   │   ├── service/
│   │       │   │   │   ├── NotificationService.java
│   │       │   │   │   └── impl/
│   │       │   │   │       └── NotificationServiceImpl.java
│   │       │   │   ├── controller/
│   │       │   │   │   └── NotificationController.java
│   │       │   │   ├── dto/
│   │       │   │   │   ├── NotificationDto.java
│   │       │   │   │   ├── NotificationCreateRequest.java
│   │       │   │   │   └── NotificationMarkReadRequest.java
│   │       │   │   └── websocket/
│   │       │   │       └── NotificationWebSocketHandler.java
│   │       │   ├── announcement/
│   │       │   │   ├── controller/
│   │       │   │   │   └── AnnouncementController.java
│   │       │   │   ├── dto/
│   │       │   │   │   ├── AnnouncementCreateRequest.java
│   │       │   │   │   ├── AnnouncementDto.java
│   │       │   │   │   ├── AnnouncementStatisticsDto.java
│   │       │   │   │   └── AnnouncementUpdateRequest.java
│   │       │   │   ├── entity/
│   │       │   │   │   ├── Announcement.java
│   │       │   │   │   └── AnnouncementTarget.java
│   │       │   │   ├── repository/
│   │       │   │   │   └── AnnouncementRepository.java
│   │       │   │   └── service/
│   │       │   │       ├── AnnouncementScheduledService.java
│   │       │   │       ├── AnnouncementService.java
│   │       │   │       ├── AnnouncementValidationService.java
│   │       │   │       └── impl/
│   │       │   │           └── AnnouncementServiceImpl.java
│   │       │   └── exception/
│   │       │       ├── EmailSendingException.java
│   │       │       ├── TemplateNotFoundException.java
│   │       │       ├── ChatRoomNotFoundException.java
│   │       │       └── NotificationException.java
│   │       ├── payroll/                 # Payroll Management
│   │       │   ├── entity/
│   │       │   │   ├── PayrollLedger.java
│   │       │   │   ├── PayrollPeriod.java
│   │       │   │   ├── SalaryComponent.java
│   │       │   │   └── PayrollAudit.java
│   │       │   ├── repository/
│   │       │   │   ├── PayrollLedgerRepository.java
│   │       │   │   ├── PayrollPeriodRepository.java
│   │       │   │   ├── SalaryComponentRepository.java
│   │       │   │   └── PayrollAuditRepository.java
│   │       │   ├── service/
│   │       │   │   ├── PayrollService.java
│   │       │   │   ├── PayrollCalculationService.java
│   │       │   │   ├── PayrollReportService.java
│   │       │   │   └── impl/
│   │       │   │       ├── PayrollServiceImpl.java
│   │       │   │       ├── PayrollCalculationServiceImpl.java
│   │       │   │       └── PayrollReportServiceImpl.java
│   │       │   ├── controller/
│   │       │   │   └── PayrollController.java
│   │       │   ├── dto/
│   │       │   │   ├── PayrollLedgerDto.java
│   │       │   │   ├── PayrollPeriodDto.java
│   │       │   │   ├── SalaryComponentDto.java
│   │       │   │   ├── PayrollCalculationRequest.java
│   │       │   │   ├── PayrollReportRequest.java
│   │       │   │   └── PayrollSummaryDto.java
│   │       │   ├── util/
│   │       │   │   ├── PayrollCalculationUtil.java
│   │       │   │   └── PayrollValidationUtil.java
│   │       │   └── exception/
│   │       │       ├── PayrollNotFoundException.java
│   │       │       ├── PayrollCalculationException.java
│   │       │       ├── PayrollPeriodException.java
│   │       │       └── PayrollValidationException.java
│   │       ├── config/                  # Application configuration
│   │       │   ├── RedisConfig.java
│   │       │   ├── WebSocketConfig.java
│   │       │   ├── AsyncConfig.java
│   │       │   └── CorsConfig.java
│   │       └── common/                  # Common utilities and shared components
│   │           ├── dto/
│   │           │   ├── ApiResponse.java
│   │           │   ├── ErrorResponse.java
│   │           │   └── PageResponse.java
│   │           ├── exception/
│   │           │   ├── BusinessException.java
│   │           │   ├── GlobalExceptionHandler.java
│   │           │   └── ValidationException.java
│   │           └── util/
│   │               ├── CacheUtil.java
│   │               ├── DateUtil.java
│   │               ├── FileUtil.java
│   │               ├── StringUtil.java
│   │               └── ValidationUtil.java
│   └── resources/
│       ├── application.properties       # Application configuration
│       ├── application-dev.properties   # Development configuration
│       ├── application-prod.properties  # Production configuration
│       ├── static/                      # Static web assets (for React build)
│       └── templates/                   # Email templates (Freemarker .ftl files)
│           ├── welcome-email.ftl
│           ├── notification-email.ftl
│           └── payroll-summary.ftl
└── test/
    └── java/
        └── com/example/demo/            # Test classes mirror main structure
            ├── security/
            ├── department/
            ├── employee/
            ├── position/
            ├── communication/
            ├── payroll/
            └── integration/             # Integration tests
```

## Frontend Structure (React)

### Recommended React Project Structure
```
frontend/
├── public/                              # Static assets
├── src/
│   ├── components/                      # Reusable UI components
│   │   ├── ui/                         # Basic UI components (DataTable, FormField, etc.)
│   │   ├── forms/                      # Form components
│   │   └── layout/                     # Layout components (AppShell, Navigation, Header)
│   ├── features/                       # Feature-based modules
│   │   ├── auth/                       # Authentication feature
│   │   │   ├── components/             # Auth-specific components
│   │   │   ├── hooks/                  # Auth-specific hooks
│   │   │   ├── services/               # Auth API services
│   │   │   └── types/                  # Auth type definitions
│   │   ├── employees/                  # Employee management
│   │   ├── departments/                # Department management
│   │   ├── chat/                       # Chat functionality
│   │   ├── email/                      # Email management
│   │   ├── notifications/              # Notification system
│   │   └── permissions/                # Permission management
│   ├── hooks/                          # Global custom React hooks
│   ├── services/                       # API and external services
│   │   ├── api.ts                      # Base API client
│   │   ├── websocket.ts                # WebSocket client
│   │   └── auth.ts                     # Authentication service
│   ├── stores/                         # Zustand stores
│   │   ├── authStore.ts                # Authentication state
│   │   ├── uiStore.ts                  # UI state (theme, navigation)
│   │   └── notificationStore.ts        # Notification state
│   ├── types/                          # TypeScript type definitions
│   │   ├── api.ts                      # API response types
│   │   ├── auth.ts                     # Authentication types
│   │   └── entities.ts                 # Entity types
│   ├── utils/                          # Utility functions
│   ├── constants/                      # Application constants
│   └── assets/                         # Static assets (images, icons)
├── package.json                        # Node.js dependencies
├── vite.config.ts                      # Vite configuration
├── tsconfig.json                       # TypeScript configuration
└── vitest.config.ts                    # Testing configuration
```

## Package Conventions

### Backend (Spring Boot)
- **Base package**: `com.example.demo`
- **Feature-based organization**: Each major feature (security, department, employee, position, communication, payroll) has its own package
- **Layered architecture within features**: Each feature contains entity, repository, service, controller, dto, and exception packages
- **Security module**: Complete authentication and authorization system with JWT, roles, and permissions
- **Communication module**: Subdivided into email, chat, and notification submodules
- **Common package**: Contains foundational infrastructure components and utility classes. It provides standardized responses (`dto`), centralized exception handling (`exception`), and common operations (`util`) shared across all features.
- **Configuration**: Application config in `config` package with feature-specific configurations
- **Resources**: Application properties, email templates, and static assets

### Frontend (React)
- **Feature-based organization**: Group related components, hooks, and services by feature
- **Component hierarchy**: UI components → Feature components → Layout components
- **Type definitions**: Centralized in `types/` with feature-specific types in feature folders
- **Service layer**: API clients and external service integrations
- **State management**: Separate stores for different concerns (auth, UI, notifications)

## Configuration Files

### Backend
- `application.properties` - Main configuration
- `application-{profile}.properties` - Environment-specific configs

### Frontend
- `package.json` - Dependencies and scripts
- `vite.config.ts` - Build tool configuration
- `tsconfig.json` - TypeScript compiler options
- `.env` files - Environment variables

## Build Artifacts
- **Backend**: `target/` - Maven build output, WAR file for deployment
- **Frontend**: `dist/` - Vite build output, optimized static files

## Development Guidelines

### Backend
- Keep the main application class minimal - only for bootstrapping
- Use `@SpringBootApplication` annotation on the main class
- Organize code by feature/domain with layered architecture within each feature
- Each feature module should be self-contained with its own entities, repositories, services, controllers, DTOs, and exceptions
- Use Maven commands: `mvn` (not `./mvnw` wrapper)
- Follow the established package structure with feature-based organization
- Implement proper separation of concerns with clear boundaries between modules
- Use Redis for data persistence with proper entity annotations (@RedisHash, @Indexed)
- Implement comprehensive exception handling with feature-specific exceptions
- Use Lombok annotations to reduce boilerplate code
- Follow consistent naming conventions across all modules
- Utilize `common` package utilities for consistency:
    - Use standardized `ApiResponse` for all controller methods.
    - Use `ValidationUtil` for business-specific validations.
    - Use `CacheUtil` for Redis cache operations.
    - Use `DateUtil` for all date and time manipulations.

### Frontend
- Use feature-based organization for scalability
- Implement component-driven development with Storybook
- Follow TypeScript strict mode for type safety
- Use functional components with hooks
- Implement proper error boundaries and loading states
- Ensure accessibility compliance (WCAG 2.1)
- Write comprehensive tests for all components and features
</file>

<file path="pom.xml">
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.5.4</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>com.example</groupId>
    <artifactId>demo</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <packaging>jar</packaging>
    <name>Employee Management System</name>
    <description>Spring Boot Employee Management System with PostgreSQL and Redis</description>
    
    <properties>
        <java.version>21</java.version>
        <maven.compiler.source>21</maven.compiler.source>
        <maven.compiler.target>21</maven.compiler.target>
    </properties>

    <dependencies>
        <!-- Spring Boot Starters -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-websocket</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>
        
        <dependency>
            <groupId>redis.clients</groupId>
            <artifactId>jedis</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-mail</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>

        <!-- Database Drivers -->
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>

        <!-- Database Migration -->
        <dependency>
            <groupId>org.flywaydb</groupId>
            <artifactId>flyway-core</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.flywaydb</groupId>
            <artifactId>flyway-database-postgresql</artifactId>
        </dependency>

        <!-- JWT Libraries -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>0.12.3</version>
        </dependency>
        
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>0.12.3</version>
            <scope>runtime</scope>
        </dependency>
        
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>0.12.3</version>
            <scope>runtime</scope>
        </dependency>

        <!-- Apache POI for Excel -->
        <dependency>
            <groupId>org.apache.poi</groupId>
            <artifactId>poi</artifactId>
            <version>5.2.4</version>
        </dependency>
        
        <dependency>
            <groupId>org.apache.poi</groupId>
            <artifactId>poi-ooxml</artifactId>
            <version>5.2.4</version>
        </dependency>

        <!-- Lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.38</version>
            <scope>provided</scope>
        </dependency>

        <!-- Swagger/OpenAPI Documentation -->
        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
            <version>2.2.0</version>
        </dependency>

        <!-- ModelMapper -->
        <dependency>
            <groupId>org.modelmapper</groupId>
            <artifactId>modelmapper</artifactId>
            <version>3.1.1</version>
        </dependency>

        <!-- Configuration Processor -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-configuration-processor</artifactId>
            <optional>true</optional>
        </dependency>

        <!-- Development Tools -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>

        <!-- Test Dependencies -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        
        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <scope>test</scope>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>
        
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>junit-jupiter</artifactId>
            <scope>test</scope>
        </dependency>
        
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>postgresql</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
            
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.12.1</version>
                <configuration>
                    <source>21</source>
                    <target>21</target>
                    <annotationProcessorPaths>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                            <version>1.18.38</version>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>
            
            <plugin>
                <groupId>org.flywaydb</groupId>
                <artifactId>flyway-maven-plugin</artifactId>
                <version>9.22.3</version>
            </plugin>
        </plugins>
    </build>
</project>
</file>

<file path=".kiro/specs/spring-backend/database-design.md">
# Database Design Document - Employee Management System

## Overview

This document provides comprehensive database design specifications for the Spring Boot Employee Management System using a hybrid data storage approach with PostgreSQL as the primary database and Redis for caching and real-time features. The design supports all system modules including security, employee management, departments, positions, communication, and payroll with enhanced data integrity, security, and compliance features.

## Technology Stack

- **Primary Database**: PostgreSQL 15.x
- **Cache Layer**: Redis 7.x
- **ORM**: Spring Data JPA with Hibernate
- **Caching**: Redis with Spring Cache abstraction
- **Data Modeling**: JPA entities with proper relationships and constraints
- **Transactions**: JPA transactions with Spring @Transactional
- **Security**: Field-level encryption for sensitive data
- **Migration**: Flyway for database versioning

## Database Architecture

### Hybrid Data Storage Strategy

The system uses a hybrid approach with PostgreSQL as the primary database for all persistent data and Redis exclusively for caching and real-time features:

**PostgreSQL (Primary Database - All Persistent Data):**
- All core business entities (User, Role, Resource, Employee, Department, Position, PayrollLedger)
- All transactional data with ACID compliance and referential integrity
- Complex relational queries, joins, and reporting capabilities
- Foreign key constraints and check constraints for data integrity
- Comprehensive audit trails and historical data
- User authentication data and role-based permissions

**Redis (Cache & Real-time Features Only):**
- JWT token blacklisting for secure logout functionality
- Caching of frequently accessed data (department trees, user permissions)
- Real-time chat messages (temporary storage with TTL)
- WebSocket session management and connection tracking
- Search result caching for performance optimization
- Notification queues for real-time delivery

**Critical Design Principle:** 
Redis is used exclusively for caching and real-time features. All persistent, relational data is stored in PostgreSQL to ensure ACID compliance, referential integrity, and proper transaction support. This addresses the fundamental flaw of using Redis as a primary database for relational data.

### Connection Configuration

```properties
# PostgreSQL Configuration
spring.datasource.url=jdbc:postgresql://localhost:5432/employee_management
spring.datasource.username=${DB_USERNAME:employee_admin}
spring.datasource.password=${DB_PASSWORD:secure_password}
spring.datasource.driver-class-name=org.postgresql.Driver

# JPA Configuration
spring.jpa.hibernate.ddl-auto=validate
spring.jpa.show-sql=false
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.jdbc.batch_size=20
spring.jpa.properties.hibernate.order_inserts=true
spring.jpa.properties.hibernate.order_updates=true

# Flyway Configuration
spring.flyway.enabled=true
spring.flyway.locations=classpath:db/migration
spring.flyway.baseline-on-migrate=true

# Redis Configuration (for caching and real-time features)
spring.redis.host=localhost
spring.redis.port=6379
spring.redis.database=0
spring.redis.password=
spring.redis.timeout=2000ms
spring.redis.jedis.pool.max-active=8
spring.redis.jedis.pool.max-idle=8
spring.redis.jedis.pool.min-idle=0
spring.redis.jedis.pool.max-wait=-1ms

# Cache Configuration
spring.cache.type=redis
spring.cache.redis.time-to-live=600000
spring.cache.redis.cache-null-values=false
```

## Core Entity Schemas

### 1. Security Module Entities

#### User Entity
```java
@Entity
@Table(name = "users", 
    indexes = {
        @Index(name = "idx_user_username", columnList = "username"),
        @Index(name = "idx_user_email", columnList = "email"),
        @Index(name = "idx_user_enabled", columnList = "enabled"),
        @Index(name = "idx_user_account_locked", columnList = "account_locked")
    },
    uniqueConstraints = {
        @UniqueConstraint(name = "uk_user_username", columnNames = "username"),
        @UniqueConstraint(name = "uk_user_email", columnNames = "email")
    }
)
@EntityListeners(AuditingEntityListener.class)
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "username", nullable = false, length = 50)
    @NotBlank(message = "Username is required")
    @Size(min = 3, max = 50, message = "Username must be between 3 and 50 characters")
    private String username;        // Unique username for login
    
    @Column(name = "password", nullable = false)
    @NotBlank(message = "Password is required")
    private String password;        // BCrypt encoded password
    
    @Column(name = "email", nullable = false, length = 100)
    @NotBlank(message = "Email is required")
    @Email(message = "Email must be valid")
    private String email;          // User email address
    
    @Column(name = "first_name", length = 50)
    private String firstName;      // User first name
    
    @Column(name = "last_name", length = 50)
    private String lastName;       // User last name
    
    @Column(name = "enabled", nullable = false)
    private Boolean enabled = true; // Account status
    
    @Column(name = "last_login")
    private Instant lastLogin;     // Time-zone aware timestamp
    
    @Column(name = "login_attempts", nullable = false)
    private Integer loginAttempts = 0;
    
    @Column(name = "account_locked", nullable = false)
    private Boolean accountLocked = false;
    
    @Column(name = "account_locked_until")
    private Instant accountLockedUntil; // Automatic unlock time
    
    @Column(name = "password_expired", nullable = false)
    private Boolean passwordExpired = false;
    
    @Column(name = "password_change_required", nullable = false)
    private Boolean passwordChangeRequired = false;
    
    @Column(name = "password_changed_at")
    private Instant passwordChangedAt; // Track password changes
    
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;     // Time-zone aware timestamp
    
    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;     // Time-zone aware timestamp
    
    @Column(name = "created_by")
    private Long createdBy;
    
    @Column(name = "updated_by")
    private Long updatedBy;
    
    // Many-to-Many relationship with Role
    @ManyToMany(fetch = FetchType.LAZY)
    @JoinTable(
        name = "user_roles",
        joinColumns = @JoinColumn(name = "user_id"),
        inverseJoinColumns = @JoinColumn(name = "role_id"),
        foreignKey = @ForeignKey(name = "fk_user_roles_user"),
        inverseForeignKey = @ForeignKey(name = "fk_user_roles_role")
    )
    private Set<Role> roles = new HashSet<>();
    
    // Helper methods for business logic
    public boolean isAccountNonLocked() {
        if (!accountLocked) return true;
        if (accountLockedUntil != null && Instant.now().isAfter(accountLockedUntil)) {
            accountLocked = false;
            accountLockedUntil = null;
            return true;
        }
        return false;
    }
    
    public void incrementLoginAttempts() {
        this.loginAttempts++;
        if (this.loginAttempts >= 5) { // Configurable threshold
            this.accountLocked = true;
            this.accountLockedUntil = Instant.now().plus(Duration.ofMinutes(30));
        }
    }
    
    public void resetLoginAttempts() {
        this.loginAttempts = 0;
        this.accountLocked = false;
        this.accountLockedUntil = null;
        this.lastLogin = Instant.now();
    }
}
```

**Database Table:**
- Table: `users`
- Indexes: `idx_user_username`, `idx_user_email`, `idx_user_enabled`
- Constraints: Unique constraints on username and email

#### Role Entity
```java
@Entity
@Table(name = "roles", indexes = {
    @Index(name = "idx_role_name", columnList = "name"),
    @Index(name = "idx_role_active", columnList = "active")
})
@EntityListeners(AuditingEntityListener.class)
public class Role {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "name", unique = true, nullable = false, length = 50)
    private String name;           // Role name (ADMIN, HR_MANAGER, EMPLOYEE)
    
    @Column(name = "description", length = 255)
    private String description;    // Role description
    
    @Column(name = "active", nullable = false)
    private Boolean active = true; // Role status
    
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;
    
    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;
    
    @Column(name = "created_by")
    private Long createdBy;
    
    @Column(name = "updated_by")
    private Long updatedBy;
    
    // Many-to-Many relationship with User
    @ManyToMany(mappedBy = "roles", fetch = FetchType.LAZY)
    private Set<User> users = new HashSet<>();
    
    // Many-to-Many relationship with Resource
    @ManyToMany(fetch = FetchType.LAZY)
    @JoinTable(
        name = "role_resources",
        joinColumns = @JoinColumn(name = "role_id"),
        inverseJoinColumns = @JoinColumn(name = "resource_id")
    )
    private Set<Resource> resources = new HashSet<>();
}
```

**Database Table:**
- Table: `roles`
- Indexes: `idx_role_name`, `idx_role_active`
- Constraints: Unique constraint on name

#### Resource Entity
```java
public enum ResourceCategory {
    USER,
    EMPLOYEE,
    DEPARTMENT,
    POSITION,
    PAYROLL,
    COMMUNICATION,
    SECURITY,
    OTHER
}

@Entity
@Table(name = "resources", indexes = {
    @Index(name = "idx_resource_url", columnList = "url"),
    @Index(name = "idx_resource_method", columnList = "method"),
    @Index(name = "idx_resource_category", columnList = "category"),
    @Index(name = "idx_resource_active", columnList = "active")
})
@EntityListeners(AuditingEntityListener.class)
public class Resource {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "name", nullable = false, length = 100)
    private String name;           // Resource name
    
    @Column(name = "url", nullable = false, length = 255)
    private String url;            // URL pattern
    
    @Column(name = "method", nullable = false, length = 10)
    private String method;         // HTTP method (GET, POST, PUT, DELETE)
    
    @Column(name = "description", length = 255)
    private String description;    // Resource description
    
    @Enumerated(EnumType.STRING)
    @Column(name = "category", nullable = false, length = 50)
    private ResourceCategory category; // Resource category (USER, EMPLOYEE, DEPARTMENT, etc.)
    
    @Column(name = "active", nullable = false)
    private Boolean active = true; // Resource status
    
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;
    
    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;
    
    @Column(name = "created_by")
    private Long createdBy;
    
    @Column(name = "updated_by")
    private Long updatedBy;
    
    // Many-to-Many relationship with Role
    @ManyToMany(mappedBy = "resources", fetch = FetchType.LAZY)
    private Set<Role> roles = new HashSet<>();
}
```

**Database Table:**
- Table: `resources`
- Indexes: `idx_resource_url`, `idx_resource_method`, `idx_resource_category`, `idx_resource_active`
- Constraints: Composite unique constraint on (url, method)### 
2. Department Management Entities

#### Department Entity
```java
@Entity
@Table(name = "departments", indexes = {
    @Index(name = "idx_department_name", columnList = "name"),
    @Index(name = "idx_department_code", columnList = "code"),
    @Index(name = "idx_department_parent_id", columnList = "parent_id"),
    @Index(name = "idx_department_dep_path", columnList = "dep_path"),
    @Index(name = "idx_department_enabled", columnList = "enabled"),
    @Index(name = "idx_department_manager_id", columnList = "manager_id")
})
@EntityListeners(AuditingEntityListener.class)
public class Department {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "name", nullable = false, length = 100)
    private String name;           // Department name
    
    @Column(name = "code", unique = true, nullable = false, length = 20)
    private String code;           // Department code (unique)
    
    @Column(name = "description", length = 500)
    private String description;    // Department description
    
    @Column(name = "location", length = 255)
    private String location;       // Department physical location
    
    @Column(name = "parent_id")
    private Long parentId;         // Parent department ID (null for root)
    
    @Column(name = "dep_path", length = 500)
    private String depPath;        // Hierarchical path (e.g., "/1/2/3")
    
    @Column(name = "is_parent", nullable = false)
    private Boolean isParent = false; // Has child departments
    
    @Column(name = "enabled", nullable = false)
    private Boolean enabled = true; // Department status (renamed from active for consistency)
    
    @Column(name = "level")
    private Integer level = 0;     // Hierarchy level (0 for root)
    
    @Column(name = "sort_order")
    private Integer sortOrder = 0; // Display order
    
    @Column(name = "manager_id")
    private Long managerId;        // Department manager (Employee ID)
    
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;
    
    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;
    
    @Column(name = "created_by")
    private Long createdBy;
    
    @Column(name = "updated_by")
    private Long updatedBy;
    
    // Self-referencing relationship for parent department
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "parent_id", insertable = false, updatable = false)
    private Department parent;
    
    // One-to-Many relationship for child departments
    @OneToMany(mappedBy = "parent", fetch = FetchType.LAZY)
    private Set<Department> children = new HashSet<>();
    
    // One-to-Many relationship with employees
    @OneToMany(mappedBy = "department", fetch = FetchType.LAZY)
    private Set<Employee> employees = new HashSet<>();
    
    // Transient field for employee count (calculated dynamically)
    @Transient
    private Long employeeCount;
}
```

**Database Table:**
- Table: `departments`
- Indexes: Multiple indexes for efficient querying
- Constraints: Unique constraint on code, foreign key to self for parent_id

### 3. Position Management Entities

#### Position Entity
```java
@Entity
@Table(name = "positions", indexes = {
    @Index(name = "idx_position_job_title", columnList = "job_title"),
    @Index(name = "idx_position_code", columnList = "code"),
    @Index(name = "idx_position_department_id", columnList = "department_id"),
    @Index(name = "idx_position_level", columnList = "level"),
    @Index(name = "idx_position_enabled", columnList = "enabled"),
    @Index(name = "idx_position_category", columnList = "category")
})
@EntityListeners(AuditingEntityListener.class)
public class Position {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "job_title", nullable = false, length = 100)
    private String jobTitle;       // Job title
    
    @Column(name = "professional_title", length = 100)
    private String professionalTitle; // Professional title
    
    @Column(name = "code", unique = true, nullable = false, length = 20)
    private String code;           // Position code (unique)
    
    @Column(name = "description", length = 1000)
    private String description;    // Position description
    
    @Column(name = "requirements", length = 2000)
    private String requirements;   // Job requirements
    
    @Column(name = "responsibilities", length = 2000)
    private String responsibilities; // Job responsibilities
    
    @Enumerated(EnumType.STRING)
    @Column(name = "category", nullable = false, length = 20)
    private PositionCategory category = PositionCategory.TECHNICAL; // TECHNICAL, MANAGEMENT, ADMINISTRATIVE, etc.
    
    @Column(name = "salary_grade", length = 10)
    private String salaryGrade;    // Salary grade/band
    
    @Column(name = "department_id", nullable = false)
    @NotNull(message = "Department is required")
    private Long departmentId;     // Associated department
    
    @Enumerated(EnumType.STRING)
    @Column(name = "level", nullable = false, length = 20)
    private PositionLevel level = PositionLevel.JUNIOR; // JUNIOR, SENIOR, MANAGER, etc.
    
    @Column(name = "enabled", nullable = false)
    private Boolean enabled = true; // Position enabled status
    
    @Column(name = "min_salary", precision = 12, scale = 2)
    private BigDecimal minSalary;  // Minimum salary range
    
    @Column(name = "max_salary", precision = 12, scale = 2)
    private BigDecimal maxSalary;  // Maximum salary range
    
    @Column(name = "required_skills", length = 1000)
    private String requiredSkills; // Required skills (JSON or comma-separated)
    
    @Column(name = "required_education", length = 500)
    private String requiredEducation; // Required education level
    
    @Column(name = "required_experience")
    private Integer requiredExperience; // Required years of experience
    
    @Column(name = "benefits", length = 1000)
    private String benefits;       // Position benefits
    
    @Column(name = "work_location", length = 255)
    private String workLocation;   // Work location (OFFICE, REMOTE, HYBRID)
    
    @Enumerated(EnumType.STRING)
    @Column(name = "employment_type", nullable = false, length = 20)
    private EmploymentType employmentType = EmploymentType.FULL_TIME; // FULL_TIME, PART_TIME, CONTRACT
    
    @Column(name = "is_managerial", nullable = false)
    private Boolean isManagerial = false; // Is this a management position
    
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;     // Time-zone aware timestamp
    
    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;     // Time-zone aware timestamp
    
    @Column(name = "created_by")
    private Long createdBy;
    
    @Column(name = "updated_by")
    private Long updatedBy;
    
    // Many-to-One relationship with Department
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "department_id", insertable = false, updatable = false)
    private Department department;
    
    // One-to-Many relationship with employees
    @OneToMany(mappedBy = "position", fetch = FetchType.LAZY)
    private Set<Employee> employees = new HashSet<>();
    
    // Transient field for employee count (calculated dynamically)
    @Transient
    private Long employeeCount;
    
    // Business logic methods
    public boolean isWithinSalaryRange(BigDecimal salary) {
        if (salary == null) return true;
        boolean aboveMin = minSalary == null || salary.compareTo(minSalary) >= 0;
        boolean belowMax = maxSalary == null || salary.compareTo(maxSalary) <= 0;
        return aboveMin && belowMax;
    }
}

// Position Category Enum
public enum PositionCategory {
    TECHNICAL,
    MANAGEMENT,
    ADMINISTRATIVE,
    SALES,
    MARKETING,
    FINANCE,
    HR,
    OPERATIONS,
    LEGAL,
    OTHER
}

// Position Level Enum
public enum PositionLevel {
    INTERN,
    JUNIOR,
    SENIOR,
    LEAD,
    MANAGER,
    SENIOR_MANAGER,
    DIRECTOR,
    SENIOR_DIRECTOR,
    VP,
    SVP,
    EXECUTIVE
}
```

**Database Table:**
- Table: `positions`
- Indexes: Multiple indexes for efficient querying
- Constraints: Unique constraint on code, foreign key to departments

### 4. Employee Management Entities

#### Employee Entity
```java
@Entity
@Table(name = "employees", 
    indexes = {
        @Index(name = "idx_employee_number", columnList = "employee_number"),
        @Index(name = "idx_employee_email", columnList = "email"),
        @Index(name = "idx_employee_department_id", columnList = "department_id"),
        @Index(name = "idx_employee_position_id", columnList = "position_id"),
        @Index(name = "idx_employee_manager_id", columnList = "manager_id"),
        @Index(name = "idx_employee_status", columnList = "status"),
        @Index(name = "idx_employee_pay_type", columnList = "pay_type"),
        @Index(name = "idx_employee_hire_date", columnList = "hire_date"),
        @Index(name = "idx_employee_enabled", columnList = "enabled")
    },
    uniqueConstraints = {
        @UniqueConstraint(name = "uk_employee_number", columnNames = "employee_number"),
        @UniqueConstraint(name = "uk_employee_email", columnNames = "email")
    }
)
@EntityListeners(AuditingEntityListener.class)
public class Employee {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "employee_number", nullable = false, length = 20)
    @NotBlank(message = "Employee number is required")
    private String employeeNumber; // Unique employee number
    
    @Column(name = "first_name", nullable = false, length = 50)
    @NotBlank(message = "First name is required")
    private String firstName;      // First name
    
    @Column(name = "last_name", nullable = false, length = 50)
    @NotBlank(message = "Last name is required")
    private String lastName;       // Last name
    
    @Column(name = "email", nullable = false, length = 100)
    @NotBlank(message = "Email is required")
    @Email(message = "Email must be valid")
    private String email;          // Email address (unique)
    
    @Column(name = "phone", length = 20)
    private String phone;          // Phone number
    
    @Column(name = "mobile_phone", length = 20)
    private String mobilePhone;    // Mobile phone number
    
    // Address fields (detailed breakdown)
    @Column(name = "address", length = 255)
    private String address;        // Street address
    
    @Column(name = "city", length = 100)
    private String city;           // City
    
    @Column(name = "state", length = 100)
    private String state;          // State/Province
    
    @Column(name = "zip_code", length = 20)
    private String zipCode;        // ZIP/Postal code
    
    @Column(name = "country", length = 100)
    private String country;        // Country
    
    @Column(name = "date_of_birth_encrypted", length = 255)
    private String dateOfBirthEncrypted; // Encrypted date of birth (AES)
    
    @Enumerated(EnumType.STRING)
    @Column(name = "gender", length = 10)
    private Gender gender;         // MALE, FEMALE, OTHER, PREFER_NOT_TO_SAY
    
    @Column(name = "nationality", length = 50)
    private String nationality;    // Nationality
    
    @Enumerated(EnumType.STRING)
    @Column(name = "marital_status", length = 20)
    private MaritalStatus maritalStatus; // SINGLE, MARRIED, DIVORCED, WIDOWED
    
    @Column(name = "department_id", nullable = false)
    @NotNull(message = "Department is required")
    private Long departmentId;     // Department assignment
    
    @Column(name = "position_id", nullable = false)
    @NotNull(message = "Position is required")
    private Long positionId;       // Position assignment
    
    @Column(name = "manager_id")
    private Long managerId;        // Direct manager ID
    
    @Column(name = "hire_date", nullable = false)
    @NotNull(message = "Hire date is required")
    private LocalDate hireDate;    // Hire date
    
    @Column(name = "termination_date")
    private LocalDate terminationDate; // Termination date (if applicable)
    
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 20)
    private EmployeeStatus status = EmployeeStatus.ACTIVE;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "employment_type", nullable = false, length = 20)
    private EmploymentType employmentType = EmploymentType.FULL_TIME;
    
    // CRITICAL FIX: Support both salaried and hourly employees
    @Enumerated(EnumType.STRING)
    @Column(name = "pay_type", nullable = false, length = 10)
    private PayType payType = PayType.SALARY; // SALARY or HOURLY
    
    @Column(name = "salary", precision = 12, scale = 2)
    private BigDecimal salary;     // Annual salary for salaried employees
    
    @Column(name = "hourly_rate", precision = 8, scale = 2)
    private BigDecimal hourlyRate; // Hourly rate for hourly employees
    
    @Column(name = "salary_grade", length = 10)
    private String salaryGrade;    // Salary grade/band
    
    @Enumerated(EnumType.STRING)
    @Column(name = "work_location", length = 20)
    private WorkLocation workLocation = WorkLocation.OFFICE; // OFFICE, REMOTE, HYBRID
    
    // Encrypted sensitive fields (AES encryption)
    @Column(name = "bank_account_encrypted", length = 255)
    private String bankAccountEncrypted; // Bank account details (encrypted)
    
    @Column(name = "tax_id_encrypted", length = 255)
    private String taxIdEncrypted;       // Tax identification (encrypted)
    
    // Skills and qualifications
    @Column(name = "skills", columnDefinition = "TEXT")
    private String skills;         // Skills (JSON format)
    
    @Column(name = "education", length = 1000)
    private String education;      // Education background
    
    @Column(name = "certifications", length = 1000)
    private String certifications; // Professional certifications
    
    @Column(name = "notes", length = 2000)
    private String notes;          // Additional notes
    
    @Column(name = "enabled", nullable = false)
    private Boolean enabled = true; // Account enabled status
    
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;     // Time-zone aware timestamp
    
    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;     // Time-zone aware timestamp
    
    @Column(name = "created_by")
    private Long createdBy;
    
    @Column(name = "updated_by")
    private Long updatedBy;
    
    // Profile image URL
    @Column(name = "profile_image_url", length = 500)
    private String profileImageUrl;
    
    // Emergency contact information
    @Column(name = "emergency_contact_name", length = 100)
    private String emergencyContactName;
    
    @Column(name = "emergency_contact_phone", length = 20)
    private String emergencyContactPhone;
    
    @Column(name = "emergency_contact_relation", length = 50)
    private String emergencyContactRelation;
    
    // Relationships with proper foreign key constraints
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "department_id", insertable = false, updatable = false,
                foreignKey = @ForeignKey(name = "fk_employee_department"))
    private Department department;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "position_id", insertable = false, updatable = false,
                foreignKey = @ForeignKey(name = "fk_employee_position"))
    private Position position;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "manager_id", insertable = false, updatable = false,
                foreignKey = @ForeignKey(name = "fk_employee_manager"))
    private Employee manager;
    
    @OneToMany(mappedBy = "manager", fetch = FetchType.LAZY)
    private Set<Employee> directReports = new HashSet<>();
    
    @OneToMany(mappedBy = "employee", fetch = FetchType.LAZY, cascade = CascadeType.ALL)
    private Set<PayrollLedger> payrollLedgers = new HashSet<>();
    
    // Business logic methods
    public String getFullName() {
        return firstName + " " + lastName;
    }
    
    public boolean isActive() {
        return status == EmployeeStatus.ACTIVE && enabled;
    }
    
    public boolean isSalaried() {
        return payType == PayType.SALARY;
    }
    
    public boolean isHourly() {
        return payType == PayType.HOURLY;
    }
    
    // Validation method for salary range
    public void validateSalaryAgainstPosition(Position position) {
        if (isSalaried() && salary != null && position != null) {
            if (position.getMinSalary() != null && salary.compareTo(position.getMinSalary()) < 0) {
                throw new ValidationException("Salary below minimum range for position");
            }
            if (position.getMaxSalary() != null && salary.compareTo(position.getMaxSalary()) > 0) {
                throw new ValidationException("Salary above maximum range for position");
            }
        }
    }
}

// Employee Status Enum
public enum EmployeeStatus {
    ACTIVE,
    INACTIVE,
    TERMINATED,
    ON_LEAVE,
    SUSPENDED
}

// Employment Type Enum
public enum EmploymentType {
    FULL_TIME,
    PART_TIME,
    CONTRACT,
    INTERN,
    CONSULTANT
}

// Pay Type Enum (CRITICAL FIX for payroll support)
public enum PayType {
    SALARY,    // Annual salary
    HOURLY     // Hourly rate
}

// Gender Enum
public enum Gender {
    MALE,
    FEMALE,
    OTHER,
    PREFER_NOT_TO_SAY
}

// Marital Status Enum
public enum MaritalStatus {
    SINGLE,
    MARRIED,
    DIVORCED,
    WIDOWED,
    SEPARATED
}

// Work Location Enum
public enum WorkLocation {
    OFFICE,
    REMOTE,
    HYBRID
}
```

**Database Table:**
- Table: `employees`
- Indexes: Multiple indexes for efficient querying
- Constraints: Unique constraints on employee_number and email
- Security: Sensitive fields (dateOfBirth, bankAccount, taxId) should be encrypted##
# 5. Communication System Entities

#### Email Template Entity
```java
@Entity
@Table(name = "email_templates", indexes = {
    @Index(name = "idx_email_template_name", columnList = "name"),
    @Index(name = "idx_email_template_code", columnList = "code"),
    @Index(name = "idx_email_template_category", columnList = "category"),
    @Index(name = "idx_email_template_active", columnList = "active")
})
@EntityListeners(AuditingEntityListener.class)
public class EmailTemplate {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "name", nullable = false, length = 100)
    private String name;           // Template name
    
    @Column(name = "code", unique = true, nullable = false, length = 50)
    private String code;           // Template code (unique)
    
    @Column(name = "subject", nullable = false, length = 255)
    private String subject;        // Email subject template
    
    @Column(name = "content", columnDefinition = "TEXT")
    private String content;        // Email content (unified field)
    
    @Enumerated(EnumType.STRING)
    @Column(name = "template_type", nullable = false, length = 10)
    private TemplateType templateType = TemplateType.HTML; // HTML, TEXT, MIXED
    
    @Enumerated(EnumType.STRING)
    @Column(name = "category", length = 50)
    private TemplateCategory category; // Template category
    
    @Column(name = "enabled", nullable = false)
    private Boolean enabled = true;
    
    @Column(name = "is_default", nullable = false)
    private boolean isDefault = false;
    
    @Column(name = "variables", columnDefinition = "TEXT")
    private String variables;      // JSON array of template variables
    
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;
    
    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;
    
    @Column(name = "created_by")
    private Long createdBy;        // User who created template
    
    @Column(name = "updated_by")
    private Long updatedBy;
    
    @OneToMany(mappedBy = "template", fetch = FetchType.LAZY)
    private Set<EmailLog> emailLogs = new HashSet<>();
}

// Template Type Enum
public enum TemplateType {
    HTML,
    TEXT,
    MIXED
}
```

#### Email Log Entity
```java
@Entity
@Table(name = "email_logs", indexes = {
    @Index(name = "idx_email_log_template_code", columnList = "template_code"),
    @Index(name = "idx_email_log_to_email", columnList = "to_email"),
    @Index(name = "idx_email_log_status", columnList = "status"),
    @Index(name = "idx_email_log_sent_at", columnList = "sent_at"),
    @Index(name = "idx_email_log_sent_by", columnList = "sent_by")
})
@EntityListeners(AuditingEntityListener.class)
public class EmailLog {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "template_code", length = 50)
    private String templateCode;   // Template code used (instead of ID for flexibility)
    
    @Column(name = "to_email", nullable = false, length = 255)
    private String toEmail;        // Primary recipient email
    
    @Column(name = "cc_emails", length = 1000)
    private String ccEmails;       // CC recipients (comma-separated)
    
    @Column(name = "bcc_emails", length = 1000)
    private String bccEmails;      // BCC recipients (comma-separated)
    
    @Column(name = "subject", nullable = false, length = 255)
    private String subject;        // Actual subject sent
    
    @Column(name = "content", columnDefinition = "TEXT")
    private String content;        // Actual content sent
    
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 20)
    private EmailStatus status = EmailStatus.PENDING; // PENDING, SENT, FAILED, BOUNCED
    
    @Column(name = "sent_at")
    private Instant sentAt;  // When email was sent
    
    @Column(name = "error_message", length = 1000)
    private String errorMessage;   // Error details if failed
    
    @Column(name = "retry_count")
    private Integer retryCount = 0; // Number of retry attempts
    
    @Column(name = "sent_by")
    private Long sentBy;           // User who sent email
    
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;
    
    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;
    
    // Relationship with template (optional, as template might be deleted)
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "template_id")
    private EmailTemplate template;
}

// Email Status Enum
public enum EmailStatus {
    PENDING,
    SENT,
    FAILED,
    BOUNCED,
    DELIVERED,
    OPENED,
    CLICKED
}
```

#### Chat Message Entity
```java
@Entity
@Table(name = "chat_messages", indexes = {
    @Index(name = "idx_chatmessage_room_id", columnList = "room_id"),
    @Index(name = "idx_chatmessage_sender_id", columnList = "sender_id"),
    @Index(name = "idx_chatmessage_created_at", columnList = "created_at")
})
@EntityListeners(AuditingEntityListener.class)
public class ChatMessage {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
  
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "room_id", nullable = false)
    private ChatRoom room;
      
    @Column(name = "sender_id", nullable = false)
    private Long senderId;         // Message sender
      
    @Column(name = "content", columnDefinition = "TEXT")
    private String content;        // Message content
      
    @Enumerated(EnumType.STRING)
    @Column(name = "message_type", length = 20)
    private ChatMessageType messageType;    // Mapped from ChatMessageType enum (TEXT, IMAGE, FILE, SYSTEM)
      
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;     // Time-zone aware timestamp
      
    @Column(name = "is_edited", nullable = false)
    private Boolean isEdited = false;
      
    @Column(name = "edited_at")
    private Instant editedAt;      // Time-zone aware timestamp
      
    @Column(name = "reply_to_id")
    private Long replyToId;        // Reply to message ID
      
    @Column(name = "attachment_url", length = 500)
    private String attachmentUrl;
      
    @Column(name = "attachment_type", length = 100)
    private String attachmentType;
      
    @Column(name = "attachment_size")
    private Long attachmentSize;
      
    @Column(name = "is_deleted", nullable = false)
    private Boolean isDeleted = false;
      
    @Column(name = "deleted_at")
    private Instant deletedAt;     // Time-zone aware timestamp
      
    @Column(name = "metadata", columnDefinition = "TEXT")
    private String metadata;       // JSON
      
    @Column(name = "read_receipts", columnDefinition = "TEXT")
    private String readReceipts;   // JSON
    }
```

**Note:** Chat messages are stored in PostgreSQL to ensure data integrity and support complex queries.

#### Chat Room Entity
```java
@Entity
@Table(name = "chat_rooms", indexes = {
    @Index(name = "idx_chatroom_name", columnList = "name"),
    @Index(name = "idx_chatroom_type", columnList = "type"),
    @Index(name = "idx_chatroom_created_by", columnList = "created_by")
})
@EntityListeners(AuditingEntityListener.class)
public class ChatRoom {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
  
    @Column(name = "name", length = 100)
    private String name;           // Room name
  
    @Enumerated(EnumType.STRING)
    @Column(name = "type", nullable = false, length = 20)
    private ChatRoomType type;     // DIRECT, GROUP, CHANNEL
  
    @Column(name = "description", length = 500)
    private String description;
  
    @Column(name = "created_by")
    private Long createdBy;
  
    @Column(name = "is_active", nullable = false)
    private Boolean isActive = true;
  
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;     // Time-zone aware timestamp
  
    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;     // Time-zone aware timestamp
  
    @Column(name = "last_message_at")
    private Instant lastMessageAt; // Time-zone aware timestamp
  
    @Column(name = "is_private", nullable = false)
    private Boolean isPrivate = false;
  
    @Column(name = "max_participants")
    private Integer maxParticipants;
  
    @OneToMany(mappedBy = "room", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<ChatMessage> messages = new HashSet<>();
    
    @OneToMany(mappedBy = "room", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<ChatParticipant> participants = new HashSet<>();
}

public enum ChatRoomType {
    DIRECT,
    GROUP,
    CHANNEL
}

#### ChatParticipant Entity
```java
@Entity
@Table(name = "chat_participants", uniqueConstraints = {
    @UniqueConstraint(columnNames = {"room_id", "user_id"}, name = "uk_participant_room_user")
})
public class ChatParticipant {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "room_id", nullable = false)
    private ChatRoom room;
    
    @Column(name = "user_id", nullable = false)
    private Long userId;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "role", nullable = false, length = 20)
    private ChatParticipantRole role; // OWNER, ADMIN, MEMBER
    
    @Column(name = "joined_at", nullable = false)
    private Instant joinedAt;
    
    @Column(name = "last_read_at")
    private Instant lastReadAt;
    
    @Column(name = "last_read_message_id")
    private Long lastReadMessageId;
    
    @Column(name = "is_muted", nullable = false)
    private boolean isMuted = false;
    
    @Column(name = "is_active", nullable = false)
    private boolean isActive = true;
    
    @Column(name = "left_at")
    private Instant leftAt;
}
```

#### Notification Entity
```java
@Entity
@Table(name = "notifications", indexes = {
    @Index(name = "idx_notification_user_id", columnList = "user_id"),
    @Index(name = "idx_notification_type", columnList = "type"),
    @Index(name = "idx_notification_read_status", columnList = "read_status")
})
@EntityListeners(AuditingEntityListener.class)
public class Notification {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
  
    @Column(name = "user_id", nullable = false)
    private Long userId;           // Target user
  
    @Column(name = "type", length = 50)
    private String type;           // SYSTEM, EMAIL, CHAT, TASK, etc.
  
    @Column(name = "title", length = 255)
    private String title;
  
    @Column(name = "content", columnDefinition = "TEXT")
    private String content;
  
    @Column(name = "data", columnDefinition = "TEXT")
    private String data;           // Additional JSON data
  
    @Column(name = "read_status", nullable = false)
    private Boolean read = false;
  
    @Column(name = "priority", length = 20)
    private String priority;       // LOW, MEDIUM, HIGH, URGENT
  
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;     // Time-zone aware timestamp
  
    @Column(name = "read_at")
    private Instant readAt;        // Time-zone aware timestamp
  
    @Column(name = "expires_at")
    private Instant expiresAt;     // Time-zone aware timestamp
  
    @Column(name = "action_url", length = 500)
    private String actionUrl;
  
    @Column(name = "related_entity_id")
    private Long relatedEntityId;
  
    @Column(name = "related_entity_type", length = 50)
    private String relatedEntityType;
}
```
### 6. Payroll Management Entities

### PayrollLedger Entity
```java
package com.example.demo.payroll.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import lombok.Builder;
import com.example.demo.employee.entity.Employee;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.math.BigDecimal;
import java.math.BigDecimal;
import java.time.Instant;
import java.time.LocalDate;

@Entity
@Table(name = "payroll_ledgers", indexes = {
    @Index(name = "idx_payrollledger_employee_id", columnList = "employee_id"),
    @Index(name = "idx_payrollledger_period_id", columnList = "payroll_period_id"),
    @Index(name = "idx_payrollledger_status", columnList = "status")
})
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@EntityListeners(AuditingEntityListener.class)
public class PayrollLedger {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "employee_id", nullable = false)
    private Employee employee;

    @Column(name = "payroll_period_id", nullable = false)
    private Long payrollPeriodId;

    @Column(name = "employee_number", length = 20)
    private String employeeNumber;

    @Column(name = "employee_name", length = 100)
    private String employeeName;

    @Column(name = "department_id")
    private Long departmentId;

    @Column(name = "department_name", length = 100)
    private String departmentName;

    @Column(name = "position_id")
    private Long positionId;

    @Column(name = "position_name", length = 100)
    private String positionName;

    @Column(name = "base_salary", precision = 12, scale = 2)
    private BigDecimal baseSalary;

    @Column(name = "hourly_rate", precision = 12, scale = 2)
    private BigDecimal hourlyRate;

    @Column(name = "hours_worked", precision = 10, scale = 2)
    private BigDecimal hoursWorked;

    @Column(name = "overtime_hours", precision = 10, scale = 2)
    private BigDecimal overtimeHours;

    @Column(name = "overtime_rate", precision = 12, scale = 2)
    private BigDecimal overtimeRate;

    @Column(name = "total_allowances", precision = 12, scale = 2)
    private BigDecimal totalAllowances;

    @Column(name = "total_deductions", precision = 12, scale = 2)
    private BigDecimal totalDeductions;

    @Column(name = "gross_salary", precision = 12, scale = 2)
    private BigDecimal grossSalary;

    @Column(name = "net_salary", precision = 12, scale = 2)
    private BigDecimal netSalary;

    @Column(name = "employer_contributions", precision = 12, scale = 2)
    private BigDecimal employerContributions;

    @Column(name = "total_cost", precision = 12, scale = 2)
    private BigDecimal totalCost;

    @Column(name = "currency", length = 10)
    private String currency;

    @Enumerated(EnumType.STRING)
    @Column(name = "payment_method", length = 20)
    private PaymentMethod paymentMethod;

    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 20)
    private PayrollLedgerStatus status;

    @Column(name = "pay_date")
    private LocalDate payDate;

    @Lob
    @Column(name = "notes", columnDefinition = "TEXT")
    private String notes;

    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;

    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;

    @Column(name = "created_by")
    private Long createdBy;

    @Column(name = "updated_by")
    private Long updatedBy;

    @Lob
    @Column(name = "calculation_details", columnDefinition = "TEXT")
    private String calculationDetails; // JSON string for all components
}
```

> **关键业务规则：薪资记录快照**
>
> `PayrollLedger` 实体中的以下字段必须被视为 **一次性创建的快照（Snapshot）**，以确保历史薪资报告的永久准确性：
>
> *   `employeeName`
> *   `departmentName`
> *   `positionName`
> *   `baseSalary`, `hourlyRate`, 等所有与薪资计算相关的数值字段
>
> **实现要求**：
> 1.  在创建一条新的 `PayrollLedger` 记录的业务逻辑（例如在 `PayrollService` 中）时，必须在一个事务内，从关联的 `Employee`, `Department`, `Position` 等实体中获取当前的名称和值，并填充到这些快照字段中。
> 2.  一旦 `PayrollLedger` 记录被创建，这些快照字段 **绝对不能** 因为源实体信息（如员工改名、部门调动）的变更而被更新。它们必须永久保留创建时刻的状态。
> 3.  此规则是确保系统财务审计合规性的核心要求。

### PayrollPeriod Entity
```java
package com.example.demo.payroll.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.Instant;
import java.time.LocalDate;

@Entity
@Table(name = "payroll_periods", indexes = {
    @Index(name = "idx_payrollperiod_start_end", columnList = "start_date, end_date"),
    @Index(name = "idx_payrollperiod_status", columnList = "status")
})
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@EntityListeners(AuditingEntityListener.class)
public class PayrollPeriod {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "name", nullable = false, length = 100)
    private String name;

    @Enumerated(EnumType.STRING)
    @Column(name = "type", nullable = false, length = 20)
    private PayrollPeriodType type;

    @Column(name = "start_date", nullable = false)
    private LocalDate startDate;

    @Column(name = "end_date", nullable = false)
    private LocalDate endDate;

    @Column(name = "pay_date", nullable = false)
    private LocalDate payDate;

    @Column(name = "working_days")
    private Integer workingDays;

    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 20)
    private PayrollPeriodStatus status;

    @Column(name = "description", length = 500)
    private String description;

    @Column(name = "is_active", nullable = false)
    private boolean isActive = true;

    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;

    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;

    @Column(name = "created_by")
    private Long createdBy;

    @Column(name = "updated_by")
    private Long updatedBy;
}
```

### SalaryComponent Entity
```java
package com.example.demo.payroll.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.math.BigDecimal;
import java.time.Instant;

@Entity
@Table(name = "salary_components", indexes = {
    @Index(name = "idx_salarycomponent_code", columnList = "code", unique = true),
    @Index(name = "idx_salarycomponent_type", columnList = "type")
})
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@EntityListeners(AuditingEntityListener.class)
public class SalaryComponent {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "code", nullable = false, unique = true, length = 50)
    private String code;

    @Column(name = "name", nullable = false, length = 100)
    private String name;

    @Enumerated(EnumType.STRING)
    @Column(name = "type", nullable = false, length = 20)
    private SalaryComponentType type; // ALLOWANCE, DEDUCTION

    @Enumerated(EnumType.STRING)
    @Column(name = "calculation_type", nullable = false, length = 20)
    private CalculationType calculationType; // FIXED, PERCENTAGE

    @Column(name = "value", precision = 12, scale = 2)
    private BigDecimal value; // Amount for FIXED, percentage for PERCENTAGE

    @Column(name = "is_taxable", nullable = false)
    private boolean isTaxable = false;

    @Column(name = "is_active", nullable = false)
    private boolean isActive = true;

    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;

    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;
}
```

### PayrollAudit Entity
```java
package com.example.demo.payroll.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.Instant;

@Entity
@Table(name = "payroll_audits", indexes = {
    @Index(name = "idx_payrollaudit_ledger_id", columnList = "payroll_ledger_id"),
    @Index(name = "idx_payrollaudit_performed_by", columnList = "performed_by")
})
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@EntityListeners(AuditingEntityListener.class)
public class PayrollAudit {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "payroll_ledger_id", nullable = false)
    private Long payrollLedgerId;

    @Column(name = "action", nullable = false, length = 50)
    private String action;

    @Lob
    @Column(name = "details", columnDefinition = "TEXT")
    private String details; // JSON string of changes

    @Column(name = "reason", length = 500)
    private String reason;

    @Column(name = "performed_by", nullable = false)
    private Long performedBy;

    @CreatedDate
    @Column(name = "performed_at", nullable = false, updatable = false)
    private Instant performedAt;

    @Column(name = "ip_address", length = 45)
    private String ipAddress;
}
```

## Relationship Management

### Many-to-Many Relationships

Many-to-many relationships like `User-Role` and `Role-Resource` are managed directly via JPA's `@ManyToMany` and `@JoinTable` annotations within the `User` and `Role` entities. This ensures that the relationships are stored in PostgreSQL junction tables (`user_roles`, `role_resources`), maintaining full ACID compliance and referential integrity.

The previous design of storing these critical relationships in Redis (`@RedisHash`) was a severe design flaw and has been removed. The correct implementation is already defined in the `User` and `Role` entities.

## Caching Strategy

### Cache Configurations

```java
@Configuration
@EnableCaching
public class CacheConfig {
    
    // User permissions cache - 30 minutes TTL
    @Bean
    public RedisCacheConfiguration userPermissionsCache() {
        return RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofMinutes(30))
            .serializeKeysWith(RedisSerializationContext.SerializationPair
                .fromSerializer(new StringRedisSerializer()))
            .serializeValuesWith(RedisSerializationContext.SerializationPair
                .fromSerializer(new GenericJackson2JsonRedisSerializer()));
    }
    
    // Department tree cache - 1 hour TTL
    @Bean
    public RedisCacheConfiguration departmentTreeCache() {
        return RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofHours(1));
    }
    
    // Employee search cache - 15 minutes TTL
    @Bean
    public RedisCacheConfiguration employeeSearchCache() {
        return RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofMinutes(15));
    }
}
```

### Cache Keys Pattern

```
Cache Key Patterns:
- User permissions: cache:user_permissions:{userId}
- Department tree: cache:department_tree:all
- Employee search: cache:employee_search:{searchHash}
- Position list: cache:positions:department:{departmentId}
- Payroll summary: cache:payroll_summary:{employeeId}:{period}
```#
# Data Initialization and Seeding

### Initial Data Requirements

#### Default Roles
```java
// System default roles to be created on startup
public enum DefaultRoles {
    SUPER_ADMIN("Super Administrator", "Full system access"),
    ADMIN("Administrator", "System administration access"),
    HR_MANAGER("HR Manager", "Human resources management"),
    DEPARTMENT_MANAGER("Department Manager", "Department management"),
    EMPLOYEE("Employee", "Basic employee access");
}
```

#### Default Resources
```java
// System resources for permission management
public class DefaultResources {
    // User Management
    USER_CREATE("/api/users", "POST", "Create new user"),
    USER_READ("/api/users/**", "GET", "View user information"),
    USER_UPDATE("/api/users/**", "PUT", "Update user information"),
    USER_DELETE("/api/users/**", "DELETE", "Delete user"),
    
    // Employee Management
    EMPLOYEE_CREATE("/api/employees", "POST", "Create new employee"),
    EMPLOYEE_READ("/api/employees/**", "GET", "View employee information"),
    EMPLOYEE_UPDATE("/api/employees/**", "PUT", "Update employee information"),
    EMPLOYEE_DELETE("/api/employees/**", "DELETE", "Delete employee"),
    EMPLOYEE_IMPORT("/api/employees/import", "POST", "Import employees"),
    EMPLOYEE_EXPORT("/api/employees/export", "GET", "Export employees"),
    
    // Department Management
    DEPARTMENT_CREATE("/api/departments", "POST", "Create department"),
    DEPARTMENT_READ("/api/departments/**", "GET", "View departments"),
    DEPARTMENT_UPDATE("/api/departments/**", "PUT", "Update department"),
    DEPARTMENT_DELETE("/api/departments/**", "DELETE", "Delete department"),
    
    // Payroll Management
    PAYROLL_CREATE("/api/payroll/**", "POST", "Create payroll"),
    PAYROLL_READ("/api/payroll/**", "GET", "View payroll"),
    PAYROLL_UPDATE("/api/payroll/**", "PUT", "Update payroll"),
    PAYROLL_PROCESS("/api/payroll/process", "POST", "Process payroll");
}
```

### Data Migration Scripts

#### Version 1.0 - Initial Schema
```java
@Component
public class DatabaseInitializer implements ApplicationRunner {
    
    @Override
    public void run(ApplicationArguments args) throws Exception {
        // Create default roles
        createDefaultRoles();
        
        // Create default resources
        createDefaultResources();
        
        // Create default admin user
        createDefaultAdminUser();
        
        // Create default salary components
        createDefaultSalaryComponents();
        
        // Create default email templates
        createDefaultEmailTemplates();
    }
}
```

## Performance Optimization

### Indexing Strategy

```java
// Custom indexes for complex queries
@Configuration
public class RedisIndexConfig {
    
    @Bean
    public RedisTemplate<String, Object> redisTemplate() {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        
        // Configure serializers
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        template.setHashKeySerializer(new StringRedisSerializer());
        template.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());
        
        return template;
    }
    
    // Create composite indexes for complex queries
    @PostConstruct
    public void createIndexes() {
        // Employee search index
        createEmployeeSearchIndex();
        
        // Department hierarchy index
        createDepartmentHierarchyIndex();
        
        // Payroll period index
        createPayrollPeriodIndex();
    }
}
```

### Query Optimization Patterns

```java
// Efficient query patterns for Redis
public class QueryOptimizationPatterns {
    
    // Use pipeline for batch operations
    public List<Employee> findEmployeesByIds(Set<Long> ids) {
        return redisTemplate.executePipelined(connection -> {
            ids.forEach(id -> connection.get(("employees:" + id).getBytes()));
            return null;
        });
    }
    
    // **Architectural Mandate:** Caching layers are only to be updated or invalidated *after* a successful transaction in the primary PostgreSQL database.
    // The following Lua script example is removed as it violates this principle.
}
```

## Backup and Recovery

### Backup Strategy

```yaml
# Redis backup configuration
redis:
  backup:
    enabled: true
    schedule: "0 2 * * *"  # Daily at 2 AM
    retention: 30          # Keep 30 days of backups
    location: "/backup/redis"
    compression: true
```

### Data Recovery Procedures

```java
@Service
public class DataRecoveryService {
    
    public void createBackup(String backupName) {
        // Create Redis snapshot
        redisTemplate.execute(connection -> {
            connection.bgSave();
            return null;
        });
    }
    
    public void restoreFromBackup(String backupFile) {
        // Restore from Redis dump file
        // Implementation depends on deployment strategy
    }
    
    public void validateDataIntegrity() {
        // Validate referential integrity
        validateUserRoleReferences();
        validateEmployeeDepartmentReferences();
        validatePayrollEmployeeReferences();
    }
}
```

## Monitoring and Metrics

### Database Monitoring

```java
@Component
public class DatabaseMetrics {
    
    private final MeterRegistry meterRegistry;
    private final RedisTemplate redisTemplate;
    
    @EventListener
    public void handleDatabaseOperation(DatabaseOperationEvent event) {
        Timer.Sample sample = Timer.start(meterRegistry);
        sample.stop(Timer.builder("database.operation")
            .tag("operation", event.getOperation())
            .tag("entity", event.getEntityType())
            .register(meterRegistry));
    }
    
    @Scheduled(fixedRate = 60000) // Every minute
    public void collectRedisMetrics() {
        RedisInfo info = (RedisInfo) redisTemplate.execute(connection -> {
            return connection.info();
        });
        
        // Collect memory usage, connections, operations/sec
        meterRegistry.gauge("redis.memory.used", info.getUsedMemory());
        meterRegistry.gauge("redis.connections.connected", info.getConnectedClients());
    }
}
```

## Security and Compliance

### Field-Level Encryption

To address GDPR, CCPA, and other privacy regulations, sensitive PII fields must be encrypted at rest:

```java
@Configuration
public class EncryptionConfig {
    
    @Bean
    public AESUtil aesUtil() {
        return new AESUtil(encryptionKey());
    }
    
    private String encryptionKey() {
        // Load from secure key management system
        return System.getenv("DB_ENCRYPTION_KEY");
    }
}

// Custom JPA converter for encrypted fields
@Converter
public class EncryptedStringConverter implements AttributeConverter<String, String> {
    
    @Autowired
    private AESUtil aesUtil;
    
    @Override
    public String convertToDatabaseColumn(String attribute) {
        if (attribute == null) return null;
        return aesUtil.encrypt(attribute);
    }
    
    @Override
    public String convertToEntityAttribute(String dbData) {
        if (dbData == null) return null;
        return aesUtil.decrypt(dbData);
    }
}

// Usage in entities
@Entity
public class Employee {
    // ... other fields
    
    @Convert(converter = EncryptedStringConverter.class)
    @Column(name = "date_of_birth")
    private String dateOfBirth; // Encrypted
    
    @Convert(converter = EncryptedStringConverter.class)
    @Column(name = "bank_account")
    private String bankAccount; // Encrypted
    
    @Convert(converter = EncryptedStringConverter.class)
    @Column(name = "tax_id")
    private String taxId; // Encrypted
}
```

### Audit Trail Configuration

```java
@Configuration
@EnableJpaAuditing(auditorAwareRef = "auditorProvider")
public class AuditConfig {
    
    @Bean
    public AuditorAware<Long> auditorProvider() {
        return new SecurityAuditorAware();
    }
}

@Component
public class SecurityAuditorAware implements AuditorAware<Long> {
    
    @Override
    public Optional<Long> getCurrentAuditor() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication == null || !authentication.isAuthenticated()) {
            return Optional.empty();
        }
        
        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();
        return Optional.of(userPrincipal.getId());
    }
}
```

### Permission-Based Data Access

```java
// Repository with permission-based filtering
@Repository
public interface EmployeeRepository extends JpaRepository<Employee, Long> {
    
    // Department managers can only see employees in their department
    @Query("SELECT e FROM Employee e WHERE e.departmentId = :departmentId OR :hasGlobalAccess = true")
    Page<Employee> findByDepartmentWithPermission(
        @Param("departmentId") Long departmentId,
        @Param("hasGlobalAccess") boolean hasGlobalAccess,
        Pageable pageable
    );
    
    // HR can see all, managers can see their direct reports
    @Query("SELECT e FROM Employee e WHERE e.managerId = :managerId OR :hasHRAccess = true")
    List<Employee> findDirectReportsWithPermission(
        @Param("managerId") Long managerId,
        @Param("hasHRAccess") boolean hasHRAccess
    );
}
```

## Database Migration Scripts

### Flyway Migration Structure

```
src/main/resources/db/migration/
├── V1__Initial_schema.sql
├── V2__Add_encryption_support.sql
├── V3__Add_audit_fields.sql
├── V4__Create_indexes.sql
├── V5__Insert_default_data.sql
└── V6__Add_permission_constraints.sql
```

### Sample Migration Script (V1__Initial_schema.sql)

```sql
-- Users table
CREATE TABLE users (
    id BIGSERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    password VARCHAR(255) NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    enabled BOOLEAN NOT NULL DEFAULT true,
    last_login TIMESTAMP,
    login_attempts INTEGER DEFAULT 0,
    account_locked BOOLEAN DEFAULT false,
    password_expired BOOLEAN DEFAULT false,
    password_change_required BOOLEAN DEFAULT false,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_by BIGINT,
    updated_by BIGINT
);

-- Roles table
CREATE TABLE roles (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(50) UNIQUE NOT NULL,
    description VARCHAR(255),
    active BOOLEAN NOT NULL DEFAULT true,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_by BIGINT,
    updated_by BIGINT
);

-- Resources table
CREATE TABLE resources (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    url VARCHAR(255) NOT NULL,
    method VARCHAR(10) NOT NULL,
    description VARCHAR(255),
    category VARCHAR(50) NOT NULL,
    active BOOLEAN NOT NULL DEFAULT true,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_by BIGINT,
    updated_by BIGINT,
    UNIQUE(url, method)
);

-- User-Role junction table
CREATE TABLE user_roles (
    user_id BIGINT NOT NULL,
    role_id BIGINT NOT NULL,
    assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    assigned_by BIGINT,
    expires_at TIMESTAMP,
    active BOOLEAN DEFAULT true,
    PRIMARY KEY (user_id, role_id),
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (role_id) REFERENCES roles(id) ON DELETE CASCADE
);

-- Role-Resource junction table
CREATE TABLE role_resources (
    role_id BIGINT NOT NULL,
    resource_id BIGINT NOT NULL,
    assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    assigned_by BIGINT,
    active BOOLEAN DEFAULT true,
    PRIMARY KEY (role_id, resource_id),
    FOREIGN KEY (role_id) REFERENCES roles(id) ON DELETE CASCADE,
    FOREIGN KEY (resource_id) REFERENCES resources(id) ON DELETE CASCADE
);

-- Departments table
CREATE TABLE departments (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    code VARCHAR(20) UNIQUE NOT NULL,
    description VARCHAR(500),
    location VARCHAR(255),
    parent_id BIGINT,
    dep_path VARCHAR(500),
    is_parent BOOLEAN NOT NULL DEFAULT false,
    enabled BOOLEAN NOT NULL DEFAULT true,
    level INTEGER DEFAULT 0,
    sort_order INTEGER DEFAULT 0,
    manager_id BIGINT,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_by BIGINT,
    updated_by BIGINT,
    FOREIGN KEY (parent_id) REFERENCES departments(id)
);

-- Continue with other tables...
```

## Performance Optimization

### Database Indexes Strategy

```sql
-- Composite indexes for common query patterns
CREATE INDEX idx_employee_dept_status ON employees(department_id, status);
CREATE INDEX idx_employee_manager_active ON employees(manager_id, enabled);
CREATE INDEX idx_payroll_employee_period ON payroll_ledgers(employee_id, pay_period_id);
CREATE INDEX idx_email_log_status_date ON email_logs(status, sent_at);

-- Partial indexes for active records
CREATE INDEX idx_active_employees ON employees(department_id) WHERE enabled = true;
CREATE INDEX idx_active_departments ON departments(parent_id) WHERE enabled = true;

-- Full-text search indexes
CREATE INDEX idx_employee_search ON employees USING gin(to_tsvector('english', first_name || ' ' || last_name || ' ' || email));

-- Announcements Table
CREATE TABLE announcements (
    id BIGSERIAL PRIMARY KEY,
    title VARCHAR(200) NOT NULL,
    content TEXT NOT NULL,
    author_id BIGINT NOT NULL,
    target_audience VARCHAR(50),
    department_id BIGINT,
    publish_date DATE,
    expiry_date DATE,
    published BOOLEAN NOT NULL DEFAULT false,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP,
    created_by BIGINT,
    updated_by BIGINT
);

### Query Optimization Patterns

```java
// Use projections for list views to reduce data transfer
public interface EmployeeListProjection {
    Long getId();
    String getEmployeeNumber();
    String getFirstName();
    String getLastName();
    String getEmail();
    String getDepartmentName();
    String getPositionTitle();
    EmployeeStatus getStatus();
}

@Query("SELECT e.id as id, e.employeeNumber as employeeNumber, " +
       "e.firstName as firstName, e.lastName as lastName, e.email as email, " +
       "d.name as departmentName, p.jobTitle as positionTitle, e.status as status " +
       "FROM Employee e LEFT JOIN Department d ON e.departmentId = d.id " +
       "LEFT JOIN Position p ON e.positionId = p.id " +
       "WHERE (:departmentId IS NULL OR e.departmentId = :departmentId) " +
       "AND (:status IS NULL OR e.status = :status)")
Page<EmployeeListProjection> findEmployeeList(
    @Param("departmentId") Long departmentId,
    @Param("status") EmployeeStatus status,
    Pageable pageable
);
```

## Monitoring and Health Checks

### Database Health Monitoring

```java
@Component
public class DatabaseHealthIndicator implements HealthIndicator {
    
    @Autowired
    private DataSource dataSource;
    
    @Override
    public Health health() {
        try (Connection connection = dataSource.getConnection()) {
            if (connection.isValid(1)) {
                return Health.up()
                    .withDetail("database", "PostgreSQL")
                    .withDetail("status", "Connected")
                    .build();
            }
        } catch (SQLException e) {
            return Health.down()
                .withDetail("database", "PostgreSQL")
                .withDetail("error", e.getMessage())
                .build();
        }
        return Health.down().build();
    }
}
```

This comprehensive database design document provides:

1. **Hybrid Architecture** - PostgreSQL for persistent data, Redis for caching and real-time features
2. **Complete Entity Schemas** - All entities with proper JPA annotations and relationships
3. **Security & Compliance** - Field-level encryption, audit trails, and permission-based access
4. **Data Migration** - Flyway scripts for database versioning
5. **Performance Optimization** - Strategic indexing and query optimization
6. **Monitoring** - Database health checks and metrics
7. **Conflict Resolution** - Addresses all entity field mismatches identified in the conflict analysis

The design resolves all conflicts identified in the conflict analysis and provides a robust, secure, and scalable foundation for the Spring Boot implementation.
</file>

<file path=".kiro/specs/spring-backend/security-implementation.md">
# Security and Permission Management Implementation

## Overview
This document provides detailed implementation specifications for the Security and Permission Management module of the Employee Management System. This module handles authentication, authorization, role-based access control, and permission management.

## Package Structure
```
com.example.demo.security/
├── config/
│   ├── SecurityConfig.java
│   ├── JwtConfig.java
│   └── RedisConfig.java
├── entity/
│   ├── User.java
│   ├── Role.java
│   └── Resource.java
├── repository/
│   ├── UserRepository.java
│   ├── RoleRepository.java
│   └── ResourceRepository.java
├── service/
│   ├── UserService.java
│   ├── RoleService.java
│   ├── ResourceService.java
│   ├── AuthenticationService.java
│   └── PermissionService.java
├── controller/
│   ├── AuthController.java
│   ├── UserController.java
│   ├── RoleController.java
│   └── ResourceController.java
├── dto/
│   ├── LoginRequest.java
│   ├── LoginResponse.java
│   ├── UserDto.java
│   ├── RoleDto.java
│   └── ResourceDto.java
├── security/
│   ├── JwtAuthenticationFilter.java
│   ├── JwtTokenProvider.java
│   ├── CustomUserDetailsService.java
│   └── SecurityUtils.java
└── exception/
    ├── AuthenticationException.java
    ├── AuthorizationException.java
    └── UserNotFoundException.java
```

## Entity Classes

### User Entity
```java
package com.example.demo.security.entity;

### User Entity
```java
package com.example.demo.security.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.Duration;
import java.time.Instant;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "users",
    indexes = {
        @Index(name = "idx_user_username", columnList = "username"),
        @Index(name = "idx_user_email", columnList = "email"),
        @Index(name = "idx_user_enabled", columnList = "enabled"),
        @Index(name = "idx_user_account_locked", columnList = "account_locked")
    },
    uniqueConstraints = {
        @UniqueConstraint(name = "uk_user_username", columnNames = "username"),
        @UniqueConstraint(name = "uk_user_email", columnNames = "email")
    }
)
@EntityListeners(AuditingEntityListener.class)
@Getter
@Setter
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "username", nullable = false, length = 50)
    @NotBlank(message = "Username is required")
    @Size(min = 3, max = 50, message = "Username must be between 3 and 50 characters")
    private String username;

    @Column(name = "password", nullable = false)
    @NotBlank(message = "Password is required")
    private String password;
    
    @Column(name = "email", nullable = false, length = 100)
    @NotBlank(message = "Email is required")
    @Email(message = "Email must be valid")
    private String email;
    
    @Column(name = "first_name", length = 50)
    private String firstName;
    
    @Column(name = "last_name", length = 50)
    private String lastName;
    
    @Column(name = "enabled", nullable = false)
    private Boolean enabled = true;
    
    @Column(name = "last_login")
    private Instant lastLogin;
    
    @Column(name = "login_attempts", nullable = false)
    private Integer loginAttempts = 0;
    
    @Column(name = "account_locked", nullable = false)
    private Boolean accountLocked = false;
    
    @Column(name = "account_locked_until")
    private Instant accountLockedUntil;
    
    @Column(name = "password_expired", nullable = false)
    private Boolean passwordExpired = false;
    
    @Column(name = "password_change_required", nullable = false)
    private Boolean passwordChangeRequired = false;
    
    @Column(name = "password_changed_at")
    private Instant passwordChangedAt;
    
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;
    
    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;
    
    @Column(name = "created_by")
    private Long createdBy;
    
    @Column(name = "updated_by")
    private Long updatedBy;
    
    @ManyToMany(fetch = FetchType.LAZY)
    @JoinTable(
        name = "user_roles",
        joinColumns = @JoinColumn(name = "user_id"),
        inverseJoinColumns = @JoinColumn(name = "role_id"),
        foreignKey = @ForeignKey(name = "fk_user_roles_user"),
        inverseForeignKey = @ForeignKey(name = "fk_user_roles_role")
    )
    private Set<Role> roles = new HashSet<>();
    
    public boolean isAccountNonLocked() {
        if (!accountLocked) return true;
        if (accountLockedUntil != null && Instant.now().isAfter(accountLockedUntil)) {
            accountLocked = false;
            accountLockedUntil = null;
            return true;
        }
        return false;
    }
    
    public void incrementLoginAttempts() {
        this.loginAttempts++;
        if (this.loginAttempts >= 5) {
            this.accountLocked = true;
            this.accountLockedUntil = Instant.now().plus(Duration.ofMinutes(30));
        }
    }
    
    public void resetLoginAttempts() {
        this.loginAttempts = 0;
        this.accountLocked = false;
        this.accountLockedUntil = null;
        this.lastLogin = Instant.now();
    }
}
```

### Role Entity
```java
package com.example.demo.security.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.Instant;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "roles", indexes = {
    @Index(name = "idx_role_name", columnList = "name"),
    @Index(name = "idx_role_active", columnList = "active")
})
@EntityListeners(AuditingEntityListener.class)
@Getter
@Setter
public class Role {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "name", unique = true, nullable = false, length = 50)
    private String name;
    
    @Column(name = "description", length = 255)
    private String description;
    
    @Column(name = "active", nullable = false)
    private Boolean active = true;
    
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;
    
    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;
    
    @Column(name = "created_by")
    private Long createdBy;
    
    @Column(name = "updated_by")
    private Long updatedBy;
    
    @ManyToMany(mappedBy = "roles", fetch = FetchType.LAZY)
    private Set<User> users = new HashSet<>();
    
    @ManyToMany(fetch = FetchType.LAZY)
    @JoinTable(
        name = "role_resources",
        joinColumns = @JoinColumn(name = "role_id"),
        inverseJoinColumns = @JoinColumn(name = "resource_id")
    )
    private Set<Resource> resources = new HashSet<>();
}
```


### UserCreateRequest DTO
```java
package com.example.demo.security.dto;

import lombok.Data;
import jakarta.validation.constraints.*;
import java.util.Set;

@Data
public class UserCreateRequest {
    @NotBlank @Size(min = 3, max = 50)
    private String username;
    @NotBlank @Email
    private String email;
    @NotBlank @Size(min = 8, max = 100)
    private String password;
    @NotBlank @Size(max = 50)
    private String firstName;
    @NotBlank @Size(max = 50)
    private String lastName;
    private Set<Long> roleIds;
}
```

### UserUpdateRequest DTO
```java
package com.example.demo.security.dto;

import lombok.Data;
import jakarta.validation.constraints.*;
import java.util.Set;

@Data
public class UserUpdateRequest {
    @NotBlank @Email
    private String email;
    @NotBlank @Size(max = 50)
    private String firstName;
    @NotBlank @Size(max = 50)
    private String lastName;
    private Boolean enabled;
    private Set<Long> roleIds;
}

```

### Resource Entity
```java
package com.example.demo.security.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.Instant;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "resources", indexes = {
    @Index(name = "idx_resource_url", columnList = "url"),
    @Index(name = "idx_resource_method", columnList = "method"),
    @Index(name = "idx_resource_category", columnList = "category"),
    @Index(name = "idx_resource_active", columnList = "active")
})
@EntityListeners(AuditingEntityListener.class)
@Getter
@Setter
public class Resource {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "name", nullable = false, length = 100)
    private String name;
    
    @Column(name = "url", nullable = false, length = 255)
    private String url;
    
    @Column(name = "method", nullable = false, length = 10)
    private String method;
    
    @Column(name = "description", length = 255)
    private String description;
    
    @Column(name = "category", nullable = false, length = 50)
    private String category;
    
    @Column(name = "active", nullable = false)
    private Boolean active = true;
    
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;
    
    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;
    
    @Column(name = "created_by")
    private Long createdBy;
    
    @Column(name = "updated_by")
    private Long updatedBy;
    
    @ManyToMany(mappedBy = "resources", fetch = FetchType.LAZY)
    private Set<Role> roles = new HashSet<>();
tory Interfaces

### UserRepository
```java
package com.example.demo.security.repository;

import com.example.demo.security.entity.User;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;
import java.util.List;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    
    Optional<User> findByUsername(String username);
    
    Optional<User> findByEmail(String email);
    
    boolean existsByUsername(String username);
    
    boolean existsByEmail(String email);
    
    List<User> findByEnabledTrue();
    
    Page<User> findByEnabledTrue(Pageable pageable);
    
    List<User> findByUsernameContainingIgnoreCase(String username);
    
    List<User> findByFirstNameContainingIgnoreCaseOrLastNameContainingIgnoreCase(
        String firstName, String lastName);
}
```

### RoleRepository
```java
package com.example.demo.security.repository;

import com.example.demo.security.entity.Role;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;
import java.util.List;

@Repository
public interface RoleRepository extends JpaRepository<Role, Long> {
    
    Optional<Role> findByName(String name);
    
    boolean existsByName(String name);
    
    List<Role> findByEnabledTrue();
    
    List<Role> findByNameContainingIgnoreCase(String name);
}
```

### ResourceRepository
```java
package com.example.demo.security.repository;

import com.example.demo.security.entity.Resource;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface ResourceRepository extends JpaRepository<Resource, Long> {
    
    Optional<Resource> findByNameAndMethod(String name, String method);
    
    List<Resource> findByEnabledTrue();
    
    List<Resource> findByCategory(String category);
    
    List<Resource> findByUrlContainingIgnoreCase(String url);
    
    boolean existsByNameAndMethod(String name, String method);
}
```
### LoginRequest
```java
package com.example.demo.security.dto;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class LoginRequest {
    
    @NotBlank(message = "Username is required")
    @Size(min = 3, max = 50, message = "Username must be between 3 and 50 characters")
    private String username;
    
    @NotBlank(message = "Password is required")
    @Size(min = 6, max = 100, message = "Password must be between 6 and 100 characters")
    private String password;
    
    private boolean rememberMe = false;
}
```

### LoginResponse
```java
package com.example.demo.security.dto;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;

import java.time.Instant;
import java.util.Set;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class LoginResponse {
    
    private String token;
    
    private String tokenType = "Bearer";
    
    private Long expiresIn; // seconds
    
    private UserDto user;
    
    private Set<String> permissions;
    
    private Instant loginTime;
}
```

### UserDto
```java
package com.example.demo.security.dto;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import java.time.Instant;
import java.util.Set;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserDto {
    
    private Long id;
    
    @NotBlank(message = "Username is required")
    @Size(min = 3, max = 50, message = "Username must be between 3 and 50 characters")
    private String username;
    
    @NotBlank(message = "Email is required")
    @Email(message = "Email should be valid")
    private String email;
    
    @NotBlank(message = "First name is required")
    @Size(max = 50, message = "First name must not exceed 50 characters")
    private String firstName;
    
    @NotBlank(message = "Last name is required")
    @Size(max = 50, message = "Last name must not exceed 50 characters")
    private String lastName;
    
    private boolean enabled;
    
    private Instant createdAt;
    
    private Instant updatedAt;
    
    private Instant lastLoginAt;
    
    private Set<RoleDto> roles;
}
```

### RoleDto
```java
package com.example.demo.security.dto;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;

import javax.validation.constraints.NotBlank;
import javax.validation.constraints.Size;
import java.time.Instant;
import java.util.Set;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class RoleDto {
    
    private Long id;
    
    @NotBlank(message = "Role name is required")
    @Size(min = 2, max = 50, message = "Role name must be between 2 and 50 characters")
    private String name;
    
    @Size(max = 255, message = "Description must not exceed 255 characters")
    private String description;
    
    private boolean enabled;
    
    private Instant createdAt;
    
    private Instant updatedAt;
    
    private Set<ResourceDto> resources;
}
```

### ResourceDto
```java
package com.example.demo.security.dto;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;

import javax.validation.constraints.NotBlank;
import javax.validation.constraints.Pattern;
import javax.validation.constraints.Size;
import java.time.Instant;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ResourceDto {
    
    private Long id;
    
    @NotBlank(message = "Resource name is required")
    @Size(min = 2, max = 100, message = "Resource name must be between 2 and 100 characters")
    private String name;
    
    @NotBlank(message = "URL is required")
    @Size(max = 255, message = "URL must not exceed 255 characters")
    private String url;
    
    @NotBlank(message = "HTTP method is required")
    @Pattern(regexp = "GET|POST|PUT|DELETE|PATCH", message = "Method must be GET, POST, PUT, DELETE, or PATCH")
    private String method;
    
    @Size(max = 255, message = "Description must not exceed 255 characters")
    private String description;
    
    @Size(max = 50, message = "Category must not exceed 50 characters")
    private String category;
    
    private boolean enabled;
    
    private Instant createdAt;
    
    private Instant updatedAt;
}
```#
# Service Layer Implementation

### UserService
```java
package com.example.demo.security.service;

import com.example.demo.security.dto.UserDto;
import com.example.demo.security.entity.User;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import java.util.List;
import java.util.Optional;
import java.util.Set;

public interface UserService {
    
    /**
     * Create a new user
     * @param userDto User data transfer object
     * @return Created user DTO
     * @throws UserAlreadyExistsException if username or email already exists
     */
    UserDto createUser(UserCreateRequest createRequest);
    
    /**
     * Update an existing user
     * @param id User ID
     * @param userDto Updated user data
     * @return Updated user DTO
     * @throws UserNotFoundException if user not found
     */
    UserDto updateUser(Long id, UserUpdateRequest updateRequest);
    
    /**
     * Get user by ID
     * @param id User ID
     * @return User DTO
     * @throws UserNotFoundException if user not found
     */
    UserDto getUserById(Long id);
    
    /**
     * Get user by username
     * @param username Username
     * @return User DTO
     * @throws UserNotFoundException if user not found
     */
    UserDto getUserByUsername(String username);
    
    /**
     * Get all users with pagination
     * @param pageable Pagination parameters
     * @return Page of user DTOs
     */
    Page<UserDto> getAllUsers(Pageable pageable);
    
    /**
     * Search users by criteria
     * @param searchTerm Search term for username, first name, or last name
     * @param pageable Pagination parameters
     * @return Page of matching user DTOs
     */
    Page<UserDto> searchUsers(String searchTerm, Pageable pageable);
    
    /**
     * Delete user by ID
     * @param id User ID
     * @throws UserNotFoundException if user not found
     */
    void deleteUser(Long id);
    
    /**
     * Enable or disable user
     * @param id User ID
     * @param enabled Enable/disable flag
     * @throws UserNotFoundException if user not found
     */
    void setUserEnabled(Long id, boolean enabled);
    
    /**
     * Assign roles to user
     * @param userId User ID
     * @param roleIds Set of role IDs to assign
     * @throws UserNotFoundException if user not found
     * @throws RoleNotFoundException if any role not found
     */
    void assignRolesToUser(Long userId, Set<Long> roleIds);
    
    /**
     * Remove roles from user
     * @param userId User ID
     * @param roleIds Set of role IDs to remove
     * @throws UserNotFoundException if user not found
     */
    void removeRolesFromUser(Long userId, Set<Long> roleIds);
    
    /**
     * Get user permissions
     * @param userId User ID
     * @return Set of permission strings
     * @throws UserNotFoundException if user not found
     */
    Set<String> getUserPermissions(Long userId);
    
    /**
     * Check if user has specific permission
     * @param userId User ID
     * @param permission Permission string
     * @return true if user has permission
     */
    boolean hasPermission(Long userId, String permission);
    
    /**
     * Update user last login time
     * @param userId User ID
     */
    void updateLastLoginTime(Long userId);
    
    /**
     * Change user password
     * @param userId User ID
     * @param oldPassword Current password
     * @param newPassword New password
     * @throws InvalidPasswordException if old password is incorrect
     * @throws UserNotFoundException if user not found
     */
    void changePassword(Long userId, String oldPassword, String newPassword);
    
    /**
     * Reset user password (admin function)
     * @param userId User ID
     * @param newPassword New password
     * @throws UserNotFoundException if user not found
     */
    void resetPassword(Long userId, String newPassword);
}
```

### RoleService
```java
package com.example.demo.security.service;

import com.example.demo.security.dto.RoleDto;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import java.util.List;
import java.util.Set;

public interface RoleService {
    
    /**
     * Create a new role
     * @param roleDto Role data transfer object
     * @return Created role DTO
     * @throws RoleAlreadyExistsException if role name already exists
     */
    RoleDto createRole(RoleDto roleDto);
    
    /**
     * Update an existing role
     * @param id Role ID
     * @param roleDto Updated role data
     * @return Updated role DTO
     * @throws RoleNotFoundException if role not found
     */
    RoleDto updateRole(Long id, RoleDto roleDto);
    
    /**
     * Get role by ID
     * @param id Role ID
     * @return Role DTO
     * @throws RoleNotFoundException if role not found
     */
    RoleDto getRoleById(Long id);
    
    /**
     * Get role by name
     * @param name Role name
     * @return Role DTO
     * @throws RoleNotFoundException if role not found
     */
    RoleDto getRoleByName(String name);
    
    /**
     * Get all roles
     * @return List of role DTOs
     */
    List<RoleDto> getAllRoles();
    
    /**
     * Get all roles with pagination
     * @param pageable Pagination parameters
     * @return Page of role DTOs
     */
    Page<RoleDto> getAllRoles(Pageable pageable);
    
    /**
     * Search roles by name
     * @param searchTerm Search term for role name
     * @return List of matching role DTOs
     */
    List<RoleDto> searchRoles(String searchTerm);
    
    /**
     * Delete role by ID
     * @param id Role ID
     * @throws RoleNotFoundException if role not found
     * @throws RoleInUseException if role is assigned to users
     */
    void deleteRole(Long id);
    
    /**
     * Enable or disable role
     * @param id Role ID
     * @param enabled Enable/disable flag
     * @throws RoleNotFoundException if role not found
     */
    void setRoleEnabled(Long id, boolean enabled);
    
    /**
     * Assign resources to role
     * @param roleId Role ID
     * @param resourceIds Set of resource IDs to assign
     * @throws RoleNotFoundException if role not found
     * @throws ResourceNotFoundException if any resource not found
     */
    void assignResourcesToRole(Long roleId, Set<Long> resourceIds);
    
    /**
     * Remove resources from role
     * @param roleId Role ID
     * @param resourceIds Set of resource IDs to remove
     * @throws RoleNotFoundException if role not found
     */
    void removeResourcesFromRole(Long roleId, Set<Long> resourceIds);
    
    /**
     * Get role permissions
     * @param roleId Role ID
     * @return Set of permission strings
     * @throws RoleNotFoundException if role not found
     */
    Set<String> getRolePermissions(Long roleId);
}
```
</file>

<file path=".kiro/specs/spring-backend/communication-implementation.md">
# Communication System Implementation

## Overview
This document provides detailed implementation specifications for the Communication System module, which includes Email Management and Chat/Notification functionality. This module handles template-based email sending, real-time chat, and system notifications.

## Package Structure
```
com.example.demo.communication/
├── email/
│   ├── entity/
│   │   ├── EmailTemplate.java
│   │   └── EmailLog.java
│   ├── service/
│   │   ├── EmailService.java
│   │   ├── EmailTemplateService.java
│   │   └── impl/
│   │       ├── EmailServiceImpl.java
│   │       └── EmailTemplateServiceImpl.java
│   ├── controller/
│   │   └── EmailController.java
│   ├── dto/
│   │   ├── EmailRequest.java
│   │   ├── BulkEmailRequest.java
│   │   ├── EmailTemplateDto.java
│   │   └── EmailLogDto.java
│   └── util/
│       └── EmailTemplateProcessor.java
├── chat/
│   ├── entity/
│   │   ├── ChatMessage.java
│   │   ├── ChatRoom.java
│   │   └── ChatParticipant.java
│   ├── service/
│   │   ├── ChatService.java
│   │   └── impl/
│   │       └── ChatServiceImpl.java
│   ├── controller/
│   │   └── ChatController.java
│   ├── dto/
│   │   ├── ChatMessageDto.java
│   │   ├── ChatRoomDto.java
│   │   └── ChatParticipantDto.java
│   └── websocket/
│       ├── ChatWebSocketHandler.java
│       └── WebSocketConfig.java
├── notification/
│   ├── entity/
│   │   └── Notification.java // Based on the single-table model in database-design.md
│   ├── service/
│   │   ├── NotificationService.java
│   │   └── impl/
│   │       └── NotificationServiceImpl.java
│   ├── controller/
│   │   └── NotificationController.java
│   ├── dto/
│   │   ├── NotificationDto.java
│   │   ├── NotificationCreateRequest.java
│   │   └── NotificationMarkReadRequest.java
│   └── websocket/
│       └── NotificationWebSocketHandler.java
├── announcement/
│   ├── controller/
│   │   └── AnnouncementController.java
│   ├── dto/
│   │   ├── AnnouncementCreateRequest.java
│   │   ├── AnnouncementDto.java
│   │   ├── AnnouncementStatisticsDto.java
│   │   └── AnnouncementUpdateRequest.java
│   ├── entity/
│   │   ├── Announcement.java
│   │   └── AnnouncementTarget.java
│   ├── repository/
│   │   └── AnnouncementRepository.java
│   └── service/
│       ├── AnnouncementScheduledService.java
│       ├── AnnouncementService.java
│       ├── AnnouncementValidationService.java
│       └── impl/
│           └── AnnouncementServiceImpl.java
└── exception/
    ├── EmailSendingException.java
    ├── TemplateNotFoundException.java
    ├── ChatRoomNotFoundException.java
    └── NotificationException.java

```

## Email Management

### Email Entity Classes

#### EmailTemplate Entity
```java
package com.example.demo.communication.email.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.Instant;
 
public enum TemplateType {
    HTML,
    TEXT,
    MIXED
}
 
public enum TemplateCategory {
    WELCOME,
    NOTIFICATION,
    REMINDER,
    MARKETING,
    PASSWORD_RESET
}

@Entity
@Table(name = "email_templates", indexes = {
    @Index(name = "idx_emailtemplate_code", columnList = "code", unique = true),
    @Index(name = "idx_emailtemplate_category", columnList = "category")
})
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@EntityListeners(AuditingEntityListener.class)
public class EmailTemplate {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "name", nullable = false, length = 100)
    private String name; // Template name for identification
    
    @Column(name = "code", nullable = false, unique = true, length = 50)
    private String code; // Unique template code
    
    @Column(name = "subject", nullable = false, length = 255)
    private String subject; // Email subject template
    
    @Lob
    @Column(name = "content", nullable = false, columnDefinition = "TEXT")
    private String content; // Email content template (HTML/Text)
    
    @Enumerated(EnumType.STRING)
    @Column(name = "template_type", nullable = false, length = 20)
    private TemplateType templateType; // Template type (e.g., HTML, TEXT, MIXED)
    
    @Enumerated(EnumType.STRING)
    @Column(name = "category", length = 50)
    private TemplateCategory category; // WELCOME, NOTIFICATION, REMINDER, etc.
    
    @Column(name = "description", length = 500)
    private String description;
    
    @Lob
    @Column(name = "variables", columnDefinition = "TEXT")
    private String variables; // JSON string of available template variables
    
    @Column(name = "is_default", nullable = false)
    private boolean isDefault = false;
    
    @Column(name = "enabled", nullable = false)
    private boolean enabled = true;
    
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;
    
    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;
    
    @Column(name = "created_by")
    private Long createdBy;
    
    @Column(name = "updated_by")
    private Long updatedBy;
}
```

#### EmailLog Entity
```java
package com.example.demo.communication.email.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.Instant;

public enum EmailStatus {
    PENDING,
    SENT,
    FAILED,
    BOUNCED,
    DELIVERED,
    OPENED,
    CLICKED
}
 
public enum EmailPriority {
    HIGH,
    NORMAL,
    LOW
}

@Entity
@Table(name = "email_logs", indexes = {
    @Index(name = "idx_emaillog_to_email", columnList = "to_email"),
    @Index(name = "idx_emaillog_status", columnList = "status"),
    @Index(name = "idx_emaillog_template_code", columnList = "template_code"),
    @Index(name = "idx_emaillog_sent_by", columnList = "sent_by")
})
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@EntityListeners(AuditingEntityListener.class)
public class EmailLog {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "to_email", nullable = false)
    private String toEmail;
    
    @Column(name = "cc_emails", length = 1000)
    private String ccEmails; // Comma-separated CC emails
    
    @Column(name = "bcc_emails", length = 1000)
    private String bccEmails; // Comma-separated BCC emails
    
    @Column(name = "subject", nullable = false)
    private String subject;
    
    @Lob
    @Column(name = "content", nullable = false, columnDefinition = "TEXT")
    private String content;
    
    @Column(name = "template_code", length = 50)
    private String templateCode; // Template used (if any)
    
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 20)
    private EmailStatus status; // PENDING, SENT, FAILED, BOUNCED
    
    @Column(name = "error_message", length = 2000)
    private String errorMessage; // Error details if failed
    
    @Column(name = "retry_count", nullable = false)
    private Integer retryCount = 0;
    
    @Column(name = "sent_at")
    private Instant sentAt;
    
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;
    
    @Column(name = "sent_by")
    private Long sentBy; // User who sent the email
    
    @Column(name = "message_id", length = 255)
    private String messageId; // Email provider message ID
    
    @Enumerated(EnumType.STRING)
    @Column(name = "priority", length = 20)
    private EmailPriority priority; // HIGH, NORMAL, LOW
}
```

### Email Service Interface
```java
package com.example.demo.communication.email.service;

import com.example.demo.communication.email.dto.EmailRequest;
import com.example.demo.communication.email.dto.BulkEmailRequest;
import com.example.demo.communication.email.dto.EmailLogDto;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;

public interface EmailService {
    
    /**
     * Send a single email
     * @param emailRequest Email request details
     * @return CompletableFuture for async processing
     * @throws EmailSendingException if email sending fails
     */
    CompletableFuture<Void> sendEmail(EmailRequest emailRequest);
    
    /**
     * Send templated email
     * @param toEmail Recipient email
     * @param templateCode Template code
     * @param variables Template variables
     * @return CompletableFuture for async processing
     * @throws TemplateNotFoundException if template not found
     * @throws EmailSendingException if email sending fails
     */
    CompletableFuture<Void> sendTemplatedEmail(String toEmail, String templateCode, Map<String, Object> variables);
    
    /**
     * Send bulk emails
     * @param bulkEmailRequest Bulk email request
     * @return CompletableFuture for async processing
     * @throws EmailSendingException if bulk email sending fails
     */
    CompletableFuture<Void> sendBulkEmails(BulkEmailRequest bulkEmailRequest);
    
    /**
     * Send bulk templated emails
     * @param recipients List of recipient emails
     * @param templateCode Template code
     * @param variables Template variables
     * @return CompletableFuture for async processing
     * @throws TemplateNotFoundException if template not found
     * @throws EmailSendingException if bulk email sending fails
     */
    CompletableFuture<Void> sendBulkTemplatedEmails(List<String> recipients, String templateCode, Map<String, Object> variables);
    
    /**
     * Get email logs with pagination
     * @param pageable Pagination parameters
     * @return Page of email log DTOs
     */
    Page<EmailLogDto> getEmailLogs(Pageable pageable);
    
    /**
     * Get email logs by recipient
     * @param toEmail Recipient email
     * @param pageable Pagination parameters
     * @return Page of email log DTOs
     */
    Page<EmailLogDto> getEmailLogsByRecipient(String toEmail, Pageable pageable);
    
    /**
     * Get email logs by status
     * @param status Email status
     * @param pageable Pagination parameters
     * @return Page of email log DTOs
     */
    Page<EmailLogDto> getEmailLogsByStatus(String status, Pageable pageable);
    
    /**
     * Get email logs by template
     * @param templateCode Template code
     * @param pageable Pagination parameters
     * @return Page of email log DTOs
     */
    Page<EmailLogDto> getEmailLogsByTemplate(String templateCode, Pageable pageable);
    
    /**
     * Retry failed email
     * @param emailLogId Email log ID
     * @return CompletableFuture for async processing
     * @throws EmailLogNotFoundException if email log not found
     * @throws EmailSendingException if retry fails
     */
    CompletableFuture<Void> retryFailedEmail(Long emailLogId);
    
    /**
     * Get email sending statistics
     * @return Email statistics
     */
    EmailStatisticsDto getEmailStatistics();
}
```

## Chat System

### Chat Entity Classes

### Enum Definitions

#### ChatRoomType Enum
```java
package com.example.demo.communication.chat.entity;

public enum ChatRoomType {
    DIRECT, // One-on-one chat
    GROUP,  // Multi-user group chat
    CHANNEL // Broadcast-style channel
}
```

#### ChatParticipantRole Enum
```java
package com.example.demo.communication.chat.entity;

public enum ChatParticipantRole {
    OWNER,
    ADMIN,
    MEMBER
}
```
#### ChatMessage Entity
```java
package com.example.demo.communication.chat.entity;
 
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;
 
import java.time.Instant;

public enum ChatMessageType {
    TEXT,
    IMAGE,
    FILE,
    SYSTEM // 系统消息, e.g., "User A has joined the room"
}
 
@Entity
@Table(name = "chat_messages", indexes = {
    @Index(name = "idx_chatmessage_room_id", columnList = "room_id"),
    @Index(name = "idx_chatmessage_sender_id", columnList = "sender_id"),
    @Index(name = "idx_chatmessage_created_at", columnList = "created_at")
})
@EntityListeners(AuditingEntityListener.class)
@Getter
@Setter
public class ChatMessage {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
  
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "room_id", nullable = false)
    private ChatRoom room;
  
    @Column(name = "sender_id", nullable = false)
    private Long senderId;         // Message sender
  
    @Column(name = "content", columnDefinition = "TEXT")
    private String content;        // Message content
  
    @Enumerated(EnumType.STRING)
    @Column(name = "message_type", length = 20)
    private ChatMessageType messageType;    // TEXT, IMAGE, FILE, SYSTEM
  
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;     // 时区无关的时间戳
  
    @Column(name = "is_edited", nullable = false)
    private Boolean isEdited = false;
  
    @Column(name = "edited_at")
    private Instant editedAt;      // 时区无关的时间戳
  
    @Column(name = "is_deleted", nullable = false)
    private Boolean isDeleted = false;
  
    @Column(name = "deleted_at")
    private Instant deletedAt;     // 时区无关的时间戳
    
    // Transient fields for display
    private transient String senderName;
    private transient String senderAvatar;
    private transient boolean isRead; // Whether current user has read this message
    
}
```

#### ChatRoom Entity
```java
package com.example.demo.communication.chat.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.Instant;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "chat_rooms", indexes = {
    @Index(name = "idx_chatroom_type", columnList = "type"),
    @Index(name = "idx_chatroom_created_by", columnList = "created_by")
})
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@EntityListeners(AuditingEntityListener.class)
public class ChatRoom {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "name", length = 100)
    private String name; // Room name (for group chats)
    
    @Enumerated(EnumType.STRING)
    @Column(name = "type", nullable = false, length = 20)
    private ChatRoomType type; // DIRECT, GROUP, CHANNEL
    
    @Column(name = "description", length = 500)
    private String description;
    
    @Column(name = "avatar_url", length = 255)
    private String avatarUrl;
    
    @Column(name = "created_by", nullable = false)
    private Long createdBy; // User who created the room
    
    @Column(name = "is_private", nullable = false)
    private boolean isPrivate = false;
    
    @Column(name = "is_active", nullable = false)
    private boolean isActive = true;
    
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;
    
    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;
    
    @Column(name = "last_message_at")
    private Instant lastMessageAt;
    
    @Column(name = "last_message_id")
    private Long lastMessageId; // Stored in Redis, synced periodically
    
    @OneToMany(mappedBy = "room", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<ChatParticipant> participants = new HashSet<>();

    // Transient fields for DTO mapping
    @Transient
    private Long unreadCount;
    @Transient
    private String lastMessageContent;
    @Transient
    private String lastMessageSender;
}
```

#### ChatParticipant Entity
```java
package com.example.demo.communication.chat.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;

import java.time.Instant;

@Entity
@Table(name = "chat_participants", uniqueConstraints = {
    @UniqueConstraint(columnNames = {"room_id", "user_id"}, name = "uk_participant_room_user")
})
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ChatParticipant {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "room_id", nullable = false)
    private ChatRoom room;
    
    @Column(name = "user_id", nullable = false)
    private Long userId;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "role", nullable = false, length = 20)
    private ChatParticipantRole role; // OWNER, ADMIN, MEMBER
    
    @Column(name = "joined_at", nullable = false)
    private Instant joinedAt;
    
    @Column(name = "last_read_at")
    private Instant lastReadAt;
    
    @Column(name = "last_read_message_id")
    private Long lastReadMessageId; // Stored in Redis, synced periodically
    
    @Column(name = "is_muted", nullable = false)
    private boolean isMuted = false;
    
    @Column(name = "is_active", nullable = false)
    private boolean isActive = true;
    
    @Column(name = "left_at")
    private Instant leftAt;
    
    // Transient fields for DTO mapping
    @Transient
    private String userName;
    @Transient
    private String userAvatar;
    @Transient
    private boolean isOnline;
}
```

### Chat Service Interface
```java
package com.example.demo.communication.chat.service;

import com.example.demo.communication.chat.dto.ChatMessageDto;
import com.example.demo.communication.chat.dto.ChatRoomDto;
import com.example.demo.communication.chat.dto.ChatParticipantDto;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import java.util.List;

public interface ChatService {
    
    /**
     * Create a new chat room
     * @param name Room name
     * @param type Room type (DIRECT, GROUP, CHANNEL)
     * @param description Room description
     * @param createdBy Creator user ID
     * @param participantIds Initial participant user IDs
     * @return Created chat room DTO
     * @throws ChatRoomCreationException if room creation fails
     */
    ChatRoomDto createChatRoom(String name, ChatRoomType type, String description, Long createdBy, List<Long> participantIds);
    
    /**
     * Get chat room by ID
     * @param roomId Room ID
     * @param userId Current user ID (for permission check)
     * @return Chat room DTO
     * @throws ChatRoomNotFoundException if room not found
     * @throws AccessDeniedException if user doesn't have access
     */
    ChatRoomDto getChatRoom(Long roomId, Long userId);
    
    /**
     * Get user's chat rooms
     * @param userId User ID
     * @return List of chat room DTOs
     */
    List<ChatRoomDto> getUserChatRooms(Long userId);
    
    /**
     * Send message to chat room
     * @param roomId Room ID
     * @param senderId Sender user ID
     * @param content Message content
     * @param messageType Message type
     * @return Created message DTO
     * @throws ChatRoomNotFoundException if room not found
     * @throws AccessDeniedException if user doesn't have access
     */
    ChatMessageDto sendMessage(Long roomId, Long senderId, String content, String messageType);
    
    /**
     * Get chat messages for room
     * @param roomId Room ID
     * @param userId Current user ID (for permission check)
     * @param pageable Pagination parameters
     * @return Page of message DTOs
     * @throws ChatRoomNotFoundException if room not found
     * @throws AccessDeniedException if user doesn't have access
     */
    Page<ChatMessageDto> getChatMessages(Long roomId, Long userId, Pageable pageable);
    
    /**
     * Edit message
     * @param messageId Message ID
     * @param userId User ID (must be message sender)
     * @param newContent New message content
     * @return Updated message DTO
     * @throws ChatMessageNotFoundException if message not found
     * @throws AccessDeniedException if user is not the sender
     */
    ChatMessageDto editMessage(Long messageId, Long userId, String newContent);
    
    /**
     * Delete message
     * @param messageId Message ID
     * @param userId User ID (must be message sender or room admin)
     * @throws ChatMessageNotFoundException if message not found
     * @throws AccessDeniedException if user doesn't have permission
     */
    void deleteMessage(Long messageId, Long userId);
    
    /**
     * Add participant to chat room
     * @param roomId Room ID
     * @param userId User ID to add
     * @param addedBy User ID who is adding (must have permission)
     * @return Chat participant DTO
     * @throws ChatRoomNotFoundException if room not found
     * @throws AccessDeniedException if addedBy user doesn't have permission
     */
    ChatParticipantDto addParticipant(Long roomId, Long userId, Long addedBy);
    
    /**
     * Remove participant from chat room
     * @param roomId Room ID
     * @param userId User ID to remove
     * @param removedBy User ID who is removing (must have permission)
     * @throws ChatRoomNotFoundException if room not found
     * @throws AccessDeniedException if removedBy user doesn't have permission
     */
    void removeParticipant(Long roomId, Long userId, Long removedBy);
    
    /**
     * Mark messages as read
     * @param roomId Room ID
     * @param userId User ID
     * @param lastReadMessageId Last message ID read
     */
    void markMessagesAsRead(Long roomId, Long userId, Long lastReadMessageId);
    
    /**
     * Get unread message count for user
     * @param userId User ID
     * @return Total unread message count across all rooms
     */
    Long getUnreadMessageCount(Long userId);
    
    /**
     * Get unread message count for specific room
     * @param roomId Room ID
     * @param userId User ID
     * @return Unread message count for the room
     */
    Long getUnreadMessageCount(Long roomId, Long userId);
    
    /**
     * Search messages in room
     * @param roomId Room ID
     * @param userId Current user ID (for permission check)
     * @param searchTerm Search term
     * @param pageable Pagination parameters
     * @return Page of matching message DTOs
     */
    Page<ChatMessageDto> searchMessages(Long roomId, Long userId, String searchTerm, Pageable pageable);
}
```

## Notification & Announcement System

**Note:** The implementation of the notification system must adhere to the `Notification` entity defined in `database-design.md`. The single-table model is the authoritative design standard, superseding any previous multi-table designs.

This section covers system-wide notifications and announcements.

### Announcement Entity
```java
package com.example.demo.communication.announcement.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.Instant;
import java.time.LocalDate;
 
public enum AnnouncementTarget {
    ALL,          // 全体员工
    DEPARTMENT,   // 特定部门
    ROLE          // 特定角色
}

@Entity
@Table(name = "announcements")
@EntityListeners(AuditingEntityListener.class)
@Getter
@Setter
public class Announcement {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 200)
    private String title;

    @Lob
    @Column(nullable = false, columnDefinition = "TEXT")
    private String content;

    @Column(name = "author_id", nullable = false)
    private Long authorId; // Added author ID

    @Enumerated(EnumType.STRING)
    @Column(name = "target_audience", length = 50) // e.g., ALL, DEPARTMENT, ROLE
    private AnnouncementTarget targetAudience;

    @Column(name = "department_id") // if target is a specific department
    private Long departmentId;

    @Column(name = "publish_date")
    private LocalDate publishDate;

    @Column(name = "expiry_date")
    private LocalDate expiryDate;

    @Column(nullable = false)
    private boolean published = false;

    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;

    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt; // Added updatedAt

    @Column(name = "created_by")
    private Long createdBy;

    @Column(name = "updated_by")
    private Long updatedBy; // Added updatedBy
}
```

### Notification Service Implementation
```java
package com.example.demo.communication.notification.service.impl;

import com.example.demo.communication.notification.service.NotificationService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;

@Service
@Slf4j
@RequiredArgsConstructor
public class NotificationServiceImpl implements NotificationService {

    // Assume WebSocket and Email services are injected
    // private final SimpMessagingTemplate messagingTemplate;
    // private final EmailService emailService;

    @Override
    @Async // Execute asynchronously to avoid blocking the caller thread
    public void sendNotification(Long userId, String message) {
        try {
            log.info("Sending notification to user {}: {}", userId, message);
            // 1. Send via WebSocket for real-time update
            // messagingTemplate.convertAndSendToUser(userId.toString(), "/queue/notifications", message);

            // 2. Optionally, send an email as well
            // Employee user = employeeRepository.findById(userId).orElse(null);
            // if (user != null && user.getEmail() != null) {
            //     emailService.sendSimpleMessage(user.getEmail(), "New Notification", message);
            // }
            log.info("Successfully sent notification to user {}", userId);
        } catch (Exception e) {
            // Robust error handling
            log.error("Failed to send notification to user {}: {}", userId, e.getMessage(), e);
            // Here you could add logic to retry, or flag the notification as failed
        }
    }
}
```

### Announcement Service Implementation
```java
package com.example.demo.communication.announcement.service.impl;

import com.example.demo.communication.announcement.dto.AnnouncementDto;
import com.example.demo.communication.announcement.entity.Announcement;
import com.example.demo.communication.announcement.repository.AnnouncementRepository;
import com.example.demo.communication.announcement.service.AnnouncementService;
import com.example.demo.communication.notification.service.NotificationService;
import com.example.demo.employee.repository.EmployeeRepository;
import lombok.RequiredArgsConstructor;
import org.modelmapper.ModelMapper;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class AnnouncementServiceImpl implements AnnouncementService {

    private final AnnouncementRepository announcementRepository;
    private final NotificationService notificationService;
    private final EmployeeRepository employeeRepository; // To get target employees
    private final ModelMapper modelMapper;

    @Override
    @Transactional
    public AnnouncementDto createAnnouncement(AnnouncementDto announcementDto) {
        Announcement announcement = modelMapper.map(announcementDto, Announcement.class);
        Announcement savedAnnouncement = announcementRepository.save(announcement);

        // If the announcement is published, send notifications
        if (savedAnnouncement.isPublished()) {
            notifyUsers(savedAnnouncement);
        }

        return modelMapper.map(savedAnnouncement, AnnouncementDto.class);
    }
  
    @Override
    @Transactional
    public AnnouncementDto updateAnnouncement(Long id, AnnouncementDto announcementDto) {
        Announcement existing = announcementRepository.findById(id)
            .orElseThrow(() -> new RuntimeException("Announcement not found"));
      
        modelMapper.map(announcementDto, existing);
        Announcement updatedAnnouncement = announcementRepository.save(existing);

        // If the announcement is published, send notifications
        if (updatedAnnouncement.isPublished()) {
            notifyUsers(updatedAnnouncement);
        }
      
        return modelMapper.map(updatedAnnouncement, AnnouncementDto.class);
    }

    private void notifyUsers(Announcement announcement) {
        String message = "New Announcement: " + announcement.getTitle();
        List<Long> targetUserIds = getTargetUserIds(announcement);
      
        targetUserIds.forEach(userId -> notificationService.sendNotification(userId, message));
    }

    private List<Long> getTargetUserIds(Announcement announcement) {
        // Logic to determine which users should be notified based on target_audience
        // For example:
        if ("ALL".equals(announcement.getTargetAudience())) {
            return employeeRepository.findAll().stream().map(e -> e.getId()).collect(Collectors.toList());
        } else if ("DEPARTMENT".equals(announcement.getTargetAudience()) && announcement.getDepartmentId() != null) {
            // Assuming EmployeeRepository has findByDepartmentId method
            // return employeeRepository.findByDepartmentId(announcement.getDepartmentId()).stream()...
        }
        return List.of(); // return empty list if no target
    }
    // Other methods (get, delete, etc.) would be implemented here.
}
```

### Announcement Controller
```java
package com.example.demo.communication.announcement.controller;

import com.example.demo.communication.announcement.dto.AnnouncementDto;
import com.example.demo.communication.announcement.service.AnnouncementService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/v1/announcements")
@RequiredArgsConstructor
public class AnnouncementController {

    private final AnnouncementService announcementService;

    @PostMapping
    @PreAuthorize("hasAuthority('ANNOUNCEMENT_MANAGE')")
    public ResponseEntity<AnnouncementDto> createAnnouncement(@Valid @RequestBody AnnouncementDto announcementDto) {
        AnnouncementDto created = announcementService.createAnnouncement(announcementDto);
        return new ResponseEntity<>(created, HttpStatus.CREATED);
    }

    @PutMapping("/{id}")
    @PreAuthorize("hasAuthority('ANNOUNCEMENT_MANAGE')")
    public ResponseEntity<AnnouncementDto> updateAnnouncement(@PathVariable Long id, @Valid @RequestBody AnnouncementDto announcementDto) {
        AnnouncementDto updated = announcementService.updateAnnouncement(id, announcementDto);
        return ResponseEntity.ok(updated);
    }

    // Endpoints for getting/deleting announcements would be here
}
```
</file>

<file path=".kiro/specs/spring-backend/employee-implementation.md">
# Employee Management Implementation

## Overview
This document provides detailed implementation specifications for the Employee Management module. This module handles comprehensive employee CRUD operations, search functionality, pagination, Excel import/export, and batch operations.

## Package Structure
```
com.example.demo.employee/
├── entity/
│   ├── Employee.java
│   └── EmployeeStatus.java
├── repository/
│   └── EmployeeRepository.java
├── service/
│   ├── EmployeeService.java
│   ├── EmployeeImportService.java
│   ├── EmployeeExportService.java
│   └── impl/
│       ├── EmployeeServiceImpl.java
│       ├── EmployeeImportServiceImpl.java
│       └── EmployeeExportServiceImpl.java
├── controller/
│   └── EmployeeController.java
├── dto/
│   ├── EmployeeDto.java
│   ├── EmployeeCreateRequest.java
│   ├── EmployeeUpdateRequest.java
│   ├── EmployeeSearchCriteria.java
│   ├── EmployeeImportResult.java
│   └── EmployeeExportRequest.java
├── util/
│   ├── EmployeeExcelUtil.java
│   └── EmployeeValidationUtil.java
└── exception/
    ├── EmployeeNotFoundException.java
    ├── EmployeeAlreadyExistsException.java
    ├── EmployeeImportException.java
    └── EmployeeExportException.java
```

## Entity Classes

### EmployeeStatus Enum
```java
package com.example.demo.employee.entity;

public enum EmployeeStatus {
    ACTIVE("Active"),
    INACTIVE("Inactive"),
    TERMINATED("Terminated"),
    ON_LEAVE("On Leave"),
    PROBATION("Probation"),
    SUSPENDED("Suspended");
    
    private final String displayName;
    
    EmployeeStatus(String displayName) {
        this.displayName = displayName;
    }
    
    public String getDisplayName() {
        return displayName;
    }
}
```

### PayType Enum
```java
package com.example.demo.employee.entity;

public enum PayType {
    SALARIED,
    HOURLY
}
```

### Employee Entity
```java
package com.example.demo.employee.entity;

import com.example.demo.config.security.EncryptedStringConverter;
import com.example.demo.department.entity.Department;
import com.example.demo.position.entity.Position;
import com.example.demo.payroll.entity.PayrollLedger;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.math.BigDecimal;
import java.time.Instant;
import java.time.LocalDate;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "employees",
    indexes = {
        @Index(name = "idx_employee_number", columnList = "employee_number", unique = true),
        @Index(name = "idx_employee_email", columnList = "email", unique = true),
        @Index(name = "idx_employee_department_id", columnList = "department_id"),
        @Index(name = "idx_employee_position_id", columnList = "position_id"),
        @Index(name = "idx_employee_status", columnList = "status")
    }
)
@EntityListeners(AuditingEntityListener.class)
@Getter
@Setter
public class Employee {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "employee_number", nullable = false, unique = true, length = 20)
    private String employeeNumber;

    @Column(name = "first_name", nullable = false, length = 50)
    private String firstName;

    @Column(name = "last_name", nullable = false, length = 50)
    private String lastName;

    @Column(name = "email", nullable = false, unique = true, length = 100)
    private String email;

    @Column(name = "phone", length = 20)
    private String phone;

    @Column(name = "mobile_phone", length = 20)
    private String mobilePhone;

    @Column(name = "address", length = 255)
    private String address;

    @Column(name = "city", length = 100)
    private String city;

    @Column(name = "state", length = 100)
    private String state;

    @Column(name = "zip_code", length = 20)
    private String zipCode;

    @Column(name = "country", length = 100)
    private String country;

    @Convert(converter = EncryptedStringConverter.class)
    @Column(name = "date_of_birth_encrypted")
    private String dateOfBirth; // Encrypted

    @Enumerated(EnumType.STRING)
    @Column(name = "gender", length = 20)
    private Gender gender;

    @Enumerated(EnumType.STRING)
    @Column(name = "marital_status", length = 20)
    private MaritalStatus maritalStatus;

    @Column(name = "nationality", length = 50)
    private String nationality;

    @Column(name = "department_id", nullable = false)
    private Long departmentId;

    @Column(name = "position_id", nullable = false)
    private Long positionId;

    @Column(name = "manager_id")
    private Long managerId;

    @Column(name = "hire_date", nullable = false)
    private LocalDate hireDate;

    @Column(name = "termination_date")
    private LocalDate terminationDate;

    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 20)
    private EmployeeStatus status = EmployeeStatus.ACTIVE;

    @Enumerated(EnumType.STRING)
    @Column(name = "employment_type", nullable = false, length = 20)
    private EmploymentType employmentType = EmploymentType.FULL_TIME;

    @Enumerated(EnumType.STRING)
    @Column(name = "pay_type", nullable = false, length = 10)
    private PayType payType = PayType.SALARY;

    @Column(name = "salary", precision = 12, scale = 2)
    private BigDecimal salary;

    @Column(name = "hourly_rate", precision = 8, scale = 2)
    private BigDecimal hourlyRate;

    @Convert(converter = EncryptedStringConverter.class)
    @Column(name = "bank_account_encrypted")
    private String bankAccount; // Encrypted

    @Convert(converter = EncryptedStringConverter.class)
    @Column(name = "tax_id_encrypted")
    private String taxId; // Encrypted

    @Column(name = "enabled", nullable = false)
    private boolean enabled = true;

    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;

    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;

    @Column(name = "created_by")
    private Long createdBy;

    @Column(name = "updated_by")
    private Long updatedBy;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "department_id", insertable = false, updatable = false)
    private Department department;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "position_id", insertable = false, updatable = false)
    private Position position;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "manager_id", insertable = false, updatable = false)
    private Employee manager;

    @OneToMany(mappedBy = "manager", fetch = FetchType.LAZY)
    private Set<Employee> directReports = new HashSet<>();

    @OneToMany(mappedBy = "employee", fetch = FetchType.LAZY, cascade = CascadeType.ALL)
    private Set<PayrollLedger> payrollLedgers = new HashSet<>();

    // Helper methods
    public String getFullName() {
        return firstName + " " + lastName;
    }
}
```
itory Interface
### EmployeeRepository
```java
package com.example.demo.employee.repository;

import com.example.demo.employee.entity.Employee;
import com.example.demo.employee.entity.EmployeeStatus;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

@Repository
public interface EmployeeRepository extends JpaRepository<Employee, Long> {
    
    /**
     * Find employee by employee number
     * @param employeeNumber Unique employee number
     * @return Optional employee
     */
    Optional<Employee> findByEmployeeNumber(String employeeNumber);
    
    /**
     * Find employee by email
     * @param email Employee email
     * @return Optional employee
     */
    Optional<Employee> findByEmail(String email);
    
    /**
     * Find employees by department ID
     * @param departmentId Department ID
     * @param pageable Pagination parameters
     * @return Page of employees
     */
    Page<Employee> findByDepartmentId(Long departmentId, Pageable pageable);
    
    /**
     * Find employees by position ID
     * @param positionId Position ID
     * @param pageable Pagination parameters
     * @return Page of employees
     */
    Page<Employee> findByPositionId(Long positionId, Pageable pageable);
    
    /**
     * Find employees by manager ID
     * @param managerId Manager employee ID
     * @param pageable Pagination parameters
     * @return Page of employees
     */
    Page<Employee> findByManagerId(Long managerId, Pageable pageable);
    
    /**
     * Find employees by status
     * @param status Employee status
     * @param pageable Pagination parameters
     * @return Page of employees
     */
    Page<Employee> findByStatus(EmployeeStatus status, Pageable pageable);
    
    /**
     * Find employees by hire date range
     * @param startDate Start date
     * @param endDate End date
     * @param pageable Pagination parameters
     * @return Page of employees
     */
    Page<Employee> findByHireDateBetween(LocalDate startDate, LocalDate endDate, Pageable pageable);
    
    /**
     * Find employees by first name containing (case insensitive)
     * @param firstName First name search term
     * @param pageable Pagination parameters
     * @return Page of employees
     */
    Page<Employee> findByFirstNameContainingIgnoreCase(String firstName, Pageable pageable);
    
    /**
     * Find employees by last name containing (case insensitive)
     * @param lastName Last name search term
     * @param pageable Pagination parameters
     * @return Page of employees
     */
    Page<Employee> findByLastNameContainingIgnoreCase(String lastName, Pageable pageable);
    
    /**
     * Find employees by first name or last name containing (case insensitive)
     * @param firstName First name search term
     * @param lastName Last name search term
     * @param pageable Pagination parameters
     * @return Page of employees
     */
    Page<Employee> findByFirstNameContainingIgnoreCaseOrLastNameContainingIgnoreCase(
        String firstName, String lastName, Pageable pageable);
    
    /**
     * Find employees by email containing (case insensitive)
     * @param email Email search term
     * @param pageable Pagination parameters
     * @return Page of employees
     */
    Page<Employee> findByEmailContainingIgnoreCase(String email, Pageable pageable);
    
    /**
     * Find enabled employees
     * @param pageable Pagination parameters
     * @return Page of enabled employees
     */
    Page<Employee> findByEnabledTrue(Pageable pageable);
    
    /**
     * Find employees by multiple criteria (for advanced search)
     * @param departmentId Department ID (optional)
     * @param positionId Position ID (optional)
     * @param status Employee status (optional)
     * @param pageable Pagination parameters
     * @return Page of employees matching criteria
     */
    Page<Employee> findByDepartmentIdAndPositionIdAndStatus(
        Long departmentId, Long positionId, EmployeeStatus status, Pageable pageable);
    
    /**
     * Check if employee number exists
     * @param employeeNumber Employee number
     * @return true if exists
     */
    boolean existsByEmployeeNumber(String employeeNumber);
    
    /**
     * Check if email exists
     * @param email Employee email
     * @return true if exists
     */
    boolean existsByEmail(String email);
    
    /**
     * Count employees by department ID
     * @param departmentId Department ID
     * @return Count of employees
     */
    long countByDepartmentId(Long departmentId);
    
    /**
     * Count employees by position ID
     * @param positionId Position ID
     * @return Count of employees
     */
    long countByPositionId(Long positionId);
    
    /**
     * Count employees by status
     * @param status Employee status
     * @return Count of employees
     */
    long countByStatus(EmployeeStatus status);
    
    /**
     * Find employees by IDs
     * @param ids List of employee IDs
     * @return List of employees
     */
    List<Employee> findByIdIn(List<Long> ids);
    
    /**
     * Find employees hired in date range
     * @param startDate Start date
     * @param endDate End date
     * @return List of employees
     */
    List<Employee> findByHireDateBetween(LocalDate startDate, LocalDate endDate);
    
    /**
     * Find employees with birthdays in date range
     * @param startDate Start date
     * @param endDate End date
     * @return List of employees
     */
    List<Employee> findByDateOfBirthBetween(LocalDate startDate, LocalDate endDate);
}
```
## DTO Classes

### EmployeeDto
```java
package com.example.demo.employee.dto;

import com.example.demo.employee.entity.EmployeeStatus;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;

import jakarta.validation.constraints.*;
import java.time.LocalDate;
import java.time.Instant;
import java.math.BigDecimal;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class EmployeeDto {
  
    private Long id;
  
    @NotBlank(message = "Employee number is required")
    @Size(max = 20, message = "Employee number must not exceed 20 characters")
    private String employeeNumber;
  
    @NotBlank(message = "First name is required")
    @Size(min = 2, max = 50, message = "First name must be between 2 and 50 characters")
    private String firstName;
  
    @NotBlank(message = "Last name is required")
    @Size(min = 2, max = 50, message = "Last name must be between 2 and 50 characters")
    private String lastName;
  
    @NotBlank(message = "Email is required")
    @Email(message = "Email should be valid")
    @Size(max = 100, message = "Email must not exceed 100 characters")
    private String email;
  
    @Pattern(regexp = "^[+]?[0-9\\s\\-\\(\\)]{10,20}$", message = "Phone number format is invalid")
    private String phone;
  
    @Pattern(regexp = "^[+]?[0-9\\s\\-\\(\\)]{10,20}$", message = "Mobile phone number format is invalid")
    private String mobilePhone;
  
    @Size(max = 255, message = "Address must not exceed 255 characters")
    private String address;
  
    @Size(max = 100, message = "City must not exceed 100 characters")
    private String city;
  
    @Size(max = 100, message = "State must not exceed 100 characters")
    private String state;
  
    @Size(max = 20, message = "Zip code must not exceed 20 characters")
    private String zipCode;
  
    @Size(max = 100, message = "Country must not exceed 100 characters")
    private String country;
  
    // Sensitive fields are strings in DTO, service layer handles encryption/decryption
    private String dateOfBirth;
  
    private String gender;
  
    private String maritalStatus;
  
    @Size(max = 50, message = "Nationality must not exceed 50 characters")
    private String nationality;
  
    @NotNull(message = "Department is required")
    private Long departmentId;
  
    private String departmentName; // Transient field for display
  
    @NotNull(message = "Position is required")
    private Long positionId;
  
    private String positionName; // Transient field for display
  
    private Long managerId;
  
    private String managerName; // Transient field for display
  
    @NotNull(message = "Hire date is required")
    @PastOrPresent(message = "Hire date cannot be in the future")
    private LocalDate hireDate;
  
    private LocalDate terminationDate;
  
    @NotNull(message = "Employee status is required")
    private EmployeeStatus status;
  
    private String employmentType;
  
    private String payType;
  
    @DecimalMin(value = "0.0", inclusive = true, message = "Salary must be non-negative")
    @Digits(integer = 10, fraction = 2, message = "Salary format is invalid")
    private BigDecimal salary;
  
    @DecimalMin(value = "0.0", inclusive = true, message = "Hourly rate must be non-negative")
    @Digits(integer = 6, fraction = 2, message = "Hourly rate format is invalid")
    private BigDecimal hourlyRate;
  
    // Sensitive fields are strings in DTO
    private String bankAccount;
    private String taxId;
  
    private boolean enabled;
  
    private Instant createdAt;
  
    private Instant updatedAt;
  
    private String fullName; // firstName + lastName
}
```

### EmployeeCreateRequest
```java
package com.example.demo.employee.dto;

import lombok.Data;

@Data
    @NotNull(message = "Department is required")
    private Long departmentId;
 
    @NotNull(message = "Position is required")
    private Long positionId;
 
    private Long managerId;
 
    @NotNull(message = "Hire date is required")
    @PastOrPresent
    private LocalDate hireDate;
 
    @NotNull(message = "Employee status is required")
    private EmployeeStatus status;
    
    @NotNull(message = "Pay type is required")
    private PayType payType;
    
    @DecimalMin(value = "0.0", inclusive = false)
    @Digits(integer = 10, fraction = 2)
    private BigDecimal salary; // For SALARY pay type
    
    @DecimalMin(value = "0.0", inclusive = false)
    @Digits(integer = 6, fraction = 2)
    private BigDecimal hourlyRate; // For HOURLY pay type
 
    // 其他允许在创建时由客户端提供的字段...
    private String phone;
    private String address;
    // 注意：不包含 id, employeeNumber, createdAt, updatedAt 等系统生成或只读的字段
}
```

### EmployeeUpdateRequest DTO
```java
package com.example.demo.employee.dto;

import com.example.demo.employee.entity.EmployeeStatus;
import com.example.demo.employee.entity.EmploymentType;
import com.example.demo.employee.entity.Gender;
import com.example.demo.employee.entity.MaritalStatus;
import jakarta.validation.constraints.*;
import lombok.Data;

import java.math.BigDecimal;
import java.time.LocalDate;

/**
 * 用于更新员工信息的数据传输对象。
 * 包含所有允许客户端修改的字段。
 */
@Data
public class EmployeeUpdateRequest {

    @NotBlank(message = "First name is required")
    @Size(max = 50, message = "First name must not exceed 50 characters")
    private String firstName;

    @NotBlank(message = "Last name is required")
    @Size(max = 50, message = "Last name must not exceed 50 characters")
    private String lastName;

    @NotBlank(message = "Email is required")
    @Email(message = "Email should be valid")
    @Size(max = 100, message = "Email must not exceed 100 characters")
    private String email;

    @Pattern(regexp = "^[+]?[0-9\\s\\-\\(\\)]{7,20}$", message = "Phone number format is invalid")
    private String phone;

    @Pattern(regexp = "^[+]?[0-9\\s\\-\\(\\)]{7,20}$", message = "Mobile phone number format is invalid")
    private String mobilePhone;

    @Size(max = 255)
    private String address;

    @Size(max = 100)
    private String city;

    @Size(max = 100)
    private String state;

    @Size(max = 20)
    private String zipCode;

    @Size(max = 100)
    private String country;

    // 敏感字段在传输时是字符串，由服务器处理加密
    private String dateOfBirth; 

    private Gender gender;
    
    private MaritalStatus maritalStatus;

    @Size(max = 50)
    private String nationality;

    @NotNull(message = "Department is required")
    private Long departmentId;

    @NotNull(message = "Position is required")
    private Long positionId;

    // 经理ID可以为null（例如，对于CEO）
    private Long managerId;

    @NotNull(message = "Hire date is required")
    @PastOrPresent(message = "Hire date cannot be in the future")
    private LocalDate hireDate;
    
    // 离职日期可以为null
    private LocalDate terminationDate;

    @NotNull(message = "Employee status is required")
    private EmployeeStatus status;
    
    @NotNull(message = "Employment type is required")
    private EmploymentType employmentType;

    // 薪资和时薪可以为null，取决于员工的薪资类型
    @DecimalMin(value = "0.0", inclusive = true, message = "Salary must be non-negative")
    @Digits(integer = 10, fraction = 2, message = "Salary format is invalid")
    private BigDecimal salary;

    @DecimalMin(value = "0.0", inclusive = true, message = "Hourly rate must be non-negative")
    @Digits(integer = 6, fraction = 2, message = "Hourly rate format is invalid")
    private BigDecimal hourlyRate;

    // 敏感字段
    private String bankAccount;
    private String taxId;

    @NotNull(message = "Enabled status is required")
    private Boolean enabled;
}
```

## Service Implementation

```java
package com.example.demo.employee.service.impl;

import com.example.demo.employee.dto.EmployeeCreateRequest;
import com.example.demo.employee.dto.EmployeeDto;
import com.example.demo.employee.dto.EmployeeUpdateRequest;
import com.example.demo.employee.entity.Employee;
import com.example.demo.employee.exception.EmployeeNotFoundException;
import com.example.demo.employee.exception.SalaryValidationException;
import com.example.demo.employee.repository.EmployeeRepository;
import com.example.demo.employee.service.EmployeeService;
import com.example.demo.position.entity.Position;
import com.example.demo.position.repository.PositionRepository;
import com.example.demo.util.EncryptionService; // 假设此服务存在
import lombok.RequiredArgsConstructor;
import org.modelmapper.ModelMapper;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.util.UUID; // <--- 新增：确保导入UUID

@Service
@RequiredArgsConstructor
public class EmployeeServiceImpl implements EmployeeService {

    private final EmployeeRepository employeeRepository;
    private final PositionRepository positionRepository;
    private final ModelMapper modelMapper;
    private final EncryptionService encryptionService;

    @Override
    @Transactional
    public EmployeeDto createEmployee(EmployeeCreateRequest createRequest) {
        // 校验薪资范围
        validateSalary(createRequest.getPositionId(), createRequest.getSalary());
 
        // 将 Request DTO 映射到新的 Employee 实体
        Employee employee = modelMapper.map(createRequest, Employee.class);
      
        // 生成系统控制的字段，如员工编号
        employee.setEmployeeNumber("EMP-" + UUID.randomUUID().toString().substring(0, 8).toUpperCase());
        employee.setEnabled(true); // 默认启用
    
        // 在保存前加密敏感数据
        if (createRequest.getDateOfBirth() != null) {
            employee.setDateOfBirth(encryptionService.encrypt(createRequest.getDateOfBirth()));
        }
        if (createRequest.getBankAccount() != null) {
            employee.setBankAccount(encryptionService.encrypt(createRequest.getBankAccount()));
        }
        if (createRequest.getTaxId() != null) {
            employee.setTaxId(encryptionService.encrypt(createRequest.getTaxId()));
        }
    
        // 保存实体并将其转换为用于响应的 DTO
        Employee savedEmployee = employeeRepository.save(employee);
        return convertToDto(savedEmployee);
    }

    /**
     * --- (2) 修改：重构 updateEmployee 方法以确保安全 ---
     *
     * 我们不再使用 modelMapper.map() 进行直接映射，以避免意外地将非空字段更新为 null。
     * 而是手动、有选择地更新每一个字段，只有当请求中的值不为 null 时才进行更新。
     * 这使得更新操作更加明确和安全。
     */
    @Override
    @Transactional
    public EmployeeDto updateEmployee(Long id, EmployeeUpdateRequest updateRequest) {
        Employee existingEmployee = employeeRepository.findById(id)
                .orElseThrow(() -> new EmployeeNotFoundException("Employee not found with id: " + id));
    
        // 校验薪资是否在职位范围内
        validateSalary(updateRequest.getPositionId(), updateRequest.getSalary());
    
        // **安全更新模式**
        // 有选择地更新非空字段
        if (updateRequest.getFirstName() != null) {
            existingEmployee.setFirstName(updateRequest.getFirstName());
        }
        if (updateRequest.getLastName() != null) {
            existingEmployee.setLastName(updateRequest.getLastName());
        }
        if (updateRequest.getEmail() != null) {
            existingEmployee.setEmail(updateRequest.getEmail());
        }
        if (updateRequest.getPhone() != null) {
            existingEmployee.setPhone(updateRequest.getPhone());
        }
        if (updateRequest.getMobilePhone() != null) {
            existingEmployee.setMobilePhone(updateRequest.getMobilePhone());
        }
        if (updateRequest.getAddress() != null) {
            existingEmployee.setAddress(updateRequest.getAddress());
        }
        if (updateRequest.getCity() != null) {
            existingEmployee.setCity(updateRequest.getCity());
        }
        if (updateRequest.getState() != null) {
            existingEmployee.setState(updateRequest.getState());
        }
        if (updateRequest.getZipCode() != null) {
            existingEmployee.setZipCode(updateRequest.getZipCode());
        }
        if (updateRequest.getCountry() != null) {
            existingEmployee.setCountry(updateRequest.getCountry());
        }
        if (updateRequest.getGender() != null) {
            existingEmployee.setGender(updateRequest.getGender());
        }
        if (updateRequest.getMaritalStatus() != null) {
            existingEmployee.setMaritalStatus(updateRequest.getMaritalStatus());
        }
        if (updateRequest.getNationality() != null) {
            existingEmployee.setNationality(updateRequest.getNationality());
        }
        if (updateRequest.getDepartmentId() != null) {
            existingEmployee.setDepartmentId(updateRequest.getDepartmentId());
        }
        if (updateRequest.getPositionId() != null) {
            existingEmployee.setPositionId(updateRequest.getPositionId());
        }
        if (updateRequest.getManagerId() != null) {
            existingEmployee.setManagerId(updateRequest.getManagerId());
        }
        if (updateRequest.getHireDate() != null) {
            existingEmployee.setHireDate(updateRequest.getHireDate());
        }
        if (updateRequest.getTerminationDate() != null) {
            existingEmployee.setTerminationDate(updateRequest.getTerminationDate());
        }
        if (updateRequest.getStatus() != null) {
            existingEmployee.setStatus(updateRequest.getStatus());
        }
        if (updateRequest.getEmploymentType() != null) {
            existingEmployee.setEmploymentType(updateRequest.getEmploymentType());
        }
        if (updateRequest.getSalary() != null) {
            existingEmployee.setSalary(updateRequest.getSalary());
        }
        if (updateRequest.getHourlyRate() != null) {
            existingEmployee.setHourlyRate(updateRequest.getHourlyRate());
        }
        if (updateRequest.getEnabled() != null) {
            existingEmployee.setEnabled(updateRequest.getEnabled());
        }
    
        // 加密敏感数据
        encryptSensitiveData(existingEmployee, updateRequest);
    
        Employee updatedEmployee = employeeRepository.save(existingEmployee);
        return convertToDto(updatedEmployee);
    }

    @Override
    @Transactional(readOnly = true)
    public EmployeeDto getEmployeeById(Long id) {
        Employee employee = employeeRepository.findById(id)
                .orElseThrow(() -> new EmployeeNotFoundException("Employee not found with id: " + id));
        return convertToDto(employee);
    }

    @Override
    @Transactional(readOnly = true)
    public Page<EmployeeDto> getAllEmployees(Pageable pageable) {
        return employeeRepository.findAll(pageable).map(this::convertToDto);
    }

    @Override
    @Transactional
    public void deleteEmployee(Long id) {
        if (!employeeRepository.existsById(id)) {
            throw new EmployeeNotFoundException("Employee not found with id: " + id);
        }
        employeeRepository.deleteById(id);
    }

    private void validateSalary(Long positionId, BigDecimal salary) {
        if (positionId == null || salary == null) {
            return;
        }
        Position position = positionRepository.findById(positionId)
                .orElseThrow(() -> new RuntimeException("Position not found with id: " + positionId));

        if (position.getMinSalary() != null && salary.compareTo(position.getMinSalary()) < 0) {
            throw new SalaryValidationException("Salary is below the minimum for this position.");
        }
        if (position.getMaxSalary() != null && salary.compareTo(position.getMaxSalary()) > 0) {
            throw new SalaryValidationException("Salary is above the maximum for this position.");
        }
    }

    private void encryptSensitiveData(Employee employee, EmployeeUpdateRequest dto) {
        if (dto.getDateOfBirth() != null) {
            employee.setDateOfBirth(encryptionService.encrypt(dto.getDateOfBirth()));
        }
        if (dto.getBankAccount() != null) {
            employee.setBankAccount(encryptionService.encrypt(dto.getBankAccount()));
        }
        if (dto.getTaxId() != null) {
            employee.setTaxId(encryptionService.encrypt(dto.getTaxId()));
        }
    }

    /**
     * --- (3) 修改：增强数据转换的健壮性 ---
     *
     * 在对银行账号进行脱敏处理时，增加了长度检查。
     * 这可以防止当银行账号长度不足时，substring 操作抛出异常。
     */
    private EmployeeDto convertToDto(Employee employee) {
        EmployeeDto dto = modelMapper.map(employee, EmployeeDto.class);
      
        // 解密敏感数据以供显示
        if (employee.getDateOfBirth() != null) {
            dto.setDateOfBirth(encryptionService.decrypt(employee.getDateOfBirth()));
        }
        if (employee.getBankAccount() != null) {
            String decryptedAccount = encryptionService.decrypt(employee.getBankAccount());
            // 增加健壮性检查
            if (decryptedAccount != null && decryptedAccount.length() > 4) {
                dto.setBankAccount("****" + decryptedAccount.substring(decryptedAccount.length() - 4));
            } else {
                dto.setBankAccount("****"); // 或者返回一个完全屏蔽的值
            }
        }
        if (employee.getTaxId() != null) {
            dto.setTaxId(encryptionService.decrypt(employee.getTaxId()));
        }
      
        // 填充用于显示的瞬态字段
        if (employee.getDepartment() != null) {
            dto.setDepartmentName(employee.getDepartment().getName());
        }
        if (employee.getPosition() != null) {
            dto.setPositionName(employee.getPosition().getJobTitle());
        }
        dto.setFullName(employee.getFullName());
      
        return dto;
    }
}

```

## Controller Implementation

### EmployeeController
```java
package com.example.demo.employee.controller;

import com.example.demo.employee.dto.EmployeeDto;
import com.example.demo.employee.service.EmployeeService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/v1/employees")
@RequiredArgsConstructor
public class EmployeeController {

    private final EmployeeService employeeService;

    @PostMapping
    @PreAuthorize("hasAuthority('EMPLOYEE_CREATE')")
    public ResponseEntity<EmployeeDto> createEmployee(@Valid @RequestBody EmployeeCreateRequest createRequest) {
        EmployeeDto createdEmployee = employeeService.createEmployee(createRequest);
        return new ResponseEntity<>(createdEmployee, HttpStatus.CREATED);
    }

    @GetMapping("/{id}")
    @PreAuthorize("hasAuthority('EMPLOYEE_READ')")
    public ResponseEntity<EmployeeDto> getEmployeeById(@PathVariable Long id) {
        EmployeeDto employeeDto = employeeService.getEmployeeById(id);
        return ResponseEntity.ok(employeeDto);
    }

    @GetMapping
    @PreAuthorize("hasAuthority('EMPLOYEE_READ')")
    public ResponseEntity<Page<EmployeeDto>> getAllEmployees(Pageable pageable) {
        Page<EmployeeDto> employees = employeeService.getAllEmployees(pageable);
        return ResponseEntity.ok(employees);
    }

    @PutMapping("/{id}")
    @PreAuthorize("hasAuthority('EMPLOYEE_UPDATE')")
    public ResponseEntity<EmployeeDto> updateEmployee(@PathVariable Long id, @Valid @RequestBody EmployeeUpdateRequest updateRequest) {
        EmployeeDto updatedEmployee = employeeService.updateEmployee(id, updateRequest);
        return ResponseEntity.ok(updatedEmployee);
    }

    @DeleteMapping("/{id}")
    @PreAuthorize("hasAuthority('EMPLOYEE_DELETE')")
    public ResponseEntity<Void> deleteEmployee(@PathVariable Long id) {
        employeeService.deleteEmployee(id);
        return ResponseEntity.noContent().build();
    }
}
```
</file>

<file path=".kiro/specs/spring-backend/payroll-implementation.md">
# Payroll Management Implementation

## Overview
This document provides detailed implementation specifications for the Payroll Management module. This module handles payroll ledgers, salary calculations, payroll processing, and payroll reporting with comprehensive audit trails.

## Package Structure
```
com.example.demo.payroll/
├── entity/
│   ├── PayrollLedger.java
│   ├── PayrollPeriod.java
│   ├── SalaryComponent.java
│   └── PayrollAudit.java
├── repository/
│   ├── PayrollLedgerRepository.java
│   ├── PayrollPeriodRepository.java
│   ├── SalaryComponentRepository.java
│   └── PayrollAuditRepository.java
├── service/
│   ├── PayrollService.java
│   ├── PayrollCalculationService.java
│   ├── PayrollReportService.java
│   └── impl/
│       ├── PayrollServiceImpl.java
│       ├── PayrollCalculationServiceImpl.java
│       └── PayrollReportServiceImpl.java
├── controller/
│   └── PayrollController.java
├── dto/
│   ├── PayrollLedgerDto.java
│   ├── PayrollPeriodDto.java
│   ├── SalaryComponentDto.java
│   ├── PayrollCalculationRequest.java
│   ├── PayrollReportRequest.java
│   └── PayrollSummaryDto.java
├── util/
│   ├── PayrollCalculationUtil.java
│   └── PayrollValidationUtil.java
└── exception/
    ├── PayrollNotFoundException.java
    ├── PayrollCalculationException.java
    ├── PayrollPeriodException.java
    └── PayrollValidationException.java
```

## Entity Classes

### Enum Definitions

#### PayrollLedgerStatus Enum
```java
package com.example.demo.payroll.entity;

public enum PayrollLedgerStatus {
    PENDING,
    CALCULATED,
    APPROVED,
    PAID,
    REJECTED,
    CANCELLED
}
```

#### PaymentMethod Enum
```java
package com.example.demo.payroll.entity;

public enum PaymentMethod {
    BANK_TRANSFER,
    CHECK,
    CASH,
    OTHER
}
```

#### PayrollPeriodType Enum
```java
package com.example.demo.payroll.entity;

public enum PayrollPeriodType {
    MONTHLY,
    BI_WEEKLY,
    WEEKLY,
    CUSTOM
}
```

#### PayrollPeriodStatus Enum
```java
package com.example.demo.payroll.entity;

public enum PayrollPeriodStatus {
    DRAFT,
    OPEN,
    CLOSED,
    ARCHIVED
}
```

#### SalaryComponentType Enum
```java
package com.example.demo.payroll.entity;

public enum SalaryComponentType {
    ALLOWANCE,
    DEDUCTION
}
```

#### CalculationType Enum
```java
package com.example.demo.payroll.entity;

public enum CalculationType {
    FIXED,
    PERCENTAGE
}
```
### PayrollLedger Entity
```java
package com.example.demo.payroll.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import lombok.Builder;
import com.example.demo.employee.entity.Employee;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.math.BigDecimal;
import java.time.Instant;
import java.time.LocalDate;

@Entity
@Table(name = "payroll_ledgers", indexes = {
    @Index(name = "idx_payrollledger_employee_id", columnList = "employee_id"),
    @Index(name = "idx_payrollledger_period_id", columnList = "payroll_period_id"),
    @Index(name = "idx_payrollledger_status", columnList = "status")
})
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@EntityListeners(AuditingEntityListener.class)
public class PayrollLedger {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "employee_id", nullable = false)
    private Employee employee;

    @Column(name = "payroll_period_id", nullable = false)
    private Long payrollPeriodId;

    @Column(name = "employee_number", length = 20)
    private String employeeNumber;

    @Column(name = "employee_name", length = 100)
    private String employeeName;

    @Column(name = "department_id")
    private Long departmentId;

    @Column(name = "department_name", length = 100)
    private String departmentName;

    @Column(name = "position_id")
    private Long positionId;

    @Column(name = "position_name", length = 100)
    private String positionName;

    @Column(name = "base_salary", precision = 12, scale = 2)
    private BigDecimal baseSalary;

    @Column(name = "hourly_rate", precision = 12, scale = 2)
    private BigDecimal hourlyRate;

    @Column(name = "hours_worked", precision = 10, scale = 2)
    private BigDecimal hoursWorked;

    @Column(name = "overtime_hours", precision = 10, scale = 2)
    private BigDecimal overtimeHours;

    @Column(name = "overtime_rate", precision = 12, scale = 2)
    private BigDecimal overtimeRate;

    @Column(name = "total_allowances", precision = 12, scale = 2)
    private BigDecimal totalAllowances;

    @Column(name = "total_deductions", precision = 12, scale = 2)
    private BigDecimal totalDeductions;

    @Column(name = "gross_salary", precision = 12, scale = 2)
    private BigDecimal grossSalary;

    @Column(name = "net_salary", precision = 12, scale = 2)
    private BigDecimal netSalary;

    @Column(name = "employer_contributions", precision = 12, scale = 2)
    private BigDecimal employerContributions;

    @Column(name = "total_cost", precision = 12, scale = 2)
    private BigDecimal totalCost;

    @Column(name = "currency", length = 10)
    private String currency;

    @Enumerated(EnumType.STRING)
    @Column(name = "payment_method", length = 20)
    private PaymentMethod paymentMethod;

    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 20)
    private PayrollLedgerStatus status;

    @Column(name = "pay_date")
    private LocalDate payDate;

    @Lob
    @Column(name = "notes", columnDefinition = "TEXT")
    private String notes;

    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;

    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;

    @Column(name = "created_by")
    private Long createdBy;

    @Column(name = "updated_by")
    private Long updatedBy;

    @Lob
    @Column(name = "calculation_details", columnDefinition = "TEXT")
    private String calculationDetails; // JSON string for all components
}
```
### PayrollPeriod Entity
```java
package com.example.demo.payroll.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.Instant;
import java.time.LocalDate;

@Entity
@Table(name = "payroll_periods", indexes = {
    @Index(name = "idx_payrollperiod_start_end", columnList = "start_date, end_date"),
    @Index(name = "idx_payrollperiod_status", columnList = "status")
})
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@EntityListeners(AuditingEntityListener.class)
public class PayrollPeriod {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "name", nullable = false, length = 100)
    private String name;

    @Enumerated(EnumType.STRING)
    @Column(name = "type", nullable = false, length = 20)
    private PayrollPeriodType type;

    @Column(name = "start_date", nullable = false)
    private LocalDate startDate;

    @Column(name = "end_date", nullable = false)
    private LocalDate endDate;

    @Column(name = "pay_date", nullable = false)
    private LocalDate payDate;

    @Column(name = "working_days")
    private Integer workingDays;

    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 20)
    private PayrollPeriodStatus status;

    @Column(name = "description", length = 500)
    private String description;

    @Column(name = "is_active", nullable = false)
    private boolean isActive = true;

    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;

    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;

    @Column(name = "created_by")
    private Long createdBy;

    @Column(name = "updated_by")
    private Long updatedBy;
}
```

### SalaryComponent Entity
```java
package com.example.demo.payroll.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.math.BigDecimal;
import java.time.Instant;

@Entity
@Table(name = "salary_components", indexes = {
    @Index(name = "idx_salarycomponent_code", columnList = "code", unique = true),
    @Index(name = "idx_salarycomponent_type", columnList = "type")
})
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@EntityListeners(AuditingEntityListener.class)
public class SalaryComponent {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "code", nullable = false, unique = true, length = 50)
    private String code;

    @Column(name = "name", nullable = false, length = 100)
    private String name;

    @Enumerated(EnumType.STRING)
    @Column(name = "type", nullable = false, length = 20)
    private SalaryComponentType type; // ALLOWANCE, DEDUCTION

    @Enumerated(EnumType.STRING)
    @Column(name = "calculation_type", nullable = false, length = 20)
    private CalculationType calculationType; // FIXED, PERCENTAGE

    @Column(name = "value", precision = 12, scale = 2)
    private BigDecimal value; // Amount for FIXED, percentage for PERCENTAGE

    @Column(name = "is_taxable", nullable = false)
    private boolean isTaxable = false;

    @Column(name = "is_active", nullable = false)
    private boolean isActive = true;

    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;

    @LastModifiedDate
    @Column(name = "updated_at")
    private Instant updatedAt;
}
```

### PayrollAudit Entity
```java
package com.example.demo.payroll.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.Instant;

@Entity
@Table(name = "payroll_audits", indexes = {
    @Index(name = "idx_payrollaudit_ledger_id", columnList = "payroll_ledger_id"),
    @Index(name = "idx_payrollaudit_performed_by", columnList = "performed_by")
})
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@EntityListeners(AuditingEntityListener.class)
public class PayrollAudit {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "payroll_ledger_id", nullable = false)
    private Long payrollLedgerId;

    @Column(name = "action", nullable = false, length = 50)
    private String action;

    @Lob
    @Column(name = "details", columnDefinition = "TEXT")
    private String details; // JSON string of changes

    @Column(name = "reason", length = 500)
    private String reason;

    @Column(name = "performed_by", nullable = false)
    private Long performedBy;

    @CreatedDate
    @Column(name = "performed_at", nullable = false, updatable = false)
    private Instant performedAt;

    @Column(name = "ip_address", length = 45)
    private String ipAddress;
}
```
```## Repos
itory Interfaces

### PayrollLedgerRepository
```java
package com.example.demo.payroll.repository;

import com.example.demo.payroll.entity.PayrollLedger;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

@Repository
public interface PayrollLedgerRepository extends JpaRepository<PayrollLedger, Long> {
    
    /**
     * Find payroll ledger by employee and payroll period
     * @param employeeId Employee ID
     * @param payrollPeriodId Payroll period ID
     * @return Optional payroll ledger
     */
    Optional<PayrollLedger> findByEmployeeIdAndPayrollPeriodId(Long employeeId, Long payrollPeriodId);
    
    /**
     * Find payroll ledgers by employee ID
     * @param employeeId Employee ID
     * @param pageable Pagination parameters
     * @return Page of payroll ledgers
     */
    Page<PayrollLedger> findByEmployeeIdOrderByPayDateDesc(Long employeeId, Pageable pageable);
    
    /**
     * Find payroll ledgers by payroll period
     * @param payrollPeriodId Payroll period ID
     * @param pageable Pagination parameters
     * @return Page of payroll ledgers
     */
    Page<PayrollLedger> findByPayrollPeriodId(Long payrollPeriodId, Pageable pageable);
    
    /**
     * Find payroll ledgers by department
     * @param departmentId Department ID
     * @param pageable Pagination parameters
     * @return Page of payroll ledgers
     */
    Page<PayrollLedger> findByDepartmentId(Long departmentId, Pageable pageable);
    
    /**
     * Find payroll ledgers by status
     * @param status Payroll status
     * @param pageable Pagination parameters
     * @return Page of payroll ledgers
     */
    Page<PayrollLedger> findByStatus(String status, Pageable pageable);
    
    /**
     * Find payroll ledgers by pay date range
     * @param startDate Start date
     * @param endDate End date
     * @param pageable Pagination parameters
     * @return Page of payroll ledgers
     */
    Page<PayrollLedger> findByPayDateBetween(LocalDate startDate, LocalDate endDate, Pageable pageable);
    
    /**
     * Find payroll ledgers by employee and date range
     * @param employeeId Employee ID
     * @param startDate Start date
     * @param endDate End date
     * @return List of payroll ledgers
     */
    List<PayrollLedger> findByEmployeeIdAndPayDateBetweenOrderByPayDateDesc(
        Long employeeId, LocalDate startDate, LocalDate endDate);
    
    /**
     * Find payroll ledgers by department and payroll period
     * @param departmentId Department ID
     * @param payrollPeriodId Payroll period ID
     * @return List of payroll ledgers
     */
    List<PayrollLedger> findByDepartmentIdAndPayrollPeriodId(Long departmentId, Long payrollPeriodId);
    
    /**
     * Check if payroll exists for employee and period
     * @param employeeId Employee ID
     * @param payrollPeriodId Payroll period ID
     * @return true if exists
     */
    boolean existsByEmployeeIdAndPayrollPeriodId(Long employeeId, Long payrollPeriodId);
    
    /**
     * Count payroll ledgers by status
     * @param status Payroll status
     * @return Count of payroll ledgers
     */
    long countByStatus(String status);
    
    /**
     * Count payroll ledgers by payroll period
     * @param payrollPeriodId Payroll period ID
     * @return Count of payroll ledgers
     */
    long countByPayrollPeriodId(Long payrollPeriodId);
    
    /**
     * Find payroll ledgers by multiple criteria
     * @param departmentId Department ID (optional)
     * @param payrollPeriodId Payroll period ID (optional)
     * @param status Status (optional)
     * @param pageable Pagination parameters
     * @return Page of payroll ledgers
     */
    Page<PayrollLedger> findByDepartmentIdAndPayrollPeriodIdAndStatus(
        Long departmentId, Long payrollPeriodId, String status, Pageable pageable);
}
```

### PayrollPeriodRepository
```java
package com.example.demo.payroll.repository;

import com.example.demo.payroll.entity.PayrollPeriod;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

@Repository
public interface PayrollPeriodRepository extends JpaRepository<PayrollPeriod, Long> {
    
    /**
     * Find payroll period by name
     * @param name Period name
     * @return Optional payroll period
     */
    Optional<PayrollPeriod> findByName(String name);
    
    /**
     * Find active payroll periods
     * @return List of active payroll periods
     */
    List<PayrollPeriod> findByIsActiveTrueOrderByStartDateDesc();
    
    /**
     * Find payroll periods by type
     * @param type Period type
     * @param pageable Pagination parameters
     * @return Page of payroll periods
     */
    Page<PayrollPeriod> findByTypeOrderByStartDateDesc(String type, Pageable pageable);
    
    /**
     * Find payroll periods by status
     * @param status Period status
     * @param pageable Pagination parameters
     * @return Page of payroll periods
     */
    Page<PayrollPeriod> findByStatusOrderByStartDateDesc(String status, Pageable pageable);
    
    /**
     * Find payroll periods by date range
     * @param startDate Start date
     * @param endDate End date
     * @return List of payroll periods
     */
    List<PayrollPeriod> findByStartDateBetweenOrderByStartDateDesc(LocalDate startDate, LocalDate endDate);
    
    /**
     * Find current payroll period (contains given date)
     * @param date Date to check
     * @return Optional payroll period
     */
    Optional<PayrollPeriod> findByStartDateLessThanEqualAndEndDateGreaterThanEqualAndIsActiveTrue(
        LocalDate date, LocalDate date2);
    
    /**
     * Find overlapping payroll periods
     * @param startDate Start date
     * @param endDate End date
     * @return List of overlapping periods
     */
    List<PayrollPeriod> findByStartDateLessThanEqualAndEndDateGreaterThanEqual(
        LocalDate endDate, LocalDate startDate);
    
    /**
     * Check if period name exists
     * @param name Period name
     * @return true if exists
     */
    boolean existsByName(String name);
    
    /**
     * Find latest payroll period by type
     * @param type Period type
     * @return Optional payroll period
     */
    Optional<PayrollPeriod> findFirstByTypeOrderByStartDateDesc(String type);
}
```

## DTO Classes

### PayrollLedgerDto
```java
package com.example.demo.payroll.dto;

import lombok.Data;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;
import java.math.BigDecimal;
import java.time.Instant;
import java.time.LocalDate;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class PayrollLedgerDto {
    private Long id;

    @NotNull
    private Long employeeId;

    @NotNull
    private Long payrollPeriodId;

    private String employeeNumber;
    private String employeeName;
    private Long departmentId;
    private String departmentName;
    private Long positionId;
    private String positionName;

    @Positive
    private BigDecimal baseSalary;
    private BigDecimal hourlyRate;
    private BigDecimal hoursWorked;
    private BigDecimal overtimeHours;
    private BigDecimal overtimeRate;
    private BigDecimal totalAllowances;
    private BigDecimal totalDeductions;

    @NotNull
    private BigDecimal grossSalary;

    @NotNull
    private BigDecimal netSalary;

    private BigDecimal employerContributions;
    private BigDecimal totalCost;
    private String currency;
    private String paymentMethod;

    @NotNull
    private String status;

    private LocalDate payDate;
    private String notes;
    private String calculationDetails;

    private Instant createdAt;
    private Instant updatedAt;
}
```

### PayrollPeriodDto
```java
package com.example.demo.payroll.dto;

import lombok.Data;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import java.time.Instant;
import java.time.LocalDate;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class PayrollPeriodDto {
    private Long id;

    @NotBlank
    private String name;

    @NotBlank
    private String type;

    @NotNull
    private LocalDate startDate;

    @NotNull
    private LocalDate endDate;

    @NotNull
    private LocalDate payDate;

    private Integer workingDays;

    @NotBlank
    private String status;

    private String description;
    private boolean isActive;

    private Instant createdAt;
    private Instant updatedAt;
}
```

## Service Interfaces

### PayrollService
```java
package com.example.demo.payroll.service;

import com.example.demo.payroll.dto.PayrollLedgerDto;
import com.example.demo.payroll.dto.PayrollPeriodDto;
import com.example.demo.payroll.dto.PayrollCalculationRequest;
import com.example.demo.payroll.dto.PayrollSummaryDto;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import java.time.LocalDate;
import java.util.List;

public interface PayrollService {

    /**
     * ### Business Rule for Payroll Ledger Snapshot
     *
     * When creating a `PayrollLedger` record, the `PayrollService` must, within a transaction,
     * fetch the current names of associated entities like employee, department, and position.
     * These names must be stored as a **one-time snapshot** in the corresponding fields
     * (`employeeName`, `departmentName`, etc.). These snapshot fields **should not be automatically
     * updated** after the record is created to ensure the historical accuracy of payroll reports.
     */

    /**
     * Create a new payroll ledger
     * @param payrollLedgerDto Payroll ledger data
     * @return Created payroll ledger DTO
     * @throws PayrollValidationException if validation fails
     * @throws EmployeeNotFoundException if employee not found
     * @throws PayrollPeriodNotFoundException if payroll period not found
     */
    PayrollLedgerDto createPayrollLedger(PayrollLedgerDto payrollLedgerDto);
    
    /**
     * Update an existing payroll ledger
     * @param id Payroll ledger ID
     * @param payrollLedgerDto Updated payroll ledger data
     * @return Updated payroll ledger DTO
     * @throws PayrollNotFoundException if payroll ledger not found
     * @throws PayrollValidationException if validation fails
     */
    PayrollLedgerDto updatePayrollLedger(Long id, PayrollLedgerDto payrollLedgerDto);
    
    /**
     * Get payroll ledger by ID
     * @param id Payroll ledger ID
     * @return Payroll ledger DTO
     * @throws PayrollNotFoundException if payroll ledger not found
     */
    PayrollLedgerDto getPayrollLedger(Long id);
    
    /**
     * Get payroll ledgers with pagination
     * @param pageable Pagination parameters
     * @return Page of payroll ledger DTOs
     */
    Page<PayrollLedgerDto> getPayrollLedgers(Pageable pageable);
    
    /**
     * Get employee payroll history
     * @param employeeId Employee ID
     * @param pageable Pagination parameters
     * @return Page of payroll ledger DTOs
     * @throws EmployeeNotFoundException if employee not found
     */
    Page<PayrollLedgerDto> getEmployeePayrollHistory(Long employeeId, Pageable pageable);
    
    /**
     * Get payroll ledgers by period
     * @param payrollPeriodId Payroll period ID
     * @param pageable Pagination parameters
     * @return Page of payroll ledger DTOs
     * @throws PayrollPeriodNotFoundException if payroll period not found
     */
    Page<PayrollLedgerDto> getPayrollLedgersByPeriod(Long payrollPeriodId, Pageable pageable);
    
    /**
     * Get payroll ledgers by department
     * @param departmentId Department ID
     * @param pageable Pagination parameters
     * @return Page of payroll ledger DTOs
     * @throws DepartmentNotFoundException if department not found
     */
    Page<PayrollLedgerDto> getPayrollLedgersByDepartment(Long departmentId, Pageable pageable);
    
    /**
     * Calculate payroll for employee and period
     * @param request Payroll calculation request
     * @return Calculated payroll ledger DTO
     * @throws PayrollCalculationException if calculation fails
     * @throws EmployeeNotFoundException if employee not found
     * @throws PayrollPeriodNotFoundException if payroll period not found
     */
    PayrollLedgerDto calculatePayroll(PayrollCalculationRequest request);
    
    /**
     * Calculate payroll for all employees in a period
     * @param payrollPeriodId Payroll period ID
     * @return List of calculated payroll ledger DTOs
     * @throws PayrollPeriodNotFoundException if payroll period not found
     * @throws PayrollCalculationException if calculation fails
     */
    List<PayrollLedgerDto> calculatePayrollForPeriod(Long payrollPeriodId);
    
    /**
     * Calculate payroll for department in a period
     * @param departmentId Department ID
     * @param payrollPeriodId Payroll period ID
     * @return List of calculated payroll ledger DTOs
     * @throws DepartmentNotFoundException if department not found
     * @throws PayrollPeriodNotFoundException if payroll period not found
     * @throws PayrollCalculationException if calculation fails
     */
    List<PayrollLedgerDto> calculatePayrollForDepartment(Long departmentId, Long payrollPeriodId);
    
    /**
     * Approve payroll ledger
     * @param id Payroll ledger ID
     * @param approvedBy User ID who approved
     * @return Approved payroll ledger DTO
     * @throws PayrollNotFoundException if payroll ledger not found
     * @throws PayrollValidationException if payroll cannot be approved
     */
    PayrollLedgerDto approvePayroll(Long id, Long approvedBy);
    
    /**
     * Approve multiple payroll ledgers
     * @param ids List of payroll ledger IDs
     * @param approvedBy User ID who approved
     * @return List of approved payroll ledger DTOs
     * @throws PayrollNotFoundException if any payroll ledger not found
     * @throws PayrollValidationException if any payroll cannot be approved
     */
    List<PayrollLedgerDto> approvePayrolls(List<Long> ids, Long approvedBy);
    
    /**
     * Mark payroll as paid
     * @param id Payroll ledger ID
     * @param paidBy User ID who marked as paid
     * @param paymentReference Payment reference
     * @return Updated payroll ledger DTO
     * @throws PayrollNotFoundException if payroll ledger not found
     * @throws PayrollValidationException if payroll cannot be marked as paid
     */
    PayrollLedgerDto markPayrollAsPaid(Long id, Long paidBy, String paymentReference);
    
    /**
     * Cancel payroll ledger
     * @param id Payroll ledger ID
     * @param cancelledBy User ID who cancelled
     * @param reason Cancellation reason
     * @throws PayrollNotFoundException if payroll ledger not found
     * @throws PayrollValidationException if payroll cannot be cancelled
     */
    void cancelPayroll(Long id, Long cancelledBy, String reason);
    
    /**
     * Delete payroll ledger
     * @param id Payroll ledger ID
     * @throws PayrollNotFoundException if payroll ledger not found
     * @throws PayrollValidationException if payroll cannot be deleted
     */
    void deletePayrollLedger(Long id);
    
    /**
     * Get payroll summary for period
     * @param payrollPeriodId Payroll period ID
     * @return Payroll summary DTO
     * @throws PayrollPeriodNotFoundException if payroll period not found
     */
    PayrollSummaryDto getPayrollSummary(Long payrollPeriodId);
    
    /**
     * Get payroll summary for department and period
     * @param departmentId Department ID
     * @param payrollPeriodId Payroll period ID
     * @return Payroll summary DTO
     * @throws DepartmentNotFoundException if department not found
     * @throws PayrollPeriodNotFoundException if payroll period not found
     */
    PayrollSummaryDto getPayrollSummary(Long departmentId, Long payrollPeriodId);
}
```

This completes the comprehensive implementation documentation for all major modules of the Spring Boot backend. Each document provides:

1. **Complete package structure** with all necessary classes
2. **Detailed entity definitions** with all fields, annotations, and relationships
3. **Repository interfaces** with all required query methods
4. **Service interfaces** with complete method signatures, parameters, return types, and exceptions
5. **DTO classes** with validation annotations and constraints
6. **Exception handling** specifications
7. **Database schema** considerations for Redis

The implementation documents are structured to provide developers with everything they need to implement each module without having to make design decisions. Each method signature includes:
- Clear parameter definitions
- Return type specifications
- Exception declarations
- JavaDoc documentation explaining the purpose and behavior
</file>

<file path=".kiro/specs/spring-backend/tasks.md">
# Implementation Plan - Spring Boot Employee Management System

## Overview

This implementation plan provides detailed, actionable tasks for building the Spring Boot Employee Management System backend using a hybrid PostgreSQL + Redis architecture. Each task is designed to be executed incrementally, building upon previous implementations while maintaining system integrity and following best practices. The plan addresses all conflicts identified in the conflict analysis and implements comprehensive security and compliance features.

## Phase 1: Project Foundation and Hybrid Database Setup

### Task 1: Project Initialization and Basic Structure

- [x] 1.1 Create Spring Boot project structure with hybrid database support
  - Initialize Maven project with Spring Boot 3.5.4 and Java 24
  - Set up basic directory structure following package conventions
  - Create main application class DemoApplication.java
  - Configure Maven pom.xml with PostgreSQL, Redis, and security dependencies
  - Set up executable JAR packaging for modern deployment
  - _Requirements: 2.1, 10.1_

- [x] 1.2 Configure hybrid database dependencies
  - Add Spring Boot Starter Web for REST API support
  - Add Spring Boot Starter Security for authentication
  - Add Spring Boot Starter Data JPA for PostgreSQL operations
  - Add Spring Boot Starter Data Redis for caching and real-time features
  - Add PostgreSQL JDBC driver
  - Add Flyway for database migrations
  - Add Spring Boot Starter WebSocket for real-time communication
  - Add Spring Boot Starter Mail for email functionality
  - Add Spring Boot Starter Actuator for monitoring
  - Add Lombok for code generation
  - Add Spring Boot Starter Test for testing
  - _Requirements: 2.1, 6.2, 8.1, 10.1_

- [x] 1.3 Set up hybrid database configuration
  - Create application.properties with PostgreSQL and Redis configuration
  - Create application-dev.properties for development environment
  - Configure PostgreSQL connection properties with connection pooling
  - Configure Redis connection properties for caching and sessions
  - Set up Flyway migration configuration
  - Configure JPA/Hibernate properties for PostgreSQL
  - Set up basic logging configuration
  - Configure server port and context path
  - _Requirements: 2.1, 10.1, 10.2_

### Task 2: Database Infrastructure Setup

- [x] 2.1 Implement PostgreSQL configuration
  - Create JpaConfig class with EntityManagerFactory configuration
  - Configure PostgreSQL dialect and connection pooling
  - Set up transaction management with @Transactional support
  - Add PostgreSQL health check configuration
  - Create database connection validation
  - _Requirements: 10.1, 10.5_

- [x] 2.2 Implement Redis configuration for caching and real-time features
  - Create RedisConfig class with RedisTemplate configuration
  - Configure Redis serializers for keys and values
  - Set up Redis connection factory with connection pooling
  - Configure Redis cache manager for Spring Cache abstraction
  - Add Redis health check configuration
  - Test Redis connectivity with basic operations
  - _Requirements: 8.1, 8.2, 10.1_

- [x] 2.3 Create database migration infrastructure
  - Set up Flyway configuration for versioned migrations
  - Create initial migration scripts directory structure
  - Implement database initialization scripts
  - Create rollback and recovery procedures
  - Add migration validation and testing
  - _Requirements: 10.4, 10.5_

- [x] 2.4 Create common infrastructure classes
  - Implement ApiResponse<T> for standardized API responses
  - Create ErrorResponse for error information
  - Add PageResponse<T> for paginated data
  - Create basic utility classes (DateUtil, StringUtil)
  - Set up global exception handling structure
  - _Requirements: 2.4, 5.2_
  - Add PageResponse<T> for paginated data
  - Create basic utility classes (DateUtil, StringUtil)
  - Set up global exception handling structure
  - _Requirements: 2.4, 5.2_

## Security and Authentication Module

### Task 3: Core Security Entities and Database Schema

- [x] 3.1 Implement User entity with JPA annotations for PostgreSQL
  - Create User.java with @Entity annotation for PostgreSQL.
  - Define fields: id, username, password, enabled, roles
  - Add validation annotations (@NotNull, @Size, @Email)
  - Implement audit fields with @CreatedDate, @LastModifiedDate
  - Add password encoding support with BCrypt
  - Create proper JPA relationships with Role entities.
  - _Requirements: 1.1, 2.1, 2.2_

- [x] 3.2 Implement Role entity with resource relationships
  - Create Role.java with @Entity annotation for PostgreSQL.
  - Define fields: id, name, description, resources
  - Implement many-to-many relationship with Resource entities
  - Add validation for role name uniqueness
  - Create proper database constraints and indexes.
  - _Requirements: 1.1, 1.2_

- [x] 3.3 Implement Resource entity for permission management
  - Create Resource.java with @Entity annotation for PostgreSQL.
  - Define fields: id, name, url, method, description
  - Add validation for URL patterns and HTTP methods
  - Implement resource hierarchy support
  - _Requirements: 1.1, 1.4_
  - Create composite unique constraints on (url, method).

- [x] 3.4 Create junction entities for many-to-many relationships
  - Create V1__Create_security_tables.sql migration script.
  - Define users, roles, resources tables with proper constraints.
  - Create user_roles and role_resources junction tables.
  - Add indexes for performance optimization.
  - Implement UserRole.java for user-role associations
  - Implement RoleResource.java for role-resource associations
  - Add composite keys and validation
  - _Requirements: 1.1, 1.3_

### Task 4: Security Repository Layer

- [x] 4.1 Create UserRepository with custom query methods
  - Extend JpaRepository<User, Long>
  - Add findByUsername method using JPQL.
  - Add findByUsername method with @Query annotation
  - Implement findByEnabledTrue for active users
  - Add existsByUsername for validation
  - Create findUsersWithRoles method using JOIN FETCH for performance.
  - _Requirements: 1.2, 2.2_

- [x] 4.2 Create RoleRepository with permission queries
  - Extend JpaRepository<Role, Long>
  - Add findByName method for role lookup
  - Implement findRolesWithResources method using JOIN FETCH.
  - Add caching annotations for frequently accessed roles.
  - Create custom query for role hierarchy
  - _Requirements: 1.2, 1.3_

- [x] 4.3 Create ResourceRepository with URL pattern matching
  - Extend JpaRepository<Resource, Long>
  - Add findByUrlAndMethod for permission checking
  - Implement findResourcesByRoleId method
  - Create pattern matching queries for URL authorization
  - _Requirements: 1.4, 1.5_

- [x] 4.4 Implement junction table repositories
  - Create UserRoleRepository for user-role management
  - Create RoleResourceRepository for role-resource management
  - Add bulk operations with @Modifying annotations
  - Implement transaction support with @Transactional
  - _Requirements: 1.3_

### Task 5: Security Service Layer Implementation

- [x] 5.1 Implement UserDetailsService for Spring Security
  - Create CustomUserDetailsService implementing UserDetailsService
  - Override loadUserByUsername method with database queries from UserRepository.
  - Map User entity to UserDetails with authorities
  - Handle user not found and disabled user scenarios
  - Cache user details in Redis for performance
  - _Requirements: 2.1, 2.2_

- [x] 5.2 Create AuthenticationService for login/logout
  - Implement authenticate method with password validation
  - Generate JWT tokens upon successful authentication
  - Handle authentication failures with custom exceptions
  - Implement logout functionality with token invalidation
  - Implement secure logout functionality by adding the JWT token to a blacklist in Redis until it expires.
  - _Requirements: 2.1, 2.2, 2.5_

- [x] 5.3 Implement UserService for user management
  - Create CRUD operations for user entities
  - Add password encoding and validation
  - Implement user role assignment methods
  - Create user search and pagination functionality
  - Add bulk user operations with transaction support
  - _Requirements: 1.2, 1.3_

- [x] 5.4 Create PermissionService for authorization
  - Implement hasPermission method for resource access
  - Create role-based permission checking
  - Add dynamic permission loading based on user roles
  - Implement permission caching with Redis
  - Create permission validation utilities
  - _Requirements: 1.4, 1.5_

### Task 6: JWT Token Management

- [x] 6.1 Implement JwtTokenProvider utility class
  - Create JWT token generation with user claims
  - Implement token validation and parsing
  - Add token expiration and refresh logic
  - Create token blacklist functionality with Redis
  - Handle token security with proper signing keys
  - _Requirements: 2.1, 2.2_

- [x] 6.2 Create JwtAuthenticationFilter for request processing
  - Extend OncePerRequestFilter for JWT processing
  - Extract and validate JWT tokens from requests
  - Set SecurityContext with authenticated user
  - Handle token expiration and invalid token scenarios
  - Implement proper error responses for authentication failures
  - _Requirements: 2.1, 2.5_

### Task 7: Security Configuration

- [x] 7.1 Implement SecurityConfig with filter chain
  - Create SecurityFilterChain bean with HTTP security
  - Configure JWT authentication filter in security chain
  - Set up CORS configuration for frontend integration
  - Disable CSRF for stateless JWT authentication
  - Configure session management as stateless
  - _Requirements: 2.1, 2.3_

- [x] 7.2 Configure method-level security
  - Enable @PreAuthorize and @PostAuthorize annotations
  - Create custom security expressions for permission checking
  - Implement role-based method security
  - Add audit logging for security events
  - _Requirements: 1.4, 1.5_

### Task 8: Security Controllers and DTOs

- [x] 8.1 Create AuthController for authentication endpoints
  - Implement POST /api/auth/login endpoint
  - Add POST /api/auth/logout endpoint
  - Create POST /api/auth/refresh-token endpoint
  - Implement proper request/response DTOs
  - Add comprehensive error handling and validation
  - Include OpenAPI/Swagger documentation
  - _Requirements: 2.1, 2.2_

- [x] 8.2 Implement UserController for user management
  - Create GET /api/users endpoint with pagination
  - Add POST /api/users for user creation
  - Implement PUT /api/users/{id} for user updates
  - Create DELETE /api/users/{id} with validation
  - Add GET /api/users/{id}/roles for role management
  - Include @PreAuthorize annotations for security
  - _Requirements: 1.2, 1.3_

- [x] 8.3 Create security-related DTOs
  - Implement LoginRequest with validation annotations
  - Create LoginResponse with token and user info
  - Add UserDto for user data transfer
  - Create RoleDto and ResourceDto classes
  - Implement proper validation and error messages
  - _Requirements: 2.1, 1.2_

## Department Management Module

### Task 9: Department Entity and Repository

- [x] 9.1 Implement Department entity with hierarchical structure
  - Create Department.java with @Entity annotation for PostgreSQL.
  - Define fields: id, name, depPath, parentId, isParent
  - Implement self-referencing relationship for hierarchy
  - Add validation for department name and path
  - Create audit fields for tracking changes
  - _Requirements: 3.1, 3.4, 3.5_

- [x] 9.2 Create DepartmentRepository with tree queries
  - Extend JpaRepository<Department, Long>
  - Add findByParentId method for child departments
  - Implement findRootDepartments for top-level departments
  - Create recursive query methods for department tree
  - Add findByDepPathStartingWith for path-based queries
  - _Requirements: 3.1, 3.3_

- [x] 9.3 Create Flyway migration for departments table
  - Create a new migration script, e.g., V2__Create_departments_table.sql.
  - Define the departments table schema including hierarchical fields (parent_id, dep_path, is_parent, level) and manager_id.
  - Add a self-referencing foreign key on parent_id to the departments(id) to enforce the hierarchy.
  - Create a unique constraint on the department code column to prevent duplicate codes.
  - Add indexes on parent_id and dep_path to optimize hierarchical queries, and on manager_id for quick lookups.
  - _Requirements: 3.1, 10.4_


### Task 10: Department Service Implementation

- [x] 10.1 Implement DepartmentService with tree operations
  - Create getDepartmentTree method with recursive loading
  - Implement createDepartment with path generation
  - Add updateDepartment with hierarchy validation
  - Create deleteDepartment with dependency checking
  - Implement department move operations
  - _Requirements: 3.1, 3.2, 3.4, 3.5_

- [x] 10.2 Add department validation and business logic
  - Validate department hierarchy constraints
  - Prevent circular references in department tree
  - Check for existing employees before deletion
  - Implement department path recalculation
  - Add department statistics and reporting
  - _Requirements: 3.4, 3.5_

### Task 11: Department Controller and DTOs

- [x] 11.1 Create DepartmentController with REST endpoints
  - Implement GET /api/departments/tree for hierarchy
  - Add POST /api/departments for creation
  - Create PUT /api/departments/{id} for updates
  - Implement DELETE /api/departments/{id} with validation
  - Add GET /api/departments/{id}/employees endpoint
  - Include proper security annotations
  - _Requirements: 3.1, 3.2_

- [x] 11.2 Implement department DTOs and validation
  - Create DepartmentDto for data transfer
  - Add DepartmentTreeDto for hierarchical display
  - Implement DepartmentCreateRequest with validation
  - Create DepartmentUpdateRequest class
  - Add custom validation for department hierarchy
  - _Requirements: 3.1, 3.2_## Employee Management Module

### Task 12: Employee Entity and Status Management

- [x] 12.1 Implement Employee entity with comprehensive fields
  - Create Employee.java with @Entity annotation for PostgreSQL.
  - Define fields: id, employeeNumber, name, email, phone
  - Add department and position relationships
  - Include hireDate, status, and audit fields
  - Implement validation annotations for all fields
  - _Requirements: 5.1, 5.7_

- [x] 12.2 Create EmployeeStatus enum and validation
  - Define status values: ACTIVE, INACTIVE, TERMINATED
  - Add status transition validation logic
  - Implement status-based business rules
  - Create status history tracking
  - _Requirements: 5.1_

- [x] 12.3 Create Flyway migration for employees table
  - Create a new migration script, e.g., V4__Create_employees_table.sql.
  - Define the employees table schema with all comprehensive fields, including encrypted columns for sensitive data (e.g., bank_account_encrypted).
  - Add foreign key constraints for department_id, position_id, and a self-referencing key for manager_id.
  - Create unique constraints on employee_number and email to ensure data integrity.
  - Add indexes on frequently queried fields like last_name, status, department_id, and position_id to boost search performance.
  - _Requirements: 5.1, 10.4_

### Task 13: Employee Repository with Search Capabilities

- [x] 13.1 Create EmployeeRepository with advanced queries
  - Extend JpaRepository<Employee, Long>
  - Add findByDepartmentId for department filtering
  - Implement findByStatus for status-based queries
  - Create findByEmployeeNumberContaining for search
  - Add pagination support with Pageable parameters
  - _Requirements: 5.1, 5.2, 5.4_

- [x] 13.2 Implement dynamic search with Specification API
  - Create EmployeeSearchCriteria class
  - Implement dynamic query building
  - Add support for multiple search criteria
  - Create sorting and filtering capabilities
  - Implement full-text search functionality
  - _Requirements: 5.4_

### Task 14: Employee Service Layer

- [x] 14.1 Implement core EmployeeService operations
  - Create CRUD operations for employee management
  - Add employee number generation and validation
  - Implement employee search with pagination
  - Create batch operations for multiple employees
  - Add employee status management methods
  - _Requirements: 5.1, 5.2, 5.3_

- [x] 14.2 Create EmployeeImportService for Excel processing
  - Implement Excel file parsing with Apache POI
  - Add data validation for imported employees
  - Create error reporting for invalid data
  - Implement batch import with transaction support
  - Add duplicate detection and handling
  - _Requirements: 5.5, 5.7_

- [x] 14.3 Implement EmployeeExportService for data export
  - Create Excel export functionality
  - Add customizable export templates
  - Implement filtered export based on criteria
  - Create export scheduling and background processing
  - Add export history and tracking
  - _Requirements: 5.6_

### Task 15: Employee Controller and API Endpoints

- [x] 15.1 Create EmployeeController with comprehensive REST API
  - Implement GET /api/employees with pagination and search
  - Add POST /api/employees for employee creation
  - Create PUT /api/employees/{id} for updates
  - Implement DELETE /api/employees/{id} with validation
  - Add batch operations endpoints
  - Include proper security and validation
  - _Requirements: 5.1, 5.2, 5.3_

- [x] 15.2 Add import/export endpoints
  - Create POST /api/employees/import for Excel upload
  - Implement GET /api/employees/export for data export
  - Add GET /api/employees/import/template for template download
  - Create import status tracking endpoints
  - Add export job management
  - _Requirements: 5.5, 5.6, 5.7_## Position Management Module

### Task 16: Position Entity and Repository

- [x] 16.1 Implement Position entity with job classifications
  - Create Position.java with @Entity annotation for PostgreSQL.
  - Define fields: id, jobTitle, professionalTitle, description
  - Add department relationship and validation
  - Implement position hierarchy if needed
  - Create audit fields and validation rules
  - _Requirements: 4.1, 4.4_

- [x] 16.2 Create PositionRepository with search capabilities
  - Extend JpaRepository<Position, Long> to leverage JPA-specific features.
  - Add findByDepartmentId for department filtering
  - Implement findByJobTitleContaining for search
  - Create position availability queries
  - Add sorting and pagination support
  - _Requirements: 4.1, 4.2, 4.3_

- [x] 16.3 Create Flyway migration for positions table
  - Create a new migration script, e.g., V3__Create_positions_table.sql.
  - Define the positions table schema with all required columns (job_title, code, department_id, min_salary, max_salary, etc.).
  - Add a foreign key constraint linking department_id to the departments table.
  - Create indexes on frequently queried columns like department_id, job_title, and category for performance.
  - Add a unique constraint on the position code column to ensure data integrity.
  - _Requirements: 4.1, 10.4_

### Task 17: Position Service and Controller

- [x] 17.1 Implement PositionService with business logic
  - Create CRUD operations for position management
  - Add position validation and dependency checking
  - Implement position search and filtering
  - Create position assignment tracking
  - Add position statistics and reporting
  - _Requirements: 4.1, 4.2, 4.4, 4.5_

- [x] 17.2 Create PositionController with REST endpoints
  - Implement GET /api/positions with filtering
  - Add POST /api/positions for creation
  - Create PUT /api/positions/{id} for updates
  - Implement DELETE /api/positions/{id} with validation
  - Add position assignment endpoints
  - Include proper security annotations
  - _Requirements: 4.1, 4.2, 4.3_

## Communication System Module

### Task 18: Email Management Implementation

- [x] 18.1 Create email entities and templates
  - Implement EmailTemplate.java with template management
  - Create EmailLog.java for tracking sent emails
  - Add template variable support with Freemarker
  - Implement template versioning and validation
  - Create email template repository
  - _Requirements: 6.1, 6.4_

- [x] 18.2 Implement EmailService with async processing
  - Create sendTemplatedEmail method with @Async
  - Add sendBulkEmails for mass communication
  - Implement email queue management
  - Create email retry logic for failures
  - Add email tracking and status updates
  - _Requirements: 6.1, 6.2, 6.3, 6.5_

- [x] 18.3 Create EmailController and template management
  - Implement POST /api/emails/send for single emails
  - Add POST /api/emails/bulk for mass emails
  - Create GET /api/email-templates for template management
  - Implement email preview functionality
  - Add email history and tracking endpoints
  - _Requirements: 6.1, 6.4_

### Task 19: Chat System Implementation

- [x] 19.1 Implement chat entities for PostgreSQL storage
  - Create `ChatMessage.java` with @Entity annotation for persistent message storage
  - Implement ChatRoom.java for conversation management
  - Add ChatParticipant.java for user participation
  - Create message threading and reply support
  - Implement message status tracking
  - Create enum classes (ChatRoomType, ChatParticipantRole, ChatMessageType)
  - _Requirements: 8.1, 8.6_

- [x] 19.2 Create ChatService with real-time features
  - Implement message sending and receiving
  - Add chat room management functionality
  - Create message history with pagination
  - Implement message search and filtering
  - Add typing indicators and presence
  - Create repository interfaces and DTOs
  - Create ChatController with REST endpoints
  - _Requirements: 8.1, 8.6_

- [x] 19.3 Implement WebSocket configuration for real-time chat
  - Create WebSocketConfig with message broker
  - Add ChatWebSocketHandler for connection management
  - Implement message routing and broadcasting
  - Create user session management
  - Add connection authentication and authorization
  - Create database migration V6__Create_chat_tables.sql
  - _Requirements: 8.1, 8.6_
  
### Task 20: Notification System Implementation

- [x] 20.1 Create notification entities for persistent storage in PostgreSQL
  - Implement Notification.java entity (single-table model as per database-design.md)
  - Create Announcement.java entity for announcements
  - Add notification types and priority levels (enums)
  - Implement notification templates and formatting
  - Create notification history and archiving
  - Create repository interfaces (NotificationRepository, AnnouncementRepository)
  - _Requirements: 8.2, 8.3, 8.5_

- [x] 20.2 Implement NotificationService with m nrid delivery mechanism
  - Create createNotification method for system notifications
  - Add getUserNotifications with pagination
  - Implement markAsRead functionality
  - Create notification broadcasting with WebSocket
  - Add notification preferences and filtering
  - Implement async notification sending with real-time delivery
  - Create bulk notification functionality
  - _Requirements: 8.2, 8.4, 8.5_

  **Implementation Notes:**
  - Notifications are saved to PostgreSQL `notifications` table for persistence
  - Real-time delivery via WebSocket using SimpMessagingTemplate
  - Redis caching for unread counts and performance optimization
  - Comprehensive notification management with cleanup and archiving

- [x] 20.3 Create NotificationController and WebSocket handlers
  - Implement GET /api/notifications for user notifications
  - Add PUT /api/notifications/{id}/read for marking read
  - Create NotificationWebSocketHandler for real-time updates
  - Implement notification subscription management
  - Add notification statistics and reporting
  - Create database migration V7__Create_notification_tables.sql
  - Include proper security

## Payroll Management Module

### Task 21: Payroll Entities and Calculations

- [x] 21.1 Implement payroll entities with financial data
  - Create PayrollLedger.java with salary components
  - Implement PayrollPeriod.java for pay period management
  - Add SalaryComponent.java for detailed breakdowns
  - Create PayrollAudit.java for change tracking
  - Implement financial validation and constraints
  - _Requirements: 7.1, 7.4, 7.5_

- [x] 21.2 Create PayrollCalculationService for salary processing
  - Implement salary calculation algorithms
  - Add tax and deduction calculations
  - Create overtime and bonus processing
  - Implement payroll validation rules
  - Add calculation audit trails
  - _Requirements: 7.4, 7.5_

### Task 22: Payroll Service and Management

- [x] 22.1 Implement PayrollService with ledger management
  - Create payroll ledger CRUD operations
  - Add payroll period management
  - Implement employee payroll history
  - Create payroll approval workflows
  - Add payroll reporting and analytics
  - _Requirements: 7.1, 7.2, 7.3_

- [x] 22.2 Create PayrollController with financial endpoints
  - Implement GET /api/payroll/ledgers with filtering
  - Add POST /api/payroll/calculate for salary calculations
  - Create payroll report generation endpoints
  - Implement payroll approval and processing
  - Add payroll audit and history endpoints
  - Include proper financial security measures
  - _Requirements: 7.1, 7.2, 7.3_

## Common Infrastructure and Utilities

### Task 22: Global Exception Handling

- [x] 22.1 Create custom exception classes
  - Implement BusinessException for business logic errors
  - Create ValidationException for data validation
  - Add feature-specific exceptions (EmployeeNotFoundException, etc.)
  - Implement exception hierarchy and error codes
  - Create exception message internationalization
  - _Requirements: 2.3, 2.5_

- [x] 22.2 Implement GlobalExceptionHandler
  - Create @ControllerAdvice for centralized exception handling
  - Add @ExceptionHandler methods for different exception types
  - Implement proper HTTP status code mapping
  - Create standardized error response format
  - Add exception logging and monitoring
  - _Requirements: 2.3, 2.4_
  
### Task 23: Common DTOs and Utilities

- [x] 23.1 Create common response DTOs
  - Implement ApiResponse<T> for standardized responses
  - Create ErrorResponse for error information
  - Add PageResponse<T> for paginated data
  - Implement validation error response formatting
  - Create success response templates
  - _Requirements: 2.4, 5.2_

- [x] 23.2 Implement utility classes
  - Create DateUtil for date operations
  - Add StringUtil for string processing
  - Implement ValidationUtil for custom validations
  - Create FileUtil for file operations
  - Add CacheUtil for Redis operations
  - _Requirements: 5.5, 5.6, 6.4_

### Task 24: Configuration and Infrastructure

- [x] 24.1 Implement Redis configuration
  - Create RedisConfig with connection settings
  - Add Redis template configuration
  - Implement caching configuration with @Cacheable
  - Create Redis key naming strategies
  - Add Redis health checks and monitoring
  - _Requirements: 1.1, 2.2_

- [x] 24.2 Configure async processing
  - Create AsyncConfig with thread pool settings
  - Implement @EnableAsync configuration
  - Add AsyncUncaughtExceptionHandler
  - Create async method monitoring
  - Configure async security context propagation
  - _Requirements: 6.3, 8.1_

- [x] 24.3 Set up WebSocket configuration
  - Create WebSocketConfig with STOMP support
  - Configure message broker settings
  - Add WebSocket security configuration
  - Implement connection interceptors
  - Create WebSocket monitoring and logging
  - _Requirements: 8.1, 8.6_

- [x] 24.4 Configure CORS and security headers
  - Create CorsConfig for frontend integration
  - Add security headers configuration
  - Implement CSRF protection where needed
  - Configure content security policy
  - Add request/response logging
  - _Requirements: 2.1, 2.3_

## Testing Implementation

### Task 25: Unit Testing Setup

- [ ] 25.1 Create test configuration and utilities
  - Set up test application properties
  - Create test data builders and factories
  - Implement test utilities for Redis operations
  - Add mock configuration for external services
  - Create test security configuration
  - _Requirements: 10.1, 10.2_

- [ ] 25.2 Implement repository layer tests
  - Create @DataRedisTest classes for repositories
  - Add test cases for custom query methods
  - Implement pagination and sorting tests
  - Create transaction rollback tests
  - Add performance tests for complex queries
  - _Requirements: 10.1_

### Task 26: Service Layer Testing

- [ ] 26.1 Create service unit tests with Mockito
  - Implement @ExtendWith(MockitoExtension.class) setup
  - Add @Mock and @InjectMocks configurations
  - Create test cases for business logic validation
  - Implement exception handling tests
  - Add async method testing
  - _Requirements: 10.1_

- [ ] 26.2 Create integration tests for services
  - Implement @SpringBootTest configurations
  - Add database integration tests
  - Create email service integration tests
  - Implement WebSocket integration tests
  - Add security integration tests
  - _Requirements: 10.1_#
## Task 27: Controller and API Testing

- [ ] 27.1 Implement controller unit tests
  - Create @WebMvcTest configurations for controllers
  - Add MockMvc setup for HTTP testing
  - Implement request/response validation tests
  - Create security annotation tests with @WithMockUser
  - Add JSON serialization/deserialization tests
  - _Requirements: 10.1_

- [ ] 27.2 Create API integration tests
  - Implement full @SpringBootTest with web environment
  - Add TestRestTemplate for API testing
  - Create end-to-end workflow tests
  - Implement authentication flow tests
  - Add file upload/download tests
  - _Requirements: 10.1_

### Task 28: Performance and Load Testing

- [ ] 28.1 Create performance test suite
  - Implement JMeter test plans for API endpoints
  - Add database performance tests
  - Create concurrent user simulation tests
  - Implement memory usage and leak tests
  - Add Redis cache performance tests
  - _Requirements: 10.1_

- [ ] 28.2 Set up monitoring and metrics
  - Configure Spring Boot Actuator endpoints
  - Add custom metrics for business operations
  - Implement health checks for dependencies
  - Create performance monitoring dashboards
  - Add alerting for performance degradation
  - _Requirements: 10.2_

## Documentation and Deployment

### Task 29: API Documentation

- [ ] 29.1 Implement OpenAPI/Swagger documentation
  - Add Springdoc OpenAPI dependency
  - Create API documentation annotations
  - Implement request/response schema documentation
  - Add authentication documentation
  - Create API usage examples
  - _Requirements: 10.1, 10.2_

- [ ] 29.2 Create developer documentation
  - Write setup and installation guides
  - Create API integration examples
  - Document configuration options
  - Add troubleshooting guides
  - Create architecture documentation
  - _Requirements: 10.1, 10.2, 10.3, 10.4_

### Task 30: Production Deployment Preparation

- [ ] 30.1 Configure production settings
  - Create production application properties
  - Add environment-specific configurations
  - Implement security hardening measures
  - Configure logging for production
  - Add monitoring and alerting setup
  - _Requirements: 2.1, 10.2_

- [ ] 30.2 Create deployment artifacts
  - Build WAR file for deployment
  - Create Docker containerization (optional)
  - Add database migration scripts
  - Create deployment documentation
  - Implement rollback procedures
  - _Requirements: 10.2, 10.5_

## Final Integration and Testing

### Task 31: System Integration Testing

- [ ] 31.1 End-to-end system testing
  - Test complete user workflows
  - Validate security across all modules
  - Test real-time features (chat, notifications)
  - Verify email functionality
  - Test file import/export operations
  - _Requirements: All requirements_

- [ ] 31.2 Performance optimization and tuning
  - Optimize database queries and indexing
  - Tune Redis cache configurations
  - Optimize async processing performance
  - Implement connection pooling tuning
  - Add performance monitoring and alerting
  - _Requirements: 10.2_

### Task 32: Final Documentation and Handover

- [ ] 32.1 Complete system documentation
  - Finalize API documentation
  - Create user guides and tutorials
  - Document deployment procedures
  - Add maintenance and troubleshooting guides
  - Create system architecture documentation
  - _Requirements: 10.1, 10.2, 10.3, 10.4, 10.5_

- [ ] 32.2 Prepare for production deployment
  - Conduct final security review
  - Perform load testing validation
  - Create monitoring and alerting setup
  - Prepare rollback and recovery procedures
  - Document post-deployment verification steps
  - _Requirements: 10.2, 10.5_

## Implementation Notes

### Development Best Practices
- Follow test-driven development (TDD) approach where applicable
- Implement proper logging at all levels (DEBUG, INFO, WARN, ERROR)
- Use transactions appropriately for data consistency
- Implement proper validation at all input points
- Follow Spring Boot conventions and best practices
- Maintain clean code principles and documentation

### Security Considerations
- Validate all inputs and sanitize outputs
- Implement proper authentication and authorization
- Use HTTPS for all communications
- Implement rate limiting for API endpoints
- Log security events for audit purposes
- Regular security testing and vulnerability assessment

### Performance Guidelines
- Implement caching strategies for frequently accessed data
- Use pagination for large datasets
- Optimize database queries and use appropriate indexes
- Implement async processing for long-running operations
- Monitor and optimize memory usage
- Use connection pooling for database connections

This implementation plan provides a comprehensive roadmap for building the Spring Boot Employee Management System backend. Each task builds upon previous implementations and includes specific requirements references to ensure all functionality is properly implemented.
## Phase 
2: Security and Authentication Module

### Task 3: Core Security Entities and Database Schema

- [ ] 3.1 Implement User entity with JPA annotations
  - Create User.java with @Entity annotation
  - Define fields: id, username, password, enabled, roles
  - Add validation annotations (@NotNull, @Size, @Email)
  - Implement audit fields with @CreatedDate, @LastModifiedDate
  - Add password encoding support with BCrypt
  - Create proper JPA relationships with Role entities
  - _Requirements: 1.1, 2.1, 2.2_

- [ ] 3.2 Implement Role entity with resource relationships
  - Create Role.java with @Entity annotation
  - Define fields: id, name, description, resources
  - Implement many-to-many relationship with Resource entities
  - Add validation for role name uniqueness
  - Create proper database constraints and indexes
  - _Requirements: 1.1, 1.2_

- [ ] 3.3 Implement Resource entity for permission management
  - Create Resource.java with @Entity annotation
  - Define fields: id, name, url, method, description
  - Add validation for URL patterns and HTTP methods
  - Implement resource hierarchy support
  - Create composite unique constraints on (url, method)
  - _Requirements: 1.1, 1.4_

- [ ] 3.4 Create Flyway migration scripts for security tables
  - Create V1__Create_security_tables.sql migration script
  - Define users, roles, resources tables with proper constraints
  - Create user_roles and role_resources junction tables
  - Add indexes for performance optimization
  - Include default data insertion for system roles and resources
  - _Requirements: 1.1, 1.3, 10.4_

### Task 4: Security Repository Layer

- [ ] 4.1 Create UserRepository with custom query methods
  - Extend JpaRepository<User, Long>
  - Add findByUsername method with @Query annotation
  - Implement findByEnabledTrue for active users
  - Add existsByUsername for validation
  - Create findUsersWithRoles method using JOIN FETCH
  - _Requirements: 1.2, 2.2_

- [ ] 4.2 Create RoleRepository with permission queries
  - Extend JpaRepository<Role, Long>
  - Add findByName method for role lookup
  - Implement findRolesWithResources method
  - Create custom query for role hierarchy
  - Add caching annotations for frequently accessed roles
  - _Requirements: 1.2, 1.3_

- [ ] 4.3 Create ResourceRepository with URL pattern matching
  - Extend JpaRepository<Resource, Long>
  - Add findByUrlAndMethod for permission checking
  - Implement findResourcesByRoleId method
  - Create pattern matching queries for URL authorization
  - Add caching for resource permissions
  - _Requirements: 1.4, 1.5_

### Task 5: Security Service Layer Implementation

- [ ] 5.1 Implement UserDetailsService for Spring Security
  - Create CustomUserDetailsService implementing UserDetailsService
  - Override loadUserByUsername method with database queries
  - Map User entity to UserDetails with authorities
  - Handle user not found and disabled user scenarios
  - Cache user details in Redis for performance
  - _Requirements: 2.1, 2.2_

- [ ] 5.2 Create AuthenticationService for login/logout
  - Implement authenticate method with password validation
  - Generate JWT tokens upon successful authentication
  - Handle authentication failures with custom exceptions
  - Implement logout functionality with token invalidation
  - Add session management with Redis storage
  - _Requirements: 2.1, 2.2, 2.5_

- [ ] 5.3 Implement UserService for user management
  - Create CRUD operations for user entities
  - Add password encoding and validation
  - Implement user role assignment methods
  - Create user search and pagination functionality
  - Add bulk user operations with transaction support
  - _Requirements: 1.2, 1.3_

- [ ] 5.4 Create PermissionService for authorization
  - Implement hasPermission method for resource access
  - Create role-based permission checking
  - Add dynamic permission loading based on user roles
  - Implement permission caching with Redis
  - Create permission validation utilities
  - _Requirements: 1.4, 1.5_

### Task 6: JWT Token Management and Encryption

- [ ] 6.1 Implement JwtTokenProvider utility class
  - Create JWT token generation with user claims
  - Implement token validation and parsing
  - Add token expiration and refresh logic
  - Create token blacklist functionality with Redis
  - Handle token security with proper signing keys
  - _Requirements: 2.1, 2.2_

- [ ] 6.2 Create JwtAuthenticationFilter for request processing
  - Extend OncePerRequestFilter for JWT processing
  - Extract and validate JWT tokens from requests
  - Set SecurityContext with authenticated user
  - Handle token expiration and invalid token scenarios
  - Implement proper error responses for authentication failures
  - _Requirements: 2.1, 2.5_

- [ ] 6.3 Implement field-level encryption for sensitive data
  - Create AESUtil class for encryption/decryption operations
  - Implement EncryptedStringConverter for JPA attribute conversion
  - Add encryption configuration with secure key management
  - Apply encryption to sensitive fields (dateOfBirth, bankAccount, taxId)
  - Create encryption service for manual encrypt/decrypt operations
  - _Requirements: 2.3, 10.3_

### Task 7: Security Configuration and Audit

- [ ] 7.1 Implement SecurityConfig with filter chain
  - Create SecurityFilterChain bean with HTTP security
  - Configure JWT authentication filter in security chain
  - Set up CORS configuration for frontend integration
  - Disable CSRF for stateless JWT authentication
  - Configure session management as stateless
  - _Requirements: 2.1, 2.3_

- [ ] 7.2 Configure method-level security and audit
  - Enable @PreAuthorize and @PostAuthorize annotations
  - Create custom security expressions for permission checking
  - Implement role-based method security
  - Add audit logging for security events
  - Create AuditorAware implementation for automatic audit field population
  - _Requirements: 1.4, 1.5, 2.6_

### Task 8: Security Controllers and DTOs

- [ ] 8.1 Create AuthController for authentication endpoints
  - Implement POST /api/auth/login endpoint
  - Add POST /api/auth/logout endpoint
  - Create POST /api/auth/refresh-token endpoint
  - Implement proper request/response DTOs
  - Add comprehensive error handling and validation
  - Include OpenAPI/Swagger documentation
  - _Requirements: 2.1, 2.2_

- [ ] 8.2 Implement UserController for user management
  - Create GET /api/users endpoint with pagination
  - Add POST /api/users for user creation
  - Implement PUT /api/users/{id} for user updates
  - Create DELETE /api/users/{id} with validation
  - Add GET /api/users/{id}/roles for role management
  - Include @PreAuthorize annotations for security
  - _Requirements: 1.2, 1.3_

- [ ] 8.3 Create security-related DTOs
  - Implement LoginRequest with validation annotations
  - Create LoginResponse with token and user info
  - Add UserDto for user data transfer
  - Create RoleDto and ResourceDto classes
  - Implement proper validation and error messages
  - _Requirements: 2.1, 1.2_## Phase 3:
 Department Management Module

### Task 9: Department Entity and Repository

- [x] 9.1 Implement Department entity with hierarchical structure
  - Create Department.java with @Entity annotation
  - Define fields: id, name, code, depPath, parentId, isParent, location, managerId
  - Implement self-referencing relationship for hierarchy
  - Add validation for department name and path
  - Create audit fields for tracking changes
  - Add proper indexes for hierarchical queries
  - _Requirements: 3.1, 3.4, 3.5, 3.6_

- [x] 9.2 Create DepartmentRepository with tree queries
  - Extend JpaRepository<Department, Long>
  - Add findByParentId method for child departments
  - Implement findRootDepartments for top-level departments
  - Create recursive query methods for department tree using PostgreSQL CTEs
  - Add findByDepPathStartingWith for path-based queries
  - Implement caching for department tree structure
  - _Requirements: 3.1, 3.3, 3.4_

- [x] 9.3 Create Flyway migration for departments table
  - Create V2__Create_departments_table.sql migration script
  - Define departments table with hierarchical constraints
  - Add foreign key constraints for parent-child relationships
  - Create indexes for efficient tree queries
  - Add check constraints for data integrity
  - _Requirements: 3.1, 10.4_

### Task 10: Department Service Implementation

- [x] 10.1 Implement DepartmentService with tree operations
  - Create getDepartmentTree method with recursive loading
  - Implement createDepartment with path generation
  - Add updateDepartment with hierarchy validation
  - Create deleteDepartment with dependency checking
  - Implement department move operations with path recalculation
  - Add caching for frequently accessed department data
  - _Requirements: 3.1, 3.2, 3.4, 3.5, 3.6, 3.7_

- [x] 10.2 Add department validation and business logic
  - Validate department hierarchy constraints
  - Prevent circular references in department tree
  - Check for existing employees before deletion
  - Implement department path recalculation
  - Add department statistics and reporting
  - Validate manager assignment (must be an employee)
  - _Requirements: 3.4, 3.5, 3.6, 3.7_

### Task 11: Department Controller and DTOs

- [x] 11.1 Create DepartmentController with REST endpoints
  - Implement GET /api/departments/tree for hierarchy
  - Add POST /api/departments for creation
  - Create PUT /api/departments/{id} for updates
  - Implement DELETE /api/departments/{id} with validation
  - Add GET /api/departments/{id}/employees endpoint
  - Include proper security annotations and permission checks
  - _Requirements: 3.1, 3.2, 3.6_

- [x] 11.2 Implement department DTOs and validation
  - Create DepartmentDto for data transfer
  - Add DepartmentTreeDto for hierarchical display
  - Implement DepartmentCreateRequest with validation
  - Create DepartmentUpdateRequest class
  - Add custom validation for department hierarchy
  - Include manager assignment validation
  - _Requirements: 3.1, 3.2, 3.6_## Phase 4
: Position Management Module

### Task 12: Position Entity and Repository

- [ ] 12.1 Implement Position entity with comprehensive fields
  - Create Position.java with @Entity annotation
  - Define fields: id, jobTitle, professionalTitle, code, category, salaryGrade
  - Add detailed fields: requirements, responsibilities, benefits, workLocation
  - Include salary range fields (minSalary, maxSalary)
  - Add employment type and managerial status fields
  - Create proper relationships with Department entity
  - _Requirements: 4.1, 4.4_

- [ ] 12.2 Create PositionRepository with search capabilities
  - Extend JpaRepository<Position, Long>
  - Add findByDepartmentId for department filtering
  - Implement findByJobTitleContaining for search
  - Create position availability queries
  - Add sorting and pagination support
  - Implement caching for frequently accessed positions
  - _Requirements: 4.1, 4.2, 4.3_

- [ ] 12.3 Create Flyway migration for positions table
  - Create V3__Create_positions_table.sql migration script
  - Define positions table with all required fields
  - Add foreign key constraints to departments
  - Create indexes for search and filtering
  - Add unique constraints on position codes
  - _Requirements: 4.1, 10.4_

### Task 13: Position Service and Controller

- [ ] 13.1 Implement PositionService with business logic
  - Create CRUD operations for position management
  - Add position validation and dependency checking
  - Implement position search and filtering
  - Create position assignment tracking
  - Add position statistics and reporting
  - Validate salary ranges and employment types
  - _Requirements: 4.1, 4.2, 4.4, 4.5_

- [ ] 13.2 Create PositionController with REST endpoints
  - Implement GET /api/positions with filtering
  - Add POST /api/positions for creation
  - Create PUT /api/positions/{id} for updates
  - Implement DELETE /api/positions/{id} with validation
  - Add position assignment endpoints
  - Include proper security annotations
  - _Requirements: 4.1, 4.2, 4.3_

## Phase 5: Employee Management Module

### Task 14: Employee Entity and Status Management

- [ ] 14.1 Implement Employee entity with comprehensive fields
  - Create Employee.java with @Entity annotation
  - Define core fields: id, employeeNumber, firstName, lastName, email
  - Add contact fields: phone, mobilePhone, address details (city, state, zipCode)
  - Include personal fields: dateOfBirth, gender, nationality, maritalStatus
  - Add employment fields: departmentId, positionId, managerId, hireDate, status
  - Include payroll fields: salary, salaryGrade, bankAccount, taxId (encrypted)
  - Add skills, education, certifications, and notes fields
  - Create emergency contact fields
  - _Requirements: 5.1, 5.7, 10.3_

- [ ] 14.2 Create EmployeeStatus enum and validation
  - Define status values: ACTIVE, INACTIVE, TERMINATED, ON_LEAVE, SUSPENDED
  - Add status transition validation logic
  - Implement status-based business rules
  - Create status history tracking
  - Add proper enum mapping for database storage
  - _Requirements: 5.1_

- [ ] 14.3 Create Flyway migration for employees table
  - Create V4__Create_employees_table.sql migration script
  - Define employees table with all comprehensive fields
  - Add foreign key constraints to departments, positions, and self-reference for manager
  - Create indexes for search, filtering, and relationships
  - Add unique constraints on employee number and email
  - _Requirements: 5.1, 10.4_

### Task 15: Employee Repository with Advanced Search

- [ ] 15.1 Create EmployeeRepository with advanced queries
  - Extend JpaRepository<Employee, Long>
  - Add findByDepartmentId for department filtering
  - Implement findByStatus for status-based queries
  - Create findByEmployeeNumberContaining for search
  - Add pagination support with Pageable parameters
  - Implement permission-based filtering queries
  - _Requirements: 5.1, 5.2, 5.4, 10.8_

- [ ] 15.2 Implement dynamic search with Specification API
  - Create EmployeeSearchCriteria class with all search fields
  - Implement EmployeeSpecification for dynamic query building
  - Add support for multiple search criteria combination
  - Create sorting and filtering capabilities
  - Implement full-text search functionality
  - Add date range searches for hire dates
  - _Requirements: 5.4_

### Task 16: Employee Service Layer

- [ ] 16.1 Implement core EmployeeService operations
  - Create CRUD operations for employee management
  - Add employee number generation and validation
  - Implement employee search with pagination and criteria
  - Create batch operations for multiple employees
  - Add employee status management methods
  - Implement permission-based data filtering
  - _Requirements: 5.1, 5.2, 5.3, 10.8_

- [ ] 16.2 Create EmployeeImportService for Excel processing
  - Implement Excel file parsing with Apache POI
  - Add data validation for imported employees
  - Create error reporting for invalid data
  - Implement batch import with transaction support
  - Add duplicate detection and handling
  - Create import progress tracking
  - _Requirements: 5.5, 5.7_

- [ ] 16.3 Implement EmployeeExportService for data export
  - Create Excel export functionality
  - Add customizable export templates
  - Implement filtered export based on criteria
  - Create export scheduling and background processing
  - Add export history and tracking
  - Implement permission-based export filtering
  - _Requirements: 5.6, 10.8_

### Task 17: Employee Controller and API Endpoints

- [ ] 17.1 Create EmployeeController with comprehensive REST API
  - Implement GET /api/employees with pagination and search
  - Add POST /api/employees for employee creation
  - Create PUT /api/employees/{id} for updates
  - Implement DELETE /api/employees/{id} with validation
  - Add batch operations endpoints
  - Include proper security and validation
  - _Requirements: 5.1, 5.2, 5.3_

- [ ] 17.2 Add import/export endpoints
  - Create POST /api/employees/import for Excel upload
  - Implement GET /api/employees/export for data export
  - Add GET /api/employees/import/template for template download
  - Create import status tracking endpoints
  - Add export job management
  - Include permission-based access control
  - _Requirements: 5.5, 5.6, 5.7, 10.8_## Phase 6:
 Communication System Module

### Task 18: Email Management Implementation

- [ ] 18.1 Create email entities and templates
  - Implement EmailTemplate.java with unified content field and templateType enum
  - Create EmailLog.java with templateCode reference and multiple recipient fields
  - Add template variable support with Freemarker
  - Implement template versioning and validation
  - Create proper JPA relationships and constraints
  - _Requirements: 6.1, 6.4_

- [ ] 18.2 Create Flyway migration for email tables
  - Create V5__Create_email_tables.sql migration script
  - Define email_templates and email_logs tables
  - Add indexes for efficient querying
  - Create constraints for data integrity
  - Add default email templates
  - _Requirements: 6.1, 10.4_

- [ ] 18.3 Implement EmailService with async processing
  - Create sendTemplatedEmail method with @Async
  - Add sendBulkEmails for mass communication
  - Implement email queue management
  - Create email retry logic for failures
  - Add email tracking and status updates
  - Implement template processing with Freemarker
  - _Requirements: 6.1, 6.2, 6.3, 6.5_

- [ ] 18.4 Create EmailController and template management
  - Implement POST /api/emails/send for single emails
  - Add POST /api/emails/bulk for mass emails
  - Create GET /api/email-templates for template management
  - Implement email preview functionality
  - Add email history and tracking endpoints
  - Include proper security and permission checks
  - _Requirements: 6.1, 6.4_

### Task 19: Chat System Implementation

- [ ] 19.1 Implement chat entities for Redis storage
  - Create ChatMessage.java with consistent field naming (createdAt, isDeleted)
  - Implement ChatRoom.java for conversation management
  - Add ChatParticipant.java for user participation
  - Create message threading and reply support
  - Implement message status tracking and read receipts
  - Add attachment support with metadata
  - _Requirements: 8.1, 8.6_

- [ ] 19.2 Create ChatService with real-time features
  - Implement message sending and receiving
  - Add chat room management functionality
  - Create message history with pagination
  - Implement message search and filtering
  - Add typing indicators and presence
  - Create message archiving for historical data
  - _Requirements: 8.1, 8.6_

- [ ] 19.3 Implement WebSocket configuration for real-time chat
  - Create WebSocketConfig with message broker
  - Add ChatWebSocketHandler for connection management
  - Implement message routing and broadcasting
  - Create user session management
  - Add connection authentication and authorization
  - Implement connection recovery and reconnection
  - _Requirements: 8.1, 8.6_

### Task 20: Notification System Implementation

- [ ] 20.1 Create notification entities and management
  - Implement `Notification.java` entity for the `notifications` table (as defined in `design.md`), to be stored persistently in PostgreSQL. This entity should include fields like `user_id`, `title`, `content`, `type`, `is_read`, `read_at`, etc.
  - Create SystemMessage.java for user-notification relationships (PostgreSQL)
  - Add notification types and priority levels
  - Implement notification templates and formatting
  - Create notification history and archiving
  - Add notification preferences and filtering
  - _Requirements: 8.2, 8.3, 8.5_

- [ ] 20.2 Create Flyway migration for notification tables
  - Create V6__Create_notification_tables.sql migration script
  - Define msgcontent and sysmsg tables
  - Add indexes for efficient querying
  - Create constraints for data integrity
  - Add notification type and priority enums
  - _Requirements: 8.2, 10.4_

- [ ] 20.3 Implement NotificationService with real-time delivery
  - Create createNotification method for system notifications
  - Add getUserNotifications with pagination
  - Implement markAsRead functionality
  - Create notification broadcasting with WebSocket
  - Add notification preferences and filtering
  - Implement notification cleanup and archiving
  - _Requirements: 8.2, 8.4, 8.5_

- [ ] 20.4 Create NotificationController and WebSocket handlers
  - Implement GET /api/notifications for user notifications
  - Add PUT /api/notifications/{id}/read for marking read
  - Create NotificationWebSocketHandler for real-time updates
  - Implement notification subscription management
  - Add notification statistics and reporting
  - Include proper security and permission checks
  - _Requirements: 8.4, 8.5_

## Phase 7: Payroll Management Module

### Task 21: Payroll Entities and Calculations

- [ ] 21.1 Implement payroll entities with financial data
  - Create PayrollLedger.java with comprehensive salary components
  - Implement PayrollPeriod.java for pay period management
  - Add SalaryComponent.java for detailed breakdowns
  - Create PayrollAudit.java for change tracking
  - Implement financial validation and constraints
  - Add proper decimal precision for monetary fields
  - _Requirements: 7.1, 7.4, 7.5_

- [ ] 21.2 Create Flyway migration for payroll tables
  - Create V7__Create_payroll_tables.sql migration script
  - Define payroll_ledgers, pay_periods, salary_components tables
  - Add foreign key constraints to employees
  - Create indexes for efficient querying
  - Add check constraints for financial data integrity
  - _Requirements: 7.1, 10.4_

- [ ] 21.3 Create PayrollCalculationService for salary processing
  - Implement salary calculation algorithms
  - Add tax and deduction calculations
  - Create overtime and bonus processing
  - Implement payroll validation rules
  - Add calculation audit trails
  - Create snapshot functionality for historical accuracy
  - _Requirements: 7.4, 7.5_

### Task 22: Payroll Service and Management

- [ ] 22.1 Implement PayrollService with ledger management
  - Create payroll ledger CRUD operations
  - Add payroll period management
  - Implement employee payroll history
  - Create payroll approval workflows
  - Add payroll reporting and analytics
  - Implement data snapshot preservation for historical records
  - _Requirements: 7.1, 7.2, 7.3_

- [ ] 22.2 Create PayrollController with financial endpoints
  - Implement GET /api/payroll/ledgers with filtering
  - Add POST /api/payroll/calculate for salary calculations
  - Create payroll report generation endpoints
  - Implement payroll approval and processing
  - Add payroll audit and history endpoints
  - Include proper financial security measures and permissions
  - _Requirements: 7.1, 7.2, 7.3_#
# Phase 8: Common Infrastructure and Utilities

### Task 23: Global Exception Handling

- [ ] 23.1 Create custom exception classes
  - Implement BusinessException for business logic errors
  - Create ValidationException for data validation
  - Add feature-specific exceptions (EmployeeNotFoundException, etc.)
  - Implement exception hierarchy and error codes
  - Create exception message internationalization
  - _Requirements: 2.3, 2.5_

- [ ] 23.2 Implement GlobalExceptionHandler
  - Create @ControllerAdvice for centralized exception handling
  - Add @ExceptionHandler methods for different exception types
  - Implement proper HTTP status code mapping
  - Create standardized error response format
  - Add exception logging and monitoring
  - Handle security exceptions without exposing sensitive information
  - _Requirements: 2.3, 2.4, 2.8_

### Task 24: Common DTOs and Utilities

- [ ] 24.1 Create common response DTOs
  - Implement ApiResponse<T> for standardized responses
  - Create ErrorResponse for error information
  - Add PageResponse<T> for paginated data
  - Implement validation error response formatting
  - Create success response templates
  - _Requirements: 2.4, 5.2_

- [ ] 24.2 Implement utility classes
  - Create DateUtil for date operations
  - Add StringUtil for string processing
  - Implement ValidationUtil for custom validations
  - Create FileUtil for file operations
  - Add CacheUtil for Redis operations
  - Create EncryptionUtil for field-level encryption
  - _Requirements: 5.5, 5.6, 6.4, 10.3_

### Task 25: Configuration and Infrastructure

- [ ] 25.1 Implement caching configuration
  - Create CacheConfig with Redis cache manager
  - Add cache configurations for different data types
  - Implement cache key naming strategies
  - Create cache eviction policies
  - Add cache monitoring and metrics
  - _Requirements: 1.1, 2.2, 10.2_

- [ ] 25.2 Configure async processing
  - Create AsyncConfig with thread pool settings
  - Implement @EnableAsync configuration
  - Add AsyncUncaughtExceptionHandler
  - Create async method monitoring
  - Configure async security context propagation
  - _Requirements: 6.3, 8.1_

- [ ] 25.3 Set up WebSocket configuration
  - Create WebSocketConfig with STOMP support
  - Configure message broker settings
  - Add WebSocket security configuration
  - Implement connection interceptors
  - Create WebSocket monitoring and logging
  - _Requirements: 8.1, 8.6_

- [ ] 25.4 Configure CORS and security headers
  - Create CorsConfig for frontend integration
  - Add security headers configuration
  - Implement CSRF protection where needed
  - Configure content security policy
  - Add request/response logging
  - _Requirements: 2.1, 2.3_

## Phase 9: Testing Implementation

### Task 26: Unit Testing Setup

- [ ] 26.1 Create test configuration and utilities
  - Set up test application properties
  - Create test data builders and factories
  - Implement test utilities for database operations
  - Add mock configuration for external services
  - Create test security configuration
  - _Requirements: 10.1, 10.2_

- [ ] 26.2 Implement repository layer tests
  - Create @DataJpaTest classes for repositories
  - Create separate @DataRedisTest classes for Redis-specific repositories
  - Add test cases for custom query methods
  - Implement pagination and sorting tests
  - Create transaction rollback tests
  - Add performance tests for complex queries
  - Test encryption/decryption functionality
  - _Requirements: 10.1, 10.3_

### Task 27: Service Layer Testing

- [ ] 27.1 Create service unit tests with Mockito
  - Implement @ExtendWith(MockitoExtension.class) setup
  - Add @Mock and @InjectMocks configurations
  - Create test cases for business logic validation
  - Implement exception handling tests
  - Add async method testing
  - Test security and permission enforcement
  - _Requirements: 10.1_

- [ ] 27.2 Create integration tests for services
  - Implement @SpringBootTest configurations
  - Add database integration tests
  - Create email service integration tests
  - Implement WebSocket integration tests
  - Add security integration tests
  - Test cross-module interactions
  - _Requirements: 10.1_

### Task 28: Controller and API Testing

- [ ] 29.1 Implement controller unit tests
  - Create @WebMvcTest configurations for controllers
  - Add MockMvc setup for HTTP testing
  - Implement request/response validation tests
  - Create security annotation tests with @WithMockUser
  - Add JSON serialization/deserialization tests
  - Test permission-based access control
  - _Requirements: 10.1_

- [ ] 29.2 Create API integration tests
  - Implement full @SpringBootTest with web environment
  - Add TestRestTemplate for API testing
  - Create end-to-end workflow tests
  - Implement authentication flow tests
  - Add file upload/download tests
  - Test real-time features (WebSocket)
  - _Requirements: 10.1_

### Task 30: Performance and Load Testing

- [ ] 30.1 Create performance test suite
  - Implement JMeter test plans for API endpoints
  - Add database performance tests
  - Create concurrent user simulation tests
  - Implement memory usage and leak tests
  - Add Redis cache performance tests
  - Test encryption/decryption performance
  - _Requirements: 10.1, 10.2_

- [ ] 30.2 Set up monitoring and metrics
  - Configure Spring Boot Actuator endpoints
  - Add custom metrics for business operations
  - Implement health checks for dependencies
  - Create performance monitoring dashboards
  - Add alerting for performance degradation
  - Monitor security events and audit trails
  - _Requirements: 10.2_

## Phase 10: Documentation and Deployment

### Task 31: API Documentation

- [ ] 31.1 Implement OpenAPI/Swagger documentation
  - Add Springdoc OpenAPI dependency
  - Create API documentation annotations
  - Implement request/response schema documentation
  - Add authentication documentation
  - Create API usage examples
  - Document security requirements and permissions
  - _Requirements: 11.1, 11.2_

- [ ] 31.2 Create developer documentation
  - Write setup and installation guides
  - Create API integration examples
  - Document configuration options
  - Add troubleshooting guides
  - Create architecture documentation
  - Document security and encryption procedures
  - _Requirements: 11.1, 11.2, 11.3, 11.4_

### Task 32: Production Deployment Preparation

- [ ] 32.1 Configure production settings
  - Create production application properties
  - Add environment-specific configurations
  - Implement security hardening measures
  - Configure logging for production
  - Add monitoring and alerting setup
  - Configure database connection pooling
  - _Requirements: 2.1, 10.2, 10.7_

- [ ] 32.2 Create deployment artifacts
  - Build executable JAR file for deployment
  - Create Docker containerization (optional)
  - Add database migration scripts
  - Create deployment documentation
  - Implement rollback procedures
  - Set up backup and recovery procedures
  - _Requirements: 10.2, 10.5, 10.7_

## Phase 11: Final Integration and Testing

### Task 33: System Integration Testing

- [ ] 33.1 End-to-end system testing
  - Test complete user workflows
  - Validate security across all modules
  - Test real-time features (chat, notifications)
  - Verify email functionality
  - Test file import/export operations
  - Validate encryption and audit trails
  - _Requirements: All requirements_

- [ ] 33.2 Performance optimization and tuning
  - Optimize database queries and indexing
  - Tune Redis cache configurations
  - Optimize async processing performance
  - Implement connection pooling tuning
  - Add performance monitoring and alerting
  - Optimize encryption operations
  - _Requirements: 10.2_

### Task 33: Final Documentation and Handover

- [ ] 33.1 Complete system documentation
  - Finalize API documentation
  - Create user guides and tutorials
  - Document deployment procedures
  - Add maintenance and troubleshooting guides
  - Create system architecture documentation
  - Document security procedures and compliance measures
  - _Requirements: 11.1, 11.2, 11.3, 11.4, 11.5_

- [ ] 33.2 Prepare for production deployment
  - Conduct final security review
  - Perform load testing validation
  - Create monitoring and alerting setup
  - Prepare rollback and disaster recovery procedures
  - Conduct compliance audit for data protection
  - Create operational runbooks
  - _Requirements: 10.2, 10.3, 10.7_

## Summary

This comprehensive implementation plan addresses all conflicts identified in the conflict analysis:

1. **Hybrid Architecture**: Uses PostgreSQL for persistent data and Redis for caching/real-time features
2. **Entity Field Reconciliation**: Includes all missing fields identified in the conflict analysis
3. **Security & Compliance**: Implements field-level encryption and comprehensive audit trails
4. **Consistent Naming**: Standardizes field names across all entities
5. **Modern Deployment**: Uses executable JAR instead of WAR packaging
6. **Permission-Based Access**: Implements fine-grained, ownership-based permissions
7. **Data Integrity**: Ensures proper referential integrity and transaction boundaries

The plan provides 33 major tasks with 66 sub-tasks, each referencing specific requirements and focusing exclusively on coding activities that can be executed by a development team.
</file>

</files>
